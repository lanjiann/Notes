#+TITLE: Programming Rust
#+VERSION: 2017, 1st
#+AUTHOR: Jim Blandy and Jason Orendorff
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[1. Why Rust? - 1][1. Why Rust? - 1]]
  - [[Type Safety - 3][Type Safety - 3]]
- [[2. A Tour of Rust - 7 -- =Reading=][2. A Tour of Rust - 7 -- =Reading=]]
  - [[Downloading and installing Rust - 7][Downloading and installing Rust - 7]]
  - [[A Simple Function - 10][A Simple Function - 10]]
  - [[Writing and Running Unit Tests - 11][Writing and Running Unit Tests - 11]]
  - [[Handling Command-Line Arguments - 12][Handling Command-Line Arguments - 12]]
  - [[A Simple Web Server - 17 =TODO= =NOTE=][A Simple Web Server - 17 =TODO= =NOTE=]]
  - [[Concurrency - 23][Concurrency - 23]]
    - [[What the Mandelbrot Set Actually Is - 24][What the Mandelbrot Set Actually Is - 24]]
    - [[Parsing Pair Command-Line Arguments - 28][Parsing Pair Command-Line Arguments - 28]]
    - [[Mapping from Pixels to Complex Numbers - 31][Mapping from Pixels to Complex Numbers - 31]]
    - [[Plotting the Set - 32][Plotting the Set - 32]]
    - [[Writing Image Files - 34][Writing Image Files - 34]]
    - [[A Concurrent Mandelbrot Program - 35][A Concurrent Mandelbrot Program - 35]]
    - [[Running the Mandelbrot Plotter - 40][Running the Mandelbrot Plotter - 40]]
    - [[Safety Is Invisible - 41][Safety Is Invisible - 41]]
- [[3. Basic types - 43][3. Basic types - 43]]
  - [[Machine Types - 46][Machine Types - 46]]
    - [[Integer Types - 47][Integer Types - 47]]
    - [[Floating-Point Types - 50][Floating-Point Types - 50]]
    - [[The ~bool~ Type - 51][The ~bool~ Type - 51]]
    - [[Characters - 52][Characters - 52]]
  - [[Tuples - 54][Tuples - 54]]
  - [[Pointer types - 55][Pointer types - 55]]
    - [[References - 56][References - 56]]
    - [[Boxes - 56][Boxes - 56]]
    - [[Raw Pointers - 57][Raw Pointers - 57]]
  - [[Arrays, Vectors, and Slices - 57][Arrays, Vectors, and Slices - 57]]
    - [[Arrays - 58][Arrays - 58]]
    - [[Vectors - 59][Vectors - 59]]
    - [[Building Vectors Element by Element - 62][Building Vectors Element by Element - 62]]
    - [[Slices - 62][Slices - 62]]
  - [[String Types - 64 =RE=READ=][String Types - 64 =RE=READ=]]
    - [[String Literals - 64][String Literals - 64]]
    - [[Byte Strings - 65][Byte Strings - 65]]
    - [[Strings in Memory - 65][Strings in Memory - 65]]
    - [[String - 67 =RE-READ=][String - 67 =RE-READ=]]
    - [[Using Strings - 68][Using Strings - 68]]
    - [[Other String-Like Types - 68][Other String-Like Types - 68]]
  - [[Beyond the basics - 69][Beyond the basics - 69]]
- [[4. Ownership - 71][4. Ownership - 71]]
  - [[Ownership - 73 =TODO= =NOTE=][Ownership - 73 =TODO= =NOTE=]]
  - [[Moves - 77][Moves - 77]]
    - [[More Operations That Move - 82][More Operations That Move - 82]]
    - [[Moves and Control Flow - 84][Moves and Control Flow - 84]]
    - [[Moves and Indexed Content - 84][Moves and Indexed Content - 84]]
  - [[~Copy~ Types: The Exception to Moves - 86][~Copy~ Types: The Exception to Moves - 86]]
  - [[~Rc~ and ~Arc~: shared ownership - 90 =Re-Read= =Reference counter and Circular reference=][~Rc~ and ~Arc~: shared ownership - 90 =Re-Read= =Reference counter and Circular reference=]]
- [[5. References and borrowing - 93][5. References and borrowing - 93]]
  - [[References as Values - 97][References as Values - 97]]
    - [[Rust References Versus C++ References - 97][Rust References Versus C++ References - 97]]
    - [[Assigning References - 98][Assigning References - 98]]
    - [[References to References - 99][References to References - 99]]
    - [[Comparing References - 99][Comparing References - 99]]
    - [[References Are Never Null - 100][References Are Never Null - 100]]
    - [[Borrowing References to Arbitrary Expressions - 100][Borrowing References to Arbitrary Expressions - 100]]
    - [[References to Slices and Trait Objects - 101 =TODO=][References to Slices and Trait Objects - 101 =TODO=]]
  - [[Reference Safety - 101][Reference Safety - 101]]
    - [[Borrowing a Local Variable - 101][Borrowing a Local Variable - 101]]
    - [[Receiving References as Parameters - 105][Receiving References as Parameters - 105]]
    - [[Passing References as Arguments - 107][Passing References as Arguments - 107]]
    - [[Returning References - 107][Returning References - 107]]
    - [[Structs Containing References - 109][Structs Containing References - 109]]
    - [[Distinct Lifetime Parameters - 111][Distinct Lifetime Parameters - 111]]
    - [[Omitting Lifetime Parameters - 112][Omitting Lifetime Parameters - 112]]
  - [[Sharing Versus Mutation - 114][Sharing Versus Mutation - 114]]
  - [[Taking Arms Against a Sea of Objects - 121][Taking Arms Against a Sea of Objects - 121]]
- [[6. Expressions - 123 =NOTE=][6. Expressions - 123 =NOTE=]]
  - [[An Expression Language - 123][An Expression Language - 123]]
  - [[Blocks and Semicolons - 124][Blocks and Semicolons - 124]]
  - [[Declarations - 126][Declarations - 126]]
  - [[~if~ and match - 127][~if~ and match - 127]]
    - [[~if let~ - 129][~if let~ - 129]]
  - [[Loops - 130][Loops - 130]]
  - [[~return~ Expressions - 132][~return~ Expressions - 132]]
  - [[Why Rust Has ~loop~ - 133 =Re-Read=][Why Rust Has ~loop~ - 133 =Re-Read=]]
  - [[Function and Method Calls - 134][Function and Method Calls - 134]]
  - [[Fields and Elements - 135][Fields and Elements - 135]]
  - [[Reference Operators - 137][Reference Operators - 137]]
  - [[Arithmetic, Bitwise, Comparison, and Logical Operators - 137 =TODO=][Arithmetic, Bitwise, Comparison, and Logical Operators - 137 =TODO=]]
  - [[Assignment 138][Assignment 138]]
  - [[Type Casts 139][Type Casts 139]]
  - [[Closures - 140][Closures - 140]]
  - [[Precedence and Associativity - 140 =TODO=][Precedence and Associativity - 140 =TODO=]]
  - [[Onward - 142][Onward - 142]]
- [[7. Error Handling - 145][7. Error Handling - 145]]
  - [[Panic - 145][Panic - 145]]
    - [[Unwinding - 146][Unwinding - 146]]
    - [[Aborting - 147][Aborting - 147]]
  - [[Result - 148][Result - 148]]
    - [[Catching Errors - 148][Catching Errors - 148]]
    - [[Result Type Aliases - 150][Result Type Aliases - 150]]
    - [[Printing Errors - 150][Printing Errors - 150]]
    - [[Propagating Errors - 152][Propagating Errors - 152]]
    - [[Working with Multiple Error Types - 153][Working with Multiple Error Types - 153]]
    - [[Dealing with Errors That "Can't Happen" - 155][Dealing with Errors That "Can't Happen" - 155]]
    - [[Ignoring Errors - 156][Ignoring Errors - 156]]
    - [[Handling Errors in ~main()~ - 156][Handling Errors in ~main()~ - 156]]
    - [[Declaring a Custom Error Type - 157][Declaring a Custom Error Type - 157]]
    - [[Why Results? - 158][Why Results? - 158]]
- [[8. Crates and Modules - 161][8. Crates and Modules - 161]]
  - [[Crates - 161][Crates - 161]]
    - [[Build Profiles - 164][Build Profiles - 164]]
  - [[Modules - 165][Modules - 165]]
    - [[Modules in Separate Files - 166][Modules in Separate Files - 166]]
    - [[Paths and Imports - 167][Paths and Imports - 167]]
    - [[The Standard Prelude - 169][The Standard Prelude - 169]]
    - [[Items, the Building Blocks of Rust - 170 =RE-READ=][Items, the Building Blocks of Rust - 170 =RE-READ=]]
  - [[Turning a Program into a Library - 172][Turning a Program into a Library - 172]]
  - [[The =src/bin= Directory - 174][The =src/bin= Directory - 174]]
  - [[Attributes - 175][Attributes - 175]]
  - [[Tests and Documentation - 178][Tests and Documentation - 178]]
    - [[Integration Tests - 180][Integration Tests - 180]]
    - [[Documentation - 181][Documentation - 181]]
    - [[Doc-Tests - 182][Doc-Tests - 182]]
  - [[Specifying Dependencies - 185][Specifying Dependencies - 185]]
    - [[Versions - 186][Versions - 186]]
    - [[~Cargo.lock~ - 187][~Cargo.lock~ - 187]]
  - [[Publishing Crates to crates.io - 188][Publishing Crates to crates.io - 188]]
  - [[Workspaces - 190][Workspaces - 190]]
  - [[More Nice Things - 191][More Nice Things - 191]]
- [[9. Structs - 193][9. Structs - 193]]
  - [[Named-Field Structs - 193][Named-Field Structs - 193]]
  - [[Tuple-Like Structs - 196][Tuple-Like Structs - 196]]
  - [[Unit-Like Structs - 197][Unit-Like Structs - 197]]
  - [[Struct Layout - 197][Struct Layout - 197]]
  - [[Defining Methods with ~impl~ - 198][Defining Methods with ~impl~ - 198]]
  - [[Generic Structs - 202][Generic Structs - 202]]
  - [[Structs with Lifetime Parameters - 203][Structs with Lifetime Parameters - 203]]
  - [[Deriving Common Traits for Struct Types - 204][Deriving Common Traits for Struct Types - 204]]
  - [[Interior Mutability - 205][Interior Mutability - 205]]
- [[10. Enums and patterns - 211][10. Enums and patterns - 211]]
  - [[Enums - 212][Enums - 212]]
    - [[Enums with Data - 214][Enums with Data - 214]]
    - [[Enums in Memory - 215][Enums in Memory - 215]]
    - [[Rich Data Structures Using Enums - 216][Rich Data Structures Using Enums - 216]]
    - [[Generic Enums - 218][Generic Enums - 218]]
  - [[Patterns - 221][Patterns - 221]]
    - [[Literals, Variables, and Wildcards in Patterns - 223][Literals, Variables, and Wildcards in Patterns - 223]]
    - [[Tuple and Struct Patterns - 225][Tuple and Struct Patterns - 225]]
    - [[Reference Patterns - 226][Reference Patterns - 226]]
    - [[Matching Multiple Possibilities - 229][Matching Multiple Possibilities - 229]]
    - [[Pattern Guards - 229][Pattern Guards - 229]]
    - [[~@~ patterns - 230][~@~ patterns - 230]]
    - [[Where Patterns Are Allowed - 230][Where Patterns Are Allowed - 230]]
    - [[Populating a Binary Tree 232][Populating a Binary Tree 232]]
  - [[The Big Picture - 233][The Big Picture - 233]]
- [[11. Traits and Generics - 235][11. Traits and Generics - 235]]
  - [[Using Traits - 237][Using Traits - 237]]
    - [[Trait Objects - 238][Trait Objects - 238]]
    - [[Trait Object Layout - 239][Trait Object Layout - 239]]
    - [[Generic Functions - 240][Generic Functions - 240]]
    - [[Which to Use - 243][Which to Use - 243]]
  - [[Defining and Implementing Traits - 245][Defining and Implementing Traits - 245]]
    - [[Default Methods - 246][Default Methods - 246]]
    - [[Traits and Other People's Types - 247][Traits and Other People's Types - 247]]
    - [[Self in Traits - 249][Self in Traits - 249]]
    - [[Subtraits - 250][Subtraits - 250]]
    - [[Static Methods - 251][Static Methods - 251]]
  - [[Fully Qualified Method Calls - 252][Fully Qualified Method Calls - 252]]
  - [[Traits That Define Relationships Between Types - 253][Traits That Define Relationships Between Types - 253]]
    - [[Associated Types (or How Iterators Work) - 254][Associated Types (or How Iterators Work) - 254]]
    - [[Generic Traits (or How Operator Overloading Works) - 257][Generic Traits (or How Operator Overloading Works) - 257]]
    - [[Buddy Traits (or How ~rand::random()~ Works) - 258][Buddy Traits (or How ~rand::random()~ Works) - 258]]
  - [[Reverse-Engineering Bounds - 260][Reverse-Engineering Bounds - 260]]
  - [[Conclusion - 263][Conclusion - 263]]
- [[12. Operator Overloading - 265][12. Operator Overloading - 265]]
  - [[Arithmetic and Bitwise Operators - 266][Arithmetic and Bitwise Operators - 266]]
    - [[Unary Operators - 268][Unary Operators - 268]]
    - [[Binary Operators - 269][Binary Operators - 269]]
    - [[Compound Assignment Operators - 270][Compound Assignment Operators - 270]]
  - [[Equality Tests - 272][Equality Tests - 272]]
  - [[Ordered Comparisons - 275][Ordered Comparisons - 275]]
  - [[~Index~ and ~IndexMut~ - 277][~Index~ and ~IndexMut~ - 277]]
  - [[Other Operators - 280][Other Operators - 280]]
- [[13. Utility Traits - 281][13. Utility Traits - 281]]
  - [[~Drop~ - 282][~Drop~ - 282]]
  - [[~Sized~ - 285][~Sized~ - 285]]
  - [[~Clone~ - 287][~Clone~ - 287]]
  - [[~Copy~ - 289][~Copy~ - 289]]
  - [[~Deref~ and ~DerefMut~ - 289][~Deref~ and ~DerefMut~ - 289]]
  - [[~Default~][~Default~]]
  - [[~AsRef~ and ~AsMut~ - 294][~AsRef~ and ~AsMut~ - 294]]
  - [[~Borrow~ and ~BorrowMut~ - 296][~Borrow~ and ~BorrowMut~ - 296]]
  - [[~From~ and ~Into~ - 297][~From~ and ~Into~ - 297]]
  - [[~ToOwned~ - 300][~ToOwned~ - 300]]
  - [[~Borrow~ and ~ToOwned~ at Work: The Humble ~Cow~ - 300][~Borrow~ and ~ToOwned~ at Work: The Humble ~Cow~ - 300]]
- [[14. Closures - 303][14. Closures - 303]]
  - [[Capturing Variables - 305][Capturing Variables - 305]]
    - [[Closures That Borrow - 306][Closures That Borrow - 306]]
    - [[Closures That Steal - 306][Closures That Steal - 306]]
  - [[Function and Closure Types - 308][Function and Closure Types - 308]]
  - [[Closure Performance - 310][Closure Performance - 310]]
  - [[Closures and Safety - 311][Closures and Safety - 311]]
    - [[Closures That Kill - 312][Closures That Kill - 312]]
    - [[~FnOnce~ - 312][~FnOnce~ - 312]]
    - [[~FnMut~ - 314][~FnMut~ - 314]]
  - [[Callbacks - 316][Callbacks - 316]]
  - [[Using Closures Effectively - 319][Using Closures Effectively - 319]]
- [[15. Iterators - 321][15. Iterators - 321]]
  - [[The ~Iterator~ and ~IntoIterator~ Traits - 322][The ~Iterator~ and ~IntoIterator~ Traits - 322]]
  - [[Creating ~Iterator~'s - 324][Creating ~Iterator~'s - 324]]
    - [[~iter~ and ~iter_mut~ Methods - 324][~iter~ and ~iter_mut~ Methods - 324]]
    - [[~IntoIterator~ Implementations - 325][~IntoIterator~ Implementations - 325]]
    - [[~drain~ Methods - 327][~drain~ Methods - 327]]
    - [[Other ~Iterator~ Sources - 328][Other ~Iterator~ Sources - 328]]
  - [[~Iterator~ Adapters - 330][~Iterator~ Adapters - 330]]
    - [[~map~ and ~filter~ - 330][~map~ and ~filter~ - 330]]
    - [[~filter_map~ and ~flat_map~ - 332][~filter_map~ and ~flat_map~ - 332]]
    - [[~scan~ - 335][~scan~ - 335]]
    - [[~take~ and ~take_while~ - 335][~take~ and ~take_while~ - 335]]
    - [[~skip~ and ~skip_while~ - 336][~skip~ and ~skip_while~ - 336]]
    - [[~peekable~ - 337][~peekable~ - 337]]
    - [[fuse - 338][fuse - 338]]
    - [[Reversible ~Iterator~'s and ~rev~ - 339][Reversible ~Iterator~'s and ~rev~ - 339]]
    - [[~inspect~ - 340][~inspect~ - 340]]
    - [[~chain~ - 341][~chain~ - 341]]
    - [[~enumerate~ - 341][~enumerate~ - 341]]
    - [[~zip~ - 342][~zip~ - 342]]
    - [[~by_ref~ - 342][~by_ref~ - 342]]
    - [[~cloned~ - 344][~cloned~ - 344]]
    - [[~cycle~ - 344][~cycle~ - 344]]
  - [[Consuming Iterators - 345][Consuming Iterators - 345]]
    - [[Simple Accumulation: ~count~, ~sum~, ~product~ - 345][Simple Accumulation: ~count~, ~sum~, ~product~ - 345]]
    - [[~max~, ~min~ - 346][~max~, ~min~ - 346]]
    - [[~max_by~, ~min_by~ - 346][~max_by~, ~min_by~ - 346]]
    - [[~max_by_key~, ~min_by_key~ - 347][~max_by_key~, ~min_by_key~ - 347]]
    - [[Comparing Item Sequences - 347][Comparing Item Sequences - 347]]
    - [[~any~ and ~all~ - 348][~any~ and ~all~ - 348]]
    - [[~position~, ~rposition~, and ~ExactSizeIterator~ - 348][~position~, ~rposition~, and ~ExactSizeIterator~ - 348]]
    - [[~fold~ - 349][~fold~ - 349]]
    - [[~nth~ - 350][~nth~ - 350]]
    - [[~last~ - 350][~last~ - 350]]
    - [[~find~ - 351][~find~ - 351]]
    - [[Building Collections: ~collect~ and ~FromIterator~ - 351][Building Collections: ~collect~ and ~FromIterator~ - 351]]
    - [[The ~Extend~ Trait - 353][The ~Extend~ Trait - 353]]
    - [[~partition~ - 353][~partition~ - 353]]
  - [[Implementing Your Own Iterators - 354][Implementing Your Own Iterators - 354]]
- [[16. Collections - 359][16. Collections - 359]]
  - [[Overview - 360][Overview - 360]]
  - [[~Vec<T>~ - 361][~Vec<T>~ - 361]]
    - [[Accessing Elements - 362][Accessing Elements - 362]]
    - [[Iteration - 364][Iteration - 364]]
    - [[Growing and Shrinking Vectors - 364][Growing and Shrinking Vectors - 364]]
    - [[Joining - 367][Joining - 367]]
    - [[Splitting - 368][Splitting - 368]]
    - [[Swapping - 370][Swapping - 370]]
    - [[Sorting and Searching - 370][Sorting and Searching - 370]]
    - [[Comparing Slices - 372][Comparing Slices - 372]]
    - [[Random Elements - 373][Random Elements - 373]]
    - [[Rust Rules Out Invalidation Errors - 373][Rust Rules Out Invalidation Errors - 373]]
  - [[~VecDeque<T>~ - 374][~VecDeque<T>~ - 374]]
  - [[~LinkedList<T>~ - 376][~LinkedList<T>~ - 376]]
  - [[~BinaryHeap<T>~ - 377][~BinaryHeap<T>~ - 377]]
  - [[~HashMap<K, V>~ and ~BTreeMap<K, V>~ - 378][~HashMap<K, V>~ and ~BTreeMap<K, V>~ - 378]]
    - [[Entries - 381][Entries - 381]]
    - [[Map Iteration - 383][Map Iteration - 383]]
  - [[~HashSet<T>~ and ~BTreeSet<T>~ - 384][~HashSet<T>~ and ~BTreeSet<T>~ - 384]]
    - [[Set Iteration - 384][Set Iteration - 384]]
    - [[When Equal Values Are Different - 385][When Equal Values Are Different - 385]]
    - [[Whole-Set Operations - 385][Whole-Set Operations - 385]]
  - [[Hashing - 387][Hashing - 387]]
    - [[Using a Custom Hashing Algorithm - 388][Using a Custom Hashing Algorithm - 388]]
  - [[Beyond the Standard Collections 389][Beyond the Standard Collections 389]]
- [[17. Strings and Text - 391][17. Strings and Text - 391]]
  - [[Some Unicode Background - 392][Some Unicode Background - 392]]
    - [[ASCII, Latin-1, and Unicode - 392][ASCII, Latin-1, and Unicode - 392]]
    - [[UTF-8 - 392][UTF-8 - 392]]
    - [[Text Directionality - 394][Text Directionality - 394]]
  - [[Characters (~char~) - 394][Characters (~char~) - 394]]
    - [[Classifying Characters - 395][Classifying Characters - 395]]
    - [[Handling Digits - 395][Handling Digits - 395]]
    - [[Case Conversion for Characters - 396][Case Conversion for Characters - 396]]
    - [[Conversions to and from Integers - 396][Conversions to and from Integers - 396]]
  - [[~String~ and ~str~ - 397][~String~ and ~str~ - 397]]
    - [[Creating String Values - 398][Creating String Values - 398]]
    - [[Simple Inspection - 398][Simple Inspection - 398]]
    - [[Appending and Inserting Text - 399][Appending and Inserting Text - 399]]
    - [[Removing Text - 401][Removing Text - 401]]
    - [[Conventions for Searching and Iterating - 401][Conventions for Searching and Iterating - 401]]
    - [[Patterns for Searching Text - 402][Patterns for Searching Text - 402]]
    - [[Searching and Replacing - 403][Searching and Replacing - 403]]
    - [[Iterating over Text - 403][Iterating over Text - 403]]
    - [[Trimming - 406][Trimming - 406]]
    - [[Case Conversion for Strings - 406][Case Conversion for Strings - 406]]
    - [[Parsing Other Types from Strings - 406][Parsing Other Types from Strings - 406]]
    - [[Converting Other Types to Strings - 407][Converting Other Types to Strings - 407]]
    - [[Borrowing as Other Text-Like Types - 408][Borrowing as Other Text-Like Types - 408]]
    - [[Accessing Text as UTF-8 - 409][Accessing Text as UTF-8 - 409]]
    - [[Producing Text from UTF-8 Data - 409][Producing Text from UTF-8 Data - 409]]
    - [[Putting Off Allocation - 410][Putting Off Allocation - 410]]
    - [[Strings as Generic Collections - 412][Strings as Generic Collections - 412]]
  - [[Formatting Values - 413][Formatting Values - 413]]
    - [[Formatting Text Values - 414][Formatting Text Values - 414]]
    - [[Formatting Numbers - 415][Formatting Numbers - 415]]
    - [[Formatting Other Types - 417][Formatting Other Types - 417]]
    - [[Formatting Values for Debugging - 418][Formatting Values for Debugging - 418]]
    - [[Formatting Pointers for Debugging - 419][Formatting Pointers for Debugging - 419]]
    - [[Referring to Arguments by Index or Name - 419][Referring to Arguments by Index or Name - 419]]
    - [[Dynamic Widths and Precisions - 420][Dynamic Widths and Precisions - 420]]
    - [[Formatting Your Own Types - 421][Formatting Your Own Types - 421]]
    - [[Using the Formatting Language in Your Own Code - 423][Using the Formatting Language in Your Own Code - 423]]
  - [[Regular Expressions - 424][Regular Expressions - 424]]
    - [[Basic Regex Use - 425][Basic Regex Use - 425]]
    - [[Building Regex Values Lazily - 426][Building Regex Values Lazily - 426]]
  - [[Normalization - 427][Normalization - 427]]
    - [[Normalization Forms - 428][Normalization Forms - 428]]
    - [[The unicode-normalization Crate - 429][The unicode-normalization Crate - 429]]
- [[18. Input and Output - 431][18. Input and Output - 431]]
  - [[Readers and Writers - 432][Readers and Writers - 432]]
    - [[Readers - 433][Readers - 433]]
    - [[Buffered Readers - 435][Buffered Readers - 435]]
    - [[Reading Lines - 436][Reading Lines - 436]]
    - [[Collecting Lines - 439][Collecting Lines - 439]]
    - [[Writers - 439][Writers - 439]]
    - [[Files - 441][Files - 441]]
    - [[Seeking - 441][Seeking - 441]]
    - [[Other Reader and Writer Types - 442][Other Reader and Writer Types - 442]]
    - [[Binary Data, Compression, and Serialization - 444][Binary Data, Compression, and Serialization - 444]]
  - [[Files and Directories - 445][Files and Directories - 445]]
    - [[~OsStr~ and ~Path~ - 445][~OsStr~ and ~Path~ - 445]]
    - [[~Path~ and ~PathBuf~ Methods - 447][~Path~ and ~PathBuf~ Methods - 447]]
    - [[Filesystem Access Functions - 449][Filesystem Access Functions - 449]]
    - [[Reading Directories - 450][Reading Directories - 450]]
    - [[Platform-Specific Features - 451][Platform-Specific Features - 451]]
  - [[Networking - 453][Networking - 453]]
- [[19. Concurrency - 457][19. Concurrency - 457]]
  - [[Fork-Join Parallelism - 459][Fork-Join Parallelism - 459]]
    - [[~spawn~ and ~join~ - 461][~spawn~ and ~join~ - 461]]
    - [[Error Handling Across Threads - 463][Error Handling Across Threads - 463]]
    - [[Sharing Immutable Data Across Threads - 464][Sharing Immutable Data Across Threads - 464]]
    - [[Rayon - 466][Rayon - 466]]
    - [[Revisiting the Mandelbrot Set - 468][Revisiting the Mandelbrot Set - 468]]
  - [[Channels - 470][Channels - 470]]
    - [[Sending Values - 472][Sending Values - 472]]
    - [[Receiving Values - 475][Receiving Values - 475]]
    - [[Running the Pipeline - 476][Running the Pipeline - 476]]
    - [[Channel Features and Performance - 478][Channel Features and Performance - 478]]
    - [[Thread Safety: Send and Sync - 479][Thread Safety: Send and Sync - 479]]
    - [[Piping Almost Any Iterator to a Channel - 482][Piping Almost Any Iterator to a Channel - 482]]
    - [[Beyond Pipelines - 483][Beyond Pipelines - 483]]
  - [[Shared Mutable State - 484][Shared Mutable State - 484]]
    - [[What Is a Mutex? - 484][What Is a Mutex? - 484]]
    - [[~Mutex<T>~ - 486][~Mutex<T>~ - 486]]
    - [[mut and Mutex - 488][mut and Mutex - 488]]
    - [[Why Mutexes Are Not Always a Good Idea - 488][Why Mutexes Are Not Always a Good Idea - 488]]
    - [[Deadlock - 489][Deadlock - 489]]
    - [[Poisoned Mutexes - 490][Poisoned Mutexes - 490]]
    - [[Multi-producer Channels Using Mutexes - 490][Multi-producer Channels Using Mutexes - 490]]
    - [[Read/Write Locks (~RwLock<T>~) - 491][Read/Write Locks (~RwLock<T>~) - 491]]
    - [[Condition Variables (Condvar) - 493][Condition Variables (Condvar) - 493]]
    - [[Atomics - 494][Atomics - 494]]
    - [[Global Variables - 496][Global Variables - 496]]
  - [[What Hacking Concurrent Code in Rust Is Like - 497][What Hacking Concurrent Code in Rust Is Like - 497]]
- [[20. Macros - 499][20. Macros - 499]]
  - [[Macro Basics - 500][Macro Basics - 500]]
    - [[Basics of Macro Expansion - 501][Basics of Macro Expansion - 501]]
    - [[Unintended Consequences - 503][Unintended Consequences - 503]]
    - [[Repetition - 505][Repetition - 505]]
  - [[Built-In Macros - 507][Built-In Macros - 507]]
  - [[Debugging Macros - 508][Debugging Macros - 508]]
  - [[The ~json!~ Macro - 509][The ~json!~ Macro - 509]]
    - [[Fragment Types - 510][Fragment Types - 510]]
    - [[Recursion in Macros - 513][Recursion in Macros - 513]]
    - [[Using Traits with Macros - 514][Using Traits with Macros - 514]]
    - [[Scoping and Hygiene - 516][Scoping and Hygiene - 516]]
    - [[Importing and Exporting Macros - 519][Importing and Exporting Macros - 519]]
  - [[Avoiding Syntax Errors During Matching - 521][Avoiding Syntax Errors During Matching - 521]]
  - [[Beyond ~macro_rules!~ - 522][Beyond ~macro_rules!~ - 522]]
- [[21. Unsafe Code - 525][21. Unsafe Code - 525]]
  - [[Unsafe from What? - 526][Unsafe from What? - 526]]
  - [[Unsafe Blocks - 527][Unsafe Blocks - 527]]
    - [[Example: An Efficient ASCII String Type - 529][Example: An Efficient ASCII String Type - 529]]
  - [[Unsafe Functions - 531][Unsafe Functions - 531]]
  - [[Unsafe Block or Unsafe Function? - 533][Unsafe Block or Unsafe Function? - 533]]
  - [[Undefined Behavior - 533][Undefined Behavior - 533]]
  - [[Unsafe Traits - 536][Unsafe Traits - 536]]
  - [[Raw Pointers - 538][Raw Pointers - 538]]
    - [[Dereferencing Raw Pointers Safely - 540][Dereferencing Raw Pointers Safely - 540]]
    - [[Example: ~RefWithFlag~ - 541][Example: ~RefWithFlag~ - 541]]
    - [[Nullable Pointers - 544][Nullable Pointers - 544]]
    - [[Type Sizes and Alignments - 544][Type Sizes and Alignments - 544]]
    - [[Pointer Arithmetic - 545][Pointer Arithmetic - 545]]
    - [[Moving into and out of Memory - 546][Moving into and out of Memory - 546]]
    - [[Example: ~GapBuffer~ - 550][Example: ~GapBuffer~ - 550]]
    - [[Panic Safety in Unsafe Code - 556][Panic Safety in Unsafe Code - 556]]
  - [[Foreign Functions: Calling C and C++ from Rust - 557][Foreign Functions: Calling C and C++ from Rust - 557]]
    - [[Finding Common Data Representations - 558][Finding Common Data Representations - 558]]
    - [[Declaring Foreign Functions and Variables - 561][Declaring Foreign Functions and Variables - 561]]
    - [[Using Functions from Libraries - 562][Using Functions from Libraries - 562]]
    - [[A Raw Interface to libgit2 - 566][A Raw Interface to libgit2 - 566]]
    - [[A Safe Interface to libgit2 - 572][A Safe Interface to libgit2 - 572]]
  - [[Conclusion - 583][Conclusion - 583]]
- [[Index - 585][Index - 585]]

* 1. Why Rust? - 1
  - Enter Rust:
    a *safe* (memory safety), *concurrent* (trustworthy concurrency) language
    with the *performance* of C and C++.

  - Rust shares the ambitions Bjarne Stroustrup articulates for C++ in his paper
    "Abstraction and the C++ Machine Model:"
    #+BEGIN_QUOTE
    In general, C++ implementations obey the *zero-overhead principle*:
    What you don't use, you don't pay for.

    And further: What you do use, you couldn't hand code any better.
    #+END_QUOTE

  - The key to meeting all these promises is Rust's novel system of /ownership/,
    /moves/, and /borrows/, checked at /compile time/ and carefully designed to
    complement Rust's flexible static type system.

  - Rust is able to prevent /data races/ at /compile time/.

  - In fact, Servo and Rust have grown up together, with Servo using the latest
    new language features, and Rust evolving based on feedback from Servo's
    developers.

** DONE Type Safety - 3
   CLOSED: [2018-05-19 Sat 14:21]
   =TODO= =NOTE=

* TODO 2. A Tour of Rust - 7 -- =Reading=
  - In this chapter we'll look at several short programs to see _HOW_ Rust's
    + syntax
    + types
    + semantics

    fit together to support

    + safe
    + concurrent
    + efficient

    code.

** DONE Downloading and installing Rust - 7
   CLOSED: [2018-05-31 Thu 14:13]
   - The recommend way is to use the tool *rustup*.

   - Once you finish the installation, you have *three* new commands:
     + *cargo* :: The Rust's tool as
       * _compilation manager_
       * _package manager_
       * _general-purpose_

       You can use it to
       + _start a new project_
       + _build_ and _run_ your program,
       + _manage any external libraries_ your code depends on.

     + *rustc* :: Rust's compiler. Usually we let Cargo invoke the compiler for
                  us.

     + *rustdoc* :: Rust documentation tool. Like *rustc*, we usually let Cargo
                    run *rustdoc* for us.

   - Example:
     ~cargo new --bin hello~
     Create a new package directory named =hello=, and the =--bin= flag directs
     Cargo to prepare this as an /executable/, not a /library/.

     + Inside the =hello= directory is by default initalized as a /git repository/
       (with a =.gitignore= file), you have =Cargo.toml= and the =src= folder.

     + You can record the /dependencies/ of your package in the =Cargo.toml= file,
       and Cargo will take care of downloading, building, and updating those
       libraries for us.
       =TODO= Cover the =Cargo.toml= file in detail in Chapter 8.

   - ~cargo --vcs none [other flags and their values]~
     Tell Cargo to skip the step of initalized your package as a git
     repository.

   - ~cargo run~
     _build_ and _run_ your program.

   - Cargo places the executable in the =target= subdirectory at the top of the
     package.
       You can check the =target/debug= directory, and the executable is inside
     named as =hello=.

   - ~cargo clean~
     clean up the generated files

** DONE A Simple Function - 10
   CLOSED: [2018-05-31 Thu 15:06]
   - Example (Euclid's algorithm):
     #+BEGIN_SRC rust
       fn gcd(mut n: u64, mut m: u64) -> u64 {
           assert!(n != 0 && m != 0);

           while m != 0 {
               if m < n {
                   let t = m;
                   m = n;
                   n = t;
               }
               m = m % n;
           }
           n
       }
     #+END_SRC

   - =From Jian=
     I don't like the usage of ~assert!~ in the above example code!
     If should use something like ~require!~, which is a better word for
     precondition check!

   - UNLIKE C/C++, Rust's ~assert!~ CANNOT be skipped in all cases!

     There is a ~debug_assert!~ macro do the similar thing, but it can be
     skipped when the program is compiled for speed.

** DONE Writing and Running Unit Tests - 11
   CLOSED: [2018-05-31 Thu 15:51]
   - Example:
     #+BEGIN_SRC rust
       #[test]
       fn test_gcd() {
           assert_eq!(gcd(14, 15), 1);
           assert_eq!(gcd(2 * 3 * 5 * 11 * 17,
                          3 * 7 * 11 * 13 * 19),
                      3 * 11);
       }
     #+END_SRC

   - The ~#[test]~ atop the definition marks ~test_gcd~ as a test function, to be
     _skipped in normal compilations_,
     but included and called automatically if we run our program with the ~cargo
     test~ command.

   - The /tests/ can be scatter in throughout our source tree.

   - The ~#[test]~ is an example of an /attribute/.

   - /Attributes/ are an open-ended system for *marking* functions and other
     declarations with _extra information_, like /attributes/ in C++ and C#, or
     /annotations/ in Java.

     They're used to control
     + compiler warnings
     + code style checks
     + include code conditionally (like ~#ifdef~ in C and C++)
     + tell Rust how to interact with code written in other languages, and so on.

     We'll see more examples of /attributes/ as we go.

** DONE Handling Command-Line Arguments - 12
   CLOSED: [2018-05-31 Thu 16:42]
   Example:
   #+BEGIN_SRC rust
     use std::io::Write;
     use std::str::FromStr;
     fn main() {
         let mut numbers = Vec::new();

         for arg in std::env::args().skip(1) {
             numbers.push(u64::from_str(&arg)
                          .expect("error parsing argument"));
         }

         if numbers.len() == 0 {
             writeln!(std::io::stderr(), "Usage: gcd NUMBER ...").unwrap();
             std::process::exit(1);
         }

         let mut d = numbers[0];
         for m in &numbers[1..] {
             d = gcd(d, *m);
         }

         println!("The greatest common divisor of {:?} is {}",
                  numbers, d);
     }
   #+END_SRC

   Let's take it piece by piece:
   - The ~use~ lines:
     The ~use~ /declarations/ bring the two /traits/ ~Write~ and ~FromStr~ into scope.

     + =TODO= We'll cover ~traits~ in detail in Chapter 11, but for now we'll
       simply say that a /trait/ is a collection of /methods/ that /types/ can
       implement.

     + Although we never use the names ~Write~ or ~FromStr~ elsewhere in the program,
       a /trait/ _MUST be in scope_ in order to use its /methods/.

       In the present case:
       * Any type that implements the ~Write~ /trait/ has a ~write_fmt~ /method/ that
         *writes* _formatted text_ to a /stream/.

         The ~std::io::Stderr~ type implements ~Write~, and we'll use the
         ~writeln!~ /macro/ to print error messages; that /macro/ expands to
         code that uses the ~write_fmt~ /method/.

       * Any type that implements the ~FromStr~ /trait/ has a ~from_str~ /method/
         that tries to *parse* a value of that type from a string. The ~u64~ type
         implements ~FromStr~, and we'll call ~u64::from_str~ to parse our
         command-line arguments.

   - ~let mut numbers = Vec::new();~
     Even though /vectors/ are designed to be grown and shrunk dynamically, we must
     still mark the variable ~mut~ for Rust to let us push numbers onto the end
     of it.

     =IMPORTANT= =???=
     =From Jian= ~mut~ here is used to manage the _content_ of the vector
     ~numbers~, rather the the reference saved in ~numbers~!
     *This is different from most of the other languages!*

   - The ~for arg in std::env::args().skip(1)~ block: 
     + The ~std::env::args()~ returns an /iterator/.

       * =En=:
         ubiquitous

       * Rust's /iterators/ are very _EFFICIENT_:
         the compiler is usually able to *translate* them into the same code as
         a handwritten loop.
         =TODO= HOW in Chapter 15

     + The ~numbers.push(u64::from_str(&arg).expect("error parsing argument"));~ line:
       * The ~from_str~ function does NOT return a ~u64~ directly, but rather a
         ~Result~ value that indicates whether the parse succeeded or failed.
         - A ~Result~ value can be one of two variants:
           + ~Ok(v)~

           + ~Err(e)~

         - UNLIKE most modern languages, Rust does NOT have /exceptions/:
           all /errors/ are handled using either ~Result~ or /panic/, as
           outlined in Chapter 7. =TODO=

         - Check the success of our parse by using ~Result~'s ~expect~ /method/.
           + If the result is some ~Err(e)~, ~expect~
             1. _prints_ a message that includes a description of ~e~
             2. _exits the program immediately_.
           + If the result is ~Ok(v)~, ~expect~ simply returns ~v~ itself.

   - The ~if numbers.len() == 0~ block:
     + The ~.unwrap()~ call is a terse way to _check_ that the attempt to print
       the error message _did not itself fail_; an ~expect~ call would work too,
       but that's probably not worth it.

     + Simple introduction to the /ownership/ and /borrow/ ...

   - _UNLIKE_ C and C++, which require ~main~ to
     + return zero if the program finished successfully
       or

     + a /nonzero exit status/ if something went wrong,

     Rust assumes that if ~main~ returns at all, the program finished
     successfully. _ONLY_ by *EXPLICITLY calling* functions like ~expect~ or
     ~std::process::exit~ can we cause the program to terminate with an /error
     status code/.

   - Check the standard library documentation in your browser with the command
     ~rustup doc --std~

** DONE A Simple Web Server - 17 =TODO= =NOTE=
   CLOSED: [2018-06-01 Fri 21:08]
   - crate :: A Rust package, whether a library or an executable.

   - To show how this works, we'll put together a *simple web server* using the
     /iron web framework/, the hyper HTTP server, and various other /crates/ on
     which they depend.

     + As shown in Figure 2-1, our website will prompt the user for two numbers,
       and compute their greatest common divisor.

   - =Cargo.toml=
     #+BEGIN_SRC toml
       [package]
       name = "iron-gcd"
       version = "0.1.0"
       authors = ["You <you@example.com>"]

       [dependencies]
       iron = "0.5.1"
       mime = "0.2.3"
       router = "0.5.1"
       urlencoded = "0.5.0"
     #+END_SRC

   - The basic version (incomplete!):
     #+BEGIN_SRC rust
       extern crate iron;
       #[macro_use] extern crate mime;

       use iron::prelude::*;
       use iron::status;

       fn main() {
           println!("Serving on http://localhost:3000...");
           Iron::new(get_form).http("localhost:3000").unwrap();
       }

       fn get_form(_request: &mut Request) -> IronResult<Response> {
           let mut response = Response::new();

           response.set_mut(status::Ok);
           response.set_mut(mime!(Text/Html; Charset=Utf8));
           response.set_mut(r#"
               <title>GCD Calculator</title>
               <form action="/gcd" method="post">
                 <input type="text" name="n"/>
                 <input type="text" name="n"/>
                 <button type="submit">Compute GCD</button>
               </form>
           "#);

           Ok(response)
       }
     #+END_SRC
     + The ~#[macro_use]~ /attribute/ alters Rust that we plan to use /macros/
       *exported* by this /crate/.

     + Use ~*~ to import all the public names of a /module/ is often NOT a good
       idea, but for a module named ~prelude~, which by convention provides
       general facilities that any user of the /crate/ will probably need. In
       this case, a wildcard ~use~ directive makes a bit more sense.

     + =TODO= NOTES =TODO=

   - =TODO= NOTES =TODO=
   - =TODO= NOTES =TODO=
   - =TODO= NOTES =TODO=

** TODO Concurrency - 23
*** What the Mandelbrot Set Actually Is - 24
*** Parsing Pair Command-Line Arguments - 28
*** Mapping from Pixels to Complex Numbers - 31
*** Plotting the Set - 32
*** Writing Image Files - 34
*** A Concurrent Mandelbrot Program - 35
*** Running the Mandelbrot Plotter - 40
*** Safety Is Invisible - 41

* DONE 3. Basic types - 43
  CLOSED: [2018-05-22 Tue 09:03]
  - Rust's types serve several goals:
    + Safety
    + Efficiency
    + Concision

  - =TODO= NOTE 

** DONE Machine Types - 46
   CLOSED: [2018-05-20 Sun 21:28]
   |  Size (bits) | Unsigned integer | Signed integer | Floating-point |
   |--------------+------------------+----------------+----------------|
   |            8 | ~u8~             | ~8~            |                |
   |           16 | ~u16~            | ~i16~          |                |
   |           32 | ~u32~            | ~i32~          | ~f32~          |
   |           64 | ~u64~            | ~i64~          | ~f64~          |
   | Machine word | ~usize~          | ~isize~        |                |

   - The /machine word/ is a value the size of an address on the machine the code
     runs one,  _usually_ (=???=) 32 bits or 64 bits, which depends on the
     target machine.

*** DONE Integer Types - 47
    CLOSED: [2018-05-19 Sat 02:47]
    - *UNLIKE* C and C++,
      Rust treats /characters/ as _distinct_ from the /numeric types/.
      Read "Characters" on Page 52.

    - ~usize~ are analogous to ~size_t~ in C/C++.

    - ~isize~ are analogous to ~ptrdiff_t~ in C/C++.

    - Rust requires /array indices/ to be ~usize~.

    - Values representing
      + the sizes of arrays or vectors

      + the counts of the number of elements in some data structure

      also generally have the ~usize~ type.

    - In /debug build/, Rust compiler checks for integer overflow in arithmetic:
      #+BEGIN_SRC rust
        let big_val = std::i32::MAX;
        let x = big_val + 1;  // panic: arithmetic operation overflowed
      #+END_SRC

    - In /release build/, this addition would wrap to a negative number
      (*UNLIKE* C++, where signed integer overflow is _undefined_ behavior).

      However, it is still a bad to do this operation if you don't want to give
      up forever.

      + Solution: Explicitly tell the compiler that you really know what you do!
        ~let x = big_val.wrapping_add(1);  // ok~

    - /Integer literals/ in Rust can take suffix indicating their type.
      For instance, ~42u8~ and ~1729isize~

      If you don't the /inference/ can satisfy what you want, you can use this
      way to indicate type manually.

    - /Inference/ usually identifies a unique type,
      BUT sometimes any one of several types would work. In this case, Rust
      defaults to ~i32~, if that is among the possibilities. Otherwise, report
      the ambiguity as an error!

    - The radix prefixes of /Integer literals/: ~0x~, ~0o~, and ~0b~.

    - You can insert _underscore_ to make long numbers more legible.
      For instance, ~4_294_967_295~.
        The positions of the _underscore_ is *FLEXIBLE* -- it's designed for
      human, NOT for the compiler! For instance, ~0xfff_ffff~, or ~127_u8~.

    - /Byte literals/    ~b'a'~
      =TODO=

    - Convert from one integer type to another integer type with the ~as~
      operator. For instance, ~10_i8 as u16~

      + =TODO= MORE Details =TODO= =NOTE=

    - /Integers/, like any other sort of value, _can have /methods/._
      Check the standard library documents. For instance, ~std::i32~

*** DONE Floating-Point Types - 50
    CLOSED: [2018-05-20 Sun 21:28]
    - Rust provides
      + IEEE single-precision floating type ~f32~:
        * at least *6* decimal digits
        * Roughly -3.4 \times{} 10^{38} to +3.4 \times{} 10^{38}

      + IEEE double-precision floating type ~f64~:
        * at least *15* decimal digits
        * Roughly -1.8 \times{} 10^{308} to +1.8 \times{} 10^{308}

    - Following the IEEE 754-2008 specification,
      these types include
      + _positive and negative *infinities*,_
      + *distinct* _positive and negative *zero values*,_
      + a *not-a-number value*

    - Rust's ~f32~ and ~f64~ correspond to
      + the ~float~ and ~double~ types in C and C++ implementations that _support_
        IEEE floating point;

      + Java, which _always_ uses IEEE floating point.

    - Example for the /floating-point literals/:
      ~3.1415.926e-4f64~

      + Every part of a floating-point number after the _integer part_ is OPTIONAL,
        but *at least one of* the _fractional part_, _exponent_, or _type suffix_
        *must* be present, to _distinguish_ it from an /integer literal/.

      + ~5.~ is a valid floating-point constant.

      + The default type is ~f64~, if both would be possible,
        which is similar as C/C++/Java.

    - You can add _underscore_ to the _fractional part_.

    - The ~std::f32~ and ~std::f64~ modules define constants for the IEEE-required
      special values like ~INFINITY~, ~NEG_INFINITY~, ~NAN~, and ~MIN~ and ~MAX~
      (the largest and smallest finite values).

    - The ~std::f32::consts~ and ~std::f64::consts~ modules provide various commonly
      used mathematical constants like ~E~, ~PI~, and _the square root of two_.

    - The ~f32~ and ~f64~ types provide a FULL COMPLEMENT of /methods/ for mathematical
      calculations; for example, ~3f64.sqrt()~.

    - The ~type suffix~ is often not required, but when the context is _not clear_,
      you need to write them down:
      ~println!("{}", (2.0).sqrt());~ is non-compilable!

      The correct version can be one of
      + ~println!("{}", (2.0_f64).sqrt());~ or with ~f32~
      + ~println!("{}", f64::sqrt(2.0));~ or with ~f32~

    - You shouldn't expect any implicity conversion for these non collectiontypes
      in Rust.

*** DONE The ~bool~ Type - 51
    CLOSED: [2018-05-19 Sat 02:51]
    - ~as~ can be used to convert ~bool~ values to ~integer~ types:
      #+BEGIN_SRC rust
        assert_eq!(false as i32, 0);
        assert_eq!(true as i32, 1);
      #+END_SRC
      However, you CANNOT convert in the other direction.

    - The info of a ~bool~ value can be saved in a single bit,
      HOWEVER, Rust use an entire byte for a ~bool~ value in memory, so you can
      create a /pointer/ to it.

*** DONE Characters - 52
    CLOSED: [2018-05-19 Sat 12:00]
    - Character (Rust's) :: ~char~ represents a single Unicode character, as a
         32-bit value.

    - Rust uses the char type for single characters in isolation,

      BUT
      Rust uses the /UTF-8 encoding/ for /strings/ and /streams/ of text.

      So,
      a String represents its text as a sequence of UTF-8 bytes, *NOT* as an array
      of ~char~.

    - If you prefer, you can write out a character's /Unicode code point/ in
      hexadecimal:
      + If a /code point/ is in the range U+0000 to U+007F, which is drawn from
        the ASCII character set, can write the character as ~'\xHH'~, where =HH=
        is a two digit hexadecimal number.

      + You can write any Unicode character as ~'\u{HHHHHH}'~, where =HHHHHH= is
        a hexadecimal number between one and six digits long.

    - A ~char~ *ALWAYS* holds a /Unicode code point/ in the range
      + from 0x0000 to 0xD7FF
        OR
      + from 0xE000 to 0x10FFFF

      A ~char~ is *NEVER* a surrogate pair half (from 0xD800 to 0xDFFF), or a
      value outside the Unicode codespace, that is, greater than 0x10FFFF.

    - Conversions:
      Rust *Never Implicitly* converts between ~char~ and any other type.

      + ~char~ --> integer numbers
        Do the *explicit conversion* with ~as~.

      + integer numbers --> ~char~
        * If you do this directly with ~as~, you can only from ~u8~ to ~char~
          - Rationale:
            *Rust intends the ~as~ operator to perform _ONLY_ cheap, infallible
            conversions*,
            BUT
            every integer type _other than_ ~u8~ includes values that are not
            permitted Unicode code points, so those conversions would _require
            runtime checks_.

        * You can use ~std::char::from_u32~, and take any ~u32~ value and returns
          an ~Option<char>~.

    - Check the ~std::char~ to learn more useful methods.
      For instance,
      #+BEGIN_SRC rust
        assert_eq!('*'.is_alphabetic(), false);
        assert_eq!('β'.is_alphabetic(), true);
        assert_eq!('8'.to_digit(10), Some(8));
        assert_eq!('ಠ'.len_utf8(), 3);
        assert_eq!(std::char::from_digit(2, 10), Some('2'));
      #+END_SRC

    - Single /characters/ are not very interesting as /strings/ and /streams/.
      =TODO= "String Types" on page 64.

** DONE Tuples - 54
   CLOSED: [2018-05-19 Sat 12:45]
   - For example,
     ~("Brazil", 1985)~ is a tuple fo type ~(&str, i32)~ (or whatever integer
     type, within a proper context, Rust infers from ~1985~).

   - You can access the elememnts of a /tuple/ ~t~ with ~t.0~, ~t.1~, and so on.

   - unit type :: it is an /empty tuple/, ~()~.

   - Since there is only one value for this type, /unit type/ is written as ~()~. 
     It is used as the return type of functions with only side-effect.

   - Rust consistently permits an *extra trailing comma* everywhere commas are
     used: /function arguments/, /arrays/, /struct/ and /enum/ definitions, and
     so on. For instance, ~("Brazil", 1985)~ and ~("Brazil", 1985,)~ are
     equivalent.

     + *Rationale*:
       This may look odd to human readers, but it can make diffs easier to read
       when entries are added and removed at the end of a list.

   - *UNLIKE* Scala, Rust support /single element tuple/, though the syntax is a
     little wierd! For instance, ~("lonely hearts",)~ is a /single element tuple/
     of type ~(&str,)~. Here the ~,~ in both /value/ and /type/ are mandatory!
     =IMPORTANT=

     =TODO= =???=
     =From Jian= Why do we need /single element tuple/??? Scala has proved that
     /single element tuple/ is NOT useful -- there are always ways to use other
     techniques, and not redundant!

** DONE Pointer types - 55
   CLOSED: [2018-05-19 Sat 13:26]
   - Rust has _SEVERAL_ /types/ that represent memory addresses.

   - We'll discuss *three* /pointer types/ here:
     + /references/
     + /boxes/
     + /unsafe pointers/

*** DONE References - 56
    CLOSED: [2018-05-19 Sat 13:18]
    - For instance, ~&String~ (pronounced "ref String") and ~&i32~ (pronounced
      "ref 32 bit int(eger)").

    - It's easiest to get started by thinking of /references/ as Rust's _BASIC
      pointer type_ -- A /reference/ can point to ANY /value/ ANYWHERE, /stack/
      or /heap/.

    - Rust has ~&~ and ~*~ for /reference/ related operations.
      They are very much like the ~&~ and ~*~ operators in C and C++.

      + The expression ~&x~ produces a reference to ~x~; in Rust terminology, we
        say that it /borrows/ a reference to ~x~.

      + Given a reference ~r~, the expression ~*r~ refers to the value ~r~ points
        to.

    - *LIKE* the ~&~ and ~*~ operators in C and C++, a /reference/ does *NOT*
      automatically free any resources when it goes out of scope.

    - *UNLIKE* the /pointers/ in C/C++, Rust references are *NEVER null*:
      there is simply *no way* to produce a /null reference/ in /safe Rust/.

    - Immutable reference :: ~&T~, like ~const *T~ in C.

    - Mutable reference :: ~&mut T~, like ~*T~ in C.

    - Another major difference is that Rust tracks the /ownership/ and
      /lifetimes/ of values, so mistakes like /dangling pointers/, /double
      frees/, and /pointer invalidation/ are *ruled out at compile time*.
      =TODO=
      Chapter 5 explains Rust’s rules for safe reference use.

*** DONE Boxes - 56
    CLOSED: [2018-05-19 Sat 13:21]
    The simplest way to *allocate* a value in the /heap/ is to use ~Box::new~:
    #+BEGIN_SRC rust
      let t = (12, "eggs");  // (i32, &str)
      let b = Box::new(t);   // Box<(i32, &str)>
    #+END_SRC

    When ~b~ _goes out of scope_, the memory is freed immediately,
    UNLESS ~b~ has been /moved/ -- by returning it, for example. =TODO=
    =TODO= Chpater 4

*** DONE Raw Pointers - 57
    CLOSED: [2018-05-19 Sat 13:26]
    - Rust also has the /raw pointer types/ ~*mut T~ and ~*const T~.
      /Raw pointers/ really are just *LIKE* pointers in C++.

    - Using a /raw pointer/ is *UNSAFE*, because Rust makes no effort to track
      what it points to. For example,
      + /raw pointers/ may be null
        OR
      + they may point to memory that has been freed
        OR
      + they may point to memory that now contains a value of a different type.

       All the classic pointer mistakes of C++ are offered for your enjoyment.

      However, you may *ONLY* _dereference_ /raw pointers/ within an ~unsafe~
      block.

    - ~unsafe~ block :: is Rust's opt-in mechanism for advanced language features
                        whose safety is up to you.

    - If your code has _NO_ ~unsafe~ blocks (or if those it does have are written
      correctly), then the safety guarantees we emphasize throughout this book still hold.
      =TODO=
      For details, see Chapter 21.

** DONE Arrays, Vectors, and Slices - 57
   CLOSED: [2018-05-20 Sun 21:05]
   - Rust has *three* types for representing a _sequence of values_ in memory:
     + ~[T; N]~ 
       An /array/ of ~N~ values, each of type ~T~.
       ~N~ must be known at compile time, which cannot be modified.

     + ~Vec<T>~
       A /vector/ of ~T~'s, which is a _dynamically allocated_, _growable_
       sequence of values of type ~T~. Since its elements live on the /heap/, so
       you can _resize_ /vectors/ at will.

     + ~&[T]~ and ~&mut [T]~, called a /shared slice of ~T~'s/ and /mutable slice
       of ~T~'s/.

       You can think of a /slice/ as a /pointer/ to its first element, together
       with a _count_ of the number of elements you can access starting at that
       point.

       * A /mutable slice/ ~&mut [T]~ lets you read and modify elements, but
         *CANNOT be shared*;

       * a /shared slice/ ~&[T]~ lets you *share access* among several readers,
         but does *NOT let you MODIFY elements*.

   - These types all have the ~len~ /method/.
     They all use the SYNTAX ~v[i]~ to index elements.
     ~i~ must be ~usize~.
     Out of bound indexing will lead to a /panic/.

*** DONE Arrays - 58
    CLOSED: [2018-05-19 Sat 13:48]
    - SYNTAX:
      + Basic: ~let lazy_caterer: [u32; 6] = [1, 2, 4, 7, 11, 16];~
      + Fill in N same values: ~[true; 10000]~ creates an array of 10000 ~bool~'s

    - Rust has *NO* notation for an /uninitialized array/. (In general, Rust
      _ensures_ that code can _NEVER_ access any sort of /uninitialized value/.)

    - Rust /arrays/ doesn't have /methods/ like iterating over elements,
      searching, sorting, filling, filtering ,and so on. They are /methods/ of
      /slices/.

      However, Rust implicitly coverts a /reference/ to an array to a /slice/
      when searching for /methods/, so _you can call any /slice/ /method/ on an
      /array/ DIRECTLY._ For example,
      #+BEGIN_SRC rust
        let mut chaos = [3, 5, 4, 1, 2];
        chaos.sort();
        assert_eq!(chaos, [1, 2, 3, 4, 5]);
      #+END_SRC

    - In fact, even the ~len~ /method/ is a /slice/ only /method/.

    - =TODO= "Slices" on page 62.

*** DONE Vectors - 59
    CLOSED: [2018-05-20 Sun 20:25]
    - SYNTAX (Type):
      ~Vec<T>~

    - vector :: resizable array, which is allocated on the /heap/.

    - The ~vec!~ /macro/ is used to create /vecotr literal/:
      For instance,
      #+BEGIN_SRC rust
        let mut v = vec![2 ,3 ,5, 7];
        assert_eq!(v.iter().fold(1, |a, b| a * b), 210);
      #+END_SRC

    - Add an element: ~v.push(11);~

    - Fill in a /vector/ with a value (the syntax is similar to that of
      /arrays/): ~vec![0; rows * cols]~

    - If you want an empty /vector/ and then push elements into it, use the
      ~Vec::new~ method, which is the same as ~vec![]~.
      #+BEGIN_SRC rust
        let mut v = Vec::new();
        v.push("step");
        v.push("on");
        v.push("no");
        v.push("pets");
        assert_eq!(v, vec!["step", "on", "no", "pets"]);
      #+END_SRC

    - Build a /vector/ from the values produced by an /iterator/:
      #+BEGIN_SRC rust
        let v: Vec<i32> = (0..5).collect();
        assert_eq!(v, [0, 1, 2, 3, 4]);
      #+END_SRC
      The type ~Vec<i32>~ here is required, or the ~collect~ method doesn't know
      the type of the value it will generate.

    - As with /arrays/, you can use /slice methods/ on /vectors/:
      #+BEGIN_SRC rust
        // palindrome!
        let mut v = vec!["a man", "a plan", "a canal", "panama"];
        v.reverse();
        // Reasonable yet disappointing:
        assert_eq!(v, vec!["panama", "a canal", "a plan", "a man"]);
      #+END_SRC
      + Here, the ~reverse~ /method/ is actually defined on /slices/, but the
        call *implicitly borrows* a ~&mut [&str]~ /slice/ from the /vector/, and
        invokes ~reverse~ on that.

    - A ~Vec<T>~ consists of *three* values:
      + a /pointer/ to the heap-allocated buffer allocated to hold the elements;

      + the /number of elements/ that buffer has the capacity to store;
        =From Jian= the ~capacity~ /method/

      + the /number it actually contains now/ (in other words, its length).
        =From Jian= the ~len~ /method/

    - When the buffer has reached its capacity, adding another element to the
      /vector/ entails
      1. *allocating* a larger buffer

      2. *copying* the present contents into it

      3. *updating* the vector's /pointer/ and /capacity/ to describe the new
         buffer
         + capacity :: the buffer it can hold without reallocation.

      4. finally *freeing* the old one.

    - Create a vector with specified /capacity/, and observe its change after
      pushing some elements into it:
      #+BEGIN_SRC rust
        let mut v = Vec::with_capacity(2);
        assert_eq!(v.len(), 0);
        assert_eq!(v.capacity(), 2);

        v.push(1);
        v.push(2);
        assert_eq!(v.len(), 2);
        assert_eq!(v.capacity(), 2);

        v.push(3);
        assert_eq!(v.len(), 3);
        assert_eq!(v.capacity(), 4);
      #+END_SRC
      For the last part above, the /capacity/ you see in your system may be
      _different_.

    - ~insert~ and ~remove~
      #+BEGIN_SRC rust
        let mut v = vec![10, 20, 30, 40, 50];

        v.insert(3, 35);
        assert_eq!(v, [10, 20, 30, 35, 40, 50]);

        v.insert(1);
        assert_eq!(v, [10, 30, 35, 40, 50]);
      #+END_SRC

    - ~pop~
      #+BEGIN_SRC rust
        let mut v = vec!["carmen", "miranda"];
        assert_eq!(v.pop(), Some("miranda"));
        assert_eq!(v.pop(), Some("carmen"));
        assert_eq!(v.pop(), None);
      #+END_SRC

    - Iterate over a /vector/ with ~for~:
      #+BEGIN_SRC rust
        let languages: Vec<String> = std::env::args().skip(1).collect();
        for l in languages {
            println!("{}: {}", l,
                     if l.len() % 2 == 0 {
                         "functional"
                     } else {
                         "imperative"
                     });
        }
        // cargo run Lisp Scheme C C++ Fortran
      #+END_SRC

    - ~Vec~ is an ordinary type defined in Rust,
      NOT built into the language.

      =TODO= Chapter 21 covers how to implement such types

*** TODO Building Vectors Element by Element - 62
    This is a bad idea!!!
    
    - It will involve a lot of re-allocating and copy.
      Whenever a vector outgrows its buffer’s capacity, it chooses a new buffer
      *twice* as large as the old one.

    - =TODO= =???= =TODO=
      =IMPORTANT= but I don't quite understand! =RE-READ=

*** DONE Slices - 62
    CLOSED: [2018-05-20 Sun 21:05]
    - /slice/ (~[T]~) :: a region of an array or vector.
      + Since a /slice/ can be any length, /slices/ *CANNOT* be stored directly
        in variables or passed as function arguments.

      + /Slices/ are _ALWAYS passed by /reference/._
          This is why we often call ~&[T]~'s or ~&str~'s a /slices/, but it is
        acutally /references to a slices/ -- /slices/ almost always appear
        behind /references/!

    - A /reference/ to a /slice/ is /a *fat* pointer/:
      a two-word value comprising
      + a /pointer/ to the /slice/'s first element
      + the number of elements in the /slice/.

    - Example:
      #+BEGIN_SRC rust
        let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];
        let a: [f64; 4] = [0.0, 0.707, 1.0, 0.707];

        let sv: &[f64] = &v;
        let sa: &[f64] = &a;
      #+END_SRC
      + Rust _automatically_ converts the ~&Vec<f64>~ /reference/ and the
        ~&[f64; 4]~ /reference/ to /slice references/ that point directly to the
        data.

    - An ORDINARY /reference/ is a non-owning pointer to _a single value_;
      An /reference/ to a /slice/ is a non-owning pointer to _several values_;

    - You can get a reference to a slice of an array or vector, or _a slice of an
      existing slice_, by indexing it with a range:
      #+BEGIN_SRC rust
        print(&v[0..2]);  // print the first two elements of v
        print(&a[2..]);   // print elements of a starting with a[2]
        print(&sv[1..3]); // print v[1] and v[2]
      #+END_SRC

** DONE String Types - 64 =RE=READ=
   CLOSED: [2018-05-22 Tue 09:03]
   Rust has a similar design as C++: two string types (in C++, they are ~char *~
   and ~std::string~).

*** DONE String Literals - 64
    CLOSED: [2018-05-21 Mon 18:44]
    - SYNTAX: double quoted sequences of characters.

    - A string may span multiple lines:
      #+BEGIN_SRC rust
        println!("In the room the women come and go,
            Singing of Mount Abora");
      #+END_SRC
      The newline character, as well as the spaces at the begining of the second
      line are included in this /string literal/.

      + If one line of a string ends with a backslash,
        then the newline character and the leading whitespace on the next line
        are dropped:
        #+BEGIN_SRC rust
          println!("It was a bright, cold day in April, and \
                    there were four of us-\
                    more or less.");
        #+END_SRC

    - /Raw string/ can reduce the double backslashes in somre strings (e.g.
      regular expressions):
      #+BEGIN_SRC rust
        let default_win_install_path = r"C:\Program Files\Gorillas";
        let pattern = Regex::new(r"\d+(\.\d+)*");
      #+END_SRC

      + You *CANNOT* include a double-quote character in a /raw string/ SIMPLY BY
        putting a backslash in front of it -- remember, we said *NO escape
        sequences are recognized*.

        * Solution: Use pound signs with /raw string/:
          #+BEGIN_SRC rust
            println!(r###"
                This raw string started with 'r###"'.
                Therefore it does not end until we reach a quote mark ('"')
                followed immediately by three pound signs ('###'):
            "###)
          #+END_SRC
          You can add as many pound signs as needed to make it clear where the /raw string/ ends.

*** DONE Byte Strings - 65
    CLOSED: [2018-05-21 Mon 21:45]
    - byte string :: a /string literal/ with the ~b~ prefix.
                     Such a /string/ is a /slice of ~u8~ values/.

    - This combines with all the other string syntax we've shown:
      + span multiple lines

      + use escape sequences

      + use backslashes to join lines.

    - /raw byte string/ starts with ~br"~

    - /byte strings/ can only contains ASCII and \xHH escape sequences.

      You *CANNOT* save other Unicode characters in bytes to form /byte
      strings/.

    - ~&[u8; 3]~

    - Example:
      #+BEGIN_SRC rust
        let method = b"GET";  // &[u8; 3]
        assert_eq!(method, &[b'G', b'E', b'T']);
      #+END_SRC
      The type of ~method~ shown here is ~&[u8; 3]~:
      it's a reference to an /array/ of three bytes.
      =TODO= =???=
      It DOESN'T have any of the /string methods/ we'll discuss in a minute.
      The most string-like thing about it is the syntax we used to write it.

*** DONE Strings in Memory - 65
    CLOSED: [2018-05-21 Mon 23:10]
    - Rust /strings/ are sequences of Unicode characters,
      but they are NOT stored in memory as array of chars.

      Instead, they are stored using UTF-8, a variable-width encoding.

    - Figure 3-3 shows the ~String~ and ~&str~ values created by the code:
      #+BEGIN_SRC rust
        let noodles = "noodles".to_string();
        let oodles = &noodles[1..];
        let poodles = "ಠ_ಠ";
      #+END_SRC
      + A ~String~ has a /resizable buffer/ holding UTF-8 text.
        The buffer is allocated on the /heap/.

    - ~&str~'s ~len()~ /method/ returns its length in byte.
      ~&str~'s ~chars().count()~ returns the number of characters.

    - It is *impossible* to modify a ~&str~:
      #+BEGIN_SRC rust
        let mut s = "hello";
        s[0] = 'c';    // error: the type `str` cannot be mutably indexed
        s.push('\n');  // error: no method named `push` found for the `&str`
      #+END_SRC

    - Create new /strings/ at run time, use ~String~.

    - The type ~&mut str~ does exist, but it is *not very useful*, since almost
      any operation on UTF-8 can *change its overall byte length*, and a /slice/
      *cannot reallocate* its referent.

      =From Jian= This means if you think you need ~&mut str~, it most be
      localized, and you must justify your reasoning!!!

        In fact, the only operations available on &mut str are ~make_ascii_uppercase~
      and ~make_ascii_lowercase~ , which modify the text in place and affect
      only single-byte characters, by definition.

*** DONE String - 67 =RE-READ=
    CLOSED: [2018-05-21 Mon 23:23]
    - ~&str~ is very much like ~&[T]~: a /fat pointer/ to some data.

    - ~String~ is analogous to ~Vec<T>~:
      |                                                  | ~Vec<T>~            | ~String~            |
      |--------------------------------------------------+---------------------+---------------------|
      | Automatically frees buffers                      | Yes                 | Yes                 |
      | Growable                                         | Yes                 | Yes                 |
      | ~::new()~ and ~::with_capacity()~ static methods | Yes                 | Yes                 |
      | ~.reverse()~ and ~.capacity()~ methods           | Yes                 | Yes                 |
      | ~.push()~ and ~.pop()~ methods                   | Yes                 | Yes                 |
      | Range syntax ~v[start..stop]~                    | Yes, returns ~&[T]~ | Yes, returns ~&str~ |
      | Automatic conversion                             | ~&Vec<T>~ to ~&[T]~ | ~&String~ to ~&str~ |
      | Inherits methods                                 | From ~&[T]~         | From &str           |

    - Like a ~Vec~,
      each ~String~ has its own heap-allocated buffer that is _NOT shared_ with
      any other ~String~. When a ~String~ variable goes out of scope, the buffer
      is automatically freed, unless the ~String~ was /moved/.

    - There are several ways to create ~Strings~:
      + The ~.to_string()~ /method/ converts a ~&str~ to a ~String~.
        This *copies* the string: ~let error_message = "too many pets".to_string();~

      + The ~format!()~ macro works just like println!(), except that
        * it returns a new ~String~ instead of writing text to stdout
        * it doesn't automatically add a new line at the end.
        #+BEGIN_SRC rust
          assert_eq!(format!("{}°{:02}′{:02}′′N", 24, 5, 23),
                     "24°05′23′′N".to_string());
        #+END_SRC

      + /Arrays/, /slices/, and /vectors/ of strings have two methods, ~.concat()~ and
        ~.join(sep)~, that form a new String from many strings.
        #+BEGIN_SRC rust
          let bits = vec!["veni", "vidi", "vici"];
          assert_eq!(bits.concat(), "venividivici");
          assert_eq!(bits.join(", "), "veni, vidi, vici");
        #+END_SRC

    - The choice sometimes arises of which type to use: ~&str~ or ~String~.
      =TODO=
      Chapter 5 addresses this question in detail.

      For now it will suffice to point out that a ~&str~ can refer to any /slice/ of
      any /string/, whether it is a /string literal/ (stored in the executable) or a
      ~String~ (allocated and freed at run time).
        This means that ~&str~ is more appropriate for function arguments when
      the caller should be allowed to pass either kind of string.

*** DONE Using Strings - 68
    CLOSED: [2018-05-22 Tue 09:03]
    - /Strings/ support the ~==~ and ~!=~ operators.
      They are used to _compare their values_, rather than address as in Java.
      ~assert!("ONE".to_lowercase() == "one");~

    - /Strings/ also support the comparison operators ~<~, ~<=~, ~>~, and ~>=~,
      as well as many useful methods and functions -- search "str (primitive
      type)" or the "~std::str~" module (or just flip to Chapter 17).
      Here are a few examples:
      #+BEGIN_SRC rust
        assert!("peanut".contains("nut"));
        assert_eq!("ಠ_ಠ".replace("ಠ", "■"), "■_■");
        assert_eq!("    clean\n".trim(), "clean");

        for word in "veni, vidi, vici".split(", ") {
            assert!(word.starts_with("v"));
        }
      #+END_SRC

    - =TODO= =NOTE=
      Keep in mind that, given the nature of Unicode, simple char-by-char
      comparison does not always give the expected answers. For example,
      + the Rust strings ~"th\u{e9}"~ and ~"the\u{301}"~ are both valid Unicode
        representations for *thé*, the French word for tea. Unicode says they
        should both be displayed and processed in the same way, but Rust treats
        them as two completely distinct strings.

        =From Jian=
        Unicode has this trap for people work on it: 
        For one kind of view, there is no unique Unicode representation!
        You cannot belive in your eyes!

      + Similarly, Rust's ordering operators like ~<~ use a simple lexicographical
        order based on character code point values.
          This ordering only sometimes resembles the ordering used for text in the
        user’s language and culture.

        =TODO=
        We discuss these issues in more detail in Chapter 17.

*** DONE Other String-Like Types - 68
    CLOSED: [2018-05-22 Tue 08:59]
    - Rust guarantees that strings are valid UTF-8.

    - Sometimes a program really needs to be able to deal with strings that are
      not valid Unicode.

      + Scenario:
        This usually happens when a Rust program has to interoperate with some
        other system that doesn't enforce any such rules.
          For example, in most OS's it's easy to create a file with a filename
        that isn't valid Unicode. What should happen when a Rust program comes
        across this sort of filename?

      + Solution: =TODO= =Learn More=
        Rust’s solution is to offer a few string-like types for these situations:
        * Stick to ~String~ and ~&str~ for Unicode text.

        * When working with filenames, use ~std::path::PathBuf~ and ~&Path~ instead.

        * When working with binary data that isn't character data at all, use ~Vec<u8>~
          and ~&[u8]~.

        * When working with environment variable names and command-line arguments
          in the native form presented by the operating system, use ~OsString~ and
          ~&OsStr~.

        * When interoperating with C libraries that use null-terminated strings,
          use ~std::ffi::CString~ and ~&CStr~.

** DONE Beyond the basics - 69
   CLOSED: [2018-05-20 Sun 21:30]
   - There are *three* kinds of /user-defined types/, and we'll cover them in
     three successive chapters:
     + ~struct~'s in Chapter 9;
     + ~enum~'s in Chapter 10;
     + ~trait~'s in Chapter 11.

   - /Functions/ and /closures/ have their own types, covered in Chapter 14.

   - The types that make up the standard library are covered throughout the book.
     For example, Chapter 16 presents _the standard collection types_.

* DONE 4. Ownership - 71
  CLOSED: [2018-05-22 Tue 14:50]
** DONE Ownership - 73 =TODO= =NOTE=
   CLOSED: [2018-05-22 Tue 14:50]
   - Rust makes the following pair of promises, both essential to a safe systems
     programming language:
     + You decide the /lifetime/ of each value in your program.
       Rust frees memory and other resources belonging to a value promptly, at a
       point under your control.

     + Even so, your program will *NEVER* use a pointer to an object after it has
       been freed.
       * Using a dangling pointer is a common mistake in C and C++:
         - if you're lucky, your program crashes.
         - if you’re unlucky, your program has a security hole.

       Rust catches these mistakes at /compile time/.

   - =EN= culprit
   - =EN= relinquish control
   - =EN= wager

   - =NOTE=

** DONE Moves - 77
   CLOSED: [2018-05-22 Tue 12:30]
   - In Rust, _for most types_, operations like
     + *assigning* a value to a variable,
     + *passing* it to a function
     + *returning* it from a function
     don't copy the value: they /move/ it.

   - move :: The source relinquishes /ownership/ of the value to the _destination_,
             and becomes _uninitialized_; the _destination_ now *controls* the
             value's lifetime.

   - =TODO= note
   - Python way:
     Copy /pointers/, and use /reference counts/.
     + Cheap to create new variables.
     + Need to maintain /reference counts/ for gc.

   - C++ way:
     Create multiple copies, and each pointer points to its own copy..
     + expensive in creating new variables.
     + Clear in the references of each pointer, and NO /reference counts/.

   - The code below are legal for Python and C++:
     + Python
       #+BEGIN_SRC python
         s = ['udon', 'ramen', 'soba']
         t = s
         u = s
       #+END_SRC

     + C++
       #+BEGIN_SRC c++
         using namespace std;
         vector<string> s = {"udon", "ramen", "soba"};
         vector<string> t = s;
         vector<string> u = s;
       #+END_SRC

   - The similar code is illegal in Rust:
     #+BEGIN_SRC rust
       let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
       let t = s;
       let u = s;

       // error[E0382]: use of moved value: `s`
       //  --> ownership_double_move.rs:9:9
       //   |
       // 8 |     let t = s;
       //   |         - value moved here
       // 9 |     let u = s;
       //   |         ^ value used here after move
       //   |
     #+END_SRC

     The Rust way is NOT intuitive for other languages users, but it has the
     benefits from both Python way and C++ way: Cheap in re-assignment, and
     _NO_ /reference counts/ required.

     + The price you pay is that you must explicitly ask for copies when you
       want them
       #+BEGIN_SRC rust
         let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
         let t = s.clone();
         let u = s.clone();
       #+END_SRC

     + If you really want the Python way, using /reference counts/, you need to
       use The ~Rc~ and ~Arc~ pointer.
       =TODO=
       See "Rc and Arc: Shared Ownership" on page 90.

*** DONE More Operations That Move - 82
    CLOSED: [2018-05-22 Tue 12:05]
    - If you /move/ a value into a variable that was _already initialized_, Rust
      /drops/ the variable's prior value.
      #+BEGIN_SRC rust
        let mut s = "Govinda".to_string();
        s = "Siddhartha".to_string(); // value "Govinda" dropped here
      #+END_SRC

    - If a variable value is /moved/, you assign it a new value (of course, it
      should be a ~mut~ variable), nothing will be /dropped/.
      #+BEGIN_SRC rust
        let mut s = "Govinda".to_string();
        let t = s;
        s = "Siddhartha".to_string();  // nothing is dropped here
      #+END_SRC

    - =TOOD= NOTE
      Read This Example to find out /moves/.

    - /Moving/ values may sound inefficient, but there are two things to keep in
      mind:
      + The /moves/ always apply to the /value proper/, not the /heap storage/
        they own. For /vectors/ and /strings/, the /value proper/ is the three-word
        header alone.

      + The Rust compiler's code generation is good at *seeing through* all these
        /moves/; in practice, the machine code often stores the value directly
        where it belongs.

*** DONE Moves and Control Flow - 84
    CLOSED: [2018-05-22 Tue 11:44]
    The general principle is that, if it's possible for a variable to have had
    its value moved away, and it hasn't definitely been given a new value since,
    it’s considered uninitialized.

    More concrete examples (they are so natural and easy to understand):
    - ~if~
      #+BEGIN_SRC rust
        let x = vec![10, 20, 30];

        if c {
            f(x); // ... ok to move from x here
        } else {
            g(x); // ... and ok to also move from x here
        }

        h(x) // BAD: x is uninitialized here if either path uses it
      #+END_SRC

    - loop
      + Illegal
        #+BEGIN_SRC rust
          let x = vec![10, 20, 30];

          while f() {
              g(x);  // bad: x would be moved in first iteration,
                     // uninitialized in second
          }
        #+END_SRC

      + Legal
        #+BEGIN_SRC rust
          let mut x = vec![10, 20, 30];

          while f() {
              g(x);      // move from x
              x = h();   // give x a fresh value
          }

          e(x);
        #+END_SRC

*** DONE Moves and Indexed Content - 84
    CLOSED: [2018-05-22 Tue 12:30]
    Sometimes you need to assign the values of elements of a collection to a
    variable. If this /moves/ these element values directly, it is wierd that
    we had a initialized collection before, and we will have a collection which
    has uninitialized elements! Rust _forbid_ you doing this :
    #+BEGIN_SRC rust
      // With Compile Error!!!


      // Build a vector of the strings "101", "102", ... "105"
      let mut v = Vec::new();
      for i in 101 .. 106 {
          v.push(i.to_string());
      }

      // Pull out random elements from the vector.
      let third = v[2];
      let fifth = v[4];

      // error[E0507]: cannot move out of indexed content
      //   --> ownership_move_out_of_vector.rs:14:17
      //    |
      // 14 |     let third = v[2];
      //    |                 ^^^^
      //    |                 |
      //    |                 help: consider using a reference instead `&v[2]`
      //    |                 cannot move out of indexed content
    #+END_SRC

    - This is abnormal. We must find a way to resolve this!!!

      Solutions (=From Jian= the main idea is NO gap (uninitialized elements) in
      the middle):
      #+BEGIN_SRC rust
        // Build a vector of the strings "101", "102", ... "105"
        let mut v = Vec::new();
        for i in 101 .. 106 {
            v.push(i.to_string());
        }
      #+END_SRC

      1. Pop a value _off the end_ of the /vector/:
         #+BEGIN_SRC rust
           let fifth = v.pop().unwrap();
           assert_eq!(fifth, "105");
         #+END_SRC

      2. Move a value out of the middle of the vector, and move the last
         element into its spot:
         =From Jian= This operation is wierd ...
         #+BEGIN_SRC rust
           let second = v.swap_remove(1);
           assert_eq!(second, "102");
         #+END_SRC

      3. Swap in another value for the one we're taking out:
         #+BEGIN_SRC rust
           let third = std::mem::replace(&mut v[2], "substitute".to_string());
           assert_eq!(third, "103");
         #+END_SRC

      Let's see what's left of our /vector/ after the operations in steps 1, 2, 3:
      ~assert_eq!(v, vec!["101", "104", "substitute"]);~

    - Collection types like ~Vec~ also generally _offer_ /methods/ to *consume*
      all their elements in a loop:
      #+BEGIN_SRC rust
        let v = vec!["liberté".to_string(),
                     "égalité".to_string(),
                     "fraternité".to_string()];

        for mut s in v {
            s.push('!');
            println!("{}", s);
        }
      #+END_SRC
      This loop will take the ownership of the value of ~v~.

    - If you do find yourself needing to move a value out of an owner that the compiler
      can’t track, you might consider changing the owner’s type to something that can
      dynamically track whether it has a value or not. For example, here’s a variant on the
      earlier example:
      #+BEGIN_SRC rust
        struct Person { name: Option<String>, birth: i32 }
        let mut composers = Vec::new();
        composers.push(Person { name: Some("Palestrina".to_string()),
                                birth: 1525 });
      #+END_SRC
      + You still CANNOT do this: ~let first_name = composers[0].name;~
        Same error as we saw before!

      + But you can do
        #+BEGIN_SRC rust
          let first_name = std::mem::replace(&mut composers[0].name, None);
          assert_eq!(first_name, Some("Palestrina".to_string()));
          assert_eq!(composers[0].name, None);
        #+END_SRC

      + Actually, the ~Option~ way is common enough and you can use a more specific
        /method/ to do the same thing as the ~std::mem::replace~ line above:
        ~let first_name = composers[0].name.take();~

** DONE ~Copy~ Types: The Exception to Moves - 86
   CLOSED: [2018-05-22 Tue 14:21]
   /Moves/ keep ownership of such types clear and assignment cheap.
   But for simpler types like integers or characters, this sort of careful
   handling really isn't necessary.

   - Assigning a value of a ~Copy~ type *copies* the value, _rather than_ /moving/
     it.

   - ~Copy~ types:
     + all the machine integer, floating-point numeric types, the ~char~ and
       ~bool~ types, and a few others.

       =From Jian= (NO SURE?!) All the types that don't need to allocate heap
       storage are ~Copy~ types.

     + A /tuple/ or /fixed-size array/ of ~Copy~ types elements is itself a
       ~Copy~ type.

   - ~struct~'s are by default NOT ~Copty~ type.
     However, if all the fields of a ~struct~ are ~Copy~ types, you can make this
     ~struct~ type ~Copy~ type as well by placing the /attribute/
     ~#[derive(Copy, Clone)]~ above the definition, like so:
     #+BEGIN_SRC rust
       #[derive(Copy, Clone)]
       struct Label { number: u32 }
     #+END_SRC

     + *CAUTION*:
       All fields MUST BE ~Copy~ types!!! OR you'll see an /error/ even if you
       use the /attribute/ ~#[derive(Copy, Clone)]~.

   - Q: Why use non-~Copy~ type as DEFAULT?

     A: If NOT, the type will be very restricted, which can only contain types
        that have no heap storage allocation.

        Change the non-~Copy~ types to ~Copy~ types won't affect your code.
        However, the opposite direction is different, and you need to modify
        your code.

   - One of Rust's principles is that
     + *costs should be apparent to the programmer*.

     + *Basic operations must remain simple*.

     + *Potentially expensive operations should be explicit*,
       like the calls to ~clone~ in the earlier example that make _deep copies_
       of /vectors/ and the /strings/ they contain.

   - =TODO= =TODO= =TODO=
     ~trait~ in general in Chapter 11
     Traits ~Copy~ and ~Clone~ in general in Chapter 13

** DONE ~Rc~ and ~Arc~: shared ownership - 90 =Re-Read= =Reference counter and Circular reference=
   CLOSED: [2018-05-22 Tue 14:49]
   - ~Rc~ and ~Arc~ are safe!
     You CANNOT
     + forget to adjust the reference count

     + create other pointers to the referent that Rust doesn't notice

     + stumble over any of the other sorts of problems that accompany
       reference-counted pointer types in C++.

   - ~Rc~ and ~Arc~ are very similar!
     *The ONLY DIFFERENCE* between them is that an ~Arc~ (/atomic reference count/)
     is safe to share between threads directly, wheereas a plain ~Rc~ uses faster
     /non-thread-safe/ code to update its reference count.

     + Use ~Rc~ if you won't share it between /threads/, and avoid performance
       penalty of an ~Arc~.

     + Rust will *prevent* you from accidentally passing ~Rc~ across a /thread/
       boundary.

     *The two types are otherwise equivalent.*
     We'll only talk about ~Rc~.

   - Use ~Rc~ to simulate the earlier Python code we saw.
     #+BEGIN_SRC rust
       use std::rc::Rc;

       // Rust can infer all these types; written out for clarity
       let s: Rc<String> = Rc::new("shirataki".to_string());
       let t: Rc<String> = s.clone();
       let u: Rc<String> = s.clone();
     #+END_SRC
     + Cloning an ~Rc<T>~ value does NOT copy the ~T~ value;
       instead, it simply creates ANOTHER /pointer/ to it, and increments the
       reference count.

     + The usual /ownership rules/ apply to the ~Rc~ /pointers/ themselves,
       and when the last extant ~Rc~ is /dropped/, Rust /drops/ the ~String~ as
       well.

   - You can use any of ~String~'s usual /methods/ directly on an ~Rc<String>~:
     #+BEGIN_SRC rust
       assert!(s.contains("shira"));
       assert_eq!(t.find("taki"), Some(5));
       println!("{} are quite chewy, almost bouncy, but lack flavor", u);
     #+END_SRC

   - A value owned by an ~Rc~ /pointer/ is *immutable*.
     If you try to add some text to the end of the string:
     #+BEGIN_SRC rust
       s.push_str(" noodles");

       // error: cannot borrow immutable borrowed content as mutable
       //   --> ownership_rc_mutability.rs:12:5
       //    |
       // 12 |     s.push_str(" noodles");
       //    |     ^ cannot borrow as mutable
     #+END_SRC

     + Rust's memory and thread-safety guarantees _depend on_ ensuring that *NO*
       value is ever _SIMULTANEOUSLY_ *shared* _and_ *mutable*.

       Rust assumes the referent of an ~Rc~ /pointer/ might in general be *shared*,
       so it _MUST NOT be_ *mutable*.

       =TODO=
       We explain why this restriction is important in Chapter 5.

   - =TODO= =Re-Write= =NOTE=
     One well-known problem with using /reference counts/ to manage memory is
     that, if there are ever two reference-counted values that point to each
     other, each will hold the other’s /reference count/ above zero, so the
     values will never be freed (Figure 4-13).
     =Circular references=

     It is possible to leak values in Rust this way, but such situations are
     *rare*:

     + MOSTLY:
       You cannot create a cycle without, at some point, making an older value
       point to a newer value. This obviously requires the older value to be
       mutable. Since Rc pointers hold their referents immutable, it’s not
       normally possible to create a cycle.

     + YOU STILL CAN:
       However, Rust does provide ways to create mutable portions of otherwise
       immutable values; this is called /interior mutability/, and we cover it
       in “Interior Mutability” on page 205 =TODO=. If you combine those
       techniques with Rc pointers, you can create a cycle and leak memory.

     *Circular references in a reference count system*

   - weak pointers :: ~std::rc::Weak~. NO details in this book, please refer to
                      the standard library doc.
                      =TODO=

   - /Moves/ and /reference-counted pointers/ are *two* ways to relax the rigidity
     of the /ownership/ tree.

     In the next chapter, we'll look at a *third* way:
     /borrowing/ references to values.

     Once you have become comfortable with both /ownership/ and /borrowing/, you
     will have climbed the steepest part of Rust's learning curve, and you'll be
     ready to take advantage of Rust's unique strengths.

* TODO 5. References and borrowing - 93
  - ALL the /pointer types/ we've seen SO FAR are /owning pointer types/:
    + the simple ~Box<T>~ heap pointer,
    + the pointers internal to ~String~ and ~Vec~ values

  - Owning pointers :: when the /owner/ is /dropped/, the /referent/ goes with
       it.

  - Rust also has /nonowning pointer types/ called /references/, which have no
    effect on their /referents' lifetimes/.

  - It's rather the opposite (/owning pointer types/ and /non-owning pointer types/):
    /references/ must *never outlive* their /referents/.

    You must make it _APPARENT_ in your code that *NO* /reference/ can possibly
    _outlive_ the value it points to.

    To emphasize this, Rust referes to creating a /reference/ to some value as
    /borrowing/ the value:
    What you have borrowed, you must eventually return to its owner!

  - You have two kinds of /references/:
    + shared references :: ~&variable~

    + mutable references :: ~&mut variable~

  - (I didn't copy the wrong code, which is used to introduce the concepts of
    /shared references/ and /mutable references/ here, ONLY the right one -- use
    /reference/ rather than /move/):
    #+BEGIN_SRC rust
      use std::collections::HashMap;

      type Table = HashMap<String, Vec<String>>;

      fn show(table: &Table) {
          for (artist, works) in table {
              println!("works by {}:", artist);
              for work in works {
                  println!(" {}", work);
              }
          }
      }

      fn main() {
          let mut table = Table::new();
          table.insert("Gesualdo".to_string(),
                       vec!["many madrigals".to_string(),
                            "Tenebrae Responsoria".to_string()]);
          table.insert("Caravaggio".to_string(),
                       vec!["The Musicians".to_string(),
                            "The Calling of St. Matthew".to_string()]);
          table.insert("Cellini".to_string(),
                       vec!["Perseus with the head of Medusa".to_string(),
                            "a salt cellar".to_string()]);
          show(table);
      }
    #+END_SRC

  - Modify the ~table~ with with /mutable references/:
    #+BEGIN_SRC rust
      fn sort_works(table: &mut Table) {
          for (_artist, works) in table {
              works.sort();
          }
      }
      sort_works(&mut table);
    #+END_SRC

  - Pass it /by value/, you use the /move/ semantics, and give out the /ownership/.
    Pass it /by reference/, you keep the /ownership/.

** TODO References as Values - 97
*** DONE Rust References Versus C++ References - 97
    CLOSED: [2018-05-24 Thu 12:07]
    - In a nutshell, whereas
      + C++ converts _IMPLICITLY_ between /references/ and /lvalues/ (that is,
        expressions referring to locations in memory), with these conversions
        appearing anywhere they're needed,
        #+BEGIN_SRC c++
          int x = 10;
          int &r = x;       // initialization creates reference implicitly
          assert(r == 10);  // implicitly dereference r to see x's value
          r = 20;           // stores 20 in x, r itself still points to x
        #+END_SRC

      + in Rust you use the ~&~ and ~*~ operators to create and follow /references/,
        #+BEGIN_SRC rust
          let x = 10;
          let r = &x;        // &x is a shared reference to x
          assert!(*r = 10);  // explicitly dereference r
        #+END_SRC

        To create a /mutable reference/, use the ~&mut~ operator:
        #+BEGIN_SRC rust
          let mut y = 32;
          let m = &mut y;     // &mut y is a mutable reference to y
          ,*m += 32;          // explicitly dereference m to set y's value
          assert!(*m == 64);  // add to see y's new value
        #+END_SRC

        with the *exception* of the ~.~ operator, which /borrows/ and
        /dereferences/ _IMPLICITLY_.
        * For instance:
          #+BEGIN_SRC rust
            struct Anime { name: &'static str, bechdel_pass: bool };
            let aria = Anime { name: "Aria: The Animation", bechdel_pass: true };
            let anime_ref = &aria;
            assert_eq!(anime_ref.name, "Aria: The Animation");

            // Equivalent to the above, but with the dereference written out:
            assert_eq!((*anime_ref).name, "Aria: The Animation");
          #+END_SRC

        * ~println!~ macro used in the ~show~ function in the last section expands
          to code that uses the ~.~ operator, so it takes advantage of this
          /implicit deference/ as well.

        * The ~.~ operator can also /implicitly borrow/ a /reference/ to its
          _left operand_, if needed for a /method/ call. For example,
          ~Vec~'s ~sort~ /method/ takes a /mutable reference/ to the vector, so
          the two calls shown here are equivalent:
          #+BEGIN_SRC rust
            let mut v = vec![1973, 1968];

            v.sort();
            // implicitly borrows a mutable reference to v

            (&mut v).sort();
            // equivalent; much uglier
          #+END_SRC

*** DONE Assigning References - 98
    CLOSED: [2018-05-24 Thu 12:17]
    - *Assigning* to a Rust /reference/ makes it _point at a new value_:
      #+BEGIN_SRC rust
        let x = 10;
        let y = 20;
        let mut r = &x;

        if b { r = &y; }
        assert!(*r == 10 || *r == 20);
      #+END_SRC
      The /reference/ ~r~ INITIALLY _points to_ ~x~.
      But if ~b~ is ~true~, the code points it at ~y~ instead, as illustrated in
      Figure 5-1. =TODO= =REVIEW=

      This is *very different from C++*,
      where *assigning* to a /reference/ *stores* the value in its /referent/.
      There's *NO WAY* to point a C++ /reference/ to a location _other than_ the
      one it was initialized with.
      =From Jian=
      The rationale is easy to understand: you didn't /move/ the value, just use
      a /reference/, it is reasonable to NOT write the value to the address where
      the /reference/ ~r~ was initialized to point to.

*** DONE References to References - 99
    CLOSED: [2018-05-24 Thu 12:22]
    - Rust permits /references to references/:
      #+BEGIN_SRC rust
        struct Point { x: i32, y: i32 };
        let point = Point { x: 1000, y: 729 };
        let r: &Point = &point;
        let rr: &&Point = &r;
        let rrr: &&&Point = &rr;
      #+END_SRC
      The ~.~ operator follows as many /references/ as it takes to find its
      target: ~assert_eq!(rrr.y, 729);~

      See the Figure 5-2. A chain of references to references (memory layout)

*** DONE Comparing References - 99
    CLOSED: [2018-05-24 Thu 12:29]
    - Like the ~.~ operator, Rust's comparison operators “see through” any number
      of /references/, *as long as both operands have the SAME type* (=From
      Jian= you can compare SAME type values):
      #+BEGIN_SRC rust
        let x = 10;
        let y = 10;

        let rx = &x;
        let ry = &y;

        let rrx = &rx;
        let rry = &ry;

        assert!(rrx <= rry);
        assert!(rrx == rry);
      #+END_SRC

    - If you actually want to know WHETHER two /references/ point to the SAME
      memory, you can use ~std::ptr::eq~, which compares them as addresses:
      #+BEGIN_SRC rust
        assert!(rx == ry);              // their referents are equal
        assert!(!std::ptr::eq(rx, ry)); // but occupy different addresses
      #+END_SRC

*** DONE References Are Never Null - 100
    CLOSED: [2018-05-24 Thu 12:32]
    /References/ are NEVER /null/, except in the ~unsafe~ block.
    Outside ~unsafe~ block, you CAN'T convert zero into a /reference/ -- the way
    you can used to create /null/ in C/C++.

*** DONE Borrowing References to Arbitrary Expressions - 100
    CLOSED: [2018-05-24 Thu 12:46]
    - Whereas C and C++ ONLY let you apply the ~&~ operator to _certain kinds of
      expressions_,
      Rust lets you /borrow/ a /reference/ to the value of any sort of
      expression at all:
      #+BEGIN_SRC rust
        fn factorial(n: usize) -> usize {
            (1..n+1).fold(1, |a, b| a * b)
        }

        let r = &factorial(6);
        assert_eq!(r + &1009, 1729);
      #+END_SRC
      + In situations like this, Rust simply creates an /anonymous variable/ to
        hold the expression's value, and makes the /reference/ point to that.
          The /lifetime/ of this /anonymous variable/ depends on what you do
        with the /reference/:
        * If you *immediately assign* the /reference/ to a /variable/ in a ~let~
          statement (or make it part of some /struct/ or /array/ that is being
          immediately assigned), then Rust makes the /anonymous variable/ live as
          long as the variable the ~let~ initializes.
            In the preceding example, Rust would do this for the referent of ~r~.

        * Otherwise, the /anonymous variable/ lives to the end of the _enclosing
          statement_. In our example, the /anonymous variable/ created to hold
          ~1009~ lasts only to the end of the ~assert_eq!~ statement.

      + This design seems error-prone for C/C++.
        However, Rust will never let you write code that would produce a
        /dangling reference/. The pointer to /anonymous variables/ will be
        /dropped/ when beyond their /lifetime/.

        If the /reference/ could ever be used *beyond* the /anonymous variable/'s
        /lifetime/, Rust will always report the problem to you at compile time.
          You can then fix your code to keep the referent in a /named variable/
        with an _appropriate_ (=???=) /lifetime/.
      
*** TODO References to Slices and Trait Objects - 101 =TODO=
    /fat pointers/
    /references/ to a /slice/
    /trait object/

** TODO Reference Safety - 101
*** DONE Borrowing a Local Variable - 101
    CLOSED: [2018-05-24 Thu 14:25]
    A pretty obvious case: you _can't_ /borrow/ a /reference/ to a local variable
    and take it out of the variable's scope:

    - Example:
      #+BEGIN_SRC rust
        {
            let r;
            {
                let x = 1;
                r = &x;
            }
            assert_eq!(*r, 1);  // bad: reads memory `x` used to occupy
        }
      #+END_SRC

      Error Message:
      #+BEGIN_SRC text
        error: `x` does not live long enough
          --> references_dangling.rs:8:5
           |
        7  |         r = &x;
           |              - borrow occurs here
        8  |     }
           |     ^ `x` dropped here while still borrowed
        9  |     assert_eq!(*r, 1); // bad: reads memory `x` used to occupy
        10 | }
           | - borrowed value needs to live until here
      #+END_SRC

    - /Lifetimes/ are entirely figments of Rust's /compile-time/ imagination.

      At /runtime/, a /reference/ is nothing but an address;
      its /lifetime/ is *part of* its /type/ and has _NO_ /runtime/
      representation.

    - In this example, there are *three* /lifetimes/ whose relationships we need
      to work out. The variables ~r~ and ~x~ each have a /lifetime/, extending

      from _the point at which they're initialized_
      until _the point that they go out of scop_.

      The third /lifetime/ is that of a /reference type/: the type of the
      /reference/ we /borrow/ to ~&x~, and store in ~r~.

      Here's one *constraint* that should seem pretty obvious:
      if you have a variable ~x~, then a /reference/ to ~x~ *must not* _outlive_
      ~x~ itself, as shown in Figure 5-3.

    - The rules Rust compiler used to do the lifetime check is not so different
      from the process C and C++ programmers impose on themselves; the
      difference is that _Rust knows the rules, and *enforces* them_.

*** TODO Receiving References as Parameters - 105
*** TODO Passing References as Arguments - 107
*** TODO Returning References - 107
*** TODO Structs Containing References - 109
*** TODO Distinct Lifetime Parameters - 111
*** TODO Omitting Lifetime Parameters - 112

** TODO Sharing Versus Mutation - 114
** TODO Taking Arms Against a Sea of Objects - 121

* DONE 6. Expressions - 123 =NOTE=
  CLOSED: [2018-05-23 Wed 22:43]
** DONE An Expression Language - 123
   CLOSED: [2018-05-22 Tue 21:19]
   - Rust is what is called an *expression* language.

** DONE Blocks and Semicolons - 124
   CLOSED: [2018-05-22 Tue 21:19]
   - /Blocks/, too, are expressions
     A /block/ produces a value and can be used _ANYWHERE_ a value is needed:
     #+BEGIN_SRC rust
       let display_name = match post.author() {
           Some(author) => author.name(),
           None         => {
               let network_info = post.get_network_metadata()?;
               let ip           = network_info.client_address();
               ip.to_string()  // NO semicolon here!!!
           }
       }
     #+END_SRC
     + The ~ip.to_string()~ line has no semicolon, and it is the returned value.

     + If all lines in a block has a semicolon at the end, the return value is
       ~()~.

     + Tips:
       #+BEGIN_SRC rust
         // error[E0308]: mismatched types
         //   --> expressions_missing_semicolon.rs:19:9
         //    |
         // 19 |         page.compute_size() // oops, missing semicolon
         //    |         ^^^^^^^^^^^^^^^^^^^ expected (), found tuple
         //    |
         //    = note: expected type `()`
         //               found type `(u32, u32)`
       #+END_SRC
       If you made this mistake in a C or Java program, the compiler would simply point out
       that you’re missing a semicolon. Here’s what Rust says:
       Rust assumes you’ve omitted this semicolon on purpose; it doesn’t consider the possi‐
       bility that it’s just a typo. A confused error message is the result.

       *When you see expected type `()` , look for a missing semicolon first.*

   - Empty statements, ~;~'s, are also allowed in /blocks/.

** TODO Declarations - 126
   - ~let mut~ is kinda of like the ~final~ in Java in some aspect, if not all:
     #+BEGIN_SRC rust
       let name;

       if user.has_nickname() {
           name = user.nickname();
       } else {
           name = generate_unique_name();
           user.register(&name);
       }
     #+END_SRC
     ~name~ assignment appears in two places, but can ONLY be one of them.
     Thus, no ~mut~ required in the declaration of ~name~;

   - A /block/ can also contain /item declarations/.
     An item is simply any declaration that could appear globally in a program
     or module, such as a ~fn~, ~struct~, or ~use~. For instance,
     #+BEGIN_SRC rust
       use std::io;
       use std::cmp::Ordering;

       fn show_files() -> io::Result<()> {
           let mut v = vec![];
           // ...
           fn cmp_by_timestamp_then_name(a: &FileInfo, b: &FileInfo) -> Ordering {
               a.timestamp.cmp(&b.timestamp)
               // first, compare timestamps
                   .reverse()
               // newest file first
                   .then(a.path.cmp(&b.path)) // compare paths to break ties
           }
           v.sort_by(cmp_by_timestamp_then_name);
           // ...
       }
     #+END_SRC

   - =TODO=
     When a ~fn~ xxxxxx

   - =TODO=
     A block can even contain a xxxxx

** DONE ~if~ and match - 127
   CLOSED: [2018-05-22 Tue 21:19]
   - SYNTAX ~if .. else if .. else~:
     #+BEGIN_SRC rust
       if condition1 {
           block_1
       } else if condition2 {
           block_2
       } else {
           block_n
       }
     #+END_SRC
     + /conditions/ doesn't require parentheses.
       The compiler will emit a warning when unnecessary parentheses are
       present.

     + The curly braces for the body blocks are mandatory!

   - SYNTAX ~match~:
     #+BEGIN_SRC rust
       match value {
           pattern => expr,
           // ...
       }
     #+END_SRC
     + If ~expr~ above is a block, the comma may be dropped

     + ~match~ has /exhaustiveness check/

   - The optimization of ~match~:
     + Use a /jump table/, just like a ~switch~ statement in C++.

     + When each arm of a ~match~ produces a constant value, the compiler builds
       an array of those values, and the ~match~ is compiled into an array access.
       Apart from a bounds check, there is a branch-free code.

*** DONE ~if let~ - 129
    CLOSED: [2018-05-22 Tue 21:19]
    - SYNTAX:
      #+BEGIN_SRC rust
        if let pattern = expr {
            block_1
        } else {
            block_2
        }
      #+END_SRC
      + It's never strictly necessary to use ~if let~,
        because ~match~ can do everything ~if let~ can do.

        =From Jian=
        ~match~ syntax is good for aligning conditions and operations, which is
        very convenient! I can imagine any cases that I want to use ~if let~!!!
          I use ~if let~-like syntax in Go, juse because Go DOESN'T HAVE ~match~!

** DONE Loops - 130
   CLOSED: [2018-05-22 Tue 22:01]
   - SYNTAX:
     #+BEGIN_SRC rust
       while condition {
           block
       }

       while let pattern = expr {
           block
       }

       loop {
           block
       }

       for pattern in collection {
           block
       }
     #+END_SRC
     + /Loops/ are also expressions, but they ONLY produce useless value ~()~.

     + ~while~ behaves exactly like the C equivalent, except Rust is stongly
       typed, which means /condition/ must be ~bool~.

     + ~loop~ is used to write /infinite loops/ (with mechanism inside to stop it,
       for instance ~break~ or ~return~ inside).

     + In the ~for~ loop, we often use /range/.
       For instance, ~0..20~ and ~std::ops::Range { start: 0, end: 20 }~ are the
       same, and they are /ranges/.

       ~Range~ can be used with ~for~ loops because ~Range~ is an /iterable type/,
       it implements the ~std::iter::IntoIterator~ /trait/.
       =TODO= Chapter 15
       The standard collections are all iterable, as are /arrays/ and /slices/.

   - In keeping with Rust's /move/ semantics, a ~for~ loop over a value *consumes*
     the value:
     #+BEGIN_SRC rust
       let strings: Vec<String> = error_messages();

       for s in strings {              // each String is moved into s here...
           println!("{}", s);
       }                               // ...and dropped here

       println!("{} error(s)", strings.len()); // error: use of moved value
     #+END_SRC
     + GOOD: This design promises the simplicity in theory.

     + Not so Good, but can be easily walked around:
       * It is very inconvenient in many cases. Use /reference/ instead!
         #+BEGIN_SRC rust
           for rs in &strings {
               println!("String {:?} is at address {:p}.", *rs, rs);
           }
         #+END_SRC
         - ~&strings~ here is ~&Vec<String>~, and
           ~rs~ is ~&String~.

       * Use ~mut~ /reference/ provides a ~mut~ /reference/ to each element:
         #+BEGIN_SRC rust
           for rs in &mut strings {  // the type of `rs` is `&mut String`
               rs.push('\n');  // add a newline to each string
           }
         #+END_SRC

   - =TODO=
     Chapter 15 covers ~for~ loops in greater detail and show many other ways to
     use /iterators/.

   - ~break~ expression exits an _enclosing loop_.

     In Rust, ~break~ works only in /loops/!
       Since ~match~ (the Rust version of C/C++ ~switch~) dosen't have the
     feature of /fall-through/, it doesn't need ~break~.

   - ~continue~

   - A /loop/ can be *labeled* with a /lifetime/.
     =From Jian= the example code below doesn't have a explicit lifetime?!
     #+BEGIN_SRC rust
       'search:
       for room in apartment {
           for spot in room.hiding_spots() {
               if spot.contains(keys) {
                   println!("Your keys are {} in the {}.", spot, room);
                   break 'search;
               }
           }
       }
     #+END_SRC
     + /Labels/ can also be used with ~continue~.

** DONE ~return~ Expressions - 132
   CLOSED: [2018-05-22 Tue 22:07]
   - ~return~ without follow-up value means return ~()~

   - ~return~ can abandon work in progress.
     If you call a function with this kind of ~return~, you may want to use ~?~
     operator to check for errors after calling.
       For instance, ~let output = File::create(filename)?;~, it is shorthand for
     a ~match~ expression:
     #+BEGIN_SRC rust
       let output = match File::create(filename) {
           Ok(f)    => f,
           Err(err) => return Err(err)
       }
     #+END_SRC
     =TODO= See "Propagating Errors" on page 152.

** DONE Why Rust Has ~loop~ - 133 =Re-Read=
   CLOSED: [2018-05-23 Wed 20:44]
   Rust compilers analyze the /control flow/ through your program.

   It is NOT convenient for the compiler to do the analysis with ~while true~
   for some reason (mentioned in the book), and the designer create ~loop~.

   =From Jian=
   This is a plausible reason.
   It is a non-fundamental solution, and a patchy solution!!!
   You should (!!!) solve the ~while true~ problem!!!

** DONE Function and Method Calls - 134
   CLOSED: [2018-05-23 Wed 21:43]
   - Rust usually makes a _sharp distinction_ between /references/ and the
     /values/ they refer to.

     + You cannot pass a /reference/ to a function requires a /value/, or vice versa.

     + However, the ~.~ operator AUTOMATICALLY *dereferences* the caller or
       *borrows* a /reference/ to it as needed.

   - SYNTAX for calling /static methods/:
     ~let mut numbers = Vec::new();~

   - One quirk of Rust syntax:
     When the invocation involves types with generic type parameter(s), the syntax
     is *NOT* intuitive:

     + Error:
       #+BEGIN_SRC rust
         return Vec<i32>::with_capacity(1000);     // error: something about chained comparisons

         let ramp = (0 .. n).collect<Vec<i32>>();  // same error
       #+END_SRC
       The compiler consider ~<~ as /less than operator/, this must be avoided.

       =From Jian= a patchy solution again!

     + Solution:
       * With wierd syntax!
         prefix the type parameter parts with ~::~
         #+BEGIN_SRC rust
           return Vec::<i32>::with_capacity(1000);     // ok, using ::<
           let ramp = (0 .. n).collect::<Vec<i32>>();  // ok, using ::<
         #+END_SRC

       * (_PREFERED_) With the help of /type inference/:
         #+BEGIN_SRC rust
           return Vec::with_capacity(10);            // ok, if the fn return type is Vec<i32>
           let ramp: Vec<i32> = (0 .. n).collect();  // ok, variable's type is given
         #+END_SRC

** DONE Fields and Elements - 135
   CLOSED: [2018-05-23 Wed 22:02]
   - For example:
     #+BEGIN_SRC rust
       game.black_pawns  // struct field
       coords.1          // tuple elements
     #+END_SRC

   - If the left of the dot is a /reference/ or /smart pointer type/, it is
     AUTOMATICALLY *dereferenced*, just as for /method/ calls.

   - SYNTAX like ~pieces[i]~ for /arrays/, /slices/ and /vectors/.

   - The ~..~ operator allows either operand to be omitted.
     #+BEGIN_SRC rust
       ..      // RangeFull
       a ..    // RangeFrom { start: a }
       .. b    // RangeTo { end: b }
       a .. b  // RangeFrom { start: a, end: b }
     #+END_SRC
     + =TODO= =???=
       Only /ranges/ that include a /start value/ are /iterable/,
       =???=

** DONE Reference Operators - 137
   CLOSED: [2018-05-23 Wed 22:18]
   The /address-of operators/, ~&~ and ~&mut~ (covered in Chapter 5).

   The unary ~*~ operator is used to access the value pointed to by a /reference/.
   1. When there is the caller before ~.~, who is a /reference/, /auto dereference/
      will happen.

   2. Therefore, ONLY when we want to read or write the entire value that the
      reference points to. For instance, pass its value as a parameter.
      #+BEGIN_SRC rust
        let padovan: Vec<u64> = compute_padovan_sequence(n);

        for elem in &padovan {
            draw_triangle(turtle, *elem);
        }
      #+END_SRC

** DONE Arithmetic, Bitwise, Comparison, and Logical Operators - 137 =TODO=
   CLOSED: [2018-05-23 Wed 22:30]
   Rust has the usual arithmetic operators, ~+~, ~-~, ~*~, ~/~, and ~%~.
   These operators are mostly like their counterpart in the other languages.

   We'll focus on the few points where Rust departs from tradition:

   - As mentioned in Chapter 3,
     + integer overflow is detected, and causes a /panic/, *in debug builds*.

     + The standard library provides /methods/ LIKE ~a.wrapping_add(b)~ for
       *unchecked* arithmetic.

   - Dividing an integer by zero triggers a /panic/ *even in release builds*.

     Integers have a method ~a.checked_div(b)~ that returns an ~Option~ (~None~
     if ~b~ is zero) and NEVER /panics/.

   - ~%~ can be applied to BOTH /integers/ and /floating numbers/.
     As in C, the result has the same sign as the LHS of the ~%~.

   - Rust use ~!~ rather than the ~~~ for bitwise NOT.

   - /Bit shifting/ is ALWAYS
     + sign-extending on /signed integer types/

     + zero-extending on /unsigned integer types/.

     Since Rust has /unsigned integers/, it does NOT need Java's ~>>>~ operator.

   - *UNLIKE C*, =TODO=
     /Bitwise operations/ have _higher PRECEDENCE_ than comparisons,
     unlike C, so if you write ~x & BIT != 0~ , that means ~(x & BIT) != 0~ , as
     you probably intended.
       This is much more useful than C's interpretation, ~x &(BIT != 0)~ , which
     tests the wrong bit!

** DONE Assignment 138
   CLOSED: [2018-05-23 Wed 22:36]
   - /assignment/ *moves* values of /non-copyable types/.

   - You _cannot_ make a chain of element assignment, and there -- the rightmost
     one will return a ~()~

   - Rust doesn't have ~++~ and ~--~
** TODO Type Casts 139
** DONE Closures - 140
   CLOSED: [2018-05-23 Wed 22:40]
   - Example:
     ~let is_even = |x| x % 2 == 0~

   - The body must a /brace block/.
** TODO Precedence and Associativity - 140 =TODO=
** DONE Onward - 142
   CLOSED: [2018-05-23 Wed 22:43]
   
* TODO 7. Error Handling - 145
  - There are two kinds of errors-handling in Rust:
    + /panic/

    + ~Results~

  - Ordinary errors are handled using ~Result~'s.

    These are typically caused by things _outside_ the program, and such situations
    occur is NOT up to us; even a bug-free program will encounter them from time to
    time. For instance, erroneous input, a network outage, or a permissions problem.

    =TODO=
    Most of this chapter is dedicated to that kind of error.

  - /Panic/ is for the other kind of error, the kind that *should NEVER happen*.

** DONE Panic - 145
   CLOSED: [2018-06-04 Mon 17:23]
   - A program /panics/ when it encounters something so messed up that there MUST
     BE a _bug_ in the program itself. Something like:
     + Out-of-bounds array access

     + Integer division by zero

     + Calling ~.unwrap()~ on an Option that happens to be ~None~

     + Assertion failure

     + the /macro/ ~panic!()~, for cases where your own code find some inconsistency
       during the calculation and discovers that it has gone wrong, and therefore
       need to trigger a /panic/ directly by your code, the ~panic!()~.

       * ~panic!()~ accepts optional ~println!()~-style arguments, for building
         an error message.

   - Check the examples given above, you see that /panics/ are programmer's fault!

   - When a /panic/ happen, Rust gives you a choice:
     + *unwind* the /stack/, which is the *default*!

     + *abort* the /process/

*** TODO Unwinding - 146
    - =EN=
      + pirates divvy up the booty from a raid - 海盜們從突襲中分出戰利品

      + loot - 贓物

    - =TODO= NOTE

    - /Panic/ is _NOT crash_!

      /Panic/ is _NOT undefined behavior_!

    - /Panic/ is more like Java's ~RuntimeException~, or C++'s ~std::logic_error~.

    - The behavior of a /panic/ is *well-defined*;
      it just *shouldn't be happening*!

    - /Panic/ is *safe*!
      It doesn't violate any of Rust's safety rules!

      The idea is that Rust catches the invalid operations, or whatever it is,
      *before* anything bad happens. Since it would be unsafe to proceed, so Rust
      _unwinds the stack_. But the rest of the process can continue running.

    - /Panic/ is *per* /thread/.
      =IMPORTANT=
      =TODO= In Chapter 19, we'll show how a parent thread can find out when a
      child thread panics and handle the error gracefully.

    - There is also a way to *catch* /stack unwinding/, _allowing_ the /thread/
      to *survive and continue running*.
        The standard library function ~std::panic::catch_unwind()~ does this.

        We won't cover how to use it, but this is the mechanism used by Rust's
      /test/ harness to *recover* when an /assertion fails/ in a /test/. (It can
      also be necessary when writing Rust code that can be called from C or C++,
      because *unwinding across non-Rust code is undefined behavior*; =TODO= see
      Chapter 21.) =IMPORTANT=

*** TODO Aborting - 147

** TODO Result - 148
*** TODO Catching Errors - 148
*** TODO Result Type Aliases - 150
*** TODO Printing Errors - 150
*** TODO Propagating Errors - 152
*** TODO Working with Multiple Error Types - 153
*** TODO Dealing with Errors That "Can't Happen" - 155
*** TODO Ignoring Errors - 156
*** TODO Handling Errors in ~main()~ - 156
*** TODO Declaring a Custom Error Type - 157
*** TODO Why Results? - 158

* TODO 8. Crates and Modules - 161
  - This chapter covers the features of Rust that help keep your program organized:
    /crates/ and /modules/.

  - We'll also cover a wide range of topics that come up naturally as your project
    grows, including
    + how to *document* and *test* Rust code,
    + how to *silence* unwanted /compiler warnings/,
    + how to use Cargo to *manage* project /dependencies/ and /versioning/,
    + how to *publish* open source libraries on _crates.io_, and more.

** DONE Crates - 161
   CLOSED: [2018-06-04 Mon 03:34]
   - Rust programs are made of /creates/.

   - Each /crate/ is a /Rust project/:
     + all the source code for a single library or executable

     + plus
       * any associated tests
       * examples
       * tools
       * configuration
       * other things.

   - Later on, we'll see how to tell Cargo to fetch source code from
     + a /Git repository/
       OR 
     + the /local filesystem/ rather than /crates.io/.

   - Once it has obtained all the source code, Cargo compiles all the crates.
     It runs ~rustc~, the Rust compiler, _ONCE_ for each /crate/ in the
     project's dependency graph.

     + When compiling libraries, Cargo uses the =--crate-type lib= option.
       This tells ~rustc~ _NOT_ to look for a ~main()~ function _BUT_ instead to
       produce an =.rlib= file containing compiled code in a form that later
       ~rustc~ commands can use as input.

       When compiling a program, Cargo uses ~--crate-type bin~, and the result
       is a binary executable for the target platform: =mandelbrot.exe= on
       Windows, for example.

   - =TODO= NOTE !!!
   - =TODO= NOTE !!!
   - =TODO= NOTE !!!

   - ~cargo build~ supports all sorts of options, most of which are beyond the
     scope of this book, but we will mention one here:
     ~cargo build --release~ produces an optimized build.

     + Release builds run faster,

     + but
       * they take _longer_ to compile,

       * they _don't check_ for /integer overflow/,

       * they _skip_ ~debug_assert!()~ assertions, and

       * the /stack traces/ they generate on /panic/ are generally *less* reliable.

*** DONE Build Profiles - 164
    CLOSED: [2018-06-04 Mon 03:34]
    - There are several _configuration settings_ you can put in your =Cargo.toml=
      file that affect the ~rustc~ command lines that ~cargo~ generates.
      | Command line            | Cargo.toml section used |
      |-------------------------+-------------------------|
      | ~cargo build~           | ~[profile.debug]~       |
      | ~cargo build --release~ | ~[profile.release]~     |
      | ~cargo test~            | ~[profile.test]~        |

    - The *defaults* are usually fine,
      but one _EXCEPTION_ we've found is when you want to use a /profiler/ -- a
      tool that measures where your program is spending its CPU time. 

      + To get the best data from a /profiler/, you need both
        * optimizations (usually enabled ONLY in release builds)
        * debug symbols (usually enabled ONLY in debug builds).

      To enable both, add this to your =Cargo.toml=:
      #+BEGIN_SRC toml
        [profile.release]
        debug = true  # enable debug symbols in release builds
      #+END_SRC
      + The ~debug~ setting controls the =-g= option to =rustc=.

      With this configuration, when you type =cargo build --release=, you'll get
      a binary with /debug symbols/. The optimization settings are unaffected.

    - *The Cargo documentation* lists many other settings you can adjust.
      =TODO= =IMPORTANT= =READ=

** DONE Modules - 165
   CLOSED: [2018-06-04 Mon 14:36]
   - modules :: Rust's namespaces.

   - /Modules/ are containers for the /functions/, /types/, /constants/, and so on
     that make up your Rust program or library.

     Whereas /crates/ are about code sharing *between* projects, modules are about
     code organization *within* a project. The look like:
     #+BEGIN_SRC rust
       mod spores {
           use cells::Cell;

           /// A cell mode by an adult fern. It disperses on the wind as part of
           /// the fern life cycle. A spore grows into a prothallus -- a whole
           /// separate organism, up to 5mm across -- which produces the zygote
           /// that grows into a new fern. (Plant sex is complicated.)
           pub struct Spore {
               // ...
           }

           // Simulate the production of a spore by meiosis.
           pub fn produce_spore(factory: &mut Sporangium) -> Spore {
               // ...
           }

           // Mix genes to prepare for meiosis (part of interphase).
           fn recombine(parent: &mut Cell) {
               // ...
           }

           // ...
       }
     #+END_SRC

   - Anything that isn't marked ~pub~ is /private/.

   - /Modules/ can _nest_.
     It's fairly common to see a /module/ that's just a collection of /submodules/.
     #+BEGIN_SRC rust
       mod plant_structures {
           pub mod roots {
               // ...
           }

           pub mod stems {
               // ...
           }

           pub mod leaves {
               // ...
           }
       }
     #+END_SRC

*** DONE Modules in Separate Files - 166
    CLOSED: [2018-06-04 Mon 13:18]
    - A module can also be written like this:
      ~mod spores;~

      This tells the compiler that the ~spores~ /module/ lives in a separate file,
      called =spores.rs=:

    - Rust _NEVER_ compiles /modules/ separately, even if they're in separate files:
      when you build a Rust /crate/, you're *recompiling* _ALL_ of its /modules/.

    - A /module/ can have _its own directory_.

      When Rust sees ~mod spores;~, it checks for both =spores.rs= and =spores/mod.rs;=
      *if neither file exists, or both exist, that's an error.*

    - For example (the earlier example ~plant_structures~)
      + Directory Structure:
        #+BEGIN_SRC text
          fern_sim/
          ├── Cargo.toml
          └── src/
              ├── main.rs
              ├── spores.rs
              └── plant_structures/
                  ├── mod.rs
                  ├── leaves.rs
                  ├── roots.rs
                  └── stems.rs
        #+END_SRC

      + Declare /modules/ 
        Declare ~pub mod plant_structures;~ in the =main.rs= causes Rust to load
        =plant_structures/mod.rs=, which declares the three /submodules/:
        #+BEGIN_SRC rust
          // in plant_structures/mod.rs
          pub mod roots;
          pub mod stem;
          pub mod leaves;
        #+END_SRC

        The content of those three /modules/ is stored in separate files named
        =leaves.rs=, =roots.rs=, and =stem.rs=, located alongside =mod.rs= in the
        =plant_structures= directory.

*** DONE Paths and Imports - 167
    CLOSED: [2018-06-04 Mon 13:43]
    - ~::~ is used to access features of a /module/.
      Code anywhere in your project can refer to any standard library feature by
      writing out its /absolute path/:
      #+BEGIN_SRC rust
        if s1 > s2 {
            ::std::mem::swap(&mut s1, &mut s2);
        }
      #+END_SRC
      + It is obvious we have a function call.
        Since it starts with a double colon, it is an absolute path.

        * The path ~::std~ refers to the /top-level module/ of the standard
          library.

        * ~::std::mem~ is a /submodules/ within the standard library, and
          ~::std::mem::swap~ is a /public function/ in that /module/.

    - You can /import/ features into the modules where they're used with ~use~:
      #+BEGIN_SRC rust
        use std::mem;

        if s1 > s2 {
            mem::swap(&mut s1, &mut s2);
        }
      #+END_SRC
      + /Paths/ in ~use~ declarations are automatically /absolute paths/, so there
        is no need for a leading ~::~.

    - /Import/ multiple features at once:
      + ~use std::collections::{HashMap, HashSet};~
      + ~use std::io::prelude::*;~

    - /Modules/ do not automatically inherit names from their /parent modules/.
      For example, suppose we have this in our =proteins/mod.rs=:
      #+BEGIN_SRC rust
        // proteins/mod.rs
        pub enum AminoAcid { ... }
        pub mod synthesis;
      #+END_SRC
      Then the code in =synthesis.rs= does NOT automatically see the type ~AminoAcid~.
      Instead, each module starts with a black slate and must import the names it
      uses:
      #+BEGIN_SRC rust
        // proteins/synthesis.rs
        use super::AminoAcid;  // explicitly import from parent

        pub fn synthesize(seq: &[AminoAcid]) // ...
      #+END_SRC

    - As in the example above, ~super~ is used to access the /parent module/.

    - ~self~ is used to represent /current module/, and you may use it to import
      /current modules/' /submodules/' features:
      #+BEGIN_SRC rust
        // in protein/mod.rs

        // import from a submodule
        use self::synthesis::synthesize;

        // import names from an enum,
        // so we can write `Lys` for lysine, rather than `AminoAcid::Lys`
        use self::AminoAcid::*;
      #+END_SRC

    - Use ~self~ and ~super~ to write /relative paths/.

    - /Submodules/ *can access* /private items/ in their /parent modules/, but they
      have to *import each one by name*.

      use ~super::*;~ ONLY imports items that are marked ~pub~.

    - There is a natural analogy between /modules/ and the /files and
      directories/ of a /Unix filesystem/.
      + ~super~ like ~..~
      + ~self~ like ~.~
      + ~use~ like ~ln~
      + ~extern crate~ like mount a filesystem

*** DONE The Standard Prelude - 169
    CLOSED: [2018-06-04 Mon 13:50]
    - The standard library ~std~ is *automatically* linked with every project.
      It's as though your =lib.rs= or =main.rs= contained an _invisible declaration_
      for it: ~extern crate std;~

    - The /standard prelude/, where is the place ~Vec~ and ~Result~ reside, is
      automatically imported.
        Rust behaves as though every /module/, including the /root module/, started
      with the following import: ~use std::prelude::v1::*;~

    - Naming a /module/ ~prelude~ is just a _convention_ that tells users it's
      meant to be imported using ~*~.
        Ususlly, this is the only use of ~*~, which is encouraged.

*** DONE Items, the Building Blocks of Rust - 170 =RE-READ=
    CLOSED: [2018-06-04 Mon 14:35]
    - A /module/ is made up of /items/.

    - There are several kinds of /item/, and the list is really a list of the
      language's major features:
      + Functions

      + Types =TODO= =RE-READ=
        * User-defined types are introduced using the ~struct~, ~enum~, and ~trait~
          keywords. =TODO= We'll dedicate a chapter to each of them.

        * A /struct's fields/, even /private fields/, are accessible *throughout*
          the /module/ where the /struct/ is declared.

          *Outside* the /module/, only /public fields/ are accessible.

        * It turns out that *enforcing /access control/ by /module/,* rather than
          by /class/ as in Java or C++, is surprisingly helpful for software design.
          - It cuts down on boilerplate /getter/ and /setter/ methods.

          - it largely eliminates the need for anything like C++ ~friend~ declarations.

          - A single /module/ can define several types that work closely together,
            such as perhaps ~frond::LeafMap~ and ~frond::LeafMapIter~, accessing
            each other's /private fields/ as needed, while still hiding those
            implementation details from the rest of your program.

      + Type aliases
        The Rust's ~type~ keyword is like the ~typedef~ in C++.
        ~type Table = HashMap<String, Vec<String>>;~

      + ~impl~ blocks
        It is used to attach /methods/ to /types/.
        For instance,
        #+BEGIN_SRC rust
          impl Cell {
              pub fn distance_from_origin(&self) -> f64 {
                  f64::hypot(self.x, self.y)
              }
          }
        #+END_SRC
        + ~impl~ blocks *CANNOT* be marked ~pub~.

        + /individual methods/ can be marked ~pub~ to make them visible outside
          the current /module/.

        + /Private methods/, like /private struct fields/, are *visible throughout
          the /module/ where they're declared.*

      + Constants =RE-READ=
        The ~const~ keyword introduces a constant.
        The syntax is just LIKE ~let~ except that it may be marked ~pub~, and
        the /type/ is *required*.

        * Uppercase names are conventional for constants.
          For instance: ~pub const ROOM_TEMPERATURE: f64 = 20.0; // Celsius~

        * The ~static~ keyword introduces a /static item/, which is nearly the
          same thing: ~pub static ROOM_TEMPERATURE: f64 = 68.0; // Fahrenheit~

        * A constant is a bit like a C++ ~#define:~ the value is compiled into
          your code every place it's used.

          A ~static~ is a variable that's set up *before* your program starts
          running and lasts until it exits.

        * Use /constants/ for /magic numbers and strings/ in your code.

          Use /statics/ for larger amounts of data, or any time you'll need to
          /borrow a reference/ to the constant value. =TODO= =???=

          =TODO=
          =From Jian=  What are the restrictions for ~const~ and ~static~ values???

        * /constants/ cannot be marked as ~mut~.

          /statics/ can be marked as ~mut~, but as discussed in Chapter 5 =TODO=,
          Rust has no way to enforce its rules about exclusive access on ~mut
          statics~ -- which means a /mut static/ is inherently *non-thread-safe*,
          and /safe code/ cannot use them at all:
          #+BEGIN_SRC rust
            static mut PACKETS_SERVED: usize = 0;
            println!("{} served", PACKETS_SERVED);  // error: use of mutable static
          #+END_SRC

          - Rust discourages global mutable state. For a discussion of the alternatives,
            see "Global Variables" on page 496. =TODO=

      + Modules
        A /module/ can contain /submodules/.
        It can be /public/ or /private/, like any other named item.

      + Imports
        ~use~ and ~extern crate~ declarations are /items/ too.

        Even though they're just aliases, they can be ~pub~!
        #+BEGIN_SRC rust
          // in plant_structures/mod.rs
          // ...
          pub use self::leaves::Leaf;
          pub use self::roots::Root;
        #+END_SRC
        * This means that ~Leaf~ and ~Root~ are /public items/ of the ~plant_structures~
          /module/. They're still simple aliases for ~plant_structures::leaves::Leaf~
          and ~plant_structures::roots::Root~.

        * Another example,
          The /standard prelude/ is written as just such a series of ~pub~ imports.

      + ~extern~ blocks
        Declare a collection of functions written in some other language
        (typically C or C++), and that your Rust code can call them.
        =TODO= See Chapter 21

    - Rust *warns* about /items/ that are _declared_, but _never used_:
      For example,
      #+BEGIN_SRC text
        warning: function is never used: `is_square`
          --> src/crates_unused_items.rs:23:9
           |
        23 | /         pub fn is_square(root: &Root) -> bool {
        24 | |             root.cross_section_shape().is_square()
        25 | |         }
           | |_________^
           |
      #+END_SRC
      This warning can be puzzling, because there are _TWO_ very different
      possible causes:
      + Perhaps this function really is dead code at the moment.
        OR
      + Maybe you meant to use it in other /crates/. =TODO= =TODO= =TODO=
        In that case, you need to *mark it and all enclosing modules as public.*

** DONE Turning a Program into a Library - 172
   CLOSED: [2018-06-04 Mon 17:44]
   You have a executable, and you want to add more facilities.

   You first want to factor out some of functionalities from the executable to a
   /library/.

   - The first step is to factor your existing project into _two_ parts:
     + a /library crate/, which contains all the shared code;

     + an /executable/, which contains the code that's only needed for your existing
       command-line program.

   - Read the (grossly simplified) original code:
     #+BEGIN_SRC rust
       struct Fern {
           size: f64,
           growth_rate: f64
       }

       impl Fern {
           /// Simulate a fern growing for one day.
           fn grow(&mut self) {
               self.size *= 1.0 + self.growth_rate;
           }
       }

       /// Run a fern simulation for some number of days.
       fn run_simulation(fern: &mut Fern, days: usize) {
           for _ in 0 .. days {
               fern.grow();
           }
       }

       fn main() {
           let mut fern = Fern {
               size: 1.0,
               growth_rate: 0.001
           };
           run_simulation(&mut fern, 1000);
           println!("final fern size: {}", fern.size);
       }
     #+END_SRC
     + Assume you have a trivial =Cargo.toml= file:
       #+BEGIN_SRC toml
         [package]
         name = "fern_sim"
         version = "0.1.0"
         authors = ["You <you@example.com>"]
       #+END_SRC

   - Turning this program into a library is easy. Here are the STEPS:
     1. *Rename* the file =src/main.rs= to =src/lib.rs=.

     2. *Add* the ~pub~ keyword to items in =src/lib.rs= that will be public features
        of our library.

     3. *Move* the ~main~ function to a temporary file somewhere.
        =TODO=
        We'll come back to it in a minute.

     The resulting =src/lib.rs= file looks like this:
     #+BEGIN_SRC rust
       pub struct Fern {
           pub size: f64,
           pub growth_rate: f64
       }

       impl Fern {
           /// Simulate a fern growing for one day.
           pub fn grow(&mut self) {
               self.size *= 1.0 + self.growth_rate;
           }
       }

       /// Run a fern simulation for some number of days.
       pub fn run_simulation(fern: &mut Fern, days: usize) {
           for _ in 0 .. days {
               fern.grow();
           }
       }
     #+END_SRC

   - We did nothing to the =Cargo.toml= file.
     By default, =cargo build= looks at the files in our source directory and
     figures out what to build. When it sees the file =src/lib.rs=, it knows to
     build a library.

   - The code in =src/lib.rs= forms the /root module/ of the library.
     Other /crates/ that USE our /library/ can ONLY access the /public items/ of
     this /root module/.

** DONE The =src/bin= Directory - 174
   CLOSED: [2018-06-04 Mon 17:58]
   - *Cargo has some built-in support for _small programs_ that live in the SAME
     codebase as a library.*

   - You can put our program and our library in the same codebase.
     Move the ~main~ function code to the file =src/bin/efern.rs=:
     #+BEGIN_SRC rust
       extern crate fern_sim;
       use fern_sim::{Fern, run_simulation};

       fn main() {
           let mut fern = Fern {
               size: 1.0,
               growth_rate: 0.001
           };

           run_simulation(&mut fern, 1000);
           println!("final fern size: {}", fern.size);
       }
     #+END_SRC

   - Because we've put this file into =src/bin=, the next time we run =cargo build=,
     Cargo will compile _BOTH_
     + the ~fern_sim~ library
       and
     + this program

   - Then you can run the ~efern~ program using =cargo run --bin efern=.
     Use =--verbose= to show the commands Cargo is running:
     #+BEGIN_SRC bash
       #$
       cargo build --verbose
       #Compiling fern_sim v0.1.0 (file:///.../fern_sim)
       #  Running `rustc src/lib.rs --crate-name fern_sim --crate-type lib ...`
       #  Running `rustc src/bin/efern.rs --crate-name efern --crate-type bin ...`

       #$
       cargo run --bin efern --verbose
       #    Fresh fern_sim v0.1.0 (file:///.../fern_sim)
       #  Running `target/debug/efern`

       # final fern size: 2.7169239322355985
     #+END_SRC

   - This time, we still didn't have to make any changes to =Cargo.toml=.
     Thanks to the Cargo default behavior -- it automatically treats =.rs= files
     in =src/bin= as extra programs to build.

   - If you decide to put the executable to its own isolated project, in a
     completely separate directory, you need to add a =Cargo.toml= listing
     ~fern_sim~ as a dependency (suppose these two projects in reside in the
     same directory):
     #+BEGIN_SRC toml
       [dependencies]
       fern_sim = { path = "../fern_sim" }
     #+END_SRC

** DONE Attributes - 175
   CLOSED: [2018-06-04 Mon 18:30]
   Any /item/ in a Rust program can be decorated with /attributes/.

   - /Attributes/ are Rust's catch-all syntax for writing
     + miscellaneous instructions
       and
     + advice to the compiler.

     =From Jian= This is like Java's /annotations/.

   - For example, suppose you're getting this warning:
     + You see a warning like:
       #+BEGIN_SRC text
         libgit2.rs: warning: type `git_revspec` should have a camel case name
             such as `GitRevspec`, #[warn(non_camel_case_types)] on by default
       #+END_SRC

       But you chose this name for a reason, and you wish Rust would shut up about
       it. You can use ~#[allow]~:
       #+BEGIN_SRC rust
         #[allow(non_camel_case_types)]
         pub struct git_revspec {
             // ...
         }
       #+END_SRC

     + /Canditional compilation/ is another feature that's written using an /attribute/,
       the ~#[cfg]~:
       #+BEGIN_SRC rust
         // Only include this module in the project if we're building for Android.
         #[cfg(target_os = "android")]
         mod mobile;
       #+END_SRC

   - You can find a COMPREHENSIVE /attributes/ usage in the *Rust Reference*.
     =TODO= The most commonly used options for ~#[cfg]~ are listed here:
     =TODO= table.

   - The ~#[inline]~ /attribute/.
     #+BEGIN_SRC rust
       /// Adjust levels of ions etc. in two adjacent cells
       /// due to osmosis between them.
       #[inline]
       fn do_osmosis(c1: &mut Cell, c2: &mut Cell) {
           // ...
       }
     #+END_SRC

     + There's one situation where /inlining/ _WON'T happen WITHOUT_ ~#[inline]~.

       When a function or method defined in one /crate/ is _called in another_
       /crate/, Rust WON'T /inline/ it UNLESS
       * it's /generic/ (it has /type parameters/)
         OR 
       * it's explicitly marked ~#[inline]~.

   - This ~#[inline]~ is only a suggestion.
     Rust also supports
     + the more insistent ~#[inline(always)]~;
     + never /inline/ ~#[inline(never)]~.

   - Some /attributes/, like ~#[cfg]~ and ~#[allow]~, can be attached to _a *whole*
     module_ and _apply to everything in it_.

     Others, like ~#[test]~ and ~#[inline]~ , must be attached to _individual_
     /items/.

   - The Rust Reference documents *the full set of supported attributes* in detail.

   - To attach an attribute to _a *whole* crate_, add it at the top of the =main.rs=
     or =lib.rs= file, *before* any /items/, and write ~#!~ instead of ~#~ , like
     this:
     #+BEGIN_SRC rust
       // libgit2_sys/lib.rs
       #![allow(non_camel_case_types)]

       pub struct git_revspec {
           // ...
       }

       pub struct git_error {
           // ...
       }
     #+END_SRC
     + The ~#!~ tells Rust to attach an /attribute/ to the _ENCLOSING_ /item/ rather
       than whatever comes next: in this case, the ~#![allow]~ /attribute/ attaches
       to the _WHOLE_ ~libgit2_sys~ crate, *not just* /struct/ ~git_revspec~.

   - ~#!~ can also be used *inside* /functions/, /structs/, and so on, *but it's
     only TYPICALLY used at the beginning of a file*, to attach an /attribute/ to
     the *whole* /module/ or /crate/.

     Some /attributes/ always use the ~#!~ syntax because they can *only be applied
     to a WHOLE /crate/.*

   - For example, the ~#![feature]~ attribute is used to *turn on* /unstable features/
     of the Rust language and libraries, /features/ that are EXPERIMENTAL, and therefore
     might _have bugs_ or might be _changed or removed in the future_.

     For instance, as we're writing this, Rust has experimental support for
     128-bit integer types ~i128~ and ~u128~ ; but since these types are
     experimental, you can only use them by

     + installing the Nightly version of Rust
       and
     + explicitly declaring that your crate uses them:
       #+BEGIN_SRC rust
         #![feature(i128_type)]

         fn main() {
             // Do my math homework, Rust!
             println!("{}", 9204093811595833589_u128 * 19973810893143440503_u128);
         }
       #+END_SRC

     Over time, the Rust team sometimes /stabilizes/ an /experimental feature/, so
     that it becomes a standard part of the language. The ~#![feature]~ /attribute/
     then becomes superfluous, and Rust generates a warning advising you to remove
     it.

** TODO Tests and Documentation - 178
   - tests :: /ordinary functions/ marked with the ~#[test]~ /attribute/.

   - For example,
     #+BEGIN_SRC rust
       #[test]
       fn math_works() {
           let x: i32 = 1;
           assert!(x.is_positive());
           assert!(x + 1, 2);
       }
     #+END_SRC

     Use ~cargo test~ to run all the tests.
     #+BEGIN_SRC bash
       #$
       cargo test
       #   Compiling math_test v0.1.0 (file:///.../math_test)
       #     Running target/release/math_test-e31ed91ae51ebf22
       #
       # running 1 test
       # test math_works ... ok
       #
       # test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
     #+END_SRC
     =TODO= You'll also see some output about “doc-tests,” which we’ll get to in
     a minute.

   - This works the same whether your /crate/ is an /executable/ or a /library/.

   - Use command like =cargo test math= to run tests that contains the word "math".

   - ~assert!(expr)~

   - ~assert_eq!(v1, v2)~ is just like ~assert!(v1 == v2)~,
     except that if the /assertion/ fails, the error message shows both values.

   - ~assert!~ and ~assert_eq!~ are even used in /release builds/.

     Use ~debug_assert!~ and ~debug_assert_eq!~ if you only want them in /debug
     builds/.

   - To TEST error cases, add the ~#[should_panic]~ /attribute/ to your test to
     specify the error that should happen:
     #+BEGIN_SRC rust
       /// This test passes only if division by zero causes a panic
       /// as we claimed in the previous chapter.

       #[test]
       #[should_panic(expected="divide by zero")]
       fn test_divide_by_zero_error() {
           1 / 0; // should panic!
       }
     #+END_SRC

   - =cargo build --release= skip the testing code.

   - By convention, when your tests get substantial enough to require support
     code, is to put them in a ~tests~ /module/ and declare the WHOLE /module/
     to be testing-only using the ~#[cfg(test)]~ /attribute/:
     #+BEGIN_SRC rust
       #[cfg(test)]
       // include this module only when testing
       mod tests {
           fn roughly_equal(a: f64, b: f64) -> bool {
               (a - b).abs() < 1e-6
           }

           #[test]
           fn trig_works() {
               use std::f64::consts::PI;
               assert!(roughly_equal(PI.sin(), 0.0));
           }
       }
     #+END_SRC

   - /Rust's test/ harness uses _multiple threads_ to run several tests at a time,
     a nice side benefit of your Rust code being *thread-safe by default*.

     To disable this,
     + either run a single test, =cargo test testname=;
       or
     + set the /environment variable/ ~RUST_TEST_THREADS~ to ~1.~



*** TODO Integration Tests - 180
*** TODO Documentation - 181
*** TODO Doc-Tests - 182

** DONE Specifying Dependencies - 185
   CLOSED: [2018-06-04 Mon 20:14]
   - =EN=
     nuanced - 细微差别的

   - Several ways to specify dependencies:
     + NOT published on crate.io
       For instance, specify a Git repository URL and revision:
       ~image = { git = "https://github.com/Piston/image.git", rev = "528f19c" }~

       * As shown here, you can specify the particular ~rev~, ~tag~ , or ~branch~
         to use. (These are all ways of telling Git which revision of the source
         code to check out.)

     + Specify a directory that contains the crate's source code:
       ~image = { path = "vendor/image" }~

*** DONE Versions - 186
    CLOSED: [2018-06-04 Mon 20:09]
    - Cargo interprets the library /crates/ versions info in =Cargo.toml= *rather
      loosely*.

    - It uses the most recent version of a /crate/ that considered compatible with
      the given version base on the rules of /Semantic Versioning/.
      =TODO= Details Note

    - Ways to specify versions in a =Cargo.toml= file:
      | Cargo.toml line         | Meaning                                                       |
      |-------------------------+---------------------------------------------------------------|
      | image = "=0.10.0"       | Use only the exact version 0.10.0                             |
      | image = ">=1.0.5"       | Use 1.0.5 or any higher version (even 2.9, if it's available) |
      | image = ">1.0.5 <1.1.9" | Use a version that's higher than 1.0.5, but lower than 1.1.9  |
      | image = "<=2.7.10"      | Use any version up to 2.7.10                                  |

      + Another version specification you'll occasionally see is the wild card ~*~.
        This tells Cargo that any version will do. Unless some other =Cargo.toml=
        file contains a more specific constraint, Cargo will use _the latest
        available version_.

        =TODO=
        See https://doc.rust-lang.org/cargo/reference/publishing.html to learn
        more details.

    - All the above rules mentioned above is a convention that Cargo will use.
      A developer should follow this convention!!!

      If you break the compatibility, you should bump the version!!!

*** DONE ~Cargo.lock~ - 187
    CLOSED: [2018-06-04 Mon 20:14]
    - Rationale: =TODO=

    - Cargo has a built-in mechanism, the first time you build a project, Cargo
      outputs a =Cargo.lock= file that *records* the _exact version_ of every
      /crate/ it used.

    - Cargo upgrade to newer versions only when you tell it to,
      + either by manually bumping up the version number in your =Cargo.toml=

      + or by runing =cargo update=.

    - If your project is an /executable/, you should commit =Cargo.lock= to version
      control. That way, everyone who builds your project will consistently get the
      same versions.

      The HISTORY of your =Cargo.lock= file will record your dependency updates.

** TODO Publishing Crates to crates.io - 188
** DONE Workspaces - 190
   CLOSED: [2018-06-04 Mon 19:48]
   Suppose you have written many /crates/. They live side by side in a SINGLE
   source repository:
   #+BEGIN_SRC text
     fernsoft/
     ├── .git/...
     ├── fern_sim/
     │   ├── Cargo.toml
     │   ├── Cargo.lock
     │   ├── src/...
     │   └── target/...
     ├── fern_img/
     │   ├── Cargo.toml
     │   ├── Cargo.lock
     │   ├── src/...
     │   └── target/...
     └── fern_video/
         ├── Cargo.toml
         ├── Cargo.lock
         ├── src/...
         └── target/...
   #+END_SRC
   Each /crate/ has its own /build directory/, =target=, which contains a separate
   build of all the crate's dependencies.

   These /build directories/ are *completely independent*.

   Even if two crates have a common dependency, they can’t share any compiled
   code.

   - Q :: This is wasteful. Do we have another way?

   - A :: You can save compilation time and disk space by using a Cargo /workspace/,
          a collection of /crates/ that share a COMMON /build directory/ and
          =Cargo.lock= file.
     1. Details:
       * Create a =Cargo.toml= file in your _repository's root directory_ and put
         these lines in it;
         #+BEGIN_SRC toml
           [workspace]
           members = ["fern_sim", "fern_img", "fern_video"]
         #+END_SRC
         =fern_sim=, =fern_img"=, and =fern_video= are your /crate/ directory names.

       * You also need to delete all the =Cargo.lock= files and =target= directories
         that exist in those subdirectories.

     2. Once you've done these steps above, =cargo build= in ANY /crate/ will
        automatically create and use a _shared_ /build directory/ under the root
        directory (in this case, =fernsoft/target=).

        The command =cargo build --all= builds all /crates/ in the CURRENT /workspace/.
        =cargo test= and =cargo doc= accept the =--all= option as well.

** DONE More Nice Things - 191
   CLOSED: [2018-06-04 Mon 19:26]
   In case you're NOT delighted yet, the Rust community has a few more odds and
   ends for you:
   - When you publish an open source /crate/ on *crates.io*, your documentation
     is _AUTOMATICALLY_ rendered and hosted on =docs.rs= thanks to Onur Aslan.

   - If your project is on GitHub, /Travis CI/ can build and test your code on
     EVERY push.

     It's surprisingly easy to set up; see travis-ci.org for details. If you're
     already familiar with Travis, this =.travis.yml= file will get you started:
     #+BEGIN_SRC yaml
       language: rust
       rust:
         - stable
     #+END_SRC

   - You can generate a =README.md= file _from_ your /crate/'s top-level doc-comment.
     This feature is offered as a _third-party Cargo plugin_ by Livio Ribeiro.

     Run =cargo install readme= to install the plugin, then =cargo readme --help=
     to learn how to use it.

   We could go on.

* TODO 9. Structs - 193
  - Rust has *three* kinds of /struct types/:
    + named-field,
    + tuple-like,
    + unit-like,

    which _differ in_ HOW YOU REFER TO THEIR COMPONENTS:
    + a named-field struct gives a name to each component

    + a tuple-like struct identifies them by the order in which they appear

    + a unit-like structs have no components at all; these are not common, but
      more useful than you might think. =TODO= =???=

  - In this chapter, we'll
    + explain each kind in DETAIL

    + show what they look like IN MEMORY.

    + cover
      * HOW to ADD /methods/ to them

      * HOW to DEFINE /generic struct types/ that work with many different component types

      * HOW to ask Rust to GENERATE implementations of common handy /traits/ for
        your /structs/.

** DONE Named-Field Structs - 193
   CLOSED: [2018-06-05 Tue 13:49]
   - Define (by example):
     #+BEGIN_SRC rust
       /// A rectangle of eight-bit grayscale pixels.
       struct GrayscaleMap {
           pixels: Vec<u8>,
           size: (usize, usize)
       }
     #+END_SRC
     + By convention
       * Use CamelCase for the name of /types/.
       * Use snake\under{}case for the name of /fields/ and /methods/.

   - Use (by example):
     #+BEGIN_SRC rust
       let width = 1024;
       let height = 576;
       let image = GrayscaleMap {
           pixels: vec![0; width * height],
           size: (width, height)
       };
     #+END_SRC

     A shorthand for populating fields from local variables or arguments with the
     same name:
     #+BEGIN_SRC rust
       fn new_map(size: (usize, usize), pixels: Vec<u8>) -> GrayscaleMap {
           assert_eq!(pixels.len(), size.8 * size.1);
           GrayscaleMap { pixels, size }
       }
     #+END_SRC

   - A /struct/ and its /fields/ are _private by default_, which means they can
     only be seen in the /module/ where it is defined.

     Use ~pub~ to make a /struct/ public! Don't forget to also add ~pub~ to
     fields.

   - =TODO= The first paragraph of Page 195 =???=

   - Use ~.. EXPR~ to initialize some /fields/ that has not been initialized.
     #+BEGIN_SRC rust
       struct Broom {
           name: String,
           height: u32,
           health: u32,
           position: (f32, f32, f32),
           intent: BroomIntent
       }

       /// Two possible alternatives for what a `Broom` could be working on.
       #[derive(Copy, Clone)]
       enum BroomIntent { FetchWater, DumpWater }

       // Receive the input Broom by value, taking ownership.
       fn chop(b: Broom) -> (Broom, Broom) {
           // Initialize `broom1` mostly from `b`, changing only `height`. Since
           // `String` is not `Copy`, `broom1` takes ownership of `b`'s name.
           let mut broom1 = Broom { height: b.height / 2, .. b };

           // Initialize `broom2` mostly from `broom1`. Since `String` is not
           // `Copy`, we must clone `name` explicitly.
           let mut broom2 = Broom { name: broom1.name.clone(), .. broom1 };

           // Give each fragment a distinct name.
           broom1.name.push_str(" I");
           broom2.name.push_str(" II");

           (broom1, broom2)
       }
     #+END_SRC

** DONE Tuple-Like Structs - 196
   CLOSED: [2018-06-05 Tue 14:01]
   - Example:
     ~struct Bounds(usize, usize);~

     It's like a tuple, but it must be created with the /struct/ name.
     ~let image_bounds = Bounds(1024, 768);~

   - The values held by a tuple-like /struct/ are called /elements/.

   - Access the /elements/ of a tuple just as you would a tuple's:
     ~assert_eq!(image_bounds.0 * image_bounds.1, 786432);~

   - Use ~pub~:
     ~pub struct Bounds(pub usize, pub usize);~

   - The expression ~Bounds(1024, 768)~ _looks like_ a /function call/, and in
     fact it is: defining the type also _implicitly defines_ a function:
     ~fn Bounds(elem0: usize, elem1: usize) -> Bounds { ... }~

   - At the most fundamental level,
     _named-field_ and _tuple-like_ /structs/ are very similar.

   - /Tuple-like structs/ are good for /newtypes/, /structs/ with a single component
     that you define to get stricter type checking. For example, if you are working
     with ASCII-only text, you might define a /newtype/ like this:
     ~struct Ascii(Vec<u8>);~

     Using this /type/ for your ASCII strings is much better than simply passing
     around ~Vec<u8>~ buffers and explaining what they are in the comments.

     =TODO=
     We'll give an example of using /newtypes/ for efficient type conversions in
     Chapter 21.

** DONE Unit-Like Structs - 197
   CLOSED: [2018-06-05 Tue 14:09]
   - Define (by example):
     #+BEGIN_SRC rust
       struct Onesuch;
     #+END_SRC

   - A value of such a type occupies no memory, much like the unit type ~()~.

     Rust doesn't bother actually storing /unit-like struct/ values in memory or
     generating code to operate on them, because it can tell everything it might
     need to know about the value from its type alone.
       But logically, an empty struct is a type with values like any other -- or
     more precisely, a type of which there is only a single value: ~let o = Onesuch;~

   - =TODO= =???= =???= =???= =???= =???= =???= =???= =???= =???=
     You've already encountered a /unit-like struct/ when reading about "Fields
     and Elements” on page 135. Whereas an expression like ~3..5~ is shorthand
     for the /struct value/ ~Range { start: 3, end: 5 }~ , the expression ~..~, a
     range omitting both end-points, is shorthand for the /unit-like struct/
     value ~RangeFull~.

   - =TODO= =TODO= =TODO=
     /Unit-like structs/ can also be useful when working with /traits/, which
     we'll describe in Chapter 11.

** DONE Struct Layout - 197
   CLOSED: [2018-06-05 Tue 14:20]
   - Figure 9-1. A ~GrayscaleMap~ structure in memory

     + UNLIKE C and C++, Rust _doesn't make specific promises_ about how it will
       order a struct's fields or elements in memory;
         Figure 9-1 shows only one possible arrangement.

     + However, Rust does promise to *store fields' values directly* IN the _struct's
       block of memory_.

       Whereas JavaScript, Python, and Java would put the ~pixels~ and ~size~ values
       each in their own heap-allocated blocks and have ~GrayscaleMap~'s fields
       point at them,
       =TODO= =???= =???= =???= =???= =???= =???= =???= =???= =???= =???= =???=
         Rust embeds pixels and size directly in the GrayscaleMap value. Only the
       heap-allocated buffer owned by the pixels vector remains in its own
       block.

   - You can ask Rust to lay out our structures in a way compatible with C and C++,
     using the ~#[repr(C)]~ /attribute/. =TODO= We'll cover this in detail in
     Chapter 21.

** DONE Defining Methods with ~impl~ - 198
   CLOSED: [2018-06-05 Tue 19:16]
   You can define /methods/ on ANY /struct type/ you define in a SEPARATE
   ~impl~ block.
   For example,
   #+BEGIN_SRC rust
     /// A last-in, first-out queue of characters.
     pub struct Queue {
         older: Vec<char>,  // older elements, eldest last.
         younger: Vec<char> // younger elements, youngest last.
     }

     impl Queue {
         pub fn new() -> Queue {
             Queue { older: Vec::new(), younger: Vec::new() }
         }

         /// Push a character onto the back of a queue.
         pub fn push(&mut self, c: char) {
             self.younger.push(c);
         }

         /// Pop a character off the front of a queue. Return `Some(c)` if there
         /// was a character to pop, or `None` if the queue was empty.
         pub fn pop(&mut self) -> Option<char> {
             if self.older.is_empty() {
                 if self.younger.is_empty() {
                     return None;
                 }

                 // Bring the elements in younger over to older, and put them in
                 // the promised order.
                 use std::mem::swap;
                 swap(&mut self.older, &mut self.younger);
                 self.older.reverse();
             }

             // Now older is guaranteed to have something. Vec's pop method
             // already returns an Option, so we're set.
             self.older.pop()
         }
     }
   #+END_SRC

   - /Methods/ are also known as /associated functions/.
     + /static method/: ~new~ -- usage: ~TypeName::method~
     + /instance methods/: ~push~ and ~pop~ -- usage: ~instanceName::method~

   - Rust lets you omit the type, and write ~self~, ~&self~, or ~&mut self~ as
     shorthand for ~self: Queue~, ~self: &Queue~ or ~self: &mut Queue~.

   - UNLIKE C++ and Java, the ~self~ must be used explicitly everytime!

   - _SYNTACTIC SUGAR_:
     Simply writing ~q.push(...)~ _borrows a mutable reference_ to ~q~ , as if
     you had written ~(&mut q).push(...)~, since that's what the ~push~
     /method/'s ~self~ requires.

   - Although you can have many separate ~impl~ blocks for a single type, they
     *MUST* all be in the SAME /crate/ that defines that type.

     =TODO=
     However, Rust does let you attach your own methods to other types; we'll
     explain how in Chapter 11.

   - Pros of separating a type's /methods/ from its definition:
     + It's always easy to find a type's /data members/.

       /Data members/ are NOT mixed with tens of /functoin members/ as in C++.

     + Although one can imagine fitting /methods/ into the syntax for /named-field
       structs/, it's not so neat for /tuple-like and unit-like structs/.
       =From Jian= TODO ??? IMAGINE ??

       Pulling methods out into an ~impl~ block allows a single syntax for all
       three.

     + The same ~impl~ syntax also serves neatly for implementing /traits/, which
       we will go into in Chapter 11.

** DONE Generic Structs - 202
   CLOSED: [2018-06-05 Tue 20:14]
   - For example,
     #+BEGIN_SRC rust
       pub struct Queue<T> {
           older: Vec<T>,
           younger: Vec<T>
       }
     #+END_SRC

     The corresponding ~impl~ block:
     #+BEGIN_SRC rust
       impl<T> Queue<T> {
           pub fn new() -> Queue<T> {
               Queue { older: Vec::new(), younger: Vec::new() }
           }

           pub fn push(&mut self, t: T) {
               self.younger.push(t);
           }

           pub fn is_empty(&self) -> bool {
               self.older.is_empty() && self.younger.is_empty()
           }

           // ...
       }
     #+END_SRC

   - Inside the ~impl~ block of ~Queue<T>~, you can use ~Self~ to represent ~Queue<T>~.

   - In the body of ~new~ you didn't write the /type parameter/ in the construction
     expression; simply writing ~Queue { ... }~ was good enough due to /type inference/
     -- since there is only one type that works for the function's return value.

   - However, you'll always need to supply /type parameters/ in /function signatures/
     and /type definitions/. Rust doesn't infer those; instead, it uses those
     /explicit types/ as the *basis* from which it infers types within function bodies.

   - With the help of /type inference/, you usully don't write code like:
     ~let mut q = Queue::<char>::new();~

     You can write:
     #+BEGIN_SRC rust
       let mut q = Queue::new();
       let mut r = Queue::new();

       q.push("CAD");  // apparently a Queue<&'static str>
       r.push(0.74);   // apparently a Queue<f64>

       q.push("BTC");  // Bitcoins per USD, 2017-5
       r.push(2737.7); // Rust fails to detect irrational exuberance
     #+END_SRC

** DONE Structs with Lifetime Parameters - 203
   CLOSED: [2018-06-05 Tue 21:03]
   For example, here's a structure that might hold references to the greatest
   and least elements of some slice:
   #+BEGIN_SRC rust
     struct Extrema<'elt> {
         greatest: &'elt i32,
         least: &'elt i32
     }

     fn find_extrema<'s>(slice: &'s [i32]) -> Extrema<'s> {
         let mut greatest = &slice[0];
         let mut least = &slice[0];

         for i in 1..slice.len() {
             if slice[i] < *least    { least    = &slice[i]; }
             if slice[i] > *greatest { greatest = &slice[i]; }
         }

         Extrema { greatest, least }
     }
   #+END_SRC
   - Since in the ~find_extrema~ function, the ~'s~ is the only /lifetime/, you
     can write ~fn find_extrema<'s>(slice: &'s [i32]) -> Extrema~ for short.

     You might have meant ~Extrema<'static>~, but that's pretty unusual.
     *Rust provides a shorthand for the common case!*

** DONE Deriving Common Traits for Struct Types - 204
   CLOSED: [2018-06-05 Tue 14:37]
   - After defining a /struct/, you would quickly notice that it's a bit of a pain:
     + you can't print it with ~println!("{:?}", point);~

     + it does NOT support the ~==~ and ~!=~ operators.

     Each of these features has a name in Rust -- ~Copy~, ~Clone~, ~Debug~, and
     ~PartialEq~. They are called /traits/. You can add these features to your
     /struct/:
     #+BEGIN_SRC rust
       #[derive(Copy, Clone, Debug, PartialEq)]
       struct Point {
           x: f64,
           y: f64
       }
     #+END_SRC

   - ~PartialCmp~ can also be derived to support the comparison operators ~<~, ~>~,
     ~<=~, and ~>=~. We haven't done so here, because comparing two points to see
     if one is "less than" the other is actually a pretty weird thing to do.

   - Implementing a /trait/ is automatically a *public* feature, so copyability,
     cloneability, and so forth are all part of your /struct's public API/ and
     should be chosen deliberately. =IMPORTANT=

   - =TODO=
     We'll describe Rust's standard /traits/ in detail, and tell which ones are
     ~#[derive]~ able, in Chapter 13.

** TODO Interior Mutability - 205
   - =EN=
     Interior - 內部

   - /Mutability/ is like anything else:
     in excess, it causes problems, but you often want just a little bit of it.

* TODO 10. Enums and patterns - 211
  - Rust /enumerations/ (simply /enums/) are the analog of /algebraic data types/
    (or known as /sum types/ or /discriminated unions/) in ML and Haskell.

** TODO Enums - 212
*** TODO Enums with Data - 214
    - =TODO= NOTES
    - All constructors and fields of a public enum are automatically public.
*** TODO Enums in Memory - 215
*** TODO Rich Data Structures Using Enums - 216
*** TODO Generic Enums - 218

** TODO Patterns - 221
*** TODO Literals, Variables, and Wildcards in Patterns - 223
*** TODO Tuple and Struct Patterns - 225
*** TODO Reference Patterns - 226
*** TODO Matching Multiple Possibilities - 229
*** TODO Pattern Guards - 229
*** TODO ~@~ patterns - 230
*** TODO Where Patterns Are Allowed - 230
*** TODO Populating a Binary Tree 232

** TODO The Big Picture - 233

* TODO 11. Traits and Generics - 235
** TODO Using Traits - 237
*** TODO Trait Objects - 238
*** TODO Trait Object Layout - 239
*** TODO Generic Functions - 240
*** TODO Which to Use - 243

** TODO Defining and Implementing Traits - 245
*** TODO Default Methods - 246
*** TODO Traits and Other People's Types - 247
*** TODO Self in Traits - 249
*** TODO Subtraits - 250
*** TODO Static Methods - 251

** TODO Fully Qualified Method Calls - 252
** TODO Traits That Define Relationships Between Types - 253
*** TODO Associated Types (or How Iterators Work) - 254
*** TODO Generic Traits (or How Operator Overloading Works) - 257
*** TODO Buddy Traits (or How ~rand::random()~ Works) - 258

** TODO Reverse-Engineering Bounds - 260
** TODO Conclusion - 263

* TODO 12. Operator Overloading - 265
** TODO Arithmetic and Bitwise Operators - 266
*** TODO Unary Operators - 268
*** TODO Binary Operators - 269
*** TODO Compound Assignment Operators - 270
** TODO Equality Tests - 272
** TODO Ordered Comparisons - 275
** TODO ~Index~ and ~IndexMut~ - 277
** TODO Other Operators - 280

* TODO 13. Utility Traits - 281
** ~Drop~ - 282
** ~Sized~ - 285
** ~Clone~ - 287
** ~Copy~ - 289
** ~Deref~ and ~DerefMut~ - 289
** ~Default~
** ~AsRef~ and ~AsMut~ - 294
** ~Borrow~ and ~BorrowMut~ - 296
** ~From~ and ~Into~ - 297
** ~ToOwned~ - 300
** ~Borrow~ and ~ToOwned~ at Work: The Humble ~Cow~ - 300

* TODO 14. Closures - 303
  - Example:
    #+BEGIN_SRC rust
      struct City {
          name: String,
          population: i64,
          country: String,
          // ...
      }
    #+END_SRC

    + WITHOUT a /closure/:
      #+BEGIN_SRC rust
        /// Helper function for sorting cities by population.
        fn city_population_descending(city: &City) -> i64 {
            -city.population
        }
        fn sort_cities(cities: &mut Vec<City>) {
            cities.sort_by_key(city_population_descending);
        }
      #+END_SRC

    + WITH a /closure/:
      #+BEGIN_SRC rust
        fn sort_cities(cities: &mut Vec<City>) {
            cities.sort_by_key(|city| -city.population);
        }
      #+END_SRC

  - In this chapter,
    + you'll learn
      * how to use closures with standard library methods
      * how a closure can “capture” variables in its scope
      * how to write your own functions and methods that take closures as arguments
      * how to store closures for later use as callbacks.

    + We'll also explain
      * how /Rust closures/ work
      * why they're *faster* than you might expect.

** TODO Capturing Variables - 305
   - A /closure/ can USE DATA that belongs to an /enclosing function/.

*** TODO Closures That Borrow - 306
*** TODO Closures That Steal - 306

** TODO Function and Closure Types - 308
** TODO Closure Performance - 310
** TODO Closures and Safety - 311
*** TODO Closures That Kill - 312
*** TODO ~FnOnce~ - 312
*** TODO ~FnMut~ - 314

** TODO Callbacks - 316
** TODO Using Closures Effectively - 319

* TODO 15. Iterators - 321
** TODO The ~Iterator~ and ~IntoIterator~ Traits - 322
** TODO Creating ~Iterator~'s - 324
*** TODO ~iter~ and ~iter_mut~ Methods - 324
*** TODO ~IntoIterator~ Implementations - 325
*** TODO ~drain~ Methods - 327
*** TODO Other ~Iterator~ Sources - 328

** TODO ~Iterator~ Adapters - 330
*** TODO ~map~ and ~filter~ - 330
*** TODO ~filter_map~ and ~flat_map~ - 332
*** TODO ~scan~ - 335
*** TODO ~take~ and ~take_while~ - 335
*** TODO ~skip~ and ~skip_while~ - 336
*** TODO ~peekable~ - 337
*** TODO fuse - 338
*** TODO Reversible ~Iterator~'s and ~rev~ - 339
*** TODO ~inspect~ - 340
*** TODO ~chain~ - 341
*** TODO ~enumerate~ - 341
*** TODO ~zip~ - 342
*** TODO ~by_ref~ - 342
*** TODO ~cloned~ - 344
*** TODO ~cycle~ - 344
** TODO Consuming Iterators - 345
*** TODO Simple Accumulation: ~count~, ~sum~, ~product~ - 345
*** TODO ~max~, ~min~ - 346
*** TODO ~max_by~, ~min_by~ - 346
*** TODO ~max_by_key~, ~min_by_key~ - 347

*** TODO Comparing Item Sequences - 347
*** TODO ~any~ and ~all~ - 348
*** TODO ~position~, ~rposition~, and ~ExactSizeIterator~ - 348
*** TODO ~fold~ - 349
*** TODO ~nth~ - 350
*** TODO ~last~ - 350
*** TODO ~find~ - 351
*** TODO Building Collections: ~collect~ and ~FromIterator~ - 351
*** TODO The ~Extend~ Trait - 353
*** TODO ~partition~ - 353

** TODO Implementing Your Own Iterators - 354

* TODO 16. Collections - 359
** TODO Overview - 360
** TODO ~Vec<T>~ - 361
*** TODO Accessing Elements - 362
*** TODO Iteration - 364
*** TODO Growing and Shrinking Vectors - 364
*** TODO Joining - 367
*** TODO Splitting - 368
*** TODO Swapping - 370
*** TODO Sorting and Searching - 370
*** TODO Comparing Slices - 372
*** TODO Random Elements - 373
*** TODO Rust Rules Out Invalidation Errors - 373

** TODO ~VecDeque<T>~ - 374
** TODO ~LinkedList<T>~ - 376
** TODO ~BinaryHeap<T>~ - 377
** TODO ~HashMap<K, V>~ and ~BTreeMap<K, V>~ - 378
*** TODO Entries - 381
*** TODO Map Iteration - 383

** TODO ~HashSet<T>~ and ~BTreeSet<T>~ - 384
*** TODO Set Iteration - 384
*** TODO When Equal Values Are Different - 385
*** TODO Whole-Set Operations - 385

** TODO Hashing - 387
*** TODO Using a Custom Hashing Algorithm - 388

** TODO Beyond the Standard Collections 389

* TODO 17. Strings and Text - 391
** TODO Some Unicode Background - 392
*** TODO ASCII, Latin-1, and Unicode - 392
*** TODO UTF-8 - 392
*** TODO Text Directionality - 394

** TODO Characters (~char~) - 394
*** TODO Classifying Characters - 395
*** TODO Handling Digits - 395
*** TODO Case Conversion for Characters - 396
*** TODO Conversions to and from Integers - 396

** TODO ~String~ and ~str~ - 397
*** TODO Creating String Values - 398
*** TODO Simple Inspection - 398
*** TODO Appending and Inserting Text - 399
*** TODO Removing Text - 401
*** TODO Conventions for Searching and Iterating - 401
*** TODO Patterns for Searching Text - 402
*** TODO Searching and Replacing - 403
*** TODO Iterating over Text - 403
*** TODO Trimming - 406
*** TODO Case Conversion for Strings - 406
*** TODO Parsing Other Types from Strings - 406
*** TODO Converting Other Types to Strings - 407
*** TODO Borrowing as Other Text-Like Types - 408
*** TODO Accessing Text as UTF-8 - 409
*** TODO Producing Text from UTF-8 Data - 409
*** TODO Putting Off Allocation - 410
*** TODO Strings as Generic Collections - 412

** TODO Formatting Values - 413
*** TODO Formatting Text Values - 414
*** TODO Formatting Numbers - 415
*** TODO Formatting Other Types - 417
*** TODO Formatting Values for Debugging - 418
*** TODO Formatting Pointers for Debugging - 419
*** TODO Referring to Arguments by Index or Name - 419
*** TODO Dynamic Widths and Precisions - 420
*** TODO Formatting Your Own Types - 421
*** TODO Using the Formatting Language in Your Own Code - 423

** TODO Regular Expressions - 424
*** TODO Basic Regex Use - 425
*** TODO Building Regex Values Lazily - 426

** TODO Normalization - 427
*** TODO Normalization Forms - 428
*** TODO The unicode-normalization Crate - 429

* TODO 18. Input and Output - 431
** TODO Readers and Writers - 432
*** TODO Readers - 433
*** TODO Buffered Readers - 435
*** TODO Reading Lines - 436
*** TODO Collecting Lines - 439
*** TODO Writers - 439
*** TODO Files - 441
*** TODO Seeking - 441
*** TODO Other Reader and Writer Types - 442
*** TODO Binary Data, Compression, and Serialization - 444

** TODO Files and Directories - 445
*** ~OsStr~ and ~Path~ - 445
*** ~Path~ and ~PathBuf~ Methods - 447
*** Filesystem Access Functions - 449
*** Reading Directories - 450
*** Platform-Specific Features - 451

** TODO Networking - 453

* TODO 19. Concurrency - 457
** TODO Fork-Join Parallelism - 459
*** TODO ~spawn~ and ~join~ - 461
*** TODO Error Handling Across Threads - 463
*** TODO Sharing Immutable Data Across Threads - 464
*** TODO Rayon - 466
*** TODO Revisiting the Mandelbrot Set - 468

** TODO Channels - 470
*** TODO Sending Values - 472
*** TODO Receiving Values - 475
*** TODO Running the Pipeline - 476
*** TODO Channel Features and Performance - 478
*** TODO Thread Safety: Send and Sync - 479
*** TODO Piping Almost Any Iterator to a Channel - 482
*** TODO Beyond Pipelines - 483

** TODO Shared Mutable State - 484
*** TODO What Is a Mutex? - 484
*** TODO ~Mutex<T>~ - 486
*** TODO mut and Mutex - 488
*** TODO Why Mutexes Are Not Always a Good Idea - 488
*** TODO Deadlock - 489
*** TODO Poisoned Mutexes - 490
*** TODO Multi-producer Channels Using Mutexes - 490
*** TODO Read/Write Locks (~RwLock<T>~) - 491
*** TODO Condition Variables (Condvar) - 493
*** TODO Atomics - 494
*** TODO Global Variables - 496

** TODO What Hacking Concurrent Code in Rust Is Like - 497

* TODO 20. Macros - 499
** TODO Macro Basics - 500
*** TODO Basics of Macro Expansion - 501
*** TODO Unintended Consequences - 503
*** TODO Repetition - 505

** DONE Built-In Macros - 507
   CLOSED: [2018-06-05 Tue 22:12]
   - The Rust compiler supplies several /macros/ that are helpful when you're
     defining your own /macros/.

     *None* of these could be implemented using ~macro_rules!~ alone -- they're
     *hardcoded* in /rustc/:

     + ~file!()~ expands to a /string literal/: the _current filename_.

       ~line!()~ expand to a ~u32 literal~ giving the _current line_ (counting
       from 1).

       ~column!()~ expand to a ~u32 literal~ giving the _current column_ (counting
       from 0).

       =REMEMBER=
       If one /macro/ calls another, which calls another, _all in DIFFERENT files_,
       and the *LAST* /macro/ calls ~file!()~, ~line!()~, or ~column!()~, it will
       expand to *indicate the location of the first macro call*.

     + ~stringify!(...tokens...)~ expands to a /string literal/ containing the
       given tokens.
       =From Jian= Here ~...tokens...~ means anything in side the parentheses.
       For instance, ~stringify!(1 2 3 4)~ generates "1 2 3 4", ~stringify!(1 , 2)~
       generates "1, 2", and ~stringify!(1 + 1)~ generates "1 + 1".

       * The ~assert!~ macro uses ~stringify!~ to generate an error message that
         includes the code of the assertion.

       * /Macro calls/ in the argument are *NOT* expanded: ~stringify!(line!())~
         expands to the string ~"line!()"~ .

       * Rust constructs the string ONLY from the tokens, so there are *NO* _line
         breaks_ or _comments_ in the string.

     + ~concat!(str0, str1, ...)~ expands to a single /string literal/ made by
       concatenating its arguments.

   - Rust also defines these /macros/ for _querying the build environment_:
     + ~cfg!(...)~ expands to a Boolean constant, true if the current build
       configuration matches the condition in parentheses. For example,
       ~cfg!(debug_assertions)~ is true if you’re compiling with debug
       assertions enabled.

       This macro supports exactly the same syntax as the #[cfg(...)] attribute
       described in “Attributes” on page 175 but instead of conditional
       compilation, you get a true or false answer.

     + ~env!("VAR_NAME")~ expands to a string: the value of the specified environment
       variable at compile time. If the variable doesn’t exist, it’s a compilation error.
       This would be fairly worthless except that Cargo sets several interesting environ‐
       ment variables when it compiles a crate. For example, to get your crate’s current
       version string, you can write: ~let version = env!("CARGO_PKG_VERSION");~
       A full list of these environment variables is included in the Cargo documentation.

     + ~option_env!("VAR_NAME")~ is the same as ~env!~ except that it returns an
       ~Option<&'static str>~ that is None if the specified variable is not set.

   - Three more /built-in macros/ let you _bring in code or data from another file_.
     + ~include!("file.rs")~ expands to the contents of the specified file, which
       must be valid Rust code -- either an expression or a sequence of items.

     + ~include_str!("file.txt")~ expands to a ~&'static str~ containing the _text_
       of the specified file. You can use it like this:
       #+BEGIN_SRC rust
         const COMPOSITOR_SHADER: &str =
             include_str!("../resources/compositor.glsl");
       #+END_SRC

       If the file doesn't exist, or is not valid UTF-8, you'll get a
       _compilation error_.

     + ~include_bytes!("file.dat")~ is the same except the file is treated as _binary
       data_, NOT UTF-8 text. The result is a ~&'static [u8]~.

** TODO Debugging Macros - 508
** TODO The ~json!~ Macro - 509
*** TODO Fragment Types - 510
*** TODO Recursion in Macros - 513
*** TODO Using Traits with Macros - 514
*** TODO Scoping and Hygiene - 516
*** TODO Importing and Exporting Macros - 519

** TODO Avoiding Syntax Errors During Matching - 521
** TODO Beyond ~macro_rules!~ - 522

* TODO 21. Unsafe Code - 525
** TODO Unsafe from What? - 526
** TODO Unsafe Blocks - 527
*** TODO Example: An Efficient ASCII String Type - 529

** TODO Unsafe Functions - 531
** TODO Unsafe Block or Unsafe Function? - 533
** TODO Undefined Behavior - 533
** TODO Unsafe Traits - 536
** TODO Raw Pointers - 538
*** TODO Dereferencing Raw Pointers Safely - 540
*** TODO Example: ~RefWithFlag~ - 541
*** TODO Nullable Pointers - 544
*** TODO Type Sizes and Alignments - 544
*** TODO Pointer Arithmetic - 545
*** TODO Moving into and out of Memory - 546
*** TODO Example: ~GapBuffer~ - 550
*** TODO Panic Safety in Unsafe Code - 556

** TODO Foreign Functions: Calling C and C++ from Rust - 557
*** TODO Finding Common Data Representations - 558
*** TODO Declaring Foreign Functions and Variables - 561
*** TODO Using Functions from Libraries - 562
*** TODO A Raw Interface to libgit2 - 566
*** TODO A Safe Interface to libgit2 - 572

** TODO Conclusion - 583

* Index - 585
