#+TITLE: Programming Rust
#+VERSION: 2017, 1st
#+AUTHOR: Jim Blandy and Jason Orendorff
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[1. Why Rust? - 1][1. Why Rust? - 1]]
  - [[Type Safety - 3][Type Safety - 3]]
- [[2. A Tour of Rust - 7][2. A Tour of Rust - 7]]
  - [[Downloading and installing Rust - 7][Downloading and installing Rust - 7]]
  - [[A Simple Function - 10][A Simple Function - 10]]
  - [[Writing and Running Unit Tests - 11][Writing and Running Unit Tests - 11]]
  - [[Handling Command-Line Arguments - 12][Handling Command-Line Arguments - 12]]
  - [[A Simple Web Server - 17][A Simple Web Server - 17]]
  - [[Concurrency - 23][Concurrency - 23]]
    - [[What the Mandelbrot Set Actually Is - 24][What the Mandelbrot Set Actually Is - 24]]
    - [[Parsing Pair Command-Line Arguments 28][Parsing Pair Command-Line Arguments 28]]
    - [[Mapping from Pixels to Complex Numbers 31][Mapping from Pixels to Complex Numbers 31]]
    - [[Plotting the Set - 32][Plotting the Set - 32]]
    - [[Writing Image Files 34][Writing Image Files 34]]
    - [[A Concurrent Mandelbrot Program 35][A Concurrent Mandelbrot Program 35]]
    - [[Running the Mandelbrot Plotter 40][Running the Mandelbrot Plotter 40]]
    - [[Safety Is Invisible 41][Safety Is Invisible 41]]
- [[3. Basic types - 43][3. Basic types - 43]]
  - [[Machine Types - 46][Machine Types - 46]]
    - [[Integer Types - 47][Integer Types - 47]]
    - [[Floating-Point Types - 50][Floating-Point Types - 50]]
    - [[The ~bool~ Type - 51][The ~bool~ Type - 51]]
    - [[Characters - 52][Characters - 52]]
  - [[Tuples - 54][Tuples - 54]]
  - [[Pointer types - 55][Pointer types - 55]]
    - [[References - 56][References - 56]]
    - [[Boxes - 56][Boxes - 56]]
    - [[Raw Pointers - 57][Raw Pointers - 57]]
  - [[Arrays, Vectors, and Slices - 57][Arrays, Vectors, and Slices - 57]]
    - [[Arrays - 58][Arrays - 58]]
    - [[Vectors - 59][Vectors - 59]]
    - [[Building Vectors Element by Element - 62][Building Vectors Element by Element - 62]]
    - [[Slices - 62][Slices - 62]]
  - [[String Types - 64 =RE=READ=][String Types - 64 =RE=READ=]]
    - [[String Literals - 64][String Literals - 64]]
    - [[Byte Strings - 65][Byte Strings - 65]]
    - [[Strings in Memory - 65][Strings in Memory - 65]]
    - [[String - 67 =RE-READ=][String - 67 =RE-READ=]]
    - [[Using Strings - 68][Using Strings - 68]]
    - [[Other String-Like Types - 68][Other String-Like Types - 68]]
  - [[Beyond the basics - 69][Beyond the basics - 69]]
- [[4. Ownership - 71][4. Ownership - 71]]
  - [[Ownership - 73 =TODO= =NOTE=][Ownership - 73 =TODO= =NOTE=]]
  - [[Moves - 77][Moves - 77]]
    - [[More Operations That Move - 82][More Operations That Move - 82]]
    - [[Moves and Control Flow - 84][Moves and Control Flow - 84]]
    - [[Moves and Indexed Content - 84][Moves and Indexed Content - 84]]
  - [[~Copy~ Types: The Exception to Moves - 86][~Copy~ Types: The Exception to Moves - 86]]
  - [[~Rc~ and ~Arc~: shared ownership - 90 =Re-Read= =Reference counter and Circular reference=][~Rc~ and ~Arc~: shared ownership - 90 =Re-Read= =Reference counter and Circular reference=]]
- [[5. References and borrowing - 93][5. References and borrowing - 93]]
  - [[References as Values - 97][References as Values - 97]]
    - [[Rust References Versus C++ References - 97][Rust References Versus C++ References - 97]]
    - [[Assigning References - 98][Assigning References - 98]]
    - [[References to References - 99][References to References - 99]]
    - [[Comparing References - 99][Comparing References - 99]]
    - [[References Are Never Null - 100][References Are Never Null - 100]]
    - [[Borrowing References to Arbitrary Expressions - 100][Borrowing References to Arbitrary Expressions - 100]]
    - [[References to Slices and Trait Objects - 101 =TODO=][References to Slices and Trait Objects - 101 =TODO=]]
  - [[Reference Safety - 101][Reference Safety - 101]]
    - [[Borrowing a Local Variable - 101][Borrowing a Local Variable - 101]]
    - [[Receiving References as Parameters - 105][Receiving References as Parameters - 105]]
    - [[Passing References as Arguments - 107][Passing References as Arguments - 107]]
    - [[Returning References - 107][Returning References - 107]]
    - [[Structs Containing References - 109][Structs Containing References - 109]]
    - [[Distinct Lifetime Parameters - 111][Distinct Lifetime Parameters - 111]]
    - [[Omitting Lifetime Parameters - 112][Omitting Lifetime Parameters - 112]]
  - [[Sharing Versus Mutation - 114][Sharing Versus Mutation - 114]]
  - [[Taking Arms Against a Sea of Objects - 121][Taking Arms Against a Sea of Objects - 121]]
- [[6. Expressions - 123 =NOTE=][6. Expressions - 123 =NOTE=]]
  - [[An Expression Language - 123][An Expression Language - 123]]
  - [[Blocks and Semicolons - 124][Blocks and Semicolons - 124]]
  - [[Declarations - 126][Declarations - 126]]
  - [[~if~ and match - 127][~if~ and match - 127]]
    - [[~if let~ - 129][~if let~ - 129]]
  - [[Loops - 130][Loops - 130]]
  - [[~return~ Expressions - 132][~return~ Expressions - 132]]
  - [[Why Rust Has ~loop~ - 133 =Re-Read=][Why Rust Has ~loop~ - 133 =Re-Read=]]
  - [[Function and Method Calls - 134][Function and Method Calls - 134]]
  - [[Fields and Elements - 135][Fields and Elements - 135]]
  - [[Reference Operators - 137][Reference Operators - 137]]
  - [[Arithmetic, Bitwise, Comparison, and Logical Operators - 137 =TODO=][Arithmetic, Bitwise, Comparison, and Logical Operators - 137 =TODO=]]
  - [[Assignment 138][Assignment 138]]
  - [[Type Casts 139][Type Casts 139]]
  - [[Closures - 140][Closures - 140]]
  - [[Precedence and Associativity 140 =TODO=][Precedence and Associativity 140 =TODO=]]
  - [[Onward 142][Onward 142]]
- [[7. Error Handling - 145][7. Error Handling - 145]]
  - [[Panic - 145][Panic - 145]]
    - [[Unwinding - 146][Unwinding - 146]]
    - [[Aborting - 147][Aborting - 147]]
  - [[Result - 148][Result - 148]]
    - [[Catching Errors - 148][Catching Errors - 148]]
    - [[Result Type Aliases - 150][Result Type Aliases - 150]]
    - [[Printing Errors - 150][Printing Errors - 150]]
    - [[Propagating Errors - 152][Propagating Errors - 152]]
    - [[Working with Multiple Error Types - 153][Working with Multiple Error Types - 153]]
    - [[Dealing with Errors That "Can't Happen" - 155][Dealing with Errors That "Can't Happen" - 155]]
    - [[Ignoring Errors - 156][Ignoring Errors - 156]]
    - [[Handling Errors in ~main()~ - 156][Handling Errors in ~main()~ - 156]]
    - [[Declaring a Custom Error Type - 157][Declaring a Custom Error Type - 157]]
    - [[Why Results? - 158][Why Results? - 158]]
- [[8. Crates and Modules - 161][8. Crates and Modules - 161]]
  - [[Crates - 161][Crates - 161]]
    - [[Build Profiles - 164][Build Profiles - 164]]
  - [[Modules - 165][Modules - 165]]
    - [[Modules in Separate Files - 166][Modules in Separate Files - 166]]
    - [[Paths and Imports - 167][Paths and Imports - 167]]
    - [[The Standard Prelude - 169][The Standard Prelude - 169]]
    - [[Items, the Building Blocks of Rust - 170][Items, the Building Blocks of Rust - 170]]
  - [[Turning a Program into a Library - 172][Turning a Program into a Library - 172]]
  - [[The src/bin Directory - 174][The src/bin Directory - 174]]
  - [[Attributes - 175][Attributes - 175]]
  - [[Tests and Documentation - 178][Tests and Documentation - 178]]
    - [[Integration Tests - 180][Integration Tests - 180]]
    - [[Documentation - 181][Documentation - 181]]
    - [[Doc-Tests - 182][Doc-Tests - 182]]
  - [[Specifying Dependencies - 185][Specifying Dependencies - 185]]
    - [[Versions - 186][Versions - 186]]
    - [[~Cargo.lock~ - 187][~Cargo.lock~ - 187]]
  - [[Publishing Crates to crates.io - 188][Publishing Crates to crates.io - 188]]
  - [[Workspaces - 190][Workspaces - 190]]
  - [[More Nice Things - 191][More Nice Things - 191]]
- [[9. Structs - 193][9. Structs - 193]]
  - [[Named-Field Structs - 193][Named-Field Structs - 193]]
  - [[Tuple-Like Structs - 196][Tuple-Like Structs - 196]]
  - [[Unit-Like Structs - 197][Unit-Like Structs - 197]]
  - [[Struct Layout - 197][Struct Layout - 197]]
  - [[Defining Methods with impl - 198][Defining Methods with impl - 198]]
  - [[Generic Structs - 202][Generic Structs - 202]]
  - [[Structs with Lifetime Parameters - 203][Structs with Lifetime Parameters - 203]]
  - [[Deriving Common Traits for Struct Types - 204][Deriving Common Traits for Struct Types - 204]]
  - [[Interior Mutability - 205][Interior Mutability - 205]]
- [[10. Enums and patterns - 211][10. Enums and patterns - 211]]
  - [[Enums - 212][Enums - 212]]
    - [[Enums with Data - 214][Enums with Data - 214]]
    - [[Enums in Memory - 215][Enums in Memory - 215]]
    - [[Rich Data Structures Using Enums - 216][Rich Data Structures Using Enums - 216]]
    - [[Generic Enums - 218][Generic Enums - 218]]
  - [[Patterns - 221][Patterns - 221]]
    - [[Literals, Variables, and Wildcards in Patterns - 223][Literals, Variables, and Wildcards in Patterns - 223]]
    - [[Tuple and Struct Patterns - 225][Tuple and Struct Patterns - 225]]
    - [[Reference Patterns - 226][Reference Patterns - 226]]
    - [[Matching Multiple Possibilities - 229][Matching Multiple Possibilities - 229]]
    - [[Pattern Guards - 229][Pattern Guards - 229]]
    - [[~@~ patterns - 230][~@~ patterns - 230]]
    - [[Where Patterns Are Allowed - 230][Where Patterns Are Allowed - 230]]
    - [[Populating a Binary Tree 232][Populating a Binary Tree 232]]
  - [[The Big Picture - 233][The Big Picture - 233]]
- [[11. Traits and Generics - 235][11. Traits and Generics - 235]]
  - [[Using Traits - 237][Using Traits - 237]]
  - [[Trait Objects - 238][Trait Objects - 238]]
  - [[Trait Object Layout - 239][Trait Object Layout - 239]]
  - [[Generic Functions - 240][Generic Functions - 240]]
  - [[Which to Use - 243][Which to Use - 243]]
  - [[Defining and Implementing Traits - 245][Defining and Implementing Traits - 245]]
  - [[Default Methods - 246][Default Methods - 246]]
  - [[Traits and Other People's Types - 247][Traits and Other People's Types - 247]]
  - [[Self in Traits - 249][Self in Traits - 249]]
  - [[Subtraits - 250][Subtraits - 250]]
  - [[Static Methods - 251][Static Methods - 251]]
  - [[Fully Qualified Method Calls - 252][Fully Qualified Method Calls - 252]]
  - [[Traits That Define Relationships Between Types - 253][Traits That Define Relationships Between Types - 253]]
  - [[Associated Types (or How Iterators Work) - 254][Associated Types (or How Iterators Work) - 254]]
  - [[Generic Traits (or How Operator Overloading Works) - 257][Generic Traits (or How Operator Overloading Works) - 257]]
  - [[Buddy Traits (or How ~rand::random()~ Works) - 258][Buddy Traits (or How ~rand::random()~ Works) - 258]]
  - [[Reverse-Engineering Bounds - 260][Reverse-Engineering Bounds - 260]]
  - [[Conclusion - 263][Conclusion - 263]]
- [[12. Operator Overloading - 265][12. Operator Overloading - 265]]
  - [[Arithmetic and Bitwise Operators - 266][Arithmetic and Bitwise Operators - 266]]
  - [[Unary Operators - 268][Unary Operators - 268]]
  - [[Binary Operators - 269][Binary Operators - 269]]
  - [[Compound Assignment Operators - 270][Compound Assignment Operators - 270]]
  - [[Equality Tests - 272][Equality Tests - 272]]
  - [[Ordered Comparisons - 275][Ordered Comparisons - 275]]
  - [[Index and IndexMut - 277][Index and IndexMut - 277]]
  - [[Other Operators - 280][Other Operators - 280]]
- [[13. Utility Traits - 281][13. Utility Traits - 281]]
  - [[Drop - 282][Drop - 282]]
  - [[Sized - 285][Sized - 285]]
  - [[Clone - 287][Clone - 287]]
  - [[Copy - 289][Copy - 289]]
  - [[Deref and DerefMut - 289][Deref and DerefMut - 289]]
  - [[Default][Default]]
  - [[AsRef and AsMut - 294][AsRef and AsMut - 294]]
  - [[Borrow and BorrowMut - 296][Borrow and BorrowMut - 296]]
  - [[From and Into - 297][From and Into - 297]]
  - [[ToOwned - 300][ToOwned - 300]]
  - [[Borrow and ToOwned at Work: The Humble Cow - 300][Borrow and ToOwned at Work: The Humble Cow - 300]]
- [[14. Closures - 303][14. Closures - 303]]
  - [[Capturing Variables - 305][Capturing Variables - 305]]
  - [[Closures That Borrow - 306][Closures That Borrow - 306]]
  - [[Closures That Steal - 306][Closures That Steal - 306]]
  - [[Function and Closure Types - 308][Function and Closure Types - 308]]
  - [[Closure Performance - 310][Closure Performance - 310]]
  - [[Closures and Safety - 311][Closures and Safety - 311]]
  - [[Closures That Kill - 312][Closures That Kill - 312]]
  - [[FnOnce - 312][FnOnce - 312]]
  - [[FnMut - 314][FnMut - 314]]
  - [[Callbacks - 316][Callbacks - 316]]
  - [[Using Closures Effectively - 319][Using Closures Effectively - 319]]
- [[15. Iterators - 321][15. Iterators - 321]]
  - [[The ~Iterator~ and ~IntoIterator~ Traits - 322][The ~Iterator~ and ~IntoIterator~ Traits - 322]]
  - [[Creating ~Iterator~'s - 324][Creating ~Iterator~'s - 324]]
    - [[~iter~ and ~iter_mut~ Methods - 324][~iter~ and ~iter_mut~ Methods - 324]]
    - [[~IntoIterator~ Implementations - 325][~IntoIterator~ Implementations - 325]]
    - [[~drain~ Methods - 327][~drain~ Methods - 327]]
    - [[Other ~Iterator~ Sources - 328][Other ~Iterator~ Sources - 328]]
  - [[~Iterator~ Adapters - 330][~Iterator~ Adapters - 330]]
    - [[~map~ and ~filter~ - 330][~map~ and ~filter~ - 330]]
    - [[~filter_map~ and ~flat_map~ - 332][~filter_map~ and ~flat_map~ - 332]]
    - [[~scan~ - 335][~scan~ - 335]]
    - [[~take~ and ~take_while~ - 335][~take~ and ~take_while~ - 335]]
    - [[~skip~ and ~skip_while~ - 336][~skip~ and ~skip_while~ - 336]]
    - [[~peekable~ - 337][~peekable~ - 337]]
    - [[fuse - 338][fuse - 338]]
    - [[Reversible ~Iterator~'s and ~rev~ - 339][Reversible ~Iterator~'s and ~rev~ - 339]]
    - [[~inspect~ - 340][~inspect~ - 340]]
    - [[~chain~ - 341][~chain~ - 341]]
    - [[~enumerate~ - 341][~enumerate~ - 341]]
    - [[~zip~ - 342][~zip~ - 342]]
    - [[~by_ref~ - 342][~by_ref~ - 342]]
    - [[~cloned~ - 344][~cloned~ - 344]]
    - [[~cycle~ - 344][~cycle~ - 344]]
  - [[Consuming Iterators - 345][Consuming Iterators - 345]]
    - [[Simple Accumulation: ~count~, ~sum~, ~product~ - 345][Simple Accumulation: ~count~, ~sum~, ~product~ - 345]]
    - [[~max~, ~min~ - 346][~max~, ~min~ - 346]]
    - [[~max_by~, ~min_by~ - 346][~max_by~, ~min_by~ - 346]]
    - [[~max_by_key~, ~min_by_key~ - 347][~max_by_key~, ~min_by_key~ - 347]]
    - [[Comparing Item Sequences - 347][Comparing Item Sequences - 347]]
    - [[~any~ and ~all~ - 348][~any~ and ~all~ - 348]]
    - [[~position~, ~rposition~, and ~ExactSizeIterator~ - 348][~position~, ~rposition~, and ~ExactSizeIterator~ - 348]]
    - [[~fold~ - 349][~fold~ - 349]]
    - [[~nth~ - 350][~nth~ - 350]]
    - [[~last~ - 350][~last~ - 350]]
    - [[~find~ - 351][~find~ - 351]]
    - [[Building Collections: ~collect~ and ~FromIterator~ - 351][Building Collections: ~collect~ and ~FromIterator~ - 351]]
    - [[The ~Extend~ Trait - 353][The ~Extend~ Trait - 353]]
    - [[~partition~ - 353][~partition~ - 353]]
  - [[Implementing Your Own Iterators - 354][Implementing Your Own Iterators - 354]]
- [[16. Collections - 359][16. Collections - 359]]
  - [[Overview - 360][Overview - 360]]
  - [[~Vec<T>~ - 361][~Vec<T>~ - 361]]
    - [[Accessing Elements - 362][Accessing Elements - 362]]
    - [[Iteration - 364][Iteration - 364]]
    - [[Growing and Shrinking Vectors - 364][Growing and Shrinking Vectors - 364]]
    - [[Joining - 367][Joining - 367]]
    - [[Splitting - 368][Splitting - 368]]
    - [[Swapping - 370][Swapping - 370]]
    - [[Sorting and Searching - 370][Sorting and Searching - 370]]
    - [[Comparing Slices - 372][Comparing Slices - 372]]
    - [[Random Elements - 373][Random Elements - 373]]
    - [[Rust Rules Out Invalidation Errors - 373][Rust Rules Out Invalidation Errors - 373]]
  - [[~VecDeque<T>~ - 374][~VecDeque<T>~ - 374]]
  - [[~LinkedList<T>~ - 376][~LinkedList<T>~ - 376]]
  - [[~BinaryHeap<T>~ - 377][~BinaryHeap<T>~ - 377]]
  - [[~HashMap<K, V>~ and ~BTreeMap<K, V>~ - 378][~HashMap<K, V>~ and ~BTreeMap<K, V>~ - 378]]
    - [[Entries - 381][Entries - 381]]
    - [[Map Iteration - 383][Map Iteration - 383]]
  - [[~HashSet<T>~ and ~BTreeSet<T>~ - 384][~HashSet<T>~ and ~BTreeSet<T>~ - 384]]
    - [[Set Iteration - 384][Set Iteration - 384]]
    - [[When Equal Values Are Different - 385][When Equal Values Are Different - 385]]
    - [[Whole-Set Operations - 385][Whole-Set Operations - 385]]
  - [[Hashing - 387][Hashing - 387]]
    - [[Using a Custom Hashing Algorithm - 388][Using a Custom Hashing Algorithm - 388]]
  - [[Beyond the Standard Collections 389][Beyond the Standard Collections 389]]
- [[17. Strings and Text - 391][17. Strings and Text - 391]]
  - [[Some Unicode Background - 392][Some Unicode Background - 392]]
    - [[ASCII, Latin-1, and Unicode - 392][ASCII, Latin-1, and Unicode - 392]]
    - [[UTF-8 - 392][UTF-8 - 392]]
    - [[Text Directionality - 394][Text Directionality - 394]]
  - [[Characters (char) - 394][Characters (char) - 394]]
    - [[Classifying Characters - 395][Classifying Characters - 395]]
    - [[Handling Digits - 395][Handling Digits - 395]]
    - [[Case Conversion for Characters - 396][Case Conversion for Characters - 396]]
    - [[Conversions to and from Integers - 396][Conversions to and from Integers - 396]]
  - [[String and str - 397][String and str - 397]]
    - [[Creating String Values - 398][Creating String Values - 398]]
    - [[Simple Inspection - 398][Simple Inspection - 398]]
    - [[Appending and Inserting Text - 399][Appending and Inserting Text - 399]]
    - [[Removing Text - 401][Removing Text - 401]]
    - [[Conventions for Searching and Iterating - 401][Conventions for Searching and Iterating - 401]]
    - [[Patterns for Searching Text - 402][Patterns for Searching Text - 402]]
    - [[Searching and Replacing - 403][Searching and Replacing - 403]]
    - [[Iterating over Text - 403][Iterating over Text - 403]]
    - [[Trimming - 406][Trimming - 406]]
    - [[Case Conversion for Strings - 406][Case Conversion for Strings - 406]]
    - [[Parsing Other Types from Strings - 406][Parsing Other Types from Strings - 406]]
    - [[Converting Other Types to Strings - 407][Converting Other Types to Strings - 407]]
    - [[Borrowing as Other Text-Like Types - 408][Borrowing as Other Text-Like Types - 408]]
    - [[Accessing Text as UTF-8 - 409][Accessing Text as UTF-8 - 409]]
    - [[Producing Text from UTF-8 Data - 409][Producing Text from UTF-8 Data - 409]]
    - [[Putting Off Allocation - 410][Putting Off Allocation - 410]]
    - [[Strings as Generic Collections - 412][Strings as Generic Collections - 412]]
  - [[Formatting Values - 413][Formatting Values - 413]]
    - [[Formatting Text Values - 414][Formatting Text Values - 414]]
    - [[Formatting Numbers - 415][Formatting Numbers - 415]]
    - [[Formatting Other Types - 417][Formatting Other Types - 417]]
    - [[Formatting Values for Debugging - 418][Formatting Values for Debugging - 418]]
    - [[Formatting Pointers for Debugging - 419][Formatting Pointers for Debugging - 419]]
    - [[Referring to Arguments by Index or Name - 419][Referring to Arguments by Index or Name - 419]]
    - [[Dynamic Widths and Precisions - 420][Dynamic Widths and Precisions - 420]]
    - [[Formatting Your Own Types - 421][Formatting Your Own Types - 421]]
    - [[Using the Formatting Language in Your Own Code - 423][Using the Formatting Language in Your Own Code - 423]]
  - [[Regular Expressions - 424][Regular Expressions - 424]]
    - [[Basic Regex Use - 425][Basic Regex Use - 425]]
    - [[Building Regex Values Lazily - 426][Building Regex Values Lazily - 426]]
  - [[Normalization - 427][Normalization - 427]]
    - [[Normalization Forms - 428][Normalization Forms - 428]]
    - [[The unicode-normalization Crate - 429][The unicode-normalization Crate - 429]]
- [[18. Input and Output - 431][18. Input and Output - 431]]
  - [[Readers and Writers - 432][Readers and Writers - 432]]
    - [[Readers - 433][Readers - 433]]
    - [[Buffered Readers - 435][Buffered Readers - 435]]
    - [[Reading Lines - 436][Reading Lines - 436]]
    - [[Collecting Lines - 439][Collecting Lines - 439]]
    - [[Writers - 439][Writers - 439]]
    - [[Files - 441][Files - 441]]
    - [[Seeking - 441][Seeking - 441]]
    - [[Other Reader and Writer Types - 442][Other Reader and Writer Types - 442]]
    - [[Binary Data, Compression, and Serialization - 444][Binary Data, Compression, and Serialization - 444]]
  - [[Files and Directories - 445][Files and Directories - 445]]
    - [[OsStr and Path - 445][OsStr and Path - 445]]
    - [[Path and PathBuf Methods - 447][Path and PathBuf Methods - 447]]
    - [[Filesystem Access Functions - 449][Filesystem Access Functions - 449]]
    - [[Reading Directories - 450][Reading Directories - 450]]
    - [[Platform-Specific Features - 451][Platform-Specific Features - 451]]
  - [[Networking - 453][Networking - 453]]
- [[19. Concurrency - 457][19. Concurrency - 457]]
  - [[Fork-Join Parallelism - 459][Fork-Join Parallelism - 459]]
    - [[~spawn~ and ~join~ - 461][~spawn~ and ~join~ - 461]]
    - [[Error Handling Across Threads - 463][Error Handling Across Threads - 463]]
    - [[Sharing Immutable Data Across Threads - 464][Sharing Immutable Data Across Threads - 464]]
    - [[Rayon - 466][Rayon - 466]]
    - [[Revisiting the Mandelbrot Set - 468][Revisiting the Mandelbrot Set - 468]]
  - [[Channels - 470][Channels - 470]]
    - [[Sending Values - 472][Sending Values - 472]]
    - [[Receiving Values - 475][Receiving Values - 475]]
    - [[Running the Pipeline - 476][Running the Pipeline - 476]]
    - [[Channel Features and Performance - 478][Channel Features and Performance - 478]]
    - [[Thread Safety: Send and Sync - 479][Thread Safety: Send and Sync - 479]]
    - [[Piping Almost Any Iterator to a Channel - 482][Piping Almost Any Iterator to a Channel - 482]]
    - [[Beyond Pipelines - 483][Beyond Pipelines - 483]]
  - [[Shared Mutable State - 484][Shared Mutable State - 484]]
    - [[What Is a Mutex? - 484][What Is a Mutex? - 484]]
    - [[~Mutex<T>~ - 486][~Mutex<T>~ - 486]]
    - [[mut and Mutex - 488][mut and Mutex - 488]]
    - [[Why Mutexes Are Not Always a Good Idea - 488][Why Mutexes Are Not Always a Good Idea - 488]]
    - [[Deadlock - 489][Deadlock - 489]]
    - [[Poisoned Mutexes - 490][Poisoned Mutexes - 490]]
    - [[Multi-producer Channels Using Mutexes - 490][Multi-producer Channels Using Mutexes - 490]]
    - [[Read/Write Locks (~RwLock<T>~) - 491][Read/Write Locks (~RwLock<T>~) - 491]]
    - [[Condition Variables (Condvar) - 493][Condition Variables (Condvar) - 493]]
    - [[Atomics - 494][Atomics - 494]]
    - [[Global Variables - 496][Global Variables - 496]]
  - [[What Hacking Concurrent Code in Rust Is Like - 497][What Hacking Concurrent Code in Rust Is Like - 497]]
- [[20. Macros - 499][20. Macros - 499]]
  - [[Macro Basics - 500][Macro Basics - 500]]
    - [[Basics of Macro Expansion - 501][Basics of Macro Expansion - 501]]
    - [[Unintended Consequences - 503][Unintended Consequences - 503]]
    - [[Repetition - 505][Repetition - 505]]
  - [[Built-In Macros - 507][Built-In Macros - 507]]
  - [[Debugging Macros - 508][Debugging Macros - 508]]
  - [[The ~json!~ Macro - 509][The ~json!~ Macro - 509]]
    - [[Fragment Types - 510][Fragment Types - 510]]
    - [[Recursion in Macros - 513][Recursion in Macros - 513]]
    - [[Using Traits with Macros - 514][Using Traits with Macros - 514]]
    - [[Scoping and Hygiene - 516][Scoping and Hygiene - 516]]
    - [[Importing and Exporting Macros - 519][Importing and Exporting Macros - 519]]
  - [[Avoiding Syntax Errors During Matching - 521][Avoiding Syntax Errors During Matching - 521]]
  - [[Beyond ~macro_rules!~ - 522][Beyond ~macro_rules!~ - 522]]
- [[21. Unsafe Code - 525][21. Unsafe Code - 525]]
  - [[Unsafe from What? - 526][Unsafe from What? - 526]]
  - [[Unsafe Blocks - 527][Unsafe Blocks - 527]]
    - [[Example: An Efficient ASCII String Type - 529][Example: An Efficient ASCII String Type - 529]]
  - [[Unsafe Functions - 531][Unsafe Functions - 531]]
  - [[Unsafe Block or Unsafe Function? - 533][Unsafe Block or Unsafe Function? - 533]]
  - [[Undefined Behavior - 533][Undefined Behavior - 533]]
  - [[Unsafe Traits - 536][Unsafe Traits - 536]]
  - [[Raw Pointers - 538][Raw Pointers - 538]]
    - [[Dereferencing Raw Pointers Safely - 540][Dereferencing Raw Pointers Safely - 540]]
    - [[Example: ~RefWithFlag~ - 541][Example: ~RefWithFlag~ - 541]]
    - [[Nullable Pointers - 544][Nullable Pointers - 544]]
    - [[Type Sizes and Alignments - 544][Type Sizes and Alignments - 544]]
    - [[Pointer Arithmetic - 545][Pointer Arithmetic - 545]]
    - [[Moving into and out of Memory - 546][Moving into and out of Memory - 546]]
    - [[Example: ~GapBuffer~ - 550][Example: ~GapBuffer~ - 550]]
    - [[Panic Safety in Unsafe Code - 556][Panic Safety in Unsafe Code - 556]]
  - [[Foreign Functions: Calling C and C++ from Rust - 557][Foreign Functions: Calling C and C++ from Rust - 557]]
    - [[Finding Common Data Representations - 558][Finding Common Data Representations - 558]]
    - [[Declaring Foreign Functions and Variables - 561][Declaring Foreign Functions and Variables - 561]]
    - [[Using Functions from Libraries - 562][Using Functions from Libraries - 562]]
    - [[A Raw Interface to libgit2 - 566][A Raw Interface to libgit2 - 566]]
    - [[A Safe Interface to libgit2 - 572][A Safe Interface to libgit2 - 572]]
  - [[Conclusion - 583][Conclusion - 583]]
- [[Index - 585][Index - 585]]

* 1. Why Rust? - 1
  - Enter Rust:
    a *safe* (memory safety), *concurrent* (trustworthy concurrency) language
    with the *performance* of C and C++.

  - Rust shares the ambitions Bjarne Stroustrup articulates for C++ in his paper
    "Abstraction and the C++ Machine Model:"
    #+BEGIN_QUOTE
    In general, C++ implementations obey the *zero-overhead principle*:
    What you don't use, you don't pay for.

    And further: What you do use, you couldn't hand code any better.
    #+END_QUOTE

  - The key to meeting all these promises is Rust's novel system of /ownership/,
    /moves/, and /borrows/, checked at /compile time/ and carefully designed to
    complement Rust's flexible static type system.

  - Rust is able to prevent /data races/ at /compile time/.

  - In fact, Servo and Rust have grown up together, with Servo using the latest
    new language features, and Rust evolving based on feedback from Servo's
    developers.

** DONE Type Safety - 3
   CLOSED: [2018-05-19 Sat 14:21]
   =TODO= =NOTE=

* 2. A Tour of Rust - 7
** Downloading and installing Rust - 7
** A Simple Function - 10
** Writing and Running Unit Tests - 11
** Handling Command-Line Arguments - 12
** A Simple Web Server - 17
** Concurrency - 23
*** What the Mandelbrot Set Actually Is - 24
*** Parsing Pair Command-Line Arguments 28
*** Mapping from Pixels to Complex Numbers 31
*** Plotting the Set - 32
*** Writing Image Files 34
*** A Concurrent Mandelbrot Program 35
*** Running the Mandelbrot Plotter 40
*** Safety Is Invisible 41

* DONE 3. Basic types - 43
  CLOSED: [2018-05-22 Tue 09:03]
  - Rust's types serve several goals:
    + Safety
    + Efficiency
    + Concision

  - =TODO= NOTE 

** DONE Machine Types - 46
   CLOSED: [2018-05-20 Sun 21:28]
   |  Size (bits) | Unsigned integer | Signed integer | Floating-point |
   |--------------+------------------+----------------+----------------|
   |            8 | ~u8~             | ~8~            |                |
   |           16 | ~u16~            | ~i16~          |                |
   |           32 | ~u32~            | ~i32~          | ~f32~          |
   |           64 | ~u64~            | ~i64~          | ~f64~          |
   | Machine word | ~usize~          | ~isize~        |                |

   - The /machine word/ is a value the size of an address on the machine the code
     runs one,  _usually_ (=???=) 32 bits or 64 bits, which depends on the
     target machine.

*** DONE Integer Types - 47
    CLOSED: [2018-05-19 Sat 02:47]
    - *UNLIKE* C and C++,
      Rust treats /characters/ as _distinct_ from the /numeric types/.
      Read "Characters" on Page 52.

    - ~usize~ are analogous to ~size_t~ in C/C++.

    - ~isize~ are analogous to ~ptrdiff_t~ in C/C++.

    - Rust requires /array indices/ to be ~usize~.

    - Values representing
      + the sizes of arrays or vectors

      + the counts of the number of elements in some data structure

      also generally have the ~usize~ type.

    - In /debug build/, Rust compiler checks for integer overflow in arithmetic:
      #+BEGIN_SRC rust
        let big_val = std::i32::MAX;
        let x = big_val + 1;  // panic: arithmetic operation overflowed
      #+END_SRC

    - In /release build/, this addition would wrap to a negative number
      (*UNLIKE* C++, where signed integer overflow is _undefined_ behavior).

      However, it is still a bad to do this operation if you don't want to give
      up forever.

      + Solution: Explicitly tell the compiler that you really know what you do!
        ~let x = big_val.wrapping_add(1);  // ok~

    - /Integer literals/ in Rust can take suffix indicating their type.
      For instance, ~42u8~ and ~1729isize~

      If you don't the /inference/ can satisfy what you want, you can use this
      way to indicate type manually.

    - /Inference/ usually identifies a unique type,
      BUT sometimes any one of several types would work. In this case, Rust
      defaults to ~i32~, if that is among the possibilities. Otherwise, report
      the ambiguity as an error!

    - The radix prefixes of /Integer literals/: ~0x~, ~0o~, and ~0b~.

    - You can insert _underscore_ to make long numbers more legible.
      For instance, ~4_294_967_295~.
        The positions of the _underscore_ is *FLEXIBLE* -- it's designed for
      human, NOT for the compiler! For instance, ~0xfff_ffff~, or ~127_u8~.

    - /Byte literals/    ~b'a'~
      =TODO=

    - Convert from one integer type to another integer type with the ~as~
      operator. For instance, ~10_i8 as u16~

      + =TODO= MORE Details =TODO= =NOTE=

    - /Integers/, like any other sort of value, _can have /methods/._
      Check the standard library documents. For instance, ~std::i32~

*** DONE Floating-Point Types - 50
    CLOSED: [2018-05-20 Sun 21:28]
    - Rust provides
      + IEEE single-precision floating type ~f32~:
        * at least *6* decimal digits
        * Roughly -3.4 \times{} 10^{38} to +3.4 \times{} 10^{38}

      + IEEE double-precision floating type ~f64~:
        * at least *15* decimal digits
        * Roughly -1.8 \times{} 10^{308} to +1.8 \times{} 10^{308}

    - Following the IEEE 754-2008 specification,
      these types include
      + _positive and negative *infinities*,_
      + *distinct* _positive and negative *zero values*,_
      + a *not-a-number value*

    - Rust's ~f32~ and ~f64~ correspond to
      + the ~float~ and ~double~ types in C and C++ implementations that _support_
        IEEE floating point;

      + Java, which _always_ uses IEEE floating point.

    - Example for the /floating-point literals/:
      ~3.1415.926e-4f64~

      + Every part of a floating-point number after the _integer part_ is OPTIONAL,
        but *at least one of* the _fractional part_, _exponent_, or _type suffix_
        *must* be present, to _distinguish_ it from an /integer literal/.

      + ~5.~ is a valid floating-point constant.

      + The default type is ~f64~, if both would be possible,
        which is similar as C/C++/Java.

    - You can add _underscore_ to the _fractional part_.

    - The ~std::f32~ and ~std::f64~ modules define constants for the IEEE-required
      special values like ~INFINITY~, ~NEG_INFINITY~, ~NAN~, and ~MIN~ and ~MAX~
      (the largest and smallest finite values).

    - The ~std::f32::consts~ and ~std::f64::consts~ modules provide various commonly
      used mathematical constants like ~E~, ~PI~, and _the square root of two_.

    - The ~f32~ and ~f64~ types provide a FULL COMPLEMENT of /methods/ for mathematical
      calculations; for example, ~3f64.sqrt()~.

    - The ~type suffix~ is often not required, but when the context is _not clear_,
      you need to write them down:
      ~println!("{}", (2.0).sqrt());~ is non-compilable!

      The correct version can be one of
      + ~println!("{}", (2.0_f64).sqrt());~ or with ~f32~
      + ~println!("{}", f64::sqrt(2.0));~ or with ~f32~

    - You shouldn't expect any implicity conversion for these non collectiontypes
      in Rust.

*** DONE The ~bool~ Type - 51
    CLOSED: [2018-05-19 Sat 02:51]
    - ~as~ can be used to convert ~bool~ values to ~integer~ types:
      #+BEGIN_SRC rust
        assert_eq!(false as i32, 0);
        assert_eq!(true as i32, 1);
      #+END_SRC
      However, you CANNOT convert in the other direction.

    - The info of a ~bool~ value can be saved in a single bit,
      HOWEVER, Rust use an entire byte for a ~bool~ value in memory, so you can
      create a /pointer/ to it.

*** DONE Characters - 52
    CLOSED: [2018-05-19 Sat 12:00]
    - Character (Rust's) :: ~char~ represents a single Unicode character, as a
         32-bit value.

    - Rust uses the char type for single characters in isolation,

      BUT
      Rust uses the /UTF-8 encoding/ for /strings/ and /streams/ of text.

      So,
      a String represents its text as a sequence of UTF-8 bytes, *NOT* as an array
      of ~char~.

    - If you prefer, you can write out a character's /Unicode code point/ in
      hexadecimal:
      + If a /code point/ is in the range U+0000 to U+007F, which is drawn from
        the ASCII character set, can write the character as ~'\xHH'~, where =HH=
        is a two digit hexadecimal number.

      + You can write any Unicode character as ~'\u{HHHHHH}'~, where =HHHHHH= is
        a hexadecimal number between one and six digits long.

    - A ~char~ *ALWAYS* holds a /Unicode code point/ in the range
      + from 0x0000 to 0xD7FF
        OR
      + from 0xE000 to 0x10FFFF

      A ~char~ is *NEVER* a surrogate pair half (from 0xD800 to 0xDFFF), or a
      value outside the Unicode codespace, that is, greater than 0x10FFFF.

    - Conversions:
      Rust *Never Implicitly* converts between ~char~ and any other type.

      + ~char~ --> integer numbers
        Do the *explicit conversion* with ~as~.

      + integer numbers --> ~char~
        * If you do this directly with ~as~, you can only from ~u8~ to ~char~
          - Rationale:
            *Rust intends the ~as~ operator to perform _ONLY_ cheap, infallible
            conversions*,
            BUT
            every integer type _other than_ ~u8~ includes values that are not
            permitted Unicode code points, so those conversions would _require
            runtime checks_.

        * You can use ~std::char::from_u32~, and take any ~u32~ value and returns
          an ~Option<char>~.

    - Check the ~std::char~ to learn more useful methods.
      For instance,
      #+BEGIN_SRC rust
        assert_eq!('*'.is_alphabetic(), false);
        assert_eq!('β'.is_alphabetic(), true);
        assert_eq!('8'.to_digit(10), Some(8));
        assert_eq!('ಠ'.len_utf8(), 3);
        assert_eq!(std::char::from_digit(2, 10), Some('2'));
      #+END_SRC

    - Single /characters/ are not very interesting as /strings/ and /streams/.
      =TODO= "String Types" on page 64.

** DONE Tuples - 54
   CLOSED: [2018-05-19 Sat 12:45]
   - For example,
     ~("Brazil", 1985)~ is a tuple fo type ~(&str, i32)~ (or whatever integer
     type, within a proper context, Rust infers from ~1985~).

   - You can access the elememnts of a /tuple/ ~t~ with ~t.0~, ~t.1~, and so on.

   - unit type :: it is an /empty tuple/, ~()~.

   - Since there is only one value for this type, /unit type/ is written as ~()~. 
     It is used as the return type of functions with only side-effect.

   - Rust consistently permits an *extra trailing comma* everywhere commas are
     used: /function arguments/, /arrays/, /struct/ and /enum/ definitions, and
     so on. For instance, ~("Brazil", 1985)~ and ~("Brazil", 1985,)~ are
     equivalent.

     + *Rationale*:
       This may look odd to human readers, but it can make diffs easier to read
       when entries are added and removed at the end of a list.

   - *UNLIKE* Scala, Rust support /single element tuple/, though the syntax is a
     little wierd! For instance, ~("lonely hearts",)~ is a /single element tuple/
     of type ~(&str,)~. Here the ~,~ in both /value/ and /type/ are mandatory!
     =IMPORTANT=

     =TODO= =???=
     =From Jian= Why do we need /single element tuple/??? Scala has proved that
     /single element tuple/ is NOT useful -- there are always ways to use other
     techniques, and not redundant!

** DONE Pointer types - 55
   CLOSED: [2018-05-19 Sat 13:26]
   - Rust has _SEVERAL_ /types/ that represent memory addresses.

   - We'll discuss *three* /pointer types/ here:
     + /references/
     + /boxes/
     + /unsafe pointers/

*** DONE References - 56
    CLOSED: [2018-05-19 Sat 13:18]
    - For instance, ~&String~ (pronounced "ref String") and ~&i32~ (pronounced
      "ref 32 bit int(eger)").

    - It's easiest to get started by thinking of /references/ as Rust's _BASIC
      pointer type_ -- A /reference/ can point to ANY /value/ ANYWHERE, /stack/
      or /heap/.

    - Rust has ~&~ and ~*~ for /reference/ related operations.
      They are very much like the ~&~ and ~*~ operators in C and C++.

      + The expression ~&x~ produces a reference to ~x~; in Rust terminology, we
        say that it /borrows/ a reference to ~x~.

      + Given a reference ~r~, the expression ~*r~ refers to the value ~r~ points
        to.

    - *LIKE* the ~&~ and ~*~ operators in C and C++, a /reference/ does *NOT*
      automatically free any resources when it goes out of scope.

    - *UNLIKE* the /pointers/ in C/C++, Rust references are *NEVER null*:
      there is simply *no way* to produce a /null reference/ in /safe Rust/.

    - Immutable reference :: ~&T~, like ~const *T~ in C.

    - Mutable reference :: ~&mut T~, like ~*T~ in C.

    - Another major difference is that Rust tracks the /ownership/ and
      /lifetimes/ of values, so mistakes like /dangling pointers/, /double
      frees/, and /pointer invalidation/ are *ruled out at compile time*.
      =TODO=
      Chapter 5 explains Rust’s rules for safe reference use.

*** DONE Boxes - 56
    CLOSED: [2018-05-19 Sat 13:21]
    The simplest way to *allocate* a value in the /heap/ is to use ~Box::new~:
    #+BEGIN_SRC rust
      let t = (12, "eggs");  // (i32, &str)
      let b = Box::new(t);   // Box<(i32, &str)>
    #+END_SRC

    When ~b~ _goes out of scope_, the memory is freed immediately,
    UNLESS ~b~ has been /moved/ -- by returning it, for example. =TODO=
    =TODO= Chpater 4

*** DONE Raw Pointers - 57
    CLOSED: [2018-05-19 Sat 13:26]
    - Rust also has the /raw pointer types/ ~*mut T~ and ~*const T~.
      /Raw pointers/ really are just *LIKE* pointers in C++.

    - Using a /raw pointer/ is *UNSAFE*, because Rust makes no effort to track
      what it points to. For example,
      + /raw pointers/ may be null
        OR
      + they may point to memory that has been freed
        OR
      + they may point to memory that now contains a value of a different type.

       All the classic pointer mistakes of C++ are offered for your enjoyment.

      However, you may *ONLY* _dereference_ /raw pointers/ within an ~unsafe~
      block.

    - ~unsafe~ block :: is Rust's opt-in mechanism for advanced language features
                        whose safety is up to you.

    - If your code has _NO_ ~unsafe~ blocks (or if those it does have are written
      correctly), then the safety guarantees we emphasize throughout this book still hold.
      =TODO=
      For details, see Chapter 21.

** DONE Arrays, Vectors, and Slices - 57
   CLOSED: [2018-05-20 Sun 21:05]
   - Rust has *three* types for representing a _sequence of values_ in memory:
     + ~[T; N]~ 
       An /array/ of ~N~ values, each of type ~T~.
       ~N~ must be known at compile time, which cannot be modified.

     + ~Vec<T>~
       A /vector/ of ~T~'s, which is a _dynamically allocated_, _growable_
       sequence of values of type ~T~. Since its elements live on the /heap/, so
       you can _resize_ /vectors/ at will.

     + ~&[T]~ and ~&mut [T]~, called a /shared slice of ~T~'s/ and /mutable slice
       of ~T~'s/.

       You can think of a /slice/ as a /pointer/ to its first element, together
       with a _count_ of the number of elements you can access starting at that
       point.

       * A /mutable slice/ ~&mut [T]~ lets you read and modify elements, but
         *CANNOT be shared*;

       * a /shared slice/ ~&[T]~ lets you *share access* among several readers,
         but does *NOT let you MODIFY elements*.

   - These types all have the ~len~ /method/.
     They all use the SYNTAX ~v[i]~ to index elements.
     ~i~ must be ~usize~.
     Out of bound indexing will lead to a /panic/.

*** DONE Arrays - 58
    CLOSED: [2018-05-19 Sat 13:48]
    - SYNTAX:
      + Basic: ~let lazy_caterer: [u32; 6] = [1, 2, 4, 7, 11, 16];~
      + Fill in N same values: ~[true; 10000]~ creates an array of 10000 ~bool~'s

    - Rust has *NO* notation for an /uninitialized array/. (In general, Rust
      _ensures_ that code can _NEVER_ access any sort of /uninitialized value/.)

    - Rust /arrays/ doesn't have /methods/ like iterating over elements,
      searching, sorting, filling, filtering ,and so on. They are /methods/ of
      /slices/.

      However, Rust implicitly coverts a /reference/ to an array to a /slice/
      when searching for /methods/, so _you can call any /slice/ /method/ on an
      /array/ DIRECTLY._ For example,
      #+BEGIN_SRC rust
        let mut chaos = [3, 5, 4, 1, 2];
        chaos.sort();
        assert_eq!(chaos, [1, 2, 3, 4, 5]);
      #+END_SRC

    - In fact, even the ~len~ /method/ is a /slice/ only /method/.

    - =TODO= "Slices" on page 62.

*** DONE Vectors - 59
    CLOSED: [2018-05-20 Sun 20:25]
    - SYNTAX (Type):
      ~Vec<T>~

    - vector :: resizable array, which is allocated on the /heap/.

    - The ~vec!~ /macro/ is used to create /vecotr literal/:
      For instance,
      #+BEGIN_SRC rust
        let mut v = vec![2 ,3 ,5, 7];
        assert_eq!(v.iter().fold(1, |a, b| a * b), 210);
      #+END_SRC

    - Add an element: ~v.push(11);~

    - Fill in a /vector/ with a value (the syntax is similar to that of
      /arrays/): ~vec![0; rows * cols]~

    - If you want an empty /vector/ and then push elements into it, use the
      ~Vec::new~ method, which is the same as ~vec![]~.
      #+BEGIN_SRC rust
        let mut v = Vec::new();
        v.push("step");
        v.push("on");
        v.push("no");
        v.push("pets");
        assert_eq!(v, vec!["step", "on", "no", "pets"]);
      #+END_SRC

    - Build a /vector/ from the values produced by an /iterator/:
      #+BEGIN_SRC rust
        let v: Vec<i32> = (0..5).collect();
        assert_eq!(v, [0, 1, 2, 3, 4]);
      #+END_SRC
      The type ~Vec<i32>~ here is required, or the ~collect~ method doesn't know
      the type of the value it will generate.

    - As with /arrays/, you can use /slice methods/ on /vectors/:
      #+BEGIN_SRC rust
        // palindrome!
        let mut v = vec!["a man", "a plan", "a canal", "panama"];
        v.reverse();
        // Reasonable yet disappointing:
        assert_eq!(v, vec!["panama", "a canal", "a plan", "a man"]);
      #+END_SRC
      + Here, the ~reverse~ /method/ is actually defined on /slices/, but the
        call *implicitly borrows* a ~&mut [&str]~ /slice/ from the /vector/, and
        invokes ~reverse~ on that.

    - A ~Vec<T>~ consists of *three* values:
      + a /pointer/ to the heap-allocated buffer allocated to hold the elements;

      + the /number of elements/ that buffer has the capacity to store;
        =From Jian= the ~capacity~ /method/

      + the /number it actually contains now/ (in other words, its length).
        =From Jian= the ~len~ /method/

    - When the buffer has reached its capacity, adding another element to the
      /vector/ entails
      1. *allocating* a larger buffer

      2. *copying* the present contents into it

      3. *updating* the vector's /pointer/ and /capacity/ to describe the new
         buffer
         + capacity :: the buffer it can hold without reallocation.

      4. finally *freeing* the old one.

    - Create a vector with specified /capacity/, and observe its change after
      pushing some elements into it:
      #+BEGIN_SRC rust
        let mut v = Vec::with_capacity(2);
        assert_eq!(v.len(), 0);
        assert_eq!(v.capacity(), 2);

        v.push(1);
        v.push(2);
        assert_eq!(v.len(), 2);
        assert_eq!(v.capacity(), 2);

        v.push(3);
        assert_eq!(v.len(), 3);
        assert_eq!(v.capacity(), 4);
      #+END_SRC
      For the last part above, the /capacity/ you see in your system may be
      _different_.

    - ~insert~ and ~remove~
      #+BEGIN_SRC rust
        let mut v = vec![10, 20, 30, 40, 50];

        v.insert(3, 35);
        assert_eq!(v, [10, 20, 30, 35, 40, 50]);

        v.insert(1);
        assert_eq!(v, [10, 30, 35, 40, 50]);
      #+END_SRC

    - ~pop~
      #+BEGIN_SRC rust
        let mut v = vec!["carmen", "miranda"];
        assert_eq!(v.pop(), Some("miranda"));
        assert_eq!(v.pop(), Some("carmen"));
        assert_eq!(v.pop(), None);
      #+END_SRC

    - Iterate over a /vector/ with ~for~:
      #+BEGIN_SRC rust
        let languages: Vec<String> = std::env::args().skip(1).collect();
        for l in languages {
            println!("{}: {}", l,
                     if l.len() % 2 == 0 {
                         "functional"
                     } else {
                         "imperative"
                     });
        }
        // cargo run Lisp Scheme C C++ Fortran
      #+END_SRC

    - ~Vec~ is an ordinary type defined in Rust,
      NOT built into the language.

      =TODO= Chapter 21 covers how to implement such types

*** TODO Building Vectors Element by Element - 62
    This is a bad idea!!!
    
    - It will involve a lot of re-allocating and copy.
      Whenever a vector outgrows its buffer’s capacity, it chooses a new buffer
      *twice* as large as the old one.

    - =TODO= =???= =TODO=
      =IMPORTANT= but I don't quite understand! =RE-READ=

*** DONE Slices - 62
    CLOSED: [2018-05-20 Sun 21:05]
    - /slice/ (~[T]~) :: a region of an array or vector.
      + Since a /slice/ can be any length, /slices/ *CANNOT* be stored directly
        in variables or passed as function arguments.

      + /Slices/ are _ALWAYS passed by /reference/._
          This is why we often call ~&[T]~'s or ~&str~'s a /slices/, but it is
        acutally /references to a slices/ -- /slices/ almost always appear
        behind /references/!

    - A /reference/ to a /slice/ is /a *fat* pointer/:
      a two-word value comprising
      + a /pointer/ to the /slice/'s first element
      + the number of elements in the /slice/.

    - Example:
      #+BEGIN_SRC rust
        let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];
        let a: [f64; 4] = [0.0, 0.707, 1.0, 0.707];

        let sv: &[f64] = &v;
        let sa: &[f64] = &a;
      #+END_SRC
      + Rust _automatically_ converts the ~&Vec<f64>~ /reference/ and the
        ~&[f64; 4]~ /reference/ to /slice references/ that point directly to the
        data.

    - An ORDINARY /reference/ is a non-owning pointer to _a single value_;
      An /reference/ to a /slice/ is a non-owning pointer to _several values_;

    - You can get a reference to a slice of an array or vector, or _a slice of an
      existing slice_, by indexing it with a range:
      #+BEGIN_SRC rust
        print(&v[0..2]);  // print the first two elements of v
        print(&a[2..]);   // print elements of a starting with a[2]
        print(&sv[1..3]); // print v[1] and v[2]
      #+END_SRC

** DONE String Types - 64 =RE=READ=
   CLOSED: [2018-05-22 Tue 09:03]
   Rust has a similar design as C++: two string types (in C++, they are ~char *~
   and ~std::string~).

*** DONE String Literals - 64
    CLOSED: [2018-05-21 Mon 18:44]
    - SYNTAX: double quoted sequences of characters.

    - A string may span multiple lines:
      #+BEGIN_SRC rust
        println!("In the room the women come and go,
            Singing of Mount Abora");
      #+END_SRC
      The newline character, as well as the spaces at the begining of the second
      line are included in this /string literal/.

      + If one line of a string ends with a backslash,
        then the newline character and the leading whitespace on the next line
        are dropped:
        #+BEGIN_SRC rust
          println!("It was a bright, cold day in April, and \
                    there were four of us-\
                    more or less.");
        #+END_SRC

    - /Raw string/ can reduce the double backslashes in somre strings (e.g.
      regular expressions):
      #+BEGIN_SRC rust
        let default_win_install_path = r"C:\Program Files\Gorillas";
        let pattern = Regex::new(r"\d+(\.\d+)*");
      #+END_SRC

      + You *CANNOT* include a double-quote character in a /raw string/ SIMPLY BY
        putting a backslash in front of it -- remember, we said *NO escape
        sequences are recognized*.

        * Solution: Use pound signs with /raw string/:
          #+BEGIN_SRC rust
            println!(r###"
                This raw string started with 'r###"'.
                Therefore it does not end until we reach a quote mark ('"')
                followed immediately by three pound signs ('###'):
            "###)
          #+END_SRC
          You can add as many pound signs as needed to make it clear where the /raw string/ ends.

*** DONE Byte Strings - 65
    CLOSED: [2018-05-21 Mon 21:45]
    - byte string :: a /string literal/ with the ~b~ prefix.
                     Such a /string/ is a /slice of ~u8~ values/.

    - This combines with all the other string syntax we've shown:
      + span multiple lines

      + use escape sequences

      + use backslashes to join lines.

    - /raw byte string/ starts with ~br"~

    - /byte strings/ can only contains ASCII and \xHH escape sequences.

      You *CANNOT* save other Unicode characters in bytes to form /byte
      strings/.

    - ~&[u8; 3]~

    - Example:
      #+BEGIN_SRC rust
        let method = b"GET";  // &[u8; 3]
        assert_eq!(method, &[b'G', b'E', b'T']);
      #+END_SRC
      The type of ~method~ shown here is ~&[u8; 3]~:
      it's a reference to an /array/ of three bytes.
      =TODO= =???=
      It DOESN'T have any of the /string methods/ we'll discuss in a minute.
      The most string-like thing about it is the syntax we used to write it.

*** DONE Strings in Memory - 65
    CLOSED: [2018-05-21 Mon 23:10]
    - Rust /strings/ are sequences of Unicode characters,
      but they are NOT stored in memory as array of chars.

      Instead, they are stored using UTF-8, a variable-width encoding.

    - Figure 3-3 shows the ~String~ and ~&str~ values created by the code:
      #+BEGIN_SRC rust
        let noodles = "noodles".to_string();
        let oodles = &noodles[1..];
        let poodles = "ಠ_ಠ";
      #+END_SRC
      + A ~String~ has a /resizable buffer/ holding UTF-8 text.
        The buffer is allocated on the /heap/.

    - ~&str~'s ~len()~ /method/ returns its length in byte.
      ~&str~'s ~chars().count()~ returns the number of characters.

    - It is *impossible* to modify a ~&str~:
      #+BEGIN_SRC rust
        let mut s = "hello";
        s[0] = 'c';    // error: the type `str` cannot be mutably indexed
        s.push('\n');  // error: no method named `push` found for the `&str`
      #+END_SRC

    - Create new /strings/ at run time, use ~String~.

    - The type ~&mut str~ does exist, but it is *not very useful*, since almost
      any operation on UTF-8 can *change its overall byte length*, and a /slice/
      *cannot reallocate* its referent.

      =From Jian= This means if you think you need ~&mut str~, it most be
      localized, and you must justify your reasoning!!!

        In fact, the only operations available on &mut str are ~make_ascii_uppercase~
      and ~make_ascii_lowercase~ , which modify the text in place and affect
      only single-byte characters, by definition.

*** DONE String - 67 =RE-READ=
    CLOSED: [2018-05-21 Mon 23:23]
    - ~&str~ is very much like ~&[T]~: a /fat pointer/ to some data.

    - ~String~ is analogous to ~Vec<T>~:
      |                                                  | ~Vec<T>~            | ~String~            |
      |--------------------------------------------------+---------------------+---------------------|
      | Automatically frees buffers                      | Yes                 | Yes                 |
      | Growable                                         | Yes                 | Yes                 |
      | ~::new()~ and ~::with_capacity()~ static methods | Yes                 | Yes                 |
      | ~.reverse()~ and ~.capacity()~ methods           | Yes                 | Yes                 |
      | ~.push()~ and ~.pop()~ methods                   | Yes                 | Yes                 |
      | Range syntax ~v[start..stop]~                    | Yes, returns ~&[T]~ | Yes, returns ~&str~ |
      | Automatic conversion                             | ~&Vec<T>~ to ~&[T]~ | ~&String~ to ~&str~ |
      | Inherits methods                                 | From ~&[T]~         | From &str           |

    - Like a ~Vec~,
      each ~String~ has its own heap-allocated buffer that is _NOT shared_ with
      any other ~String~. When a ~String~ variable goes out of scope, the buffer
      is automatically freed, unless the ~String~ was /moved/.

    - There are several ways to create ~Strings~:
      + The ~.to_string()~ /method/ converts a ~&str~ to a ~String~.
        This *copies* the string: ~let error_message = "too many pets".to_string();~

      + The ~format!()~ macro works just like println!(), except that
        * it returns a new ~String~ instead of writing text to stdout
        * it doesn't automatically add a new line at the end.
        #+BEGIN_SRC rust
          assert_eq!(format!("{}°{:02}′{:02}′′N", 24, 5, 23),
                     "24°05′23′′N".to_string());
        #+END_SRC

      + /Arrays/, /slices/, and /vectors/ of strings have two methods, ~.concat()~ and
        ~.join(sep)~, that form a new String from many strings.
        #+BEGIN_SRC rust
          let bits = vec!["veni", "vidi", "vici"];
          assert_eq!(bits.concat(), "venividivici");
          assert_eq!(bits.join(", "), "veni, vidi, vici");
        #+END_SRC

    - The choice sometimes arises of which type to use: ~&str~ or ~String~.
      =TODO=
      Chapter 5 addresses this question in detail.

      For now it will suffice to point out that a ~&str~ can refer to any /slice/ of
      any /string/, whether it is a /string literal/ (stored in the executable) or a
      ~String~ (allocated and freed at run time).
        This means that ~&str~ is more appropriate for function arguments when
      the caller should be allowed to pass either kind of string.

*** DONE Using Strings - 68
    CLOSED: [2018-05-22 Tue 09:03]
    - /Strings/ support the ~==~ and ~!=~ operators.
      They are used to _compare their values_, rather than address as in Java.
      ~assert!("ONE".to_lowercase() == "one");~

    - /Strings/ also support the comparison operators ~<~, ~<=~, ~>~, and ~>=~,
      as well as many useful methods and functions -- search "str (primitive
      type)" or the "~std::str~" module (or just flip to Chapter 17).
      Here are a few examples:
      #+BEGIN_SRC rust
        assert!("peanut".contains("nut"));
        assert_eq!("ಠ_ಠ".replace("ಠ", "■"), "■_■");
        assert_eq!("    clean\n".trim(), "clean");

        for word in "veni, vidi, vici".split(", ") {
            assert!(word.starts_with("v"));
        }
      #+END_SRC

    - =TODO= =NOTE=
      Keep in mind that, given the nature of Unicode, simple char-by-char
      comparison does not always give the expected answers. For example,
      + the Rust strings ~"th\u{e9}"~ and ~"the\u{301}"~ are both valid Unicode
        representations for *thé*, the French word for tea. Unicode says they
        should both be displayed and processed in the same way, but Rust treats
        them as two completely distinct strings.

        =From Jian=
        Unicode has this trap for people work on it: 
        For one kind of view, there is no unique Unicode representation!
        You cannot belive in your eyes!

      + Similarly, Rust's ordering operators like ~<~ use a simple lexicographical
        order based on character code point values.
          This ordering only sometimes resembles the ordering used for text in the
        user’s language and culture.

        =TODO=
        We discuss these issues in more detail in Chapter 17.

*** DONE Other String-Like Types - 68
    CLOSED: [2018-05-22 Tue 08:59]
    - Rust guarantees that strings are valid UTF-8.

    - Sometimes a program really needs to be able to deal with strings that are
      not valid Unicode.

      + Scenario:
        This usually happens when a Rust program has to interoperate with some
        other system that doesn't enforce any such rules.
          For example, in most OS's it's easy to create a file with a filename
        that isn't valid Unicode. What should happen when a Rust program comes
        across this sort of filename?

      + Solution: =TODO= =Learn More=
        Rust’s solution is to offer a few string-like types for these situations:
        * Stick to ~String~ and ~&str~ for Unicode text.

        * When working with filenames, use ~std::path::PathBuf~ and ~&Path~ instead.

        * When working with binary data that isn't character data at all, use ~Vec<u8>~
          and ~&[u8]~.

        * When working with environment variable names and command-line arguments
          in the native form presented by the operating system, use ~OsString~ and
          ~&OsStr~.

        * When interoperating with C libraries that use null-terminated strings,
          use ~std::ffi::CString~ and ~&CStr~.

** DONE Beyond the basics - 69
   CLOSED: [2018-05-20 Sun 21:30]
   - There are *three* kinds of /user-defined types/, and we'll cover them in
     three successive chapters:
     + ~struct~'s in Chapter 9;
     + ~enum~'s in Chapter 10;
     + ~trait~'s in Chapter 11.

   - /Functions/ and /closures/ have their own types, covered in Chapter 14.

   - The types that make up the standard library are covered throughout the book.
     For example, Chapter 16 presents _the standard collection types_.

* DONE 4. Ownership - 71
  CLOSED: [2018-05-22 Tue 14:50]
** DONE Ownership - 73 =TODO= =NOTE=
   CLOSED: [2018-05-22 Tue 14:50]
   - Rust makes the following pair of promises, both essential to a safe systems
     programming language:
     + You decide the /lifetime/ of each value in your program.
       Rust frees memory and other resources belonging to a value promptly, at a
       point under your control.

     + Even so, your program will *NEVER* use a pointer to an object after it has
       been freed.
       * Using a dangling pointer is a common mistake in C and C++:
         - if you're lucky, your program crashes.
         - if you’re unlucky, your program has a security hole.

       Rust catches these mistakes at /compile time/.

   - =EN= culprit
   - =EN= relinquish control
   - =EN= wager

   - =NOTE=

** DONE Moves - 77
   CLOSED: [2018-05-22 Tue 12:30]
   - In Rust, _for most types_, operations like
     + *assigning* a value to a variable,
     + *passing* it to a function
     + *returning* it from a function
     don't copy the value: they /move/ it.

   - move :: The source relinquishes /ownership/ of the value to the _destination_,
             and becomes _uninitialized_; the _destination_ now *controls* the
             value's lifetime.

   - =TODO= note
   - Python way:
     Copy /pointers/, and use /reference counts/.
     + Cheap to create new variables.
     + Need to maintain /reference counts/ for gc.

   - C++ way:
     Create multiple copies, and each pointer points to its own copy..
     + expensive in creating new variables.
     + Clear in the references of each pointer, and NO /reference counts/.

   - The code below are legal for Python and C++:
     + Python
       #+BEGIN_SRC python
         s = ['udon', 'ramen', 'soba']
         t = s
         u = s
       #+END_SRC

     + C++
       #+BEGIN_SRC c++
         using namespace std;
         vector<string> s = {"udon", "ramen", "soba"};
         vector<string> t = s;
         vector<string> u = s;
       #+END_SRC

   - The similar code is illegal in Rust:
     #+BEGIN_SRC rust
       let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
       let t = s;
       let u = s;

       // error[E0382]: use of moved value: `s`
       //  --> ownership_double_move.rs:9:9
       //   |
       // 8 |     let t = s;
       //   |         - value moved here
       // 9 |     let u = s;
       //   |         ^ value used here after move
       //   |
     #+END_SRC

     The Rust way is NOT intuitive for other languages users, but it has the
     benefits from both Python way and C++ way: Cheap in re-assignment, and
     _NO_ /reference counts/ required.

     + The price you pay is that you must explicitly ask for copies when you
       want them
       #+BEGIN_SRC rust
         let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
         let t = s.clone();
         let u = s.clone();
       #+END_SRC

     + If you really want the Python way, using /reference counts/, you need to
       use The ~Rc~ and ~Arc~ pointer.
       =TODO=
       See "Rc and Arc: Shared Ownership" on page 90.

*** DONE More Operations That Move - 82
    CLOSED: [2018-05-22 Tue 12:05]
    - If you /move/ a value into a variable that was _already initialized_, Rust
      /drops/ the variable's prior value.
      #+BEGIN_SRC rust
        let mut s = "Govinda".to_string();
        s = "Siddhartha".to_string(); // value "Govinda" dropped here
      #+END_SRC

    - If a variable value is /moved/, you assign it a new value (of course, it
      should be a ~mut~ variable), nothing will be /dropped/.
      #+BEGIN_SRC rust
        let mut s = "Govinda".to_string();
        let t = s;
        s = "Siddhartha".to_string();  // nothing is dropped here
      #+END_SRC

    - =TOOD= NOTE
      Read This Example to find out /moves/.

    - /Moving/ values may sound inefficient, but there are two things to keep in
      mind:
      + The /moves/ always apply to the /value proper/, not the /heap storage/
        they own. For /vectors/ and /strings/, the /value proper/ is the three-word
        header alone.

      + The Rust compiler's code generation is good at *seeing through* all these
        /moves/; in practice, the machine code often stores the value directly
        where it belongs.

*** DONE Moves and Control Flow - 84
    CLOSED: [2018-05-22 Tue 11:44]
    The general principle is that, if it's possible for a variable to have had
    its value moved away, and it hasn't definitely been given a new value since,
    it’s considered uninitialized.

    More concrete examples (they are so natural and easy to understand):
    - ~if~
      #+BEGIN_SRC rust
        let x = vec![10, 20, 30];

        if c {
            f(x); // ... ok to move from x here
        } else {
            g(x); // ... and ok to also move from x here
        }

        h(x) // BAD: x is uninitialized here if either path uses it
      #+END_SRC

    - loop
      + Illegal
        #+BEGIN_SRC rust
          let x = vec![10, 20, 30];

          while f() {
              g(x);  // bad: x would be moved in first iteration,
                     // uninitialized in second
          }
        #+END_SRC

      + Legal
        #+BEGIN_SRC rust
          let mut x = vec![10, 20, 30];

          while f() {
              g(x);      // move from x
              x = h();   // give x a fresh value
          }

          e(x);
        #+END_SRC

*** DONE Moves and Indexed Content - 84
    CLOSED: [2018-05-22 Tue 12:30]
    Sometimes you need to assign the values of elements of a collection to a
    variable. If this /moves/ these element values directly, it is wierd that
    we had a initialized collection before, and we will have a collection which
    has uninitialized elements! Rust _forbid_ you doing this :
    #+BEGIN_SRC rust
      // With Compile Error!!!


      // Build a vector of the strings "101", "102", ... "105"
      let mut v = Vec::new();
      for i in 101 .. 106 {
          v.push(i.to_string());
      }

      // Pull out random elements from the vector.
      let third = v[2];
      let fifth = v[4];

      // error[E0507]: cannot move out of indexed content
      //   --> ownership_move_out_of_vector.rs:14:17
      //    |
      // 14 |     let third = v[2];
      //    |                 ^^^^
      //    |                 |
      //    |                 help: consider using a reference instead `&v[2]`
      //    |                 cannot move out of indexed content
    #+END_SRC

    - This is abnormal. We must find a way to resolve this!!!

      Solutions (=From Jian= the main idea is NO gap (uninitialized elements) in
      the middle):
      #+BEGIN_SRC rust
        // Build a vector of the strings "101", "102", ... "105"
        let mut v = Vec::new();
        for i in 101 .. 106 {
            v.push(i.to_string());
        }
      #+END_SRC

      1. Pop a value _off the end_ of the /vector/:
         #+BEGIN_SRC rust
           let fifth = v.pop().unwrap();
           assert_eq!(fifth, "105");
         #+END_SRC

      2. Move a value out of the middle of the vector, and move the last
         element into its spot:
         =From Jian= This operation is wierd ...
         #+BEGIN_SRC rust
           let second = v.swap_remove(1);
           assert_eq!(second, "102");
         #+END_SRC

      3. Swap in another value for the one we're taking out:
         #+BEGIN_SRC rust
           let third = std::mem::replace(&mut v[2], "substitute".to_string());
           assert_eq!(third, "103");
         #+END_SRC

      Let's see what's left of our /vector/ after the operations in steps 1, 2, 3:
      ~assert_eq!(v, vec!["101", "104", "substitute"]);~

    - Collection types like ~Vec~ also generally _offer_ /methods/ to *consume*
      all their elements in a loop:
      #+BEGIN_SRC rust
        let v = vec!["liberté".to_string(),
                     "égalité".to_string(),
                     "fraternité".to_string()];

        for mut s in v {
            s.push('!');
            println!("{}", s);
        }
      #+END_SRC
      This loop will take the ownership of the value of ~v~.

    - If you do find yourself needing to move a value out of an owner that the compiler
      can’t track, you might consider changing the owner’s type to something that can
      dynamically track whether it has a value or not. For example, here’s a variant on the
      earlier example:
      #+BEGIN_SRC rust
        struct Person { name: Option<String>, birth: i32 }
        let mut composers = Vec::new();
        composers.push(Person { name: Some("Palestrina".to_string()),
                                birth: 1525 });
      #+END_SRC
      + You still CANNOT do this: ~let first_name = composers[0].name;~
        Same error as we saw before!

      + But you can do
        #+BEGIN_SRC rust
          let first_name = std::mem::replace(&mut composers[0].name, None);
          assert_eq!(first_name, Some("Palestrina".to_string()));
          assert_eq!(composers[0].name, None);
        #+END_SRC

      + Actually, the ~Option~ way is common enough and you can use a more specific
        /method/ to do the same thing as the ~std::mem::replace~ line above:
        ~let first_name = composers[0].name.take();~

** DONE ~Copy~ Types: The Exception to Moves - 86
   CLOSED: [2018-05-22 Tue 14:21]
   /Moves/ keep ownership of such types clear and assignment cheap.
   But for simpler types like integers or characters, this sort of careful
   handling really isn't necessary.

   - Assigning a value of a ~Copy~ type *copies* the value, _rather than_ /moving/
     it.

   - ~Copy~ types:
     + all the machine integer, floating-point numeric types, the ~char~ and
       ~bool~ types, and a few others.

       =From Jian= (NO SURE?!) All the types that don't need to allocate heap
       storage are ~Copy~ types.

     + A /tuple/ or /fixed-size array/ of ~Copy~ types elements is itself a
       ~Copy~ type.

   - ~struct~'s are by default NOT ~Copty~ type.
     However, if all the fields of a ~struct~ are ~Copy~ types, you can make this
     ~struct~ type ~Copy~ type as well by placing the /attribute/
     ~#[derive(Copy, Clone)]~ above the definition, like so:
     #+BEGIN_SRC rust
       #[derive(Copy, Clone)]
       struct Label { number: u32 }
     #+END_SRC

     + *CAUTION*:
       All fields MUST BE ~Copy~ types!!! OR you'll see an /error/ even if you
       use the /attribute/ ~#[derive(Copy, Clone)]~.

   - Q: Why use non-~Copy~ type as DEFAULT?

     A: If NOT, the type will be very restricted, which can only contain types
        that have no heap storage allocation.

        Change the non-~Copy~ types to ~Copy~ types won't affect your code.
        However, the opposite direction is different, and you need to modify
        your code.

   - One of Rust's principles is that
     + *costs should be apparent to the programmer*.

     + *Basic operations must remain simple*.

     + *Potentially expensive operations should be explicit*,
       like the calls to ~clone~ in the earlier example that make _deep copies_
       of /vectors/ and the /strings/ they contain.

   - =TODO= =TODO= =TODO=
     ~trait~ in general in Chapter 11
     Traits ~Copy~ and ~Clone~ in general in Chapter 13

** DONE ~Rc~ and ~Arc~: shared ownership - 90 =Re-Read= =Reference counter and Circular reference=
   CLOSED: [2018-05-22 Tue 14:49]
   - ~Rc~ and ~Arc~ are safe!
     You CANNOT
     + forget to adjust the reference count

     + create other pointers to the referent that Rust doesn't notice

     + stumble over any of the other sorts of problems that accompany
       reference-counted pointer types in C++.

   - ~Rc~ and ~Arc~ are very similar!
     *The ONLY DIFFERENCE* between them is that an ~Arc~ (/atomic reference count/)
     is safe to share between threads directly, wheereas a plain ~Rc~ uses faster
     /non-thread-safe/ code to update its reference count.

     + Use ~Rc~ if you won't share it between /threads/, and avoid performance
       penalty of an ~Arc~.

     + Rust will *prevent* you from accidentally passing ~Rc~ across a /thread/
       boundary.

     *The two types are otherwise equivalent.*
     We'll only talk about ~Rc~.

   - Use ~Rc~ to simulate the earlier Python code we saw.
     #+BEGIN_SRC rust
       use std::rc::Rc;

       // Rust can infer all these types; written out for clarity
       let s: Rc<String> = Rc::new("shirataki".to_string());
       let t: Rc<String> = s.clone();
       let u: Rc<String> = s.clone();
     #+END_SRC
     + Cloning an ~Rc<T>~ value does NOT copy the ~T~ value;
       instead, it simply creates ANOTHER /pointer/ to it, and increments the
       reference count.

     + The usual /ownership rules/ apply to the ~Rc~ /pointers/ themselves,
       and when the last extant ~Rc~ is /dropped/, Rust /drops/ the ~String~ as
       well.

   - You can use any of ~String~'s usual /methods/ directly on an ~Rc<String>~:
     #+BEGIN_SRC rust
       assert!(s.contains("shira"));
       assert_eq!(t.find("taki"), Some(5));
       println!("{} are quite chewy, almost bouncy, but lack flavor", u);
     #+END_SRC

   - A value owned by an ~Rc~ /pointer/ is *immutable*.
     If you try to add some text to the end of the string:
     #+BEGIN_SRC rust
       s.push_str(" noodles");

       // error: cannot borrow immutable borrowed content as mutable
       //   --> ownership_rc_mutability.rs:12:5
       //    |
       // 12 |     s.push_str(" noodles");
       //    |     ^ cannot borrow as mutable
     #+END_SRC

     + Rust's memory and thread-safety guarantees _depend on_ ensuring that *NO*
       value is ever _SIMULTANEOUSLY_ *shared* _and_ *mutable*.

       Rust assumes the referent of an ~Rc~ /pointer/ might in general be *shared*,
       so it _MUST NOT be_ *mutable*.

       =TODO=
       We explain why this restriction is important in Chapter 5.

   - =TODO= =Re-Write= =NOTE=
     One well-known problem with using /reference counts/ to manage memory is
     that, if there are ever two reference-counted values that point to each
     other, each will hold the other’s /reference count/ above zero, so the
     values will never be freed (Figure 4-13).
     =Circular references=

     It is possible to leak values in Rust this way, but such situations are
     *rare*:

     + MOSTLY:
       You cannot create a cycle without, at some point, making an older value
       point to a newer value. This obviously requires the older value to be
       mutable. Since Rc pointers hold their referents immutable, it’s not
       normally possible to create a cycle.

     + YOU STILL CAN:
       However, Rust does provide ways to create mutable portions of otherwise
       immutable values; this is called /interior mutability/, and we cover it
       in “Interior Mutability” on page 205 =TODO=. If you combine those
       techniques with Rc pointers, you can create a cycle and leak memory.

     *Circular references in a reference count system*

   - weak pointers :: ~std::rc::Weak~. NO details in this book, please refer to
                      the standard library doc.
                      =TODO=

   - /Moves/ and /reference-counted pointers/ are *two* ways to relax the rigidity
     of the /ownership/ tree.

     In the next chapter, we'll look at a *third* way:
     /borrowing/ references to values.

     Once you have become comfortable with both /ownership/ and /borrowing/, you
     will have climbed the steepest part of Rust's learning curve, and you'll be
     ready to take advantage of Rust's unique strengths.

* TODO 5. References and borrowing - 93
  - ALL the /pointer types/ we've seen SO FAR are /owning pointer types/:
    + the simple ~Box<T>~ heap pointer,
    + the pointers internal to ~String~ and ~Vec~ values

  - Owning pointers :: when the /owner/ is /dropped/, the /referent/ goes with
       it.

  - Rust also has /nonowning pointer types/ called /references/, which have no
    effect on their /referents' lifetimes/.

  - It's rather the opposite (/owning pointer types/ and /non-owning pointer types/):
    /references/ must *never outlive* their /referents/.

    You must make it _APPARENT_ in your code that *NO* /reference/ can possibly
    _outlive_ the value it points to.

    To emphasize this, Rust referes to creating a /reference/ to some value as
    /borrowing/ the value:
    What you have borrowed, you must eventually return to its owner!

  - You have two kinds of /references/:
    + shared references :: ~&variable~

    + mutable references :: ~&mut variable~

  - (I didn't copy the wrong code, which is used to introduce the concepts of
    /shared references/ and /mutable references/ here, ONLY the right one -- use
    /reference/ rather than /move/):
    #+BEGIN_SRC rust
      use std::collections::HashMap;

      type Table = HashMap<String, Vec<String>>;

      fn show(table: &Table) {
          for (artist, works) in table {
              println!("works by {}:", artist);
              for work in works {
                  println!(" {}", work);
              }
          }
      }

      fn main() {
          let mut table = Table::new();
          table.insert("Gesualdo".to_string(),
                       vec!["many madrigals".to_string(),
                            "Tenebrae Responsoria".to_string()]);
          table.insert("Caravaggio".to_string(),
                       vec!["The Musicians".to_string(),
                            "The Calling of St. Matthew".to_string()]);
          table.insert("Cellini".to_string(),
                       vec!["Perseus with the head of Medusa".to_string(),
                            "a salt cellar".to_string()]);
          show(table);
      }
    #+END_SRC

  - Modify the ~table~ with with /mutable references/:
    #+BEGIN_SRC rust
      fn sort_works(table: &mut Table) {
          for (_artist, works) in table {
              works.sort();
          }
      }
      sort_works(&mut table);
    #+END_SRC

  - Pass it /by value/, you use the /move/ semantics, and give out the /ownership/.
    Pass it /by reference/, you keep the /ownership/.

** TODO References as Values - 97
*** DONE Rust References Versus C++ References - 97
    CLOSED: [2018-05-24 Thu 12:07]
    - In a nutshell, whereas
      + C++ converts _IMPLICITLY_ between /references/ and /lvalues/ (that is,
        expressions referring to locations in memory), with these conversions
        appearing anywhere they're needed,
        #+BEGIN_SRC c++
          int x = 10;
          int &r = x;       // initialization creates reference implicitly
          assert(r == 10);  // implicitly dereference r to see x's value
          r = 20;           // stores 20 in x, r itself still points to x
        #+END_SRC

      + in Rust you use the ~&~ and ~*~ operators to create and follow /references/,
        #+BEGIN_SRC rust
          let x = 10;
          let r = &x;        // &x is a shared reference to x
          assert!(*r = 10);  // explicitly dereference r
        #+END_SRC

        To create a /mutable reference/, use the ~&mut~ operator:
        #+BEGIN_SRC rust
          let mut y = 32;
          let m = &mut y;     // &mut y is a mutable reference to y
          ,*m += 32;          // explicitly dereference m to set y's value
          assert!(*m == 64);  // add to see y's new value
        #+END_SRC

        with the *exception* of the ~.~ operator, which /borrows/ and
        /dereferences/ _IMPLICITLY_.
        * For instance:
          #+BEGIN_SRC rust
            struct Anime { name: &'static str, bechdel_pass: bool };
            let aria = Anime { name: "Aria: The Animation", bechdel_pass: true };
            let anime_ref = &aria;
            assert_eq!(anime_ref.name, "Aria: The Animation");

            // Equivalent to the above, but with the dereference written out:
            assert_eq!((*anime_ref).name, "Aria: The Animation");
          #+END_SRC

        * ~println!~ macro used in the ~show~ function in the last section expands
          to code that uses the ~.~ operator, so it takes advantage of this
          /implicit deference/ as well.

        * The ~.~ operator can also /implicitly borrow/ a /reference/ to its
          _left operand_, if needed for a /method/ call. For example,
          ~Vec~'s ~sort~ /method/ takes a /mutable reference/ to the vector, so
          the two calls shown here are equivalent:
          #+BEGIN_SRC rust
            let mut v = vec![1973, 1968];

            v.sort();
            // implicitly borrows a mutable reference to v

            (&mut v).sort();
            // equivalent; much uglier
          #+END_SRC

*** DONE Assigning References - 98
    CLOSED: [2018-05-24 Thu 12:17]
    - *Assigning* to a Rust /reference/ makes it _point at a new value_:
      #+BEGIN_SRC rust
        let x = 10;
        let y = 20;
        let mut r = &x;

        if b { r = &y; }
        assert!(*r == 10 || *r == 20);
      #+END_SRC
      The /reference/ ~r~ INITIALLY _points to_ ~x~.
      But if ~b~ is ~true~, the code points it at ~y~ instead, as illustrated in
      Figure 5-1. =TODO= =REVIEW=

      This is *very different from C++*,
      where *assigning* to a /reference/ *stores* the value in its /referent/.
      There's *NO WAY* to point a C++ /reference/ to a location _other than_ the
      one it was initialized with.
      =From Jian=
      The rationale is easy to understand: you didn't /move/ the value, just use
      a /reference/, it is reasonable to NOT write the value to the address where
      the /reference/ ~r~ was initialized to point to.

*** DONE References to References - 99
    CLOSED: [2018-05-24 Thu 12:22]
    - Rust permits /references to references/:
      #+BEGIN_SRC rust
        struct Point { x: i32, y: i32 };
        let point = Point { x: 1000, y: 729 };
        let r: &Point = &point;
        let rr: &&Point = &r;
        let rrr: &&&Point = &rr;
      #+END_SRC
      The ~.~ operator follows as many /references/ as it takes to find its
      target: ~assert_eq!(rrr.y, 729);~

      See the Figure 5-2. A chain of references to references (memory layout)

*** DONE Comparing References - 99
    CLOSED: [2018-05-24 Thu 12:29]
    - Like the ~.~ operator, Rust's comparison operators “see through” any number
      of /references/, *as long as both operands have the SAME type* (=From
      Jian= you can compare SAME type values):
      #+BEGIN_SRC rust
        let x = 10;
        let y = 10;

        let rx = &x;
        let ry = &y;

        let rrx = &rx;
        let rry = &ry;

        assert!(rrx <= rry);
        assert!(rrx == rry);
      #+END_SRC

    - If you actually want to know WHETHER two /references/ point to the SAME
      memory, you can use ~std::ptr::eq~, which compares them as addresses:
      #+BEGIN_SRC rust
        assert!(rx == ry);              // their referents are equal
        assert!(!std::ptr::eq(rx, ry)); // but occupy different addresses
      #+END_SRC

*** DONE References Are Never Null - 100
    CLOSED: [2018-05-24 Thu 12:32]
    /References/ are NEVER /null/, except in the ~unsafe~ block.
    Outside ~unsafe~ block, you CAN'T convert zero into a /reference/ -- the way
    you can used to create /null/ in C/C++.

*** DONE Borrowing References to Arbitrary Expressions - 100
    CLOSED: [2018-05-24 Thu 12:46]
    - Whereas C and C++ ONLY let you apply the ~&~ operator to _certain kinds of
      expressions_,
      Rust lets you /borrow/ a /reference/ to the value of any sort of
      expression at all:
      #+BEGIN_SRC rust
        fn factorial(n: usize) -> usize {
            (1..n+1).fold(1, |a, b| a * b)
        }

        let r = &factorial(6);
        assert_eq!(r + &1009, 1729);
      #+END_SRC
      + In situations like this, Rust simply creates an /anonymous variable/ to
        hold the expression's value, and makes the /reference/ point to that.
          The /lifetime/ of this /anonymous variable/ depends on what you do
        with the /reference/:
        * If you *immediately assign* the /reference/ to a /variable/ in a ~let~
          statement (or make it part of some /struct/ or /array/ that is being
          immediately assigned), then Rust makes the /anonymous variable/ live as
          long as the variable the ~let~ initializes.
            In the preceding example, Rust would do this for the referent of ~r~.

        * Otherwise, the /anonymous variable/ lives to the end of the _enclosing
          statement_. In our example, the /anonymous variable/ created to hold
          ~1009~ lasts only to the end of the ~assert_eq!~ statement.

      + This design seems error-prone for C/C++.
        However, Rust will never let you write code that would produce a
        /dangling reference/. The pointer to /anonymous variables/ will be
        /dropped/ when beyond their /lifetime/.

        If the /reference/ could ever be used *beyond* the /anonymous variable/'s
        /lifetime/, Rust will always report the problem to you at compile time.
          You can then fix your code to keep the referent in a /named variable/
        with an _appropriate_ (=???=) /lifetime/.
      
*** TODO References to Slices and Trait Objects - 101 =TODO=
    /fat pointers/
    /references/ to a /slice/
    /trait object/

** TODO Reference Safety - 101
*** DONE Borrowing a Local Variable - 101
    CLOSED: [2018-05-24 Thu 14:25]
    A pretty obvious case: you _can't_ /borrow/ a /reference/ to a local variable
    and take it out of the variable's scope:

    - Example:
      #+BEGIN_SRC rust
        {
            let r;
            {
                let x = 1;
                r = &x;
            }
            assert_eq!(*r, 1);  // bad: reads memory `x` used to occupy
        }
      #+END_SRC

      Error Message:
      #+BEGIN_SRC text
        error: `x` does not live long enough
          --> references_dangling.rs:8:5
           |
        7  |         r = &x;
           |              - borrow occurs here
        8  |     }
           |     ^ `x` dropped here while still borrowed
        9  |     assert_eq!(*r, 1); // bad: reads memory `x` used to occupy
        10 | }
           | - borrowed value needs to live until here
      #+END_SRC

    - /Lifetimes/ are entirely figments of Rust's /compile-time/ imagination.

      At /runtime/, a /reference/ is nothing but an address;
      its /lifetime/ is *part of* its /type/ and has _NO_ /runtime/
      representation.

    - In this example, there are *three* /lifetimes/ whose relationships we need
      to work out. The variables ~r~ and ~x~ each have a /lifetime/, extending

      from _the point at which they're initialized_
      until _the point that they go out of scop_.

      The third /lifetime/ is that of a /reference type/: the type of the
      /reference/ we /borrow/ to ~&x~, and store in ~r~.

      Here's one *constraint* that should seem pretty obvious:
      if you have a variable ~x~, then a /reference/ to ~x~ *must not* _outlive_
      ~x~ itself, as shown in Figure 5-3.

    - The rules Rust compiler used to do the lifetime check is not so different
      from the process C and C++ programmers impose on themselves; the
      difference is that _Rust knows the rules, and *enforces* them_.

*** TODO Receiving References as Parameters - 105
*** TODO Passing References as Arguments - 107
*** TODO Returning References - 107
*** TODO Structs Containing References - 109
*** TODO Distinct Lifetime Parameters - 111
*** TODO Omitting Lifetime Parameters - 112

** TODO Sharing Versus Mutation - 114
** TODO Taking Arms Against a Sea of Objects - 121


* DONE 6. Expressions - 123 =NOTE=
  CLOSED: [2018-05-23 Wed 22:43]
** DONE An Expression Language - 123
   CLOSED: [2018-05-22 Tue 21:19]
   - Rust is what is called an *expression* language.

** DONE Blocks and Semicolons - 124
   CLOSED: [2018-05-22 Tue 21:19]
   - /Blocks/, too, are expressions
     A /block/ produces a value and can be used _ANYWHERE_ a value is needed:
     #+BEGIN_SRC rust
       let display_name = match post.author() {
           Some(author) => author.name(),
           None         => {
               let network_info = post.get_network_metadata()?;
               let ip           = network_info.client_address();
               ip.to_string()  // NO semicolon here!!!
           }
       }
     #+END_SRC
     + The ~ip.to_string()~ line has no semicolon, and it is the returned value.

     + If all lines in a block has a semicolon at the end, the return value is
       ~()~.

     + Tips:
       #+BEGIN_SRC rust
         // error[E0308]: mismatched types
         //   --> expressions_missing_semicolon.rs:19:9
         //    |
         // 19 |         page.compute_size() // oops, missing semicolon
         //    |         ^^^^^^^^^^^^^^^^^^^ expected (), found tuple
         //    |
         //    = note: expected type `()`
         //               found type `(u32, u32)`
       #+END_SRC
       If you made this mistake in a C or Java program, the compiler would simply point out
       that you’re missing a semicolon. Here’s what Rust says:
       Rust assumes you’ve omitted this semicolon on purpose; it doesn’t consider the possi‐
       bility that it’s just a typo. A confused error message is the result.

       *When you see expected type `()` , look for a missing semicolon first.*

   - Empty statements, ~;~'s, are also allowed in /blocks/.

** TODO Declarations - 126
   - ~let mut~ is kinda of like the ~final~ in Java in some aspect, if not all:
     #+BEGIN_SRC rust
       let name;

       if user.has_nickname() {
           name = user.nickname();
       } else {
           name = generate_unique_name();
           user.register(&name);
       }
     #+END_SRC
     ~name~ assignment appears in two places, but can ONLY be one of them.
     Thus, no ~mut~ required in the declaration of ~name~;

   - A /block/ can also contain /item declarations/.
     An item is simply any declaration that could appear globally in a program
     or module, such as a ~fn~, ~struct~, or ~use~. For instance,
     #+BEGIN_SRC rust
       use std::io;
       use std::cmp::Ordering;

       fn show_files() -> io::Result<()> {
           let mut v = vec![];
           // ...
           fn cmp_by_timestamp_then_name(a: &FileInfo, b: &FileInfo) -> Ordering {
               a.timestamp.cmp(&b.timestamp)
               // first, compare timestamps
                   .reverse()
               // newest file first
                   .then(a.path.cmp(&b.path)) // compare paths to break ties
           }
           v.sort_by(cmp_by_timestamp_then_name);
           // ...
       }
     #+END_SRC

   - =TODO=
     When a ~fn~ xxxxxx

   - =TODO=
     A block can even contain a xxxxx

** DONE ~if~ and match - 127
   CLOSED: [2018-05-22 Tue 21:19]
   - SYNTAX ~if .. else if .. else~:
     #+BEGIN_SRC rust
       if condition1 {
           block_1
       } else if condition2 {
           block_2
       } else {
           block_n
       }
     #+END_SRC
     + /conditions/ doesn't require parentheses.
       The compiler will emit a warning when unnecessary parentheses are
       present.

     + The curly braces for the body blocks are mandatory!

   - SYNTAX ~match~:
     #+BEGIN_SRC rust
       match value {
           pattern => expr,
           // ...
       }
     #+END_SRC
     + If ~expr~ above is a block, the comma may be dropped

     + ~match~ has /exhaustiveness check/

   - The optimization of ~match~:
     + Use a /jump table/, just like a ~switch~ statement in C++.

     + When each arm of a ~match~ produces a constant value, the compiler builds
       an array of those values, and the ~match~ is compiled into an array access.
       Apart from a bounds check, there is a branch-free code.

*** DONE ~if let~ - 129
    CLOSED: [2018-05-22 Tue 21:19]
    - SYNTAX:
      #+BEGIN_SRC rust
        if let pattern = expr {
            block_1
        } else {
            block_2
        }
      #+END_SRC
      + It's never strictly necessary to use ~if let~,
        because ~match~ can do everything ~if let~ can do.

        =From Jian=
        ~match~ syntax is good for aligning conditions and operations, which is
        very convenient! I can imagine any cases that I want to use ~if let~!!!
          I use ~if let~-like syntax in Go, juse because Go DOESN'T HAVE ~match~!

** DONE Loops - 130
   CLOSED: [2018-05-22 Tue 22:01]
   - SYNTAX:
     #+BEGIN_SRC rust
       while condition {
           block
       }

       while let pattern = expr {
           block
       }

       loop {
           block
       }

       for pattern in collection {
           block
       }
     #+END_SRC
     + /Loops/ are also expressions, but they ONLY produce useless value ~()~.

     + ~while~ behaves exactly like the C equivalent, except Rust is stongly
       typed, which means /condition/ must be ~bool~.

     + ~loop~ is used to write /infinite loops/ (with mechanism inside to stop it,
       for instance ~break~ or ~return~ inside).

     + In the ~for~ loop, we often use /range/.
       For instance, ~0..20~ and ~std::ops::Range { start: 0, end: 20 }~ are the
       same, and they are /ranges/.

       ~Range~ can be used with ~for~ loops because ~Range~ is an /iterable type/,
       it implements the ~std::iter::IntoIterator~ /trait/.
       =TODO= Chapter 15
       The standard collections are all iterable, as are /arrays/ and /slices/.

   - In keeping with Rust's /move/ semantics, a ~for~ loop over a value *consumes*
     the value:
     #+BEGIN_SRC rust
       let strings: Vec<String> = error_messages();

       for s in strings {              // each String is moved into s here...
           println!("{}", s);
       }                               // ...and dropped here

       println!("{} error(s)", strings.len()); // error: use of moved value
     #+END_SRC
     + GOOD: This design promises the simplicity in theory.

     + Not so Good, but can be easily walked around:
       * It is very inconvenient in many cases. Use /reference/ instead!
         #+BEGIN_SRC rust
           for rs in &strings {
               println!("String {:?} is at address {:p}.", *rs, rs);
           }
         #+END_SRC
         - ~&strings~ here is ~&Vec<String>~, and
           ~rs~ is ~&String~.

       * Use ~mut~ /reference/ provides a ~mut~ /reference/ to each element:
         #+BEGIN_SRC rust
           for rs in &mut strings {  // the type of `rs` is `&mut String`
               rs.push('\n');  // add a newline to each string
           }
         #+END_SRC

   - =TODO=
     Chapter 15 covers ~for~ loops in greater detail and show many other ways to
     use /iterators/.

   - ~break~ expression exits an _enclosing loop_.

     In Rust, ~break~ works only in /loops/!
       Since ~match~ (the Rust version of C/C++ ~switch~) dosen't have the
     feature of /fall-through/, it doesn't need ~break~.

   - ~continue~

   - A /loop/ can be *labeled* with a /lifetime/.
     =From Jian= the example code below doesn't have a explicit lifetime?!
     #+BEGIN_SRC rust
       'search:
       for room in apartment {
           for spot in room.hiding_spots() {
               if spot.contains(keys) {
                   println!("Your keys are {} in the {}.", spot, room);
                   break 'search;
               }
           }
       }
     #+END_SRC
     + /Labels/ can also be used with ~continue~.

** DONE ~return~ Expressions - 132
   CLOSED: [2018-05-22 Tue 22:07]
   - ~return~ without follow-up value means return ~()~

   - ~return~ can abandon work in progress.
     If you call a function with this kind of ~return~, you may want to use ~?~
     operator to check for errors after calling.
       For instance, ~let output = File::create(filename)?;~, it is shorthand for
     a ~match~ expression:
     #+BEGIN_SRC rust
       let output = match File::create(filename) {
           Ok(f)    => f,
           Err(err) => return Err(err)
       }
     #+END_SRC
     =TODO= See "Propagating Errors" on page 152.

** DONE Why Rust Has ~loop~ - 133 =Re-Read=
   CLOSED: [2018-05-23 Wed 20:44]
   Rust compilers analyze the /control flow/ through your program.

   It is NOT convenient for the compiler to do the analysis with ~while true~
   for some reason (mentioned in the book), and the designer create ~loop~.

   =From Jian=
   This is a plausible reason.
   It is a non-fundamental solution, and a patchy solution!!!
   You should (!!!) solve the ~while true~ problem!!!

** DONE Function and Method Calls - 134
   CLOSED: [2018-05-23 Wed 21:43]
   - Rust usually makes a _sharp distinction_ between /references/ and the
     /values/ they refer to.

     + You cannot pass a /reference/ to a function requires a /value/, or vice versa.

     + However, the ~.~ operator AUTOMATICALLY *dereferences* the caller or
       *borrows* a /reference/ to it as needed.

   - SYNTAX for calling /static methods/:
     ~let mut numbers = Vec::new();~

   - One quirk of Rust syntax:
     When the invocation involves types with generic type parameter(s), the syntax
     is *NOT* intuitive:

     + Error:
       #+BEGIN_SRC rust
         return Vec<i32>::with_capacity(1000);     // error: something about chained comparisons

         let ramp = (0 .. n).collect<Vec<i32>>();  // same error
       #+END_SRC
       The compiler consider ~<~ as /less than operator/, this must be avoided.

       =From Jian= a patchy solution again!

     + Solution:
       * With wierd syntax!
         prefix the type parameter parts with ~::~
         #+BEGIN_SRC rust
           return Vec::<i32>::with_capacity(1000);     // ok, using ::<
           let ramp = (0 .. n).collect::<Vec<i32>>();  // ok, using ::<
         #+END_SRC

       * (_PREFERED_) With the help of /type inference/:
         #+BEGIN_SRC rust
           return Vec::with_capacity(10);            // ok, if the fn return type is Vec<i32>
           let ramp: Vec<i32> = (0 .. n).collect();  // ok, variable's type is given
         #+END_SRC

** DONE Fields and Elements - 135
   CLOSED: [2018-05-23 Wed 22:02]
   - For example:
     #+BEGIN_SRC rust
       game.black_pawns  // struct field
       coords.1          // tuple elements
     #+END_SRC

   - If the left of the dot is a /reference/ or /smart pointer type/, it is
     AUTOMATICALLY *dereferenced*, just as for /method/ calls.

   - SYNTAX like ~pieces[i]~ for /arrays/, /slices/ and /vectors/.

   - The ~..~ operator allows either operand to be omitted.
     #+BEGIN_SRC rust
       ..      // RangeFull
       a ..    // RangeFrom { start: a }
       .. b    // RangeTo { end: b }
       a .. b  // RangeFrom { start: a, end: b }
     #+END_SRC
     + =TODO= =???=
       Only /ranges/ that include a /start value/ are /iterable/,
       =???=

** DONE Reference Operators - 137
   CLOSED: [2018-05-23 Wed 22:18]
   The /address-of operators/, ~&~ and ~&mut~ (covered in Chapter 5).

   The unary ~*~ operator is used to access the value pointed to by a /reference/.
   1. When there is the caller before ~.~, who is a /reference/, /auto dereference/
      will happen.

   2. Therefore, ONLY when we want to read or write the entire value that the
      reference points to. For instance, pass its value as a parameter.
      #+BEGIN_SRC rust
        let padovan: Vec<u64> = compute_padovan_sequence(n);

        for elem in &padovan {
            draw_triangle(turtle, *elem);
        }
      #+END_SRC

** DONE Arithmetic, Bitwise, Comparison, and Logical Operators - 137 =TODO=
   CLOSED: [2018-05-23 Wed 22:30]
   Rust has the usual arithmetic operators, ~+~, ~-~, ~*~, ~/~, and ~%~.
   These operators are mostly like their counterpart in the other languages.

   We'll focus on the few points where Rust departs from tradition:

   - As mentioned in Chapter 3,
     + integer overflow is detected, and causes a /panic/, *in debug builds*.

     + The standard library provides /methods/ LIKE ~a.wrapping_add(b)~ for
       *unchecked* arithmetic.

   - Dividing an integer by zero triggers a /panic/ *even in release builds*.

     Integers have a method ~a.checked_div(b)~ that returns an ~Option~ (~None~
     if ~b~ is zero) and NEVER /panics/.

   - ~%~ can be applied to BOTH /integers/ and /floating numbers/.
     As in C, the result has the same sign as the LHS of the ~%~.

   - Rust use ~!~ rather than the ~~~ for bitwise NOT.

   - /Bit shifting/ is ALWAYS
     + sign-extending on /signed integer types/

     + zero-extending on /unsigned integer types/.

     Since Rust has /unsigned integers/, it does NOT need Java's ~>>>~ operator.

   - *UNLIKE C*, =TODO=
     /Bitwise operations/ have _higher PRECEDENCE_ than comparisons,
     unlike C, so if you write ~x & BIT != 0~ , that means ~(x & BIT) != 0~ , as
     you probably intended.
       This is much more useful than C's interpretation, ~x &(BIT != 0)~ , which
     tests the wrong bit!

** DONE Assignment 138
   CLOSED: [2018-05-23 Wed 22:36]
   - /assignment/ *moves* values of /non-copyable types/.

   - You _cannot_ make a chain of element assignment, and there -- the rightmost
     one will return a ~()~

   - Rust doesn't have ~++~ and ~--~
** TODO Type Casts 139
** DONE Closures - 140
   CLOSED: [2018-05-23 Wed 22:40]
   - Example:
     ~let is_even = |x| x % 2 == 0~

   - The body must a /brace block/.
** TODO Precedence and Associativity 140 =TODO=
** DONE Onward 142
   CLOSED: [2018-05-23 Wed 22:43]
   
* 7. Error Handling - 145
** Panic - 145
*** Unwinding - 146
*** Aborting - 147

** Result - 148
*** Catching Errors - 148
*** Result Type Aliases - 150
*** Printing Errors - 150
*** Propagating Errors - 152
*** Working with Multiple Error Types - 153
*** Dealing with Errors That "Can't Happen" - 155
*** Ignoring Errors - 156
*** Handling Errors in ~main()~ - 156
*** Declaring a Custom Error Type - 157
*** Why Results? - 158

* 8. Crates and Modules - 161
** Crates - 161
*** Build Profiles - 164

** Modules - 165
*** Modules in Separate Files - 166
*** Paths and Imports - 167
*** The Standard Prelude - 169
*** Items, the Building Blocks of Rust - 170
** Turning a Program into a Library - 172
** The src/bin Directory - 174
** Attributes - 175
** Tests and Documentation - 178
*** Integration Tests - 180
*** Documentation - 181
*** Doc-Tests - 182

** Specifying Dependencies - 185
*** Versions - 186
*** ~Cargo.lock~ - 187

** Publishing Crates to crates.io - 188
** Workspaces - 190
** More Nice Things - 191

* 9. Structs - 193
** Named-Field Structs - 193
** Tuple-Like Structs - 196
** Unit-Like Structs - 197
** Struct Layout - 197
** Defining Methods with impl - 198
** Generic Structs - 202
** Structs with Lifetime Parameters - 203
** Deriving Common Traits for Struct Types - 204
** Interior Mutability - 205

* 10. Enums and patterns - 211
** Enums - 212
*** Enums with Data - 214
*** Enums in Memory - 215
*** Rich Data Structures Using Enums - 216
*** Generic Enums - 218

** Patterns - 221
*** Literals, Variables, and Wildcards in Patterns - 223
*** Tuple and Struct Patterns - 225
*** Reference Patterns - 226
*** Matching Multiple Possibilities - 229
*** Pattern Guards - 229
*** ~@~ patterns - 230
*** Where Patterns Are Allowed - 230
*** Populating a Binary Tree 232

** The Big Picture - 233
* TODO 11. Traits and Generics - 235
** TODO Using Traits - 237
** TODO Trait Objects - 238
** TODO Trait Object Layout - 239
** TODO Generic Functions - 240
** TODO Which to Use - 243
** TODO Defining and Implementing Traits - 245
** TODO Default Methods - 246
** TODO Traits and Other People's Types - 247
** TODO Self in Traits - 249
** TODO Subtraits - 250
** TODO Static Methods - 251
** TODO Fully Qualified Method Calls - 252
** TODO Traits That Define Relationships Between Types - 253
** TODO Associated Types (or How Iterators Work) - 254
** TODO Generic Traits (or How Operator Overloading Works) - 257
** TODO Buddy Traits (or How ~rand::random()~ Works) - 258
** TODO Reverse-Engineering Bounds - 260
** TODO Conclusion - 263

* 12. Operator Overloading - 265
** Arithmetic and Bitwise Operators - 266
** Unary Operators - 268
** Binary Operators - 269
** Compound Assignment Operators - 270
** Equality Tests - 272
** Ordered Comparisons - 275
** Index and IndexMut - 277
** Other Operators - 280

* 13. Utility Traits - 281
** Drop - 282
** Sized - 285
** Clone - 287
** Copy - 289
** Deref and DerefMut - 289
** Default
** AsRef and AsMut - 294
** Borrow and BorrowMut - 296
** From and Into - 297
** ToOwned - 300
** Borrow and ToOwned at Work: The Humble Cow - 300

* 14. Closures - 303
** Capturing Variables - 305
** Closures That Borrow - 306
** Closures That Steal - 306
** Function and Closure Types - 308
** Closure Performance - 310
** Closures and Safety - 311
** Closures That Kill - 312
** FnOnce - 312
** FnMut - 314
** Callbacks - 316
** Using Closures Effectively - 319

* TODO 15. Iterators - 321
** TODO The ~Iterator~ and ~IntoIterator~ Traits - 322
** TODO Creating ~Iterator~'s - 324
*** TODO ~iter~ and ~iter_mut~ Methods - 324
*** TODO ~IntoIterator~ Implementations - 325
*** TODO ~drain~ Methods - 327
*** TODO Other ~Iterator~ Sources - 328

** TODO ~Iterator~ Adapters - 330
*** TODO ~map~ and ~filter~ - 330
*** TODO ~filter_map~ and ~flat_map~ - 332
*** TODO ~scan~ - 335
*** TODO ~take~ and ~take_while~ - 335
*** TODO ~skip~ and ~skip_while~ - 336
*** TODO ~peekable~ - 337
*** TODO fuse - 338
*** TODO Reversible ~Iterator~'s and ~rev~ - 339
*** TODO ~inspect~ - 340
*** TODO ~chain~ - 341
*** TODO ~enumerate~ - 341
*** TODO ~zip~ - 342
*** TODO ~by_ref~ - 342
*** TODO ~cloned~ - 344
*** TODO ~cycle~ - 344
** TODO Consuming Iterators - 345
*** TODO Simple Accumulation: ~count~, ~sum~, ~product~ - 345
*** TODO ~max~, ~min~ - 346
*** TODO ~max_by~, ~min_by~ - 346
*** TODO ~max_by_key~, ~min_by_key~ - 347

*** TODO Comparing Item Sequences - 347
*** TODO ~any~ and ~all~ - 348
*** TODO ~position~, ~rposition~, and ~ExactSizeIterator~ - 348
*** TODO ~fold~ - 349
*** TODO ~nth~ - 350
*** TODO ~last~ - 350
*** TODO ~find~ - 351
*** TODO Building Collections: ~collect~ and ~FromIterator~ - 351
*** TODO The ~Extend~ Trait - 353
*** TODO ~partition~ - 353

** TODO Implementing Your Own Iterators - 354

* 16. Collections - 359
** Overview - 360
** ~Vec<T>~ - 361
*** Accessing Elements - 362
*** Iteration - 364
*** Growing and Shrinking Vectors - 364
*** Joining - 367
*** Splitting - 368
*** Swapping - 370
*** Sorting and Searching - 370
*** Comparing Slices - 372
*** Random Elements - 373
*** Rust Rules Out Invalidation Errors - 373

** ~VecDeque<T>~ - 374
** ~LinkedList<T>~ - 376
** ~BinaryHeap<T>~ - 377
** ~HashMap<K, V>~ and ~BTreeMap<K, V>~ - 378
*** Entries - 381
*** Map Iteration - 383

** ~HashSet<T>~ and ~BTreeSet<T>~ - 384
*** Set Iteration - 384
*** When Equal Values Are Different - 385
*** Whole-Set Operations - 385

** Hashing - 387
*** Using a Custom Hashing Algorithm - 388

** Beyond the Standard Collections 389

* 17. Strings and Text - 391
** Some Unicode Background - 392
*** ASCII, Latin-1, and Unicode - 392
*** UTF-8 - 392
*** Text Directionality - 394

** Characters (char) - 394
*** Classifying Characters - 395
*** Handling Digits - 395
*** Case Conversion for Characters - 396
*** Conversions to and from Integers - 396

** String and str - 397
*** Creating String Values - 398
*** Simple Inspection - 398
*** Appending and Inserting Text - 399
*** Removing Text - 401
*** Conventions for Searching and Iterating - 401
*** Patterns for Searching Text - 402
*** Searching and Replacing - 403
*** Iterating over Text - 403
*** Trimming - 406
*** Case Conversion for Strings - 406
*** Parsing Other Types from Strings - 406
*** Converting Other Types to Strings - 407
*** Borrowing as Other Text-Like Types - 408
*** Accessing Text as UTF-8 - 409
*** Producing Text from UTF-8 Data - 409
*** Putting Off Allocation - 410
*** Strings as Generic Collections - 412

** Formatting Values - 413
*** Formatting Text Values - 414
*** Formatting Numbers - 415
*** Formatting Other Types - 417
*** Formatting Values for Debugging - 418
*** Formatting Pointers for Debugging - 419
*** Referring to Arguments by Index or Name - 419
*** Dynamic Widths and Precisions - 420
*** Formatting Your Own Types - 421
*** Using the Formatting Language in Your Own Code - 423

** Regular Expressions - 424
*** Basic Regex Use - 425
*** Building Regex Values Lazily - 426

** Normalization - 427
*** Normalization Forms - 428
*** The unicode-normalization Crate - 429

* 18. Input and Output - 431
** Readers and Writers - 432
*** Readers - 433
*** Buffered Readers - 435
*** Reading Lines - 436
*** Collecting Lines - 439
*** Writers - 439
*** Files - 441
*** Seeking - 441
*** Other Reader and Writer Types - 442
*** Binary Data, Compression, and Serialization - 444

** Files and Directories - 445
*** OsStr and Path - 445
*** Path and PathBuf Methods - 447
*** Filesystem Access Functions - 449
*** Reading Directories - 450
*** Platform-Specific Features - 451

** Networking - 453

* TODO 19. Concurrency - 457
** TODO Fork-Join Parallelism - 459
*** TODO ~spawn~ and ~join~ - 461
*** TODO Error Handling Across Threads - 463
*** TODO Sharing Immutable Data Across Threads - 464
*** TODO Rayon - 466
*** TODO Revisiting the Mandelbrot Set - 468

** TODO Channels - 470
*** TODO Sending Values - 472
*** TODO Receiving Values - 475
*** TODO Running the Pipeline - 476
*** TODO Channel Features and Performance - 478
*** TODO Thread Safety: Send and Sync - 479
*** TODO Piping Almost Any Iterator to a Channel - 482
*** TODO Beyond Pipelines - 483

** TODO Shared Mutable State - 484
*** TODO What Is a Mutex? - 484
*** TODO ~Mutex<T>~ - 486
*** TODO mut and Mutex - 488
*** TODO Why Mutexes Are Not Always a Good Idea - 488
*** TODO Deadlock - 489
*** TODO Poisoned Mutexes - 490
*** TODO Multi-producer Channels Using Mutexes - 490
*** TODO Read/Write Locks (~RwLock<T>~) - 491
*** TODO Condition Variables (Condvar) - 493
*** TODO Atomics - 494
*** TODO Global Variables - 496

** TODO What Hacking Concurrent Code in Rust Is Like - 497

* TODO 20. Macros - 499
** TODO Macro Basics - 500
*** TODO Basics of Macro Expansion - 501
*** TODO Unintended Consequences - 503
*** TODO Repetition - 505

** TODO Built-In Macros - 507
** TODO Debugging Macros - 508
** TODO The ~json!~ Macro - 509
*** TODO Fragment Types - 510
*** TODO Recursion in Macros - 513
*** TODO Using Traits with Macros - 514
*** TODO Scoping and Hygiene - 516
*** TODO Importing and Exporting Macros - 519

** TODO Avoiding Syntax Errors During Matching - 521
** TODO Beyond ~macro_rules!~ - 522

* TODO 21. Unsafe Code - 525
** TODO Unsafe from What? - 526
** TODO Unsafe Blocks - 527
*** TODO Example: An Efficient ASCII String Type - 529

** TODO Unsafe Functions - 531
** TODO Unsafe Block or Unsafe Function? - 533
** TODO Undefined Behavior - 533
** TODO Unsafe Traits - 536
** TODO Raw Pointers - 538
*** TODO Dereferencing Raw Pointers Safely - 540
*** TODO Example: ~RefWithFlag~ - 541
*** TODO Nullable Pointers - 544
*** TODO Type Sizes and Alignments - 544
*** TODO Pointer Arithmetic - 545
*** TODO Moving into and out of Memory - 546
*** TODO Example: ~GapBuffer~ - 550
*** TODO Panic Safety in Unsafe Code - 556

** TODO Foreign Functions: Calling C and C++ from Rust - 557
*** TODO Finding Common Data Representations - 558
*** TODO Declaring Foreign Functions and Variables - 561
*** TODO Using Functions from Libraries - 562
*** TODO A Raw Interface to libgit2 - 566
*** TODO A Safe Interface to libgit2 - 572

** Conclusion - 583

* Index - 585
