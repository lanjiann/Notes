#+TITLE: Programming Rust
#+VERSION: 2017, 1st
#+AUTHOR: Jim Blandy and Jason Orendorff
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[1. Why Rust? - 1][1. Why Rust? - 1]]
  - [[Type Safety - 3][Type Safety - 3]]
- [[2. A Tour of Rust - 7 -- =Reading=][2. A Tour of Rust - 7 -- =Reading=]]
  - [[Downloading and installing Rust - 7][Downloading and installing Rust - 7]]
  - [[A Simple Function - 10][A Simple Function - 10]]
  - [[Writing and Running Unit Tests - 11][Writing and Running Unit Tests - 11]]
  - [[Handling Command-Line Arguments - 12][Handling Command-Line Arguments - 12]]
  - [[A Simple Web Server - 17 =TODO= =NOTE=][A Simple Web Server - 17 =TODO= =NOTE=]]
  - [[Concurrency - 23][Concurrency - 23]]
    - [[What the Mandelbrot Set Actually Is - 24][What the Mandelbrot Set Actually Is - 24]]
    - [[Parsing Pair Command-Line Arguments - 28][Parsing Pair Command-Line Arguments - 28]]
    - [[Mapping from Pixels to Complex Numbers - 31][Mapping from Pixels to Complex Numbers - 31]]
    - [[Plotting the Set - 32][Plotting the Set - 32]]
    - [[Writing Image Files - 34][Writing Image Files - 34]]
    - [[A Concurrent Mandelbrot Program - 35][A Concurrent Mandelbrot Program - 35]]
    - [[Running the Mandelbrot Plotter - 40][Running the Mandelbrot Plotter - 40]]
    - [[Safety Is Invisible - 41][Safety Is Invisible - 41]]
- [[3. Basic types - 43][3. Basic types - 43]]
  - [[Machine Types - 46][Machine Types - 46]]
    - [[Integer Types - 47][Integer Types - 47]]
    - [[Floating-Point Types - 50][Floating-Point Types - 50]]
    - [[The ~bool~ Type - 51][The ~bool~ Type - 51]]
    - [[Characters - 52][Characters - 52]]
  - [[Tuples - 54][Tuples - 54]]
  - [[Pointer types - 55][Pointer types - 55]]
    - [[References - 56][References - 56]]
    - [[Boxes - 56][Boxes - 56]]
    - [[Raw Pointers - 57][Raw Pointers - 57]]
  - [[Arrays, Vectors, and Slices - 57][Arrays, Vectors, and Slices - 57]]
    - [[Arrays - 58][Arrays - 58]]
    - [[Vectors - 59][Vectors - 59]]
    - [[Building Vectors Element by Element - 62][Building Vectors Element by Element - 62]]
    - [[Slices - 62][Slices - 62]]
  - [[String Types - 64][String Types - 64]]
    - [[String Literals - 64][String Literals - 64]]
    - [[Byte Strings - 65][Byte Strings - 65]]
    - [[Strings in Memory - 65][Strings in Memory - 65]]
    - [[String - 67][String - 67]]
    - [[Using Strings - 68][Using Strings - 68]]
    - [[Other String-Like Types - 68][Other String-Like Types - 68]]
  - [[Beyond the basics - 69][Beyond the basics - 69]]
- [[4. Ownership - 71][4. Ownership - 71]]
  - [[Ownership - 73 =TODO= =NOTE=][Ownership - 73 =TODO= =NOTE=]]
  - [[Moves - 77][Moves - 77]]
    - [[More Operations That Move - 82][More Operations That Move - 82]]
    - [[Moves and Control Flow - 84][Moves and Control Flow - 84]]
    - [[Moves and Indexed Content - 84][Moves and Indexed Content - 84]]
  - [[~Copy~ Types: The Exception to Moves - 86][~Copy~ Types: The Exception to Moves - 86]]
  - [[~Rc~ and ~Arc~: shared ownership - 90 =Re-Read= =Reference counter and Circular reference=][~Rc~ and ~Arc~: shared ownership - 90 =Re-Read= =Reference counter and Circular reference=]]
- [[5. References and borrowing - 93][5. References and borrowing - 93]]
  - [[References as Values - 97][References as Values - 97]]
    - [[Rust References Versus C++ References - 97][Rust References Versus C++ References - 97]]
    - [[Assigning References - 98][Assigning References - 98]]
    - [[References to References - 99][References to References - 99]]
    - [[Comparing References - 99][Comparing References - 99]]
    - [[References Are Never Null - 100][References Are Never Null - 100]]
    - [[Borrowing References to Arbitrary Expressions - 100][Borrowing References to Arbitrary Expressions - 100]]
    - [[References to Slices and Trait Objects - 101][References to Slices and Trait Objects - 101]]
  - [[Reference Safety - 101][Reference Safety - 101]]
    - [[Borrowing a Local Variable - 101][Borrowing a Local Variable - 101]]
    - [[Receiving References as Parameters - 105][Receiving References as Parameters - 105]]
    - [[Passing References as Arguments - 107][Passing References as Arguments - 107]]
    - [[Returning References - 107][Returning References - 107]]
    - [[Structs Containing References - 109][Structs Containing References - 109]]
    - [[Distinct Lifetime Parameters - 111][Distinct Lifetime Parameters - 111]]
    - [[Omitting Lifetime Parameters - 112][Omitting Lifetime Parameters - 112]]
  - [[Sharing Versus Mutation - 114][Sharing Versus Mutation - 114]]
  - [[Taking Arms Against a Sea of Objects - 121][Taking Arms Against a Sea of Objects - 121]]
- [[6. Expressions - 123 =NOTE=][6. Expressions - 123 =NOTE=]]
  - [[An Expression Language - 123][An Expression Language - 123]]
  - [[Blocks and Semicolons - 124][Blocks and Semicolons - 124]]
  - [[Declarations - 126][Declarations - 126]]
  - [[~if~ and match - 127][~if~ and match - 127]]
    - [[~if let~ - 129][~if let~ - 129]]
  - [[Loops - 130][Loops - 130]]
  - [[~return~ Expressions - 132][~return~ Expressions - 132]]
  - [[Why Rust Has ~loop~ - 133 =Re-Read=][Why Rust Has ~loop~ - 133 =Re-Read=]]
  - [[Function and Method Calls - 134][Function and Method Calls - 134]]
  - [[Fields and Elements - 135][Fields and Elements - 135]]
  - [[Reference Operators - 137][Reference Operators - 137]]
  - [[Arithmetic, Bitwise, Comparison, and Logical Operators - 137 =TODO=][Arithmetic, Bitwise, Comparison, and Logical Operators - 137 =TODO=]]
  - [[Assignment 138][Assignment 138]]
  - [[Type Casts 139][Type Casts 139]]
  - [[Closures - 140][Closures - 140]]
  - [[Precedence and Associativity - 140 =TODO=][Precedence and Associativity - 140 =TODO=]]
  - [[Onward - 142][Onward - 142]]
- [[7. Error Handling - 145][7. Error Handling - 145]]
  - [[Panic - 145][Panic - 145]]
    - [[Unwinding - 146][Unwinding - 146]]
    - [[Aborting - 147][Aborting - 147]]
  - [[Result - 148][Result - 148]]
    - [[Catching Errors - 148][Catching Errors - 148]]
    - [[Result Type Aliases - 150][Result Type Aliases - 150]]
    - [[Printing Errors - 150][Printing Errors - 150]]
    - [[Propagating Errors - 152][Propagating Errors - 152]]
    - [[Working with Multiple Error Types - 153][Working with Multiple Error Types - 153]]
    - [[Dealing with Errors That "Can't Happen" - 155][Dealing with Errors That "Can't Happen" - 155]]
    - [[Ignoring Errors - 156][Ignoring Errors - 156]]
    - [[Handling Errors in ~main()~ - 156][Handling Errors in ~main()~ - 156]]
    - [[Declaring a Custom Error Type - 157][Declaring a Custom Error Type - 157]]
    - [[Why Results? - 158][Why Results? - 158]]
- [[8. Crates and Modules - 161][8. Crates and Modules - 161]]
  - [[Crates - 161][Crates - 161]]
    - [[Build Profiles - 164][Build Profiles - 164]]
  - [[Modules - 165][Modules - 165]]
    - [[Modules in Separate Files - 166][Modules in Separate Files - 166]]
    - [[Paths and Imports - 167][Paths and Imports - 167]]
    - [[The Standard Prelude - 169][The Standard Prelude - 169]]
    - [[Items, the Building Blocks of Rust - 170 =RE-READ=][Items, the Building Blocks of Rust - 170 =RE-READ=]]
  - [[Turning a Program into a Library - 172][Turning a Program into a Library - 172]]
  - [[The =src/bin= Directory - 174][The =src/bin= Directory - 174]]
  - [[Attributes - 175][Attributes - 175]]
  - [[Tests and Documentation - 178][Tests and Documentation - 178]]
    - [[Integration Tests - 180][Integration Tests - 180]]
    - [[Documentation - 181][Documentation - 181]]
    - [[Doc-Tests - 182][Doc-Tests - 182]]
  - [[Specifying Dependencies - 185][Specifying Dependencies - 185]]
    - [[Versions - 186][Versions - 186]]
    - [[~Cargo.lock~ - 187][~Cargo.lock~ - 187]]
  - [[Publishing Crates to crates.io - 188][Publishing Crates to crates.io - 188]]
  - [[Workspaces - 190][Workspaces - 190]]
  - [[More Nice Things - 191][More Nice Things - 191]]
- [[9. Structs - 193][9. Structs - 193]]
  - [[Named-Field Structs - 193][Named-Field Structs - 193]]
  - [[Tuple-Like Structs - 196][Tuple-Like Structs - 196]]
  - [[Unit-Like Structs - 197][Unit-Like Structs - 197]]
  - [[Struct Layout - 197][Struct Layout - 197]]
  - [[Defining Methods with ~impl~ - 198][Defining Methods with ~impl~ - 198]]
  - [[Generic Structs - 202][Generic Structs - 202]]
  - [[Structs with Lifetime Parameters - 203][Structs with Lifetime Parameters - 203]]
  - [[Deriving Common Traits for Struct Types - 204][Deriving Common Traits for Struct Types - 204]]
  - [[Interior Mutability - 205][Interior Mutability - 205]]
- [[10. Enums and patterns - 211][10. Enums and patterns - 211]]
  - [[Enums - 212][Enums - 212]]
    - [[Enums with Data - 214 - =Re-Write Notes=][Enums with Data - 214 - =Re-Write Notes=]]
    - [[Enums in Memory - 215][Enums in Memory - 215]]
    - [[Rich Data Structures Using Enums - 216][Rich Data Structures Using Enums - 216]]
    - [[Generic Enums - 218][Generic Enums - 218]]
  - [[Patterns - 221][Patterns - 221]]
    - [[Literals, Variables, and Wildcards in Patterns - 223][Literals, Variables, and Wildcards in Patterns - 223]]
    - [[Tuple and Struct Patterns - 225][Tuple and Struct Patterns - 225]]
    - [[Reference Patterns - 226][Reference Patterns - 226]]
    - [[Matching Multiple Possibilities - 229][Matching Multiple Possibilities - 229]]
    - [[Pattern Guards - 229][Pattern Guards - 229]]
    - [[~@~ patterns - 230][~@~ patterns - 230]]
    - [[Where Patterns Are Allowed - 230][Where Patterns Are Allowed - 230]]
    - [[Populating a Binary Tree 232][Populating a Binary Tree 232]]
  - [[The Big Picture - 233 =Re-Read=][The Big Picture - 233 =Re-Read=]]
- [[11. Traits and Generics - 235][11. Traits and Generics - 235]]
  - [[Using Traits - 237][Using Traits - 237]]
    - [[Trait Objects - 238][Trait Objects - 238]]
    - [[Trait Object Layout - 239][Trait Object Layout - 239]]
    - [[Generic Functions - 240][Generic Functions - 240]]
    - [[Which to Use - 243][Which to Use - 243]]
  - [[Defining and Implementing Traits - 245][Defining and Implementing Traits - 245]]
    - [[Default Methods - 246][Default Methods - 246]]
    - [[Traits and Other People's Types - 247][Traits and Other People's Types - 247]]
    - [[~Self~ in Traits - 249][~Self~ in Traits - 249]]
    - [[Subtraits - 250][Subtraits - 250]]
    - [[Static Methods - 251][Static Methods - 251]]
  - [[Fully Qualified Method Calls - 252][Fully Qualified Method Calls - 252]]
  - [[Traits That Define Relationships Between Types - 253][Traits That Define Relationships Between Types - 253]]
    - [[Associated Types (or How Iterators Work) - 254][Associated Types (or How Iterators Work) - 254]]
    - [[Generic Traits (or How Operator Overloading Works) - 257][Generic Traits (or How Operator Overloading Works) - 257]]
    - [[Buddy Traits (or How ~rand::random()~ Works) - 258][Buddy Traits (or How ~rand::random()~ Works) - 258]]
  - [[Reverse-Engineering Bounds - 260][Reverse-Engineering Bounds - 260]]
  - [[Conclusion - 263][Conclusion - 263]]
- [[12. Operator Overloading - 265 - =Reading=][12. Operator Overloading - 265 - =Reading=]]
  - [[Arithmetic and Bitwise Operators - 266][Arithmetic and Bitwise Operators - 266]]
    - [[Unary Operators - 268][Unary Operators - 268]]
    - [[Binary Operators - 269][Binary Operators - 269]]
    - [[Compound Assignment Operators - 270][Compound Assignment Operators - 270]]
  - [[Equality Tests - 272][Equality Tests - 272]]
  - [[Ordered Comparisons - 275][Ordered Comparisons - 275]]
  - [[~Index~ and ~IndexMut~ - 277][~Index~ and ~IndexMut~ - 277]]
  - [[Other Operators - 280][Other Operators - 280]]
- [[13. Utility Traits - 281][13. Utility Traits - 281]]
  - [[~Drop~ - 282][~Drop~ - 282]]
  - [[~Sized~ - 285][~Sized~ - 285]]
  - [[~Clone~ - 287][~Clone~ - 287]]
  - [[~Copy~ - 289][~Copy~ - 289]]
  - [[~Deref~ and ~DerefMut~ - 289][~Deref~ and ~DerefMut~ - 289]]
  - [[~Default~][~Default~]]
  - [[~AsRef~ and ~AsMut~ - 294][~AsRef~ and ~AsMut~ - 294]]
  - [[~Borrow~ and ~BorrowMut~ - 296][~Borrow~ and ~BorrowMut~ - 296]]
  - [[~From~ and ~Into~ - 297][~From~ and ~Into~ - 297]]
  - [[~ToOwned~ - 300][~ToOwned~ - 300]]
  - [[~Borrow~ and ~ToOwned~ at Work: The Humble ~Cow~ - 300][~Borrow~ and ~ToOwned~ at Work: The Humble ~Cow~ - 300]]
- [[14. Closures - 303 - =Re-READ=][14. Closures - 303 - =Re-READ=]]
  - [[Capturing Variables - 305][Capturing Variables - 305]]
    - [[Closures That Borrow - 306][Closures That Borrow - 306]]
    - [[Closures That Steal - 306][Closures That Steal - 306]]
  - [[Function and Closure Types - 308][Function and Closure Types - 308]]
  - [[Closure Performance - 310][Closure Performance - 310]]
  - [[Closures and Safety - 311][Closures and Safety - 311]]
    - [[Closures That Kill - 312][Closures That Kill - 312]]
    - [[~FnOnce~ - 312][~FnOnce~ - 312]]
    - [[~FnMut~ - 314][~FnMut~ - 314]]
  - [[Callbacks - 316][Callbacks - 316]]
  - [[Using Closures Effectively - 319][Using Closures Effectively - 319]]
- [[15. Iterators - 321 - =Reading=][15. Iterators - 321 - =Reading=]]
  - [[The ~Iterator~ and ~IntoIterator~ Traits - 322][The ~Iterator~ and ~IntoIterator~ Traits - 322]]
  - [[Creating ~Iterator~'s - 324 =NOTE=][Creating ~Iterator~'s - 324 =NOTE=]]
    - [[~iter~ and ~iter_mut~ Methods - 324][~iter~ and ~iter_mut~ Methods - 324]]
    - [[~IntoIterator~ Implementations - 325][~IntoIterator~ Implementations - 325]]
    - [[~drain~ Methods - 327 =???=][~drain~ Methods - 327 =???=]]
    - [[Other ~Iterator~ Sources - 328][Other ~Iterator~ Sources - 328]]
  - [[~Iterator~ Adapters - 330][~Iterator~ Adapters - 330]]
    - [[~map~ and ~filter~ - 330][~map~ and ~filter~ - 330]]
    - [[~filter_map~ and ~flat_map~ - 332][~filter_map~ and ~flat_map~ - 332]]
    - [[~scan~ - 335][~scan~ - 335]]
    - [[~take~ and ~take_while~ - 335][~take~ and ~take_while~ - 335]]
    - [[~skip~ and ~skip_while~ - 336][~skip~ and ~skip_while~ - 336]]
    - [[~peekable~ - 337][~peekable~ - 337]]
    - [[~fuse~ - 338][~fuse~ - 338]]
    - [[Reversible ~Iterator~'s and ~rev~ - 339][Reversible ~Iterator~'s and ~rev~ - 339]]
    - [[~inspect~ - 340][~inspect~ - 340]]
    - [[~chain~ - 341][~chain~ - 341]]
    - [[~enumerate~ - 341][~enumerate~ - 341]]
    - [[~zip~ - 342][~zip~ - 342]]
    - [[~by_ref~ - 342][~by_ref~ - 342]]
    - [[~cloned~ - 344][~cloned~ - 344]]
    - [[~cycle~ - 344][~cycle~ - 344]]
  - [[Consuming Iterators - 345][Consuming Iterators - 345]]
    - [[Simple Accumulation: ~count~, ~sum~, ~product~ - 345][Simple Accumulation: ~count~, ~sum~, ~product~ - 345]]
    - [[~max~, ~min~ - 346][~max~, ~min~ - 346]]
    - [[~max_by~, ~min_by~ - 346][~max_by~, ~min_by~ - 346]]
    - [[~max_by_key~, ~min_by_key~ - 347][~max_by_key~, ~min_by_key~ - 347]]
    - [[Comparing ~Item~ Sequences - 347][Comparing ~Item~ Sequences - 347]]
    - [[~any~ and ~all~ - 348][~any~ and ~all~ - 348]]
    - [[~position~, ~rposition~, and ~ExactSizeIterator~ - 348][~position~, ~rposition~, and ~ExactSizeIterator~ - 348]]
    - [[~fold~ - 349][~fold~ - 349]]
    - [[~nth~ - 350][~nth~ - 350]]
    - [[~last~ - 350][~last~ - 350]]
    - [[~find~ - 351][~find~ - 351]]
    - [[Building Collections: ~collect~ and ~FromIterator~ - 351][Building Collections: ~collect~ and ~FromIterator~ - 351]]
    - [[The ~Extend~ Trait - 353][The ~Extend~ Trait - 353]]
    - [[~partition~ - 353][~partition~ - 353]]
  - [[Implementing Your Own Iterators - 354][Implementing Your Own Iterators - 354]]
- [[16. Collections - 359][16. Collections - 359]]
  - [[Overview - 360][Overview - 360]]
  - [[~Vec<T>~ - 361][~Vec<T>~ - 361]]
    - [[Accessing Elements - 362][Accessing Elements - 362]]
    - [[Iteration - 364][Iteration - 364]]
    - [[Growing and Shrinking Vectors - 364][Growing and Shrinking Vectors - 364]]
    - [[Joining - 367][Joining - 367]]
    - [[Splitting - 368][Splitting - 368]]
    - [[Swapping - 370][Swapping - 370]]
    - [[Sorting and Searching - 370][Sorting and Searching - 370]]
    - [[Comparing Slices - 372][Comparing Slices - 372]]
    - [[Random Elements - 373][Random Elements - 373]]
    - [[Rust Rules Out Invalidation Errors - 373][Rust Rules Out Invalidation Errors - 373]]
  - [[~VecDeque<T>~ - 374][~VecDeque<T>~ - 374]]
  - [[~LinkedList<T>~ - 376][~LinkedList<T>~ - 376]]
  - [[~BinaryHeap<T>~ - 377][~BinaryHeap<T>~ - 377]]
  - [[~HashMap<K, V>~ and ~BTreeMap<K, V>~ - 378][~HashMap<K, V>~ and ~BTreeMap<K, V>~ - 378]]
    - [[Entries - 381][Entries - 381]]
    - [[Map Iteration - 383][Map Iteration - 383]]
  - [[~HashSet<T>~ and ~BTreeSet<T>~ - 384][~HashSet<T>~ and ~BTreeSet<T>~ - 384]]
    - [[Set Iteration - 384][Set Iteration - 384]]
    - [[When Equal Values Are Different - 385][When Equal Values Are Different - 385]]
    - [[Whole-Set Operations - 385][Whole-Set Operations - 385]]
  - [[Hashing - 387][Hashing - 387]]
    - [[Using a Custom Hashing Algorithm - 388][Using a Custom Hashing Algorithm - 388]]
  - [[Beyond the Standard Collections 389][Beyond the Standard Collections 389]]
- [[17. Strings and Text - 391][17. Strings and Text - 391]]
  - [[Some Unicode Background - 392][Some Unicode Background - 392]]
    - [[ASCII, Latin-1, and Unicode - 392][ASCII, Latin-1, and Unicode - 392]]
    - [[UTF-8 - 392][UTF-8 - 392]]
    - [[Text Directionality - 394][Text Directionality - 394]]
  - [[Characters (~char~) - 394][Characters (~char~) - 394]]
    - [[Classifying Characters - 395][Classifying Characters - 395]]
    - [[Handling Digits - 395][Handling Digits - 395]]
    - [[Case Conversion for Characters - 396][Case Conversion for Characters - 396]]
    - [[Conversions to and from Integers - 396][Conversions to and from Integers - 396]]
  - [[~String~ and ~str~ - 397][~String~ and ~str~ - 397]]
    - [[Creating String Values - 398][Creating String Values - 398]]
    - [[Simple Inspection - 398][Simple Inspection - 398]]
    - [[Appending and Inserting Text - 399][Appending and Inserting Text - 399]]
    - [[Removing Text - 401][Removing Text - 401]]
    - [[Conventions for Searching and Iterating - 401][Conventions for Searching and Iterating - 401]]
    - [[Patterns for Searching Text - 402][Patterns for Searching Text - 402]]
    - [[Searching and Replacing - 403][Searching and Replacing - 403]]
    - [[Iterating over Text - 403][Iterating over Text - 403]]
    - [[Trimming - 406][Trimming - 406]]
    - [[Case Conversion for Strings - 406][Case Conversion for Strings - 406]]
    - [[Parsing Other Types from Strings - 406][Parsing Other Types from Strings - 406]]
    - [[Converting Other Types to Strings - 407][Converting Other Types to Strings - 407]]
    - [[Borrowing as Other Text-Like Types - 408][Borrowing as Other Text-Like Types - 408]]
    - [[Accessing Text as UTF-8 - 409][Accessing Text as UTF-8 - 409]]
    - [[Producing Text from UTF-8 Data - 409][Producing Text from UTF-8 Data - 409]]
    - [[Putting Off Allocation - 410][Putting Off Allocation - 410]]
    - [[Strings as Generic Collections - 412][Strings as Generic Collections - 412]]
  - [[Formatting Values - 413][Formatting Values - 413]]
    - [[Formatting Text Values - 414][Formatting Text Values - 414]]
    - [[Formatting Numbers - 415][Formatting Numbers - 415]]
    - [[Formatting Other Types - 417][Formatting Other Types - 417]]
    - [[Formatting Values for Debugging - 418][Formatting Values for Debugging - 418]]
    - [[Formatting Pointers for Debugging - 419][Formatting Pointers for Debugging - 419]]
    - [[Referring to Arguments by Index or Name - 419][Referring to Arguments by Index or Name - 419]]
    - [[Dynamic Widths and Precisions - 420][Dynamic Widths and Precisions - 420]]
    - [[Formatting Your Own Types - 421][Formatting Your Own Types - 421]]
    - [[Using the Formatting Language in Your Own Code - 423][Using the Formatting Language in Your Own Code - 423]]
  - [[Regular Expressions - 424][Regular Expressions - 424]]
    - [[Basic Regex Use - 425][Basic Regex Use - 425]]
    - [[Building Regex Values Lazily - 426][Building Regex Values Lazily - 426]]
  - [[Normalization - 427][Normalization - 427]]
    - [[Normalization Forms - 428][Normalization Forms - 428]]
    - [[The unicode-normalization Crate - 429][The unicode-normalization Crate - 429]]
- [[18. Input and Output - 431][18. Input and Output - 431]]
  - [[Readers and Writers - 432][Readers and Writers - 432]]
    - [[Readers - 433][Readers - 433]]
    - [[Buffered Readers - 435][Buffered Readers - 435]]
    - [[Reading Lines - 436][Reading Lines - 436]]
    - [[Collecting Lines - 439][Collecting Lines - 439]]
    - [[Writers - 439][Writers - 439]]
    - [[Files - 441][Files - 441]]
    - [[Seeking - 441][Seeking - 441]]
    - [[Other Reader and Writer Types - 442][Other Reader and Writer Types - 442]]
    - [[Binary Data, Compression, and Serialization - 444][Binary Data, Compression, and Serialization - 444]]
  - [[Files and Directories - 445][Files and Directories - 445]]
    - [[~OsStr~ and ~Path~ - 445][~OsStr~ and ~Path~ - 445]]
    - [[~Path~ and ~PathBuf~ Methods - 447][~Path~ and ~PathBuf~ Methods - 447]]
    - [[Filesystem Access Functions - 449][Filesystem Access Functions - 449]]
    - [[Reading Directories - 450][Reading Directories - 450]]
    - [[Platform-Specific Features - 451 =RE-READ= =TAKE NOTES=][Platform-Specific Features - 451 =RE-READ= =TAKE NOTES=]]
  - [[Networking - 453][Networking - 453]]
- [[19. Concurrency - 457][19. Concurrency - 457]]
  - [[Fork-Join Parallelism - 459][Fork-Join Parallelism - 459]]
    - [[~spawn~ and ~join~ - 461][~spawn~ and ~join~ - 461]]
    - [[Error Handling Across Threads - 463][Error Handling Across Threads - 463]]
    - [[Sharing Immutable Data Across Threads - 464][Sharing Immutable Data Across Threads - 464]]
    - [[Rayon - 466][Rayon - 466]]
    - [[Revisiting the Mandelbrot Set - 468][Revisiting the Mandelbrot Set - 468]]
  - [[Channels - 470][Channels - 470]]
    - [[Sending Values - 472][Sending Values - 472]]
    - [[Receiving Values - 475][Receiving Values - 475]]
    - [[Running the Pipeline - 476][Running the Pipeline - 476]]
    - [[Channel Features and Performance - 478][Channel Features and Performance - 478]]
    - [[Thread Safety: Send and Sync - 479][Thread Safety: Send and Sync - 479]]
    - [[Piping Almost Any Iterator to a Channel - 482][Piping Almost Any Iterator to a Channel - 482]]
    - [[Beyond Pipelines - 483][Beyond Pipelines - 483]]
  - [[Shared Mutable State - 484][Shared Mutable State - 484]]
    - [[What Is a Mutex? - 484][What Is a Mutex? - 484]]
    - [[~Mutex<T>~ - 486][~Mutex<T>~ - 486]]
    - [[mut and Mutex - 488][mut and Mutex - 488]]
    - [[Why Mutexes Are Not Always a Good Idea - 488][Why Mutexes Are Not Always a Good Idea - 488]]
    - [[Deadlock - 489][Deadlock - 489]]
    - [[Poisoned Mutexes - 490][Poisoned Mutexes - 490]]
    - [[Multi-producer Channels Using Mutexes - 490][Multi-producer Channels Using Mutexes - 490]]
    - [[Read/Write Locks (~RwLock<T>~) - 491][Read/Write Locks (~RwLock<T>~) - 491]]
    - [[Condition Variables (Condvar) - 493][Condition Variables (Condvar) - 493]]
    - [[Atomics - 494][Atomics - 494]]
    - [[Global Variables - 496][Global Variables - 496]]
  - [[What Hacking Concurrent Code in Rust Is Like - 497][What Hacking Concurrent Code in Rust Is Like - 497]]
- [[20. Macros - 499][20. Macros - 499]]
  - [[Macro Basics - 500][Macro Basics - 500]]
    - [[Basics of Macro Expansion - 501][Basics of Macro Expansion - 501]]
    - [[Unintended Consequences - 503][Unintended Consequences - 503]]
    - [[Repetition - 505][Repetition - 505]]
  - [[Built-In Macros - 507][Built-In Macros - 507]]
  - [[Debugging Macros - 508][Debugging Macros - 508]]
  - [[The ~json!~ Macro - 509][The ~json!~ Macro - 509]]
    - [[Fragment Types - 510][Fragment Types - 510]]
    - [[Recursion in Macros - 513][Recursion in Macros - 513]]
    - [[Using Traits with Macros - 514][Using Traits with Macros - 514]]
    - [[Scoping and Hygiene - 516][Scoping and Hygiene - 516]]
    - [[Importing and Exporting Macros - 519][Importing and Exporting Macros - 519]]
  - [[Avoiding Syntax Errors During Matching - 521][Avoiding Syntax Errors During Matching - 521]]
  - [[Beyond ~macro_rules!~ - 522][Beyond ~macro_rules!~ - 522]]
- [[21. Unsafe Code - 525][21. Unsafe Code - 525]]
  - [[Unsafe from What? - 526][Unsafe from What? - 526]]
  - [[Unsafe Blocks - 527][Unsafe Blocks - 527]]
    - [[Example: An Efficient ASCII String Type - 529][Example: An Efficient ASCII String Type - 529]]
  - [[Unsafe Functions - 531][Unsafe Functions - 531]]
  - [[Unsafe Block or Unsafe Function? - 533][Unsafe Block or Unsafe Function? - 533]]
  - [[Undefined Behavior - 533][Undefined Behavior - 533]]
  - [[Unsafe Traits - 536][Unsafe Traits - 536]]
  - [[Raw Pointers - 538][Raw Pointers - 538]]
    - [[Dereferencing Raw Pointers Safely - 540][Dereferencing Raw Pointers Safely - 540]]
    - [[Example: ~RefWithFlag~ - 541][Example: ~RefWithFlag~ - 541]]
    - [[Nullable Pointers - 544][Nullable Pointers - 544]]
    - [[Type Sizes and Alignments - 544][Type Sizes and Alignments - 544]]
    - [[Pointer Arithmetic - 545][Pointer Arithmetic - 545]]
    - [[Moving into and out of Memory - 546][Moving into and out of Memory - 546]]
    - [[Example: ~GapBuffer~ - 550][Example: ~GapBuffer~ - 550]]
    - [[Panic Safety in Unsafe Code - 556][Panic Safety in Unsafe Code - 556]]
  - [[Foreign Functions: Calling C and C++ from Rust - 557][Foreign Functions: Calling C and C++ from Rust - 557]]
    - [[Finding Common Data Representations - 558][Finding Common Data Representations - 558]]
    - [[Declaring Foreign Functions and Variables - 561][Declaring Foreign Functions and Variables - 561]]
    - [[Using Functions from Libraries - 562][Using Functions from Libraries - 562]]
    - [[A Raw Interface to libgit2 - 566][A Raw Interface to libgit2 - 566]]
    - [[A Safe Interface to libgit2 - 572][A Safe Interface to libgit2 - 572]]
  - [[Conclusion - 583][Conclusion - 583]]
- [[Index - 585][Index - 585]]

* 1. Why Rust? - 1
  - Enter Rust:
    a *safe* (memory safety), *concurrent* (trustworthy concurrency) language
    with the *performance* of C and C++.

  - Rust shares the ambitions Bjarne Stroustrup articulates for C++ in his paper
    "Abstraction and the C++ Machine Model:"
    #+BEGIN_QUOTE
    In general, C++ implementations obey the *zero-overhead principle*:
    What you don't use, you don't pay for.

    And further: What you do use, you couldn't hand code any better.
    #+END_QUOTE

  - The key to meeting all these promises is Rust's novel system of /ownership/,
    /moves/, and /borrows/, checked at /compile time/ and carefully designed to
    complement Rust's flexible static type system.

  - Rust is able to prevent /data races/ at /compile time/.

  - In fact, Servo and Rust have grown up together, with Servo using the latest
    new language features, and Rust evolving based on feedback from Servo's
    developers.

** DONE Type Safety - 3
   CLOSED: [2018-05-19 Sat 14:21]
   =TODO= =NOTE=

* TODO 2. A Tour of Rust - 7 -- =Reading=
  - In this chapter we'll look at several short programs to see _HOW_ Rust's
    + syntax
    + types
    + semantics

    fit together to support

    + safe
    + concurrent
    + efficient

    code.

** DONE Downloading and installing Rust - 7
   CLOSED: [2018-05-31 Thu 14:13]
   - The recommend way is to use the tool *rustup*.

   - Once you finish the installation, you have *three* new commands:
     + *cargo* :: The Rust's tool as
       * _compilation manager_
       * _package manager_
       * _general-purpose_

       You can use it to
       + _start a new project_
       + _build_ and _run_ your program,
       + _manage any external libraries_ your code depends on.

     + *rustc* :: Rust's compiler. Usually we let Cargo invoke the compiler for
                  us.

     + *rustdoc* :: Rust documentation tool. Like *rustc*, we usually let Cargo
                    run *rustdoc* for us.

   - Example:
     ~cargo new --bin hello~
     Create a new package directory named =hello=, and the =--bin= flag directs
     Cargo to prepare this as an /executable/, not a /library/.

     + Inside the =hello= directory is by default initalized as a /git repository/
       (with a =.gitignore= file), you have =Cargo.toml= and the =src= folder.

     + You can record the /dependencies/ of your package in the =Cargo.toml= file,
       and Cargo will take care of downloading, building, and updating those
       libraries for us.
       =TODO= Cover the =Cargo.toml= file in detail in Chapter 8.

   - ~cargo --vcs none [other flags and their values]~
     Tell Cargo to skip the step of initalized your package as a git
     repository.

   - ~cargo run~
     _build_ and _run_ your program.

   - Cargo places the executable in the =target= subdirectory at the top of the
     package.
       You can check the =target/debug= directory, and the executable is inside
     named as =hello=.

   - ~cargo clean~
     clean up the generated files

** DONE A Simple Function - 10
   CLOSED: [2018-05-31 Thu 15:06]
   - Example (Euclid's algorithm):
     #+BEGIN_SRC rust
       fn gcd(mut n: u64, mut m: u64) -> u64 {
           assert!(n != 0 && m != 0);

           while m != 0 {
               if m < n {
                   let t = m;
                   m = n;
                   n = t;
               }
               m = m % n;
           }
           n
       }
     #+END_SRC

   - =From Jian=
     I don't like the usage of ~assert!~ in the above example code!
     If should use something like ~require!~, which is a better word for
     precondition check!

   - UNLIKE C/C++, Rust's ~assert!~ CANNOT be skipped in all cases!

     There is a ~debug_assert!~ macro do the similar thing, but it can be
     skipped when the program is compiled for speed.

** DONE Writing and Running Unit Tests - 11
   CLOSED: [2018-05-31 Thu 15:51]
   - Example:
     #+BEGIN_SRC rust
       #[test]
       fn test_gcd() {
           assert_eq!(gcd(14, 15), 1);
           assert_eq!(gcd(2 * 3 * 5 * 11 * 17,
                          3 * 7 * 11 * 13 * 19),
                      3 * 11);
       }
     #+END_SRC

   - The ~#[test]~ atop the definition marks ~test_gcd~ as a test function, to be
     _skipped in normal compilations_,
     but included and called automatically if we run our program with the ~cargo
     test~ command.

   - The /tests/ can be scatter in throughout our source tree.

   - The ~#[test]~ is an example of an /attribute/.

   - /Attributes/ are an open-ended system for *marking* functions and other
     declarations with _extra information_, like /attributes/ in C++ and C#, or
     /annotations/ in Java.

     They're used to control
     + compiler warnings
     + code style checks
     + include code conditionally (like ~#ifdef~ in C and C++)
     + tell Rust how to interact with code written in other languages, and so on.

     We'll see more examples of /attributes/ as we go.

** DONE Handling Command-Line Arguments - 12
   CLOSED: [2018-05-31 Thu 16:42]
   Example:
   #+BEGIN_SRC rust
     use std::io::Write;
     use std::str::FromStr;
     fn main() {
         let mut numbers = Vec::new();

         for arg in std::env::args().skip(1) {
             numbers.push(u64::from_str(&arg)
                          .expect("error parsing argument"));
         }

         if numbers.len() == 0 {
             writeln!(std::io::stderr(), "Usage: gcd NUMBER ...").unwrap();
             std::process::exit(1);
         }

         let mut d = numbers[0];
         for m in &numbers[1..] {
             d = gcd(d, *m);
         }

         println!("The greatest common divisor of {:?} is {}",
                  numbers, d);
     }
   #+END_SRC

   Let's take it piece by piece:
   - The ~use~ lines:
     The ~use~ /declarations/ bring the two /traits/ ~Write~ and ~FromStr~ into scope.

     + =TODO= We'll cover ~traits~ in detail in Chapter 11, but for now we'll
       simply say that a /trait/ is a collection of /methods/ that /types/ can
       implement.

     + Although we never use the names ~Write~ or ~FromStr~ elsewhere in the program,
       a /trait/ _MUST be in scope_ in order to use its /methods/.

       In the present case:
       * Any type that implements the ~Write~ /trait/ has a ~write_fmt~ /method/ that
         *writes* _formatted text_ to a /stream/.

         The ~std::io::Stderr~ type implements ~Write~, and we'll use the
         ~writeln!~ /macro/ to print error messages; that /macro/ expands to
         code that uses the ~write_fmt~ /method/.

       * Any type that implements the ~FromStr~ /trait/ has a ~from_str~ /method/
         that tries to *parse* a value of that type from a string. The ~u64~ type
         implements ~FromStr~, and we'll call ~u64::from_str~ to parse our
         command-line arguments.

   - ~let mut numbers = Vec::new();~
     Even though /vectors/ are designed to be grown and shrunk dynamically, we must
     still mark the variable ~mut~ for Rust to let us push numbers onto the end
     of it.

     =IMPORTANT= =???=
     =From Jian= ~mut~ here is used to manage the _content_ of the vector
     ~numbers~, rather the the reference saved in ~numbers~!
     *This is different from most of the other languages!*

   - The ~for arg in std::env::args().skip(1)~ block: 
     + The ~std::env::args()~ returns an /iterator/.

       * =En=:
         ubiquitous

       * Rust's /iterators/ are very _EFFICIENT_:
         the compiler is usually able to *translate* them into the same code as
         a handwritten loop.
         =TODO= HOW in Chapter 15

     + The ~numbers.push(u64::from_str(&arg).expect("error parsing argument"));~ line:
       * The ~from_str~ function does NOT return a ~u64~ directly, but rather a
         ~Result~ value that indicates whether the parse succeeded or failed.
         - A ~Result~ value can be one of two variants:
           + ~Ok(v)~

           + ~Err(e)~

         - UNLIKE most modern languages, Rust does NOT have /exceptions/:
           all /errors/ are handled using either ~Result~ or /panic/, as
           outlined in Chapter 7. =TODO=

         - Check the success of our parse by using ~Result~'s ~expect~ /method/.
           + If the result is some ~Err(e)~, ~expect~
             1. _prints_ a message that includes a description of ~e~
             2. _exits the program immediately_.
           + If the result is ~Ok(v)~, ~expect~ simply returns ~v~ itself.

   - The ~if numbers.len() == 0~ block:
     + The ~.unwrap()~ call is a terse way to _check_ that the attempt to print
       the error message _did not itself fail_; an ~expect~ call would work too,
       but that's probably not worth it.

     + Simple introduction to the /ownership/ and /borrow/ ...

   - _UNLIKE_ C and C++, which require ~main~ to
     + return zero if the program finished successfully
       or

     + a /nonzero exit status/ if something went wrong,

     Rust assumes that if ~main~ returns at all, the program finished
     successfully. _ONLY_ by *EXPLICITLY calling* functions like ~expect~ or
     ~std::process::exit~ can we cause the program to terminate with an /error
     status code/.

   - Check the standard library documentation in your browser with the command
     ~rustup doc --std~

** DONE A Simple Web Server - 17 =TODO= =NOTE=
   CLOSED: [2018-06-01 Fri 21:08]
   - crate :: A Rust package, whether a library or an executable.

   - To show how this works, we'll put together a *simple web server* using the
     /iron web framework/, the hyper HTTP server, and various other /crates/ on
     which they depend.

     + As shown in Figure 2-1, our website will prompt the user for two numbers,
       and compute their greatest common divisor.

   - =Cargo.toml=
     #+BEGIN_SRC toml
       [package]
       name = "iron-gcd"
       version = "0.1.0"
       authors = ["You <you@example.com>"]

       [dependencies]
       iron = "0.5.1"
       mime = "0.2.3"
       router = "0.5.1"
       urlencoded = "0.5.0"
     #+END_SRC

   - The basic version (incomplete!):
     #+BEGIN_SRC rust
       extern crate iron;
       #[macro_use] extern crate mime;

       use iron::prelude::*;
       use iron::status;

       fn main() {
           println!("Serving on http://localhost:3000...");
           Iron::new(get_form).http("localhost:3000").unwrap();
       }

       fn get_form(_request: &mut Request) -> IronResult<Response> {
           let mut response = Response::new();

           response.set_mut(status::Ok);
           response.set_mut(mime!(Text/Html; Charset=Utf8));
           response.set_mut(r#"
               <title>GCD Calculator</title>
               <form action="/gcd" method="post">
                 <input type="text" name="n"/>
                 <input type="text" name="n"/>
                 <button type="submit">Compute GCD</button>
               </form>
           "#);

           Ok(response)
       }
     #+END_SRC
     + The ~#[macro_use]~ /attribute/ alters Rust that we plan to use /macros/
       *exported* by this /crate/.

     + Use ~*~ to import all the public names of a /module/ is often NOT a good
       idea, but for a module named ~prelude~, which by convention provides
       general facilities that any user of the /crate/ will probably need. In
       this case, a wildcard ~use~ directive makes a bit more sense.

     + =TODO= NOTES =TODO=

   - =TODO= NOTES =TODO=
   - =TODO= NOTES =TODO=
   - =TODO= NOTES =TODO=

** TODO Concurrency - 23
*** TODO What the Mandelbrot Set Actually Is - 24
*** TODO Parsing Pair Command-Line Arguments - 28
*** TODO Mapping from Pixels to Complex Numbers - 31
*** TODO Plotting the Set - 32
*** TODO Writing Image Files - 34
*** TODO A Concurrent Mandelbrot Program - 35
*** TODO Running the Mandelbrot Plotter - 40
*** TODO Safety Is Invisible - 41

* DONE 3. Basic types - 43
  CLOSED: [2018-05-22 Tue 09:03]
  - Rust's types serve several goals:
    + Safety
    + Efficiency
    + Concision

  - =TODO= NOTE 

** DONE Machine Types - 46
   CLOSED: [2018-05-20 Sun 21:28]
   |  Size (bits) | Unsigned integer | Signed integer | Floating-point |
   |--------------+------------------+----------------+----------------|
   |            8 | ~u8~             | ~8~            |                |
   |           16 | ~u16~            | ~i16~          |                |
   |           32 | ~u32~            | ~i32~          | ~f32~          |
   |           64 | ~u64~            | ~i64~          | ~f64~          |
   | Machine word | ~usize~          | ~isize~        |                |

   - The /machine word/ is a value the size of an address on the machine the code
     runs one,  _usually_ (=???=) 32 bits or 64 bits, which depends on the
     target machine.

*** DONE Integer Types - 47
    CLOSED: [2018-05-19 Sat 02:47]
    - *UNLIKE* C and C++,
      Rust treats /characters/ as _distinct_ from the /numeric types/.
      Read "Characters" on Page 52.

    - ~usize~ are analogous to ~size_t~ in C/C++.

    - ~isize~ are analogous to ~ptrdiff_t~ in C/C++.

    - Rust requires /array indices/ to be ~usize~.

    - Values representing
      + the sizes of arrays or vectors

      + the counts of the number of elements in some data structure

      also generally have the ~usize~ type.

    - In /debug build/, Rust compiler checks for integer overflow in arithmetic:
      #+BEGIN_SRC rust
        let big_val = std::i32::MAX;
        let x = big_val + 1;  // panic: arithmetic operation overflowed
      #+END_SRC

    - In /release build/, this addition would wrap to a negative number
      (*UNLIKE* C++, where signed integer overflow is _undefined_ behavior).

      However, it is still a bad to do this operation if you don't want to give
      up forever.

      + Solution: Explicitly tell the compiler that you really know what you do!
        ~let x = big_val.wrapping_add(1);  // ok~

    - /Integer literals/ in Rust can take suffix indicating their type.
      For instance, ~42u8~ and ~1729isize~

      If you don't the /inference/ can satisfy what you want, you can use this
      way to indicate type manually.

    - /Inference/ usually identifies a unique type,
      BUT sometimes any one of several types would work. In this case, Rust
      defaults to ~i32~, if that is among the possibilities. Otherwise, report
      the ambiguity as an error!

    - The radix prefixes of /Integer literals/: ~0x~, ~0o~, and ~0b~.

    - You can insert _underscore_ to make long numbers more legible.
      For instance, ~4_294_967_295~.
        The positions of the _underscore_ is *FLEXIBLE* -- it's designed for
      human, NOT for the compiler! For instance, ~0xfff_ffff~, or ~127_u8~.

    - /Byte literals/    ~b'a'~
      =TODO=

    - Convert from one integer type to another integer type with the ~as~
      operator. For instance, ~10_i8 as u16~

      + =TODO= MORE Details =TODO= =NOTE=

    - /Integers/, like any other sort of value, _can have /methods/._
      Check the standard library documents. For instance, ~std::i32~

*** DONE Floating-Point Types - 50
    CLOSED: [2018-05-20 Sun 21:28]
    - Rust provides
      + IEEE single-precision floating type ~f32~:
        * at least *6* decimal digits
        * Roughly -3.4 \times{} 10^{38} to +3.4 \times{} 10^{38}

      + IEEE double-precision floating type ~f64~:
        * at least *15* decimal digits
        * Roughly -1.8 \times{} 10^{308} to +1.8 \times{} 10^{308}

    - Following the IEEE 754-2008 specification,
      these types include
      + _positive and negative *infinities*,_
      + *distinct* _positive and negative *zero values*,_
      + a *not-a-number value*

    - Rust's ~f32~ and ~f64~ correspond to
      + the ~float~ and ~double~ types in C and C++ implementations that _support_
        IEEE floating point;

      + Java, which _always_ uses IEEE floating point.

    - Example for the /floating-point literals/:
      ~3.1415.926e-4f64~

      + Every part of a floating-point number after the _integer part_ is OPTIONAL,
        but *at least one of* the _fractional part_, _exponent_, or _type suffix_
        *must* be present, to _distinguish_ it from an /integer literal/.

      + ~5.~ is a valid floating-point constant.

      + The default type is ~f64~, if both would be possible,
        which is similar as C/C++/Java.

    - You can add _underscore_ to the _fractional part_.

    - The ~std::f32~ and ~std::f64~ modules define constants for the IEEE-required
      special values like ~INFINITY~, ~NEG_INFINITY~, ~NAN~, and ~MIN~ and ~MAX~
      (the largest and smallest finite values).

    - The ~std::f32::consts~ and ~std::f64::consts~ modules provide various commonly
      used mathematical constants like ~E~, ~PI~, and _the square root of two_.

    - The ~f32~ and ~f64~ types provide a FULL COMPLEMENT of /methods/ for mathematical
      calculations; for example, ~3f64.sqrt()~.

    - The ~type suffix~ is often not required, but when the context is _not clear_,
      you need to write them down:
      ~println!("{}", (2.0).sqrt());~ is non-compilable!

      The correct version can be one of
      + ~println!("{}", (2.0_f64).sqrt());~ or with ~f32~
      + ~println!("{}", f64::sqrt(2.0));~ or with ~f32~

    - You shouldn't expect any implicity conversion for these non collectiontypes
      in Rust.

*** DONE The ~bool~ Type - 51
    CLOSED: [2018-05-19 Sat 02:51]
    - ~as~ can be used to convert ~bool~ values to ~integer~ types:
      #+BEGIN_SRC rust
        assert_eq!(false as i32, 0);
        assert_eq!(true as i32, 1);
      #+END_SRC
      However, you CANNOT convert in the other direction.

    - The info of a ~bool~ value can be saved in a single bit,
      HOWEVER, Rust use an entire byte for a ~bool~ value in memory, so you can
      create a /pointer/ to it.

*** DONE Characters - 52
    CLOSED: [2018-05-19 Sat 12:00]
    - Character (Rust's) :: ~char~ represents a single Unicode character, as a
         32-bit value.

    - Rust uses the char type for single characters in isolation,

      BUT
      Rust uses the /UTF-8 encoding/ for /strings/ and /streams/ of text.

      So,
      a String represents its text as a sequence of UTF-8 bytes, *NOT* as an array
      of ~char~.

    - If you prefer, you can write out a character's /Unicode code point/ in
      hexadecimal:
      + If a /code point/ is in the range U+0000 to U+007F, which is drawn from
        the ASCII character set, can write the character as ~'\xHH'~, where =HH=
        is a two digit hexadecimal number.

      + You can write any Unicode character as ~'\u{HHHHHH}'~, where =HHHHHH= is
        a hexadecimal number between one and six digits long.

    - A ~char~ *ALWAYS* holds a /Unicode code point/ in the range
      + from 0x0000 to 0xD7FF
        OR
      + from 0xE000 to 0x10FFFF

      A ~char~ is *NEVER* a surrogate pair half (from 0xD800 to 0xDFFF), or a
      value outside the Unicode codespace, that is, greater than 0x10FFFF.

    - Conversions:
      Rust *Never Implicitly* converts between ~char~ and any other type.

      + ~char~ --> integer numbers
        Do the *explicit conversion* with ~as~.

      + integer numbers --> ~char~
        * If you do this directly with ~as~, you can only from ~u8~ to ~char~
          - Rationale:
            *Rust intends the ~as~ operator to perform _ONLY_ cheap, infallible
            conversions*,
            BUT
            every integer type _other than_ ~u8~ includes values that are not
            permitted Unicode code points, so those conversions would _require
            runtime checks_.

        * You can use ~std::char::from_u32~, and take any ~u32~ value and returns
          an ~Option<char>~.

    - Check the ~std::char~ to learn more useful methods.
      For instance,
      #+BEGIN_SRC rust
        assert_eq!('*'.is_alphabetic(), false);
        assert_eq!('β'.is_alphabetic(), true);
        assert_eq!('8'.to_digit(10), Some(8));
        assert_eq!('ಠ'.len_utf8(), 3);
        assert_eq!(std::char::from_digit(2, 10), Some('2'));
      #+END_SRC

    - Single /characters/ are not very interesting as /strings/ and /streams/.
      =TODO= "String Types" on page 64.

** DONE Tuples - 54
   CLOSED: [2018-05-19 Sat 12:45]
   - For example,
     ~("Brazil", 1985)~ is a tuple fo type ~(&str, i32)~ (or whatever integer
     type, within a proper context, Rust infers from ~1985~).

   - You can access the elememnts of a /tuple/ ~t~ with ~t.0~, ~t.1~, and so on.

   - unit type :: it is an /empty tuple/, ~()~.

   - Since there is only one value for this type, /unit type/ is written as ~()~. 
     It is used as the return type of functions with only side-effect.

   - Rust consistently permits an *extra trailing comma* everywhere commas are
     used: /function arguments/, /arrays/, /struct/ and /enum/ definitions, and
     so on. For instance, ~("Brazil", 1985)~ and ~("Brazil", 1985,)~ are
     equivalent.

     + *Rationale*:
       This may look odd to human readers, but it can make diffs easier to read
       when entries are added and removed at the end of a list.

   - *UNLIKE* Scala, Rust support /single element tuple/, though the syntax is a
     little wierd! For instance, ~("lonely hearts",)~ is a /single element tuple/
     of type ~(&str,)~. Here the ~,~ in both /value/ and /type/ are mandatory!
     =IMPORTANT=

     =TODO= =???=
     =From Jian= Why do we need /single element tuple/??? Scala has proved that
     /single element tuple/ is NOT useful -- there are always ways to use other
     techniques, and not redundant!

** DONE Pointer types - 55
   CLOSED: [2018-05-19 Sat 13:26]
   - Rust has _SEVERAL_ /types/ that represent memory addresses.

   - We'll discuss *three* /pointer types/ here:
     + /references/
     + /boxes/
     + /unsafe pointers/

*** DONE References - 56
    CLOSED: [2018-05-19 Sat 13:18]
    - For instance, ~&String~ (pronounced "ref String") and ~&i32~ (pronounced
      "ref 32 bit int(eger)").

    - It's easiest to get started by thinking of /references/ as Rust's _BASIC
      pointer type_ -- A /reference/ can point to ANY /value/ ANYWHERE, /stack/
      or /heap/.

    - Rust has ~&~ and ~*~ for /reference/ related operations.
      They are very much like the ~&~ and ~*~ operators in C and C++.

      + The expression ~&x~ produces a reference to ~x~; in Rust terminology, we
        say that it /borrows/ a reference to ~x~.

      + Given a reference ~r~, the expression ~*r~ refers to the value ~r~ points
        to.

    - *LIKE* the ~&~ and ~*~ operators in C and C++, a /reference/ does *NOT*
      automatically free any resources when it goes out of scope.

    - *UNLIKE* the /pointers/ in C/C++, Rust references are *NEVER null*:
      there is simply *no way* to produce a /null reference/ in /safe Rust/.

    - Immutable reference :: ~&T~, like ~const *T~ in C.

    - Mutable reference :: ~&mut T~, like ~*T~ in C.

    - Another major difference is that Rust tracks the /ownership/ and
      /lifetimes/ of values, so mistakes like /dangling pointers/, /double
      frees/, and /pointer invalidation/ are *ruled out at compile time*.
      =TODO=
      Chapter 5 explains Rust’s rules for safe reference use.

*** DONE Boxes - 56
    CLOSED: [2018-05-19 Sat 13:21]
    The simplest way to *allocate* a value in the /heap/ is to use ~Box::new~:
    #+BEGIN_SRC rust
      let t = (12, "eggs");  // (i32, &str)
      let b = Box::new(t);   // Box<(i32, &str)>
    #+END_SRC

    When ~b~ _goes out of scope_, the memory is freed immediately,
    UNLESS ~b~ has been /moved/ -- by returning it, for example. =TODO=
    =TODO= Chpater 4

*** DONE Raw Pointers - 57
    CLOSED: [2018-05-19 Sat 13:26]
    - Rust also has the /raw pointer types/ ~*mut T~ and ~*const T~.
      /Raw pointers/ really are just *LIKE* pointers in C++.

    - Using a /raw pointer/ is *UNSAFE*, because Rust makes no effort to track
      what it points to. For example,
      + /raw pointers/ may be null
        OR
      + they may point to memory that has been freed
        OR
      + they may point to memory that now contains a value of a different type.

       All the classic pointer mistakes of C++ are offered for your enjoyment.

      However, you may *ONLY* _dereference_ /raw pointers/ within an ~unsafe~
      block.

    - ~unsafe~ block :: is Rust's opt-in mechanism for advanced language features
                        whose safety is up to you.

    - If your code has _NO_ ~unsafe~ blocks (or if those it does have are written
      correctly), then the safety guarantees we emphasize throughout this book still hold.
      =TODO=
      For details, see Chapter 21.

** DONE Arrays, Vectors, and Slices - 57
   CLOSED: [2018-05-20 Sun 21:05]
   - Rust has *three* types for representing a _sequence of values_ in memory:
     + ~[T; N]~ 
       An /array/ of ~N~ values, each of type ~T~.
       ~N~ must be known at compile time, which cannot be modified.

     + ~Vec<T>~
       A /vector/ of ~T~'s, which is a _dynamically allocated_, _growable_
       sequence of values of type ~T~. Since its elements live on the /heap/, so
       you can _resize_ /vectors/ at will.

     + ~&[T]~ and ~&mut [T]~, called a /shared slice of ~T~'s/ and /mutable slice
       of ~T~'s/.

       You can think of a /slice/ as a /pointer/ to its first element, together
       with a _count_ of the number of elements you can access starting at that
       point.

       * A /mutable slice/ ~&mut [T]~ lets you read and modify elements, but
         *CANNOT be shared*;

       * a /shared slice/ ~&[T]~ lets you *share access* among several readers,
         but does *NOT let you MODIFY elements*.

   - These types all have the ~len~ /method/.
     They all use the SYNTAX ~v[i]~ to index elements.
     ~i~ must be ~usize~.
     Out of bound indexing will lead to a /panic/.

*** DONE Arrays - 58
    CLOSED: [2018-05-19 Sat 13:48]
    - SYNTAX:
      + Basic: ~let lazy_caterer: [u32; 6] = [1, 2, 4, 7, 11, 16];~
      + Fill in N same values: ~[true; 10000]~ creates an array of 10000 ~bool~'s

    - Rust has *NO* notation for an /uninitialized array/. (In general, Rust
      _ensures_ that code can _NEVER_ access any sort of /uninitialized value/.)

    - Rust /arrays/ doesn't have /methods/ like iterating over elements,
      searching, sorting, filling, filtering ,and so on. They are /methods/ of
      /slices/.

      However, Rust implicitly coverts a /reference/ to an array to a /slice/
      when searching for /methods/, so _you can call any /slice/ /method/ on an
      /array/ DIRECTLY._ For example,
      #+BEGIN_SRC rust
        let mut chaos = [3, 5, 4, 1, 2];
        chaos.sort();
        assert_eq!(chaos, [1, 2, 3, 4, 5]);
      #+END_SRC

    - In fact, even the ~len~ /method/ is a /slice/ only /method/.

    - =TODO= "Slices" on page 62.

*** DONE Vectors - 59
    CLOSED: [2018-05-20 Sun 20:25]
    - SYNTAX (Type):
      ~Vec<T>~

    - vector :: resizable array, which is allocated on the /heap/.

    - The ~vec!~ /macro/ is used to create /vecotr literal/:
      For instance,
      #+BEGIN_SRC rust
        let mut v = vec![2 ,3 ,5, 7];
        assert_eq!(v.iter().fold(1, |a, b| a * b), 210);
      #+END_SRC

    - Add an element: ~v.push(11);~

    - Fill in a /vector/ with a value (the syntax is similar to that of
      /arrays/): ~vec![0; rows * cols]~

    - If you want an empty /vector/ and then push elements into it, use the
      ~Vec::new~ method, which is the same as ~vec![]~.
      #+BEGIN_SRC rust
        let mut v = Vec::new();
        v.push("step");
        v.push("on");
        v.push("no");
        v.push("pets");
        assert_eq!(v, vec!["step", "on", "no", "pets"]);
      #+END_SRC

    - Build a /vector/ from the values produced by an /iterator/:
      #+BEGIN_SRC rust
        let v: Vec<i32> = (0..5).collect();
        assert_eq!(v, [0, 1, 2, 3, 4]);
      #+END_SRC
      The type ~Vec<i32>~ here is required, or the ~collect~ method doesn't know
      the type of the value it will generate.

    - As with /arrays/, you can use /slice methods/ on /vectors/:
      #+BEGIN_SRC rust
        // palindrome!
        let mut v = vec!["a man", "a plan", "a canal", "panama"];
        v.reverse();
        // Reasonable yet disappointing:
        assert_eq!(v, vec!["panama", "a canal", "a plan", "a man"]);
      #+END_SRC
      + Here, the ~reverse~ /method/ is actually defined on /slices/, but the
        call *implicitly borrows* a ~&mut [&str]~ /slice/ from the /vector/, and
        invokes ~reverse~ on that.

    - A ~Vec<T>~ consists of *three* values:
      + a /pointer/ to the heap-allocated buffer allocated to hold the elements;

      + the /number of elements/ that buffer has the capacity to store;
        =From Jian= the ~capacity~ /method/

      + the /number it actually contains now/ (in other words, its length).
        =From Jian= the ~len~ /method/

    - When the buffer has reached its capacity, adding another element to the
      /vector/ entails
      1. *allocating* a larger buffer

      2. *copying* the present contents into it

      3. *updating* the vector's /pointer/ and /capacity/ to describe the new
         buffer
         + capacity :: the buffer it can hold without reallocation.

      4. finally *freeing* the old one.

    - Create a vector with specified /capacity/, and observe its change after
      pushing some elements into it:
      #+BEGIN_SRC rust
        let mut v = Vec::with_capacity(2);
        assert_eq!(v.len(), 0);
        assert_eq!(v.capacity(), 2);

        v.push(1);
        v.push(2);
        assert_eq!(v.len(), 2);
        assert_eq!(v.capacity(), 2);

        v.push(3);
        assert_eq!(v.len(), 3);
        assert_eq!(v.capacity(), 4);
      #+END_SRC
      For the last part above, the /capacity/ you see in your system may be
      _different_.

    - ~insert~ and ~remove~
      #+BEGIN_SRC rust
        let mut v = vec![10, 20, 30, 40, 50];

        v.insert(3, 35);
        assert_eq!(v, [10, 20, 30, 35, 40, 50]);

        v.insert(1);
        assert_eq!(v, [10, 30, 35, 40, 50]);
      #+END_SRC

    - ~pop~
      #+BEGIN_SRC rust
        let mut v = vec!["carmen", "miranda"];
        assert_eq!(v.pop(), Some("miranda"));
        assert_eq!(v.pop(), Some("carmen"));
        assert_eq!(v.pop(), None);
      #+END_SRC

    - Iterate over a /vector/ with ~for~:
      #+BEGIN_SRC rust
        let languages: Vec<String> = std::env::args().skip(1).collect();
        for l in languages {
            println!("{}: {}", l,
                     if l.len() % 2 == 0 {
                         "functional"
                     } else {
                         "imperative"
                     });
        }
        // cargo run Lisp Scheme C C++ Fortran
      #+END_SRC

    - ~Vec~ is an ordinary type defined in Rust,
      NOT built into the language.

      =TODO= Chapter 21 covers how to implement such types

*** TODO Building Vectors Element by Element - 62
    - =TODO= NOTE
      Reasoning and Justify!
      =TODO=

    - If you can estimate the size of your /vector/, use the /method/
      ~Vec::with_capacity~ instead of ~Vec::new~.

      Of course, if you know the content of your /vector/, use ~vec!~.

*** DONE Slices - 62
    CLOSED: [2018-05-20 Sun 21:05]
    - /slice/ (~[T]~) :: a region of an array or vector.
      + Since a /slice/ can be any length, /slices/ *CANNOT* be stored directly
        in variables or passed as function arguments.

      + /Slices/ are _ALWAYS passed by /reference/._
          This is why we often call ~&[T]~'s or ~&str~'s a /slices/, but it is
        acutally /references to a slices/ -- /slices/ almost always appear
        behind /references/!

    - A /reference/ to a /slice/ is /a *fat* pointer/:
      a two-word value comprising
      + a /pointer/ to the /slice/'s first element
      + the number of elements in the /slice/.

    - Example:
      #+BEGIN_SRC rust
        let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];
        let a: [f64; 4] = [0.0, 0.707, 1.0, 0.707];

        let sv: &[f64] = &v;
        let sa: &[f64] = &a;
      #+END_SRC
      + Rust _automatically_ converts the ~&Vec<f64>~ /reference/ and the
        ~&[f64; 4]~ /reference/ to /slice references/ that point directly to the
        data.

    - An ORDINARY /reference/ is a non-owning pointer to _a single value_;
      An /reference/ to a /slice/ is a non-owning pointer to _several values_;

    - You can get a reference to a slice of an array or vector, or _a slice of an
      existing slice_, by indexing it with a range:
      #+BEGIN_SRC rust
        print(&v[0..2]);  // print the first two elements of v
        print(&a[2..]);   // print elements of a starting with a[2]
        print(&sv[1..3]); // print v[1] and v[2]
      #+END_SRC

** DONE String Types - 64
   CLOSED: [2018-05-22 Tue 09:03]
   - Rust has a similar design as C++: two string types
     + in C++, they are ~const char *~ and ~std::string~.

   - =TODO=
     More details in Chapter 17.

*** DONE String Literals - 64
    CLOSED: [2018-05-21 Mon 18:44]
    - SYNTAX: double quoted sequences of characters.

    - A string may span multiple lines:
      #+BEGIN_SRC rust
        println!("In the room the women come and go,
            Singing of Mount Abora");

        // In the room the women come and go,
        //     Singing of Mount Abora
      #+END_SRC
      The /newline character/, as well as the /spaces/ _at the begining of the
      second line_ are included in this /string literal/.

    - If one line of a string ends with a _backslash_,
      then the /newline character/ and the _leading whitespace_ on the next line
      are dropped:
      #+BEGIN_SRC rust
        println!("It was a bright, cold day in April, and \
                  there were four of us-\
                  more or less.");

        // It was a bright, cold day in April, and there were four of us-more or less.
      #+END_SRC

    - /Raw string/ can reduce the double backslashes in some strings (e.g. Windows
      pathes and regular expressions):

      All backslashes and whitespace characters inside a /raw string/ are included
      _verbatim_ in the string. *No escape sequences are reconized.*
      #+BEGIN_SRC rust
        let default_win_install_path = r"C:\Program Files\Gorillas";
        let pattern = Regex::new(r"\d+(\.\d+)*");
      #+END_SRC

      + You *CANNOT* include a double-quote character in a /raw string/ SIMPLY BY
        putting a backslash in front of it.

        * Solution: Use pound signs with /raw string/:
          #+BEGIN_SRC rust
            println!(r###"
                This raw string started with 'r###"'.
                Therefore it does not end until we reach a quote mark ('"')
                followed immediately by three pound signs ('###'):
            "###)
          #+END_SRC
          You can add as many pound signs as needed to make it clear where the
          /raw string/ ends.

*** DONE Byte Strings - 65
    CLOSED: [2018-05-21 Mon 21:45]
    - byte string :: a /string literal/ with the ~b~ prefix.

    - Such a /byte string/ is a /slice of ~u8~ (byte) values/ --
      rather than Unicode text.

    - It does NOT have any of the string methods we'll discuss in a minute.

      The most string-like thing about /byte strings/ is the syntax we used to
      write it.

    - Example,
      #+BEGIN_SRC rust
        let method = b"GET";
        assert_eq(method, &[b'G', b'E', b'T']);
      #+END_SRC
      + Here ~method~ is if type ~&[u8; 3]~

    - This combines with all the other string syntax we've shown:
      + span multiple lines

      + use escape sequences

      + use backslashes to join lines.

    - /raw byte string/ starts with ~br"~

    - /byte strings/ can only contains ASCII and =\xHH= escape sequences.

      You *CANNOT* save other Unicode characters in bytes to form /byte
      strings/.

    - ~&[u8; 3]~

    - Example:
      #+BEGIN_SRC rust
        let method = b"GET";  // &[u8; 3]
        assert_eq!(method, &[b'G', b'E', b'T']);
      #+END_SRC
      The type of ~method~ shown here is ~&[u8; 3]~:
      it's a reference to an /array/ of three bytes.
      =TODO= =???=
      It DOESN'T have any of the /string methods/ we'll discuss in a minute.
      The most string-like thing about it is the syntax we used to write it.

*** DONE Strings in Memory - 65
    CLOSED: [2018-05-21 Mon 23:10]
    - Rust /strings/ are sequences of Unicode characters,
      but they are NOT stored in memory as array of ~char~'s (UTF-16 in Rust).

      Instead, they are *stored using UTF-8*, a variable-width encoding.

    - Figure 3-3 shows the ~String~ and ~&str~ values created by the code:
      #+BEGIN_SRC rust
        let noodles: String = "noodles".to_string();
        let oodles: &str = &noodles[1..];
        let poodles: &str = "ಠ_ಠ";
      #+END_SRC
      + A ~String~ has a /resizable buffer/ holding UTF-8 text.
        The buffer is allocated on the /heap/.

        The implementation of ~String~:
        It uses a ~Vec<u8>~ to hold the data. This ~Vec<u8>~ is guaranteed to hold
        well-formed UTF-8.

      + A ~&str~, like other slice references, is a /fat pointer/, containing both
        * the address of the actual data

        * the length of this /slice/.

      + You can think of a ~&str~ as being nothing more than a ~&[u8]~ that is
        guaranteed to hold well-formed UTF-8.

      + A /string literal/ is a ~&str~ that refers to preallocated text, typically
        stored in read-only memory along with the program's machine code (=???=).
          In the preceding example, ~poodles~ is a /string literal/, pointing to
        seven bytes that are created when the program begins execution, and that
        last until it exits

    - A ~&str~ (pronounced "stir" or "string slice").

    - ~&str~'s ~len()~ /method/ returns its length in byte.
      ~&str~'s ~chars().count()~ returns the number of characters.

    - It is *IMPOSSIBLE* to modify a ~&str~.

        let mut s = "hello";
        s[0] = 'c';    // error: the type `str` cannot be mutably indexed
        s.push('\n');  // error: no method named `push` found for the `&str`
      #+END_SRC

    - Create new /strings/ at /run time/, use ~String~.

    - The type ~&mut str~ does exist, but it is *not very useful*, since almost
      any operation on UTF-8 can _CHANGE its *overall byte length*,_ and a /slice/
      *CANNOT reallocate* its referent.

      =From Jian= This means if you think you need ~&mut str~, you operation mustn't
      change it overall byte lenght, and you must justify your reasoning!!! In general,
      this is impossible.

        In fact, the only operations available on ~&mut str~ are ~make_ascii_uppercase~
      and ~make_ascii_lowercase~ , which modify the text in place and affect only
      /single-byte character/'s, by definition.

*** DONE String - 67
    CLOSED: [2018-05-21 Mon 23:23]
    - ~&str~ is very much like ~&[T]~: a /fat pointer/ to some data.

    - ~String~ is analogous to ~Vec<T>~:
      |                                                  | ~Vec<T>~            | ~String~            |
      |--------------------------------------------------+---------------------+---------------------|
      | Automatically frees buffers                      | Yes                 | Yes                 |
      | Growable                                         | Yes                 | Yes                 |
      | ~::new()~ and ~::with_capacity()~ static methods | Yes                 | Yes                 |
      | ~.reverse()~ and ~.capacity()~ methods           | Yes                 | Yes                 |
      | ~.push()~ and ~.pop()~ methods                   | Yes                 | Yes                 |
      | Range syntax ~v[start..stop]~                    | Yes, returns ~&[T]~ | Yes, returns ~&str~ |
      | Automatic conversion                             | ~&Vec<T>~ to ~&[T]~ | ~&String~ to ~&str~ |
      | Inherits methods                                 | From ~&[T]~         | From ~&str~         |

    - Like a ~Vec~,
      each ~String~ has its own /heap-allocated buffer/ that is _NOT shared_ with
      any other ~String~. When a ~String~ variable goes out of scope, the buffer
      is _automatically freed_, unless the ~String~ was /moved/.

    - There are several ways to create ~String~'s:
      + The ~.to_string()~ /method/ converts a ~&str~ to a ~String~.
        This *copies* the string:
        ~let error_message = "too many pets".to_string();~

      + The ~format!()~ macro works just like ~println!()~, except that
        * it returns a new ~String~ instead of writing text to /stdout/
        * it doesn't automatically add a new line at the end.
        #+BEGIN_SRC rust
          assert_eq!(format!("{}°{:02}′{:02}′′N", 24, 5, 23),
                     "24°05′23′′N".to_string());
        #+END_SRC

      + /Arrays/, /slices/, and /vectors/ of strings have two methods, ~.concat()~ and
        ~.join(sep)~, that form a new String from many strings.
        #+BEGIN_SRC rust
          let bits = vec!["veni", "vidi", "vici"];
          assert_eq!(bits.concat(), "venividivici");
          assert_eq!(bits.join(", "), "veni, vidi, vici");
        #+END_SRC

    - The choice sometimes arises of which type to use: ~&str~ or ~String~.
      =TODO=
      Chapter 5 addresses this question in detail.

      For now it will suffice to point out that a ~&str~ can refer to any /slice/
      of any /string/, whether it is a /string literal/ (stored in the executable)
      or a ~String~ (allocated and freed at run time).

      =IMPORTANT=
        This means that ~&str~ is more appropriate for /function arguments/ when
      the caller should be allowed to pass either kind of string.

*** DONE Using Strings - 68
    CLOSED: [2018-05-22 Tue 09:03]
    - /Strings/ support the ~==~ and ~!=~ operators.
      They are used to _compare their values_, rather than /address/ as in Java.
      ~assert!("ONE".to_lowercase() == "one");~

    - /Strings/ also support the comparison operators ~<~, ~<=~, ~>~, and ~>=~,
      as well as many useful methods and functions -- search "~str~ (primitive
      type)" or the "~std::str~" module (or just flip to Chapter 17). =TODO=
      Here are a few examples:
      #+BEGIN_SRC rust
        assert!("peanut".contains("nut"));
        assert_eq!("ಠ_ಠ".replace("ಠ", "■"), "■_■");
        assert_eq!("    clean\n".trim(), "clean");

        for word in "veni, vidi, vici".split(", ") {
            assert!(word.starts_with("v"));
        }
      #+END_SRC

    - Keep in mind that, you shouldn't belive in your eyes and the common sense in
      your language and culture!
      + Given the nature of Unicode, simple char-by-char comparison does not always
        give the expected answers -- differnt binary forms can have the same display!

        For example, the Rust strings ~"th\u{e9}"~ and ~"the\u{301}"~ are both
        valid Unicode representations for *thé*, the French word for tea.

      + Similarly, Rust's ordering operators like ~<~ use a simple /lexicographical
        order/ based on /character code point values/.
          This ordering only sometimes resembles the ordering used for text in the
        user's language and culture.

      =TODO=
      We discuss these issues in more detail in Chapter 17.

*** DONE Other String-Like Types - 68
    CLOSED: [2018-05-22 Tue 08:59]
    - Rust guarantees that strings are valid UTF-8.

    - Sometimes a program really needs to be able to deal with strings that are
      not valid Unicode.

      + Scenario:
        This usually happens when a Rust program has to interoperate with some
        other system that doesn't enforce any such rules.
          For example, in most OS's it's easy to create a file with a filename
        that isn't valid Unicode. What should happen when a Rust program comes
        across this sort of filename?

      + Rust's Solution is to offer a few string-like types for these situations:
        * Stick to ~String~ and ~&str~ for Unicode text.

        * When working with filenames, use ~std::path::PathBuf~ and ~&Path~ instead.

        * When working with binary data that isn't character data at all, use ~Vec<u8>~
          and ~&[u8]~.

        * When working with environment variable names and command-line arguments
          in the native form presented by the operating system, use ~OsString~ and
          ~&OsStr~.

        * When interoperating with C libraries that use null-terminated strings,
          use ~std::ffi::CString~ and ~&CStr~. =IMPORTANT=

** DONE Beyond the basics - 69
   CLOSED: [2018-05-20 Sun 21:30]
   - There are *three* kinds of /user-defined types/, and we'll cover them in
     three successive chapters:
     + ~struct~'s in Chapter 9;
     + ~enum~'s in Chapter 10;
     + ~trait~'s in Chapter 11.

   - /Functions/ and /closures/ have their own types, covered in Chapter 14.

   - The types that make up the standard library are covered throughout the book.
     For example, Chapter 16 presents _the standard collection types_.

* DONE 4. Ownership - 71
  CLOSED: [2018-05-22 Tue 14:50]
** DONE Ownership - 73 =TODO= =NOTE=
   CLOSED: [2018-05-22 Tue 14:50]
   - Rust makes the following pair of promises, both essential to a safe systems
     programming language:
     + You decide the /lifetime/ of each value in your program.
       Rust frees memory and other resources belonging to a value promptly, at a
       point under your control.

     + Even so, your program will *NEVER* use a pointer to an object after it has
       been freed.
       * Using a dangling pointer is a common mistake in C and C++:
         - if you're lucky, your program crashes.
         - if you’re unlucky, your program has a security hole.

       Rust catches these mistakes at /compile time/.

   - =EN= culprit
   - =EN= relinquish control
   - =EN= wager

   - =NOTE=

** DONE Moves - 77
   CLOSED: [2018-05-22 Tue 12:30]
   - In Rust, _for most types_, operations like
     + *assigning* a value to a variable,
     + *passing* it to a function
     + *returning* it from a function
     don't copy the value: they /move/ it.

   - move :: The source relinquishes /ownership/ of the value to the _destination_,
             and becomes _uninitialized_; the _destination_ now *controls* the
             value's lifetime.

   - =TODO= note
   - Python way:
     Copy /pointers/, and use /reference counts/.
     + Cheap to create new variables.
     + Need to maintain /reference counts/ for gc.

   - C++ way:
     Create multiple copies, and each pointer points to its own copy..
     + expensive in creating new variables.
     + Clear in the references of each pointer, and NO /reference counts/.

   - The code below are legal for Python and C++:
     + Python
       #+BEGIN_SRC python
         s = ['udon', 'ramen', 'soba']
         t = s
         u = s
       #+END_SRC

     + C++
       #+BEGIN_SRC c++
         using namespace std;
         vector<string> s = {"udon", "ramen", "soba"};
         vector<string> t = s;
         vector<string> u = s;
       #+END_SRC

   - The similar code is illegal in Rust:
     #+BEGIN_SRC rust
       let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
       let t = s;
       let u = s;

       // error[E0382]: use of moved value: `s`
       //  --> ownership_double_move.rs:9:9
       //   |
       // 8 |     let t = s;
       //   |         - value moved here
       // 9 |     let u = s;
       //   |         ^ value used here after move
       //   |
     #+END_SRC

     The Rust way is NOT intuitive for other languages users, but it has the
     benefits from both Python way and C++ way: Cheap in re-assignment, and
     _NO_ /reference counts/ required.

     + The price you pay is that you must explicitly ask for copies when you
       want them
       #+BEGIN_SRC rust
         let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
         let t = s.clone();
         let u = s.clone();
       #+END_SRC

     + If you really want the Python way, using /reference counts/, you need to
       use The ~Rc~ and ~Arc~ pointer.
       =TODO=
       See "Rc and Arc: Shared Ownership" on page 90.

*** DONE More Operations That Move - 82
    CLOSED: [2018-05-22 Tue 12:05]
    - If you /move/ a value into a variable that was _already initialized_, Rust
      /drops/ the variable's prior value.
      #+BEGIN_SRC rust
        let mut s = "Govinda".to_string();
        s = "Siddhartha".to_string(); // value "Govinda" dropped here
      #+END_SRC

    - If a variable value is /moved/, you assign it a new value (of course, it
      should be a ~mut~ variable), nothing will be /dropped/.
      #+BEGIN_SRC rust
        let mut s = "Govinda".to_string();
        let t = s;
        s = "Siddhartha".to_string();  // nothing is dropped here
      #+END_SRC

    - =TOOD= NOTE
      Read This Example to find out /moves/.

    - /Moving/ values may sound inefficient, but there are two things to keep in
      mind:
      + The /moves/ always apply to the /value proper/, not the /heap storage/
        they own. For /vectors/ and /strings/, the /value proper/ is the three-word
        header alone.

      + The Rust compiler's code generation is good at *seeing through* all these
        /moves/; in practice, the machine code often stores the value directly
        where it belongs.

*** DONE Moves and Control Flow - 84
    CLOSED: [2018-05-22 Tue 11:44]
    The general principle is that, if it's possible for a variable to have had
    its value moved away, and it hasn't definitely been given a new value since,
    it’s considered uninitialized.

    More concrete examples (they are so natural and easy to understand):
    - ~if~
      #+BEGIN_SRC rust
        let x = vec![10, 20, 30];

        if c {
            f(x); // ... ok to move from x here
        } else {
            g(x); // ... and ok to also move from x here
        }

        h(x) // BAD: x is uninitialized here if either path uses it
      #+END_SRC

    - loop
      + Illegal
        #+BEGIN_SRC rust
          let x = vec![10, 20, 30];

          while f() {
              g(x);  // bad: x would be moved in first iteration,
                     // uninitialized in second
          }
        #+END_SRC

      + Legal
        #+BEGIN_SRC rust
          let mut x = vec![10, 20, 30];

          while f() {
              g(x);      // move from x
              x = h();   // give x a fresh value
          }

          e(x);
        #+END_SRC

*** DONE Moves and Indexed Content - 84
    CLOSED: [2018-05-22 Tue 12:30]
    Sometimes you need to assign the values of elements of a collection to a
    variable. If this /moves/ these element values directly, it is wierd that
    we had a initialized collection before, and we will have a collection which
    has uninitialized elements! Rust _forbid_ you doing this :
    #+BEGIN_SRC rust
      // With Compile Error!!!


      // Build a vector of the strings "101", "102", ... "105"
      let mut v = Vec::new();
      for i in 101 .. 106 {
          v.push(i.to_string());
      }

      // Pull out random elements from the vector.
      let third = v[2];
      let fifth = v[4];

      // error[E0507]: cannot move out of indexed content
      //   --> ownership_move_out_of_vector.rs:14:17
      //    |
      // 14 |     let third = v[2];
      //    |                 ^^^^
      //    |                 |
      //    |                 help: consider using a reference instead `&v[2]`
      //    |                 cannot move out of indexed content
    #+END_SRC

    - This is abnormal. We must find a way to resolve this!!!

      Solutions (=From Jian= the main idea is NO gap (uninitialized elements) in
      the middle):
      #+BEGIN_SRC rust
        // Build a vector of the strings "101", "102", ... "105"
        let mut v = Vec::new();
        for i in 101 .. 106 {
            v.push(i.to_string());
        }
      #+END_SRC

      1. Pop a value _off the end_ of the /vector/:
         #+BEGIN_SRC rust
           let fifth = v.pop().unwrap();
           assert_eq!(fifth, "105");
         #+END_SRC

      2. Move a value out of the middle of the vector, and move the last
         element into its spot:
         =From Jian= This operation is wierd ...
         #+BEGIN_SRC rust
           let second = v.swap_remove(1);
           assert_eq!(second, "102");
         #+END_SRC

      3. Swap in another value for the one we're taking out:
         #+BEGIN_SRC rust
           let third = std::mem::replace(&mut v[2], "substitute".to_string());
           assert_eq!(third, "103");
         #+END_SRC

      Let's see what's left of our /vector/ after the operations in steps 1, 2, 3:
      ~assert_eq!(v, vec!["101", "104", "substitute"]);~

    - Collection types like ~Vec~ also generally _offer_ /methods/ to *consume*
      all their elements in a loop:
      #+BEGIN_SRC rust
        let v = vec!["liberté".to_string(),
                     "égalité".to_string(),
                     "fraternité".to_string()];

        for mut s in v {
            s.push('!');
            println!("{}", s);
        }
      #+END_SRC
      This loop will take the ownership of the value of ~v~.

    - If you do find yourself needing to move a value out of an owner that the compiler
      can’t track, you might consider changing the owner’s type to something that can
      dynamically track whether it has a value or not. For example, here’s a variant on the
      earlier example:
      #+BEGIN_SRC rust
        struct Person { name: Option<String>, birth: i32 }
        let mut composers = Vec::new();
        composers.push(Person { name: Some("Palestrina".to_string()),
                                birth: 1525 });
      #+END_SRC
      + You still CANNOT do this: ~let first_name = composers[0].name;~
        Same error as we saw before!

      + But you can do
        #+BEGIN_SRC rust
          let first_name = std::mem::replace(&mut composers[0].name, None);
          assert_eq!(first_name, Some("Palestrina".to_string()));
          assert_eq!(composers[0].name, None);
        #+END_SRC

      + Actually, the ~Option~ way is common enough and you can use a more specific
        /method/ to do the same thing as the ~std::mem::replace~ line above:
        ~let first_name = composers[0].name.take();~

** DONE ~Copy~ Types: The Exception to Moves - 86
   CLOSED: [2018-05-22 Tue 14:21]
   /Moves/ keep ownership of such types clear and assignment cheap.
   But for simpler types like integers or characters, this sort of careful
   handling really isn't necessary.

   - Assigning a value of a ~Copy~ type *copies* the value, _rather than_ /moving/
     it.

   - ~Copy~ types:
     + all the machine integer, floating-point numeric types, the ~char~ and
       ~bool~ types, and a few others.

       =From Jian= (NO SURE?!) All the types that don't need to allocate heap
       storage are ~Copy~ types.

     + A /tuple/ or /fixed-size array/ of ~Copy~ types elements is itself a
       ~Copy~ type.

   - ~struct~'s are by default NOT ~Copty~ type.
     However, if all the fields of a ~struct~ are ~Copy~ types, you can make this
     ~struct~ type ~Copy~ type as well by placing the /attribute/
     ~#[derive(Copy, Clone)]~ above the definition, like so:
     #+BEGIN_SRC rust
       #[derive(Copy, Clone)]
       struct Label { number: u32 }
     #+END_SRC

     + *CAUTION*:
       All fields MUST BE ~Copy~ types!!! OR you'll see an /error/ even if you
       use the /attribute/ ~#[derive(Copy, Clone)]~.

   - Q: Why use non-~Copy~ type as DEFAULT?

     A: If NOT, the type will be very restricted, which can only contain types
        that have no heap storage allocation.

        Change the non-~Copy~ types to ~Copy~ types won't affect your code.
        However, the opposite direction is different, and you need to modify
        your code.

   - One of Rust's principles is that
     + *costs should be apparent to the programmer*.

     + *Basic operations must remain simple*.

     + *Potentially expensive operations should be explicit*,
       like the calls to ~clone~ in the earlier example that make _deep copies_
       of /vectors/ and the /strings/ they contain.

   - =TODO= =TODO= =TODO=
     ~trait~ in general in Chapter 11
     Traits ~Copy~ and ~Clone~ in general in Chapter 13

** DONE ~Rc~ and ~Arc~: shared ownership - 90 =Re-Read= =Reference counter and Circular reference=
   CLOSED: [2018-05-22 Tue 14:49]
   - ~Rc~ and ~Arc~ are safe!
     You CANNOT
     + forget to adjust the reference count

     + create other pointers to the referent that Rust doesn't notice

     + stumble over any of the other sorts of problems that accompany
       reference-counted pointer types in C++.

   - ~Rc~ and ~Arc~ are very similar!
     *The ONLY DIFFERENCE* between them is that an ~Arc~ (/atomic reference count/)
     is safe to share between threads directly, wheereas a plain ~Rc~ uses faster
     /non-thread-safe/ code to update its reference count.

     + Use ~Rc~ if you won't share it between /threads/, and avoid performance
       penalty of an ~Arc~.

     + Rust will *prevent* you from accidentally passing ~Rc~ across a /thread/
       boundary.

     *The two types are otherwise equivalent.*
     We'll only talk about ~Rc~.

   - Use ~Rc~ to simulate the earlier Python code we saw.
     #+BEGIN_SRC rust
       use std::rc::Rc;

       // Rust can infer all these types; written out for clarity
       let s: Rc<String> = Rc::new("shirataki".to_string());
       let t: Rc<String> = s.clone();
       let u: Rc<String> = s.clone();
     #+END_SRC
     + Cloning an ~Rc<T>~ value does NOT copy the ~T~ value;
       instead, it simply creates ANOTHER /pointer/ to it, and increments the
       reference count.

     + The usual /ownership rules/ apply to the ~Rc~ /pointers/ themselves,
       and when the last extant ~Rc~ is /dropped/, Rust /drops/ the ~String~ as
       well.

   - You can use any of ~String~'s usual /methods/ directly on an ~Rc<String>~:
     #+BEGIN_SRC rust
       assert!(s.contains("shira"));
       assert_eq!(t.find("taki"), Some(5));
       println!("{} are quite chewy, almost bouncy, but lack flavor", u);
     #+END_SRC

   - A value owned by an ~Rc~ /pointer/ is *immutable*.
     If you try to add some text to the end of the string:
     #+BEGIN_SRC rust
       s.push_str(" noodles");

       // error: cannot borrow immutable borrowed content as mutable
       //   --> ownership_rc_mutability.rs:12:5
       //    |
       // 12 |     s.push_str(" noodles");
       //    |     ^ cannot borrow as mutable
     #+END_SRC

     + Rust's memory and thread-safety guarantees _depend on_ ensuring that *NO*
       value is ever _SIMULTANEOUSLY_ *shared* _and_ *mutable*.

       Rust assumes the referent of an ~Rc~ /pointer/ might in general be *shared*,
       so it _MUST NOT be_ *mutable*.

       =TODO=
       We explain why this restriction is important in Chapter 5.

   - =TODO= =Re-Write= =NOTE=
     One well-known problem with using /reference counts/ to manage memory is
     that, if there are ever two reference-counted values that point to each
     other, each will hold the other’s /reference count/ above zero, so the
     values will never be freed (Figure 4-13).
     =Circular references=

     It is possible to leak values in Rust this way, but such situations are
     *rare*:

     + MOSTLY:
       You cannot create a cycle without, at some point, making an older value
       point to a newer value. This obviously requires the older value to be
       mutable. Since Rc pointers hold their referents immutable, it’s not
       normally possible to create a cycle.

     + YOU STILL CAN:
       However, Rust does provide ways to create mutable portions of otherwise
       immutable values; this is called /interior mutability/, and we cover it
       in “Interior Mutability” on page 205 =TODO=. If you combine those
       techniques with Rc pointers, you can create a cycle and leak memory.

     *Circular references in a reference count system*

   - weak pointers :: ~std::rc::Weak~. NO details in this book, please refer to
                      the standard library doc.
                      =TODO=

   - /Moves/ and /reference-counted pointers/ are *two* ways to relax the rigidity
     of the /ownership/ tree.

     In the next chapter, we'll look at a *third* way:
     /borrowing/ references to values.

     Once you have become comfortable with both /ownership/ and /borrowing/, you
     will have climbed the steepest part of Rust's learning curve, and you'll be
     ready to take advantage of Rust's unique strengths.

* DONE 5. References and borrowing - 93
  CLOSED: [2018-06-14 Thu 21:17]
  - ALL the /pointer types/ we've seen SO FAR are /owning pointer types/:
    + the simple ~Box<T>~ heap pointer,
    + the pointers internal to ~String~ and ~Vec~ values

  - Owning pointers :: when the /owner/ is /dropped/, the /referent/ goes with
       it.

  - Rust also has /nonowning pointer types/ called /references/, which have no
    effect on their /referents' lifetimes/.

  - It's rather the opposite (/owning pointer types/ and /non-owning pointer types/):
    /references/ must *never outlive* their /referents/.

    You must make it _APPARENT_ in your code that *NO* /reference/ can possibly
    _outlive_ the value it points to.

    To emphasize this, Rust referes to creating a /reference/ to some value as
    /borrowing/ the value:
    What you have borrowed, you must eventually return to its owner!

  - You have two kinds of /references/:
    + shared references :: ~&variable~

    + mutable references :: ~&mut variable~

  - (I didn't copy the wrong code, which is used to introduce the concepts of
    /shared references/ and /mutable references/ here, ONLY the right one -- use
    /reference/ rather than /move/):
    #+BEGIN_SRC rust
      use std::collections::HashMap;

      type Table = HashMap<String, Vec<String>>;

      fn show(table: &Table) {
          for (artist, works) in table {
              println!("works by {}:", artist);
              for work in works {
                  println!(" {}", work);
              }
          }
      }

      fn main() {
          let mut table = Table::new();
          table.insert("Gesualdo".to_string(),
                       vec!["many madrigals".to_string(),
                            "Tenebrae Responsoria".to_string()]);
          table.insert("Caravaggio".to_string(),
                       vec!["The Musicians".to_string(),
                            "The Calling of St. Matthew".to_string()]);
          table.insert("Cellini".to_string(),
                       vec!["Perseus with the head of Medusa".to_string(),
                            "a salt cellar".to_string()]);
          show(table);
      }
    #+END_SRC

  - Modify the ~table~ with with /mutable references/:
    #+BEGIN_SRC rust
      fn sort_works(table: &mut Table) {
          for (_artist, works) in table {
              works.sort();
          }
      }
      sort_works(&mut table);
    #+END_SRC

  - Pass it /by value/, you use the /move/ semantics, and give out the /ownership/.
    Pass it /by reference/, you keep the /ownership/.

** DONE References as Values - 97
   CLOSED: [2018-06-14 Thu 02:41]
*** DONE Rust References Versus C++ References - 97
    CLOSED: [2018-05-24 Thu 12:07]
    - In a nutshell, whereas
      + C++ converts _IMPLICITLY_ between /references/ and /lvalues/ (that is,
        expressions referring to locations in memory), with these conversions
        appearing anywhere they're needed,
        #+BEGIN_SRC c++
          int x = 10;
          int &r = x;       // initialization creates reference implicitly
          assert(r == 10);  // implicitly dereference r to see x's value
          r = 20;           // stores 20 in x, r itself still points to x
        #+END_SRC

      + in Rust you use the ~&~ and ~*~ operators to create and follow /references/,
        #+BEGIN_SRC rust
          let x = 10;
          let r = &x;        // &x is a shared reference to x
          assert!(*r = 10);  // explicitly dereference r
        #+END_SRC

        To create a /mutable reference/, use the ~&mut~ operator:
        #+BEGIN_SRC rust
          let mut y = 32;
          let m = &mut y;     // &mut y is a mutable reference to y
          *m += 32;           // explicitly dereference m to set y's value
          assert!(*m == 64);  // add to see y's new value
        #+END_SRC

        with the *exception* of the ~.~ operator, which /borrows/ and
        /dereferences/ _IMPLICITLY_.
        * For instance:
          #+BEGIN_SRC rust
            struct Anime { name: &'static str, bechdel_pass: bool };
            let aria = Anime { name: "Aria: The Animation", bechdel_pass: true };
            let anime_ref = &aria;
            assert_eq!(anime_ref.name, "Aria: The Animation");

            // Equivalent to the above, but with the dereference written out:
            assert_eq!((*anime_ref).name, "Aria: The Animation");
          #+END_SRC

        * ~println!~ macro used in the ~show~ function in the last section expands
          to code that uses the ~.~ operator, so it takes advantage of this
          /implicit deference/ as well.

        * The ~.~ operator can also /implicitly borrow/ a /reference/ to its
          _left operand_, if needed for a /method/ call.
          For example,
          ~Vec~'s ~sort~ /method/ takes a /mutable reference/ to the vector, so
          the two calls shown here are equivalent:
          #+BEGIN_SRC rust
            let mut v = vec![1973, 1968];

            v.sort();
            // implicitly borrows a mutable reference to v

            (&mut v).sort();
            // equivalent; much uglier
          #+END_SRC

*** DONE Assigning References - 98
    CLOSED: [2018-05-24 Thu 12:17]
    - *Assigning* to a Rust /reference/ makes it _point at a new value_:
      #+BEGIN_SRC rust
        let x = 10;
        let y = 20;
        let mut r = &x;

        if b { r = &y; }
        assert!(*r == 10 || *r == 20);
      #+END_SRC
      The /reference/ ~r~ INITIALLY _points to_ ~x~.
      But if ~b~ is ~true~, the code points it at ~y~ instead, as illustrated in
      Figure 5-1. =TODO= =REVIEW=

      This is *very different from C++*,
      where *assigning* to a /reference/ *stores* the value in its /referent/.
      There's *NO WAY* to point a C++ /reference/ to a location _other than_ the
      one it was initialized with.
      =From Jian=
      The rationale is easy to understand: you didn't /move/ the value, just use
      a /reference/, it is reasonable to NOT write the value to the address where
      the /reference/ ~r~ was initialized to point to.

*** DONE References to References - 99
    CLOSED: [2018-05-24 Thu 12:22]
    - Rust permits /references to references/:
      #+BEGIN_SRC rust
        struct Point { x: i32, y: i32 };
        let point = Point { x: 1000, y: 729 };
        let r: &Point = &point;
        let rr: &&Point = &r;
        let rrr: &&&Point = &rr;
      #+END_SRC
      The ~.~ operator follows as many /references/ as it takes to find its
      target: ~assert_eq!(rrr.y, 729);~

      See the Figure 5-2. A chain of references to references (memory layout)

*** DONE Comparing References - 99
    CLOSED: [2018-05-24 Thu 12:29]
    - Like the ~.~ operator, Rust's comparison operators “see through” any number
      of /references/, *as long as both operands have the SAME type* (=From
      Jian= you can compare SAME type values):
      #+BEGIN_SRC rust
        let x = 10;
        let y = 10;

        let rx = &x;
        let ry = &y;

        let rrx = &rx;
        let rry = &ry;

        assert!(rrx <= rry);
        assert!(rrx == rry);
      #+END_SRC

    - If you actually want to know WHETHER two /references/ point to the SAME
      memory, you can use ~std::ptr::eq~, which compares them as addresses:
      #+BEGIN_SRC rust
        assert!(rx == ry);              // their referents are equal
        assert!(!std::ptr::eq(rx, ry)); // but occupy different addresses
      #+END_SRC
      =IMPORTANT=

*** DONE References Are Never Null - 100
    CLOSED: [2018-05-24 Thu 12:32]
    /References/ are NEVER /null/.
    Outside ~unsafe~ block, you CAN'T convert zero into a /reference/ -- the way
    you can used to create /null/ in C/C++.

*** DONE Borrowing References to Arbitrary Expressions - 100
    CLOSED: [2018-05-24 Thu 12:46]
    - Whereas
      C and C++ ONLY let you apply the ~&~ operator to _CERTAIN kinds of
      expressions_,

      Rust lets you /borrow/ a /reference/ to the value of *ANY* sort of expression
      at all:
      #+BEGIN_SRC rust
        fn factorial(n: usize) -> usize {
            (1..n+1).fold(1, |a, b| a * b)
        }

        let r = &factorial(6);
        assert_eq!(r + &1009, 1729);
      #+END_SRC
      + In situations like this, Rust simply creates an /anonymous variable/ to
        hold the expression's value, and makes the /reference/ point to that.
          The /lifetime/ of this /anonymous variable/ depends on what you do
        with the /reference/:
        * If you *immediately assign* the /reference/ to a /variable/ in a ~let~
          statement (or make it part of some /struct/ or /array/ that is being
          immediately assigned), then Rust makes the /anonymous variable/ live as
          long as the variable the ~let~ initializes.
            In the preceding example, Rust would do this for the referent of ~r~.

        * Otherwise, the /anonymous variable/ lives to the end of the _enclosing
          statement_. In our example, the /anonymous variable/ created to hold
          ~1009~ lasts only to the end of the ~assert_eq!~ statement.

      + This design seems error-prone for C/C++.
        However, Rust will never let you write code that would produce a
        /dangling reference/. The pointer to /anonymous variables/ will be
        /dropped/ when beyond their /lifetime/.

    - If the /reference/ could ever be used *beyond* the /anonymous variable/'s
      /lifetime/, Rust will always report the problem to you at /compile time/.
        You can then fix your code to keep the referent in a /named variable/
      with an _appropriate_ (=???=) /lifetime/.
      =TODO= =TODO= =TODO=
      
*** DONE References to Slices and Trait Objects - 101
    CLOSED: [2018-06-14 Thu 02:39]
    - The /references/ we've shown _so far_ are all _SIMPLE_ /addresses/.

    - HOWEVER, Rust also includes *TWO* kinds of /fat pointers/.

    - fat pointers :: two-word values carrying the address of some value, along
                      with some further information necessary to put the value
                      to use.

    - A /reference to a slice/ is a /fat pointer/,
      carrying the _starting address_ of the /slice/ and its _length_.

      =TODO= =REVIEW=
      We described slices in detail in Chapter 3.

    - Rust's other kind of /fat pointer/ is a /trait object/,

      =From Jian= =???= =TODO= Should be a /trait object/ or a /reference trait object/ ???????

      a /reference/ to a value that implements a certain /trait/.

      A /trait object/ carries
      + a /value/'s /address/

      + a /pointer/ to the /trait/'s implementation appropriate to that value,
        for invoking the /trait/'s /methods/.

      =TODO=
      We'll cover /trait objects/ in detail in "Trait Objects" on page 238.

    - ASIDE FROM carrying this extra data,
      /slice references/ and /trait object references/ behave just like the other
      sorts of /references/ we've shown so far in this chapter:
      + they don't own their referents;

      + they are NOT allowed to _outlive_ their referents;

      + they may be /mutable/ or /shared/; and so on.

** TODO Reference Safety - 101
*** DONE Borrowing a Local Variable - 101
    CLOSED: [2018-05-24 Thu 14:25]
    A pretty obvious case: you _can't_ /borrow/ a /reference/ to a local variable
    and take it out of the variable's scope:

    - Example:
      #+BEGIN_SRC rust
        {
            let r;
            {
                let x = 1;
                r = &x;
            }
            assert_eq!(*r, 1);  // bad: reads memory `x` used to occupy
        }
      #+END_SRC

      Error Message:
      #+BEGIN_SRC text
        error: `x` does not live long enough
          --> references_dangling.rs:8:5
           |
        7  |         r = &x;
           |              - borrow occurs here
        8  |     }
           |     ^ `x` dropped here while still borrowed
        9  |     assert_eq!(*r, 1); // bad: reads memory `x` used to occupy
        10 | }
           | - borrowed value needs to live until here
      #+END_SRC

    - /Lifetimes/ are entirely figments of Rust's /compile-time/ imagination.

      At /runtime/, a /reference/ is nothing but an address;
      its /lifetime/ is *part of* its /type/ and has _NO_ /runtime/
      representation.

    - In this example, there are *three* /lifetimes/ whose relationships we need
      to work out. The variables ~r~ and ~x~ each have a /lifetime/, extending

      from _the point at which they're initialized_
      until _the point that they go out of scop_.

      The third /lifetime/ is that of a /reference type/: the type of the
      /reference/ we /borrow/ to ~&x~, and store in ~r~.

      Here's one *constraint* that should seem pretty obvious:
      if you have a variable ~x~, then a /reference/ to ~x~ *must not* _outlive_
      ~x~ itself, as shown in Figure 5-3.

    - The rules Rust compiler used to do the lifetime check is NOT so different
      from the process C and C++ programmers impose on themselves; the
      difference is that _Rust knows the rules, and *enforces* them_.

*** TODO Receiving References as Parameters - 105
*** DONE Passing References as Arguments - 107
    CLOSED: [2018-06-14 Thu 17:38]
    Now that we've shown how a function's signature relates to its body, let's
    examine how it relates to the function's callers.

    - Example:
      #+BEGIN_SRC rust
        // This could be written more briefly: fn g(p: &i32),
        // but let's write out the lifetimes for now.
        fn g<'a>(p: &'a i32) { ... }

        let x = 10;
        g(&x);
      #+END_SRC
      + From ~g~'s signature alone, Rust knows it will _NOT_ save ~p~ anywhere
        that might outlive the call:
        any /lifetime/ that encloses the call must work for ~'a~.

    - When defining /functions/ and /types/, you need to figure out /lifetime
      parameters/.

      When using them, Rust infers the /lifetimes/ for you.

    - With a definition of wrong /lifetime parameters/ settings,
      the code won't compile:
      #+BEGIN_SRC rust
        fn f(p: &'static i32) { ... }

        let x = 10;
        f(&x);
      #+END_SRC
    
*** DONE Returning References - 107
    CLOSED: [2018-06-14 Thu 17:50]
    #+BEGIN_SRC rust
      // v should have at least one element
      fn smallest(v: &[i32]) -> &i32 {
          let mut s = &v[0];

          for r in &v[1..] {
              if *r < *s { s = r; }
          }

          s
      }
    #+END_SRC
    - We've omitted lifetimes from that function's signature in the usual way.

      + When a function
        takes a SINGLE /reference/ as an argument, and
        returns a SINGLE /reference/,

        Rust assumes that the two must have the SAME /lifetime/.

      + Write it explicitly:
        ~fn smallest<'a>(v: &'a [i32]) -> &'a i32 { ... }~

    - You cannot use it in this way:
      #+BEGIN_SRC rust
        let s;
        {
            let parabola = [9, 4, 1, 0, 1, 4, 9];
            s = smallest(&parabola);
        }
        assert_eq!(*s, 0);  // bad: points to element of dropped array
      #+END_SRC
      The first line of the error message is:
      ~error: `parabola` does not live long enough~
    
*** TODO Structs Containing References - 109
    - x

    - =???= =TODO=
      In fact, ... ???

    - x

*** TODO Distinct Lifetime Parameters - 111
*** DONE Omitting Lifetime Parameters - 112
    CLOSED: [2018-06-14 Thu 21:17]
    - In the simplest case, if your function _doesn't return_ any /references/ (or
      other types that require /lifetime parameters/), then you never need to
      write out /lifetimes/ for your parameters -- *Rust just assigns a DISTINCT
      /lifetime/ to each spot that needs one.* For example:
      #+BEGIN_SRC rust
        struct S<'a, 'b> {
            x: &'a i32,
            y: &'b i32
        }

        fn sum_r_xy(r: &i32, s: S) -> i32 {
            r + s.x + s.y
        }
      #+END_SRC

      This function's signature is shorthand for:
      ~fn sum_r_xy<'a, 'b, 'c>(r: &'a i32, s: S<'b, 'c>) -> i32~

    - If there's only a _SINGLE_ /lifetime/ that appears among your function's
      parameters, then Rust _assumes_ ANY /lifetimes/ in your return value must
      be that one:
      #+BEGIN_SRC rust
        fn first_third(point: &[i32; 3]) -> (&i32, &i32) {
            (&point[0], &point[2])
        }
      #+END_SRC
      With all the lifetimes written out, the equivalent would be:
      ~fn first_third<'a>(point: &'a [i32; 3]) -> (&'a i32, &'a i32)~

    - If there are _MULTIPLE_ /lifetimes/ among your parameters,
      then there's NO natural reason to prefer one over the other for the return
      value, and
      *Rust makes you spell out what's going on*.

    - But as one final shorthand,
      if your function is a /method/ on some /type/ and takes its ~self~
      parameter /by reference/, then that breaks the tie:
        Rust assumes that ~self~'s /lifetime/ is the one to give EVERYTHING in
      your /return value/.

      + Example:
        #+BEGIN_SRC rust
          struct StringTable {
              elements: Vec<String>,
          }

          impl StringTable {
              fn find_by_prefix(&self, prefix: &str) -> Option<&String> {
                  for i in 0 .. self.elements.len() {
                      if self.elements[i].starts_with(prefix) {
                          return Some(&self.elements[i]);
                      }
                  }
                  None
              }
          }
        #+END_SRC
        The ~find_by_prefix~ /method/'s signature is shorthand for:
        ~fn find_by_prefix<'a, 'b>(&'a self, prefix: &'b str) -> Option<&'a String>~

    - *SUMMARY*:
      All these abbreviations meant to be helpful without introducing surprises.
      _When they're NOT what you want, you can always write the /lifetimes/ out
      explicitly._

** TODO Sharing Versus Mutation - 114
** DONE Taking Arms Against a Sea of Objects - 121
   CLOSED: [2018-06-14 Thu 03:06]
   - The disadvantages of languages with GC:
     Since it is easy to get not-in-use memeory back, you may create many objects
     you think you need without a fully consideration of your design and memory
     use, and build connections between them -- finally, When everything depends
     on everything else like this Figure 5-10,

     (=From Jian= two reasons:
     you create two many objects you actually don't need if you have a better
     design, and with this bad design you often have to build unecessary
     dependencies between these objects).

     it's hard to test, evolve, or even think about any component in isolation.

   - One fascinating thing about Rust is that the /ownership model/ puts a speed
     bump on the highway to hell.
     =From Jian= *Make dangerous things verbose*
       It takes a bit of effort to make a cycle in Rust -- two values such that
     each one contains a reference pointing to the other. You have to use a /smart
     pointer type/, such as ~Rc~, and /interior mutability/ -- a topic we haven't
     even covered yet. =TODO=

   - Rust prefers for /pointers/, /ownership/, and /data flow/ to pass through
     the system *in one direction*, as shown in Figure 5-11.

     Rust's /ownership model/ will give you some trouble when you want to do
     some bad design.
       The cure is to do some up-front design and build a better program.

   - Rust is all about *transferring* the pain of understanding your program _from
     the future to the present_.

     + It works unreasonably well:
       * not only can Rust force you to understand why your program is thread-safe,
       * it can even require some amount of high-level architectural design.

* DONE 6. Expressions - 123 =NOTE=
  CLOSED: [2018-05-23 Wed 22:43]
** DONE An Expression Language - 123
   CLOSED: [2018-05-22 Tue 21:19]
   - Rust is what is called an *expression* language.

** DONE Blocks and Semicolons - 124
   CLOSED: [2018-05-22 Tue 21:19]
   - /Blocks/, too, are expressions
     A /block/ produces a value and can be used _ANYWHERE_ a value is needed:
     #+BEGIN_SRC rust
       let display_name = match post.author() {
           Some(author) => author.name(),
           None         => {
               let network_info = post.get_network_metadata()?;
               let ip           = network_info.client_address();
               ip.to_string()  // NO semicolon here!!!
           }
       }
     #+END_SRC
     + The ~ip.to_string()~ line has no semicolon, and it is the returned value.

     + If all lines in a block has a semicolon at the end, the return value is
       ~()~.

     + Tips:
       #+BEGIN_SRC rust
         // error[E0308]: mismatched types
         //   --> expressions_missing_semicolon.rs:19:9
         //    |
         // 19 |         page.compute_size() // oops, missing semicolon
         //    |         ^^^^^^^^^^^^^^^^^^^ expected (), found tuple
         //    |
         //    = note: expected type `()`
         //               found type `(u32, u32)`
       #+END_SRC
       If you made this mistake in a C or Java program, the compiler would simply point out
       that you’re missing a semicolon. Here’s what Rust says:
       Rust assumes you’ve omitted this semicolon on purpose; it doesn’t consider the possi‐
       bility that it’s just a typo. A confused error message is the result.

       *When you see expected type `()` , look for a missing semicolon first.*

   - Empty statements, ~;~'s, are also allowed in /blocks/.

** TODO Declarations - 126
   - ~let mut~ is kinda of like the ~final~ in Java in some aspect, if not all:
     #+BEGIN_SRC rust
       let name;

       if user.has_nickname() {
           name = user.nickname();
       } else {
           name = generate_unique_name();
           user.register(&name);
       }
     #+END_SRC
     ~name~ assignment appears in two places, but can ONLY be one of them.
     Thus, no ~mut~ required in the declaration of ~name~;

   - A /block/ can also contain /item declarations/.
     An item is simply any declaration that could appear globally in a program
     or module, such as a ~fn~, ~struct~, or ~use~. For instance,
     #+BEGIN_SRC rust
       use std::io;
       use std::cmp::Ordering;

       fn show_files() -> io::Result<()> {
           let mut v = vec![];
           // ...
           fn cmp_by_timestamp_then_name(a: &FileInfo, b: &FileInfo) -> Ordering {
               a.timestamp.cmp(&b.timestamp)
               // first, compare timestamps
                   .reverse()
               // newest file first
                   .then(a.path.cmp(&b.path)) // compare paths to break ties
           }
           v.sort_by(cmp_by_timestamp_then_name);
           // ...
       }
     #+END_SRC

   - =TODO=
     When a ~fn~ xxxxxx

   - =TODO=
     A block can even contain a xxxxx

** DONE ~if~ and match - 127
   CLOSED: [2018-05-22 Tue 21:19]
   - SYNTAX ~if .. else if .. else~:
     #+BEGIN_SRC rust
       if condition1 {
           block_1
       } else if condition2 {
           block_2
       } else {
           block_n
       }
     #+END_SRC
     + /conditions/ doesn't require parentheses.
       The compiler will emit a warning when unnecessary parentheses are
       present.

     + The curly braces for the body blocks are mandatory!

   - SYNTAX ~match~:
     #+BEGIN_SRC rust
       match value {
           pattern => expr,
           // ...
       }
     #+END_SRC
     + If ~expr~ above is a block, the comma may be dropped

     + ~match~ has /exhaustiveness check/

   - The optimization of ~match~:
     + Use a /jump table/, just like a ~switch~ statement in C++.

     + When each arm of a ~match~ produces a constant value, the compiler builds
       an array of those values, and the ~match~ is compiled into an array access.
       Apart from a bounds check, there is a branch-free code.

*** DONE ~if let~ - 129
    CLOSED: [2018-05-22 Tue 21:19]
    - SYNTAX:
      #+BEGIN_SRC rust
        if let pattern = expr {
            block_1
        } else {
            block_2
        }
      #+END_SRC
      + It's never strictly necessary to use ~if let~,
        because ~match~ can do everything ~if let~ can do.

        =From Jian=
        ~match~ syntax is good for aligning conditions and operations, which is
        very convenient! I can imagine any cases that I want to use ~if let~!!!
          I use ~if let~-like syntax in Go, juse because Go DOESN'T HAVE ~match~!

** DONE Loops - 130
   CLOSED: [2018-05-22 Tue 22:01]
   - SYNTAX:
     #+BEGIN_SRC rust
       while condition {
           block
       }

       while let pattern = expr {
           block
       }

       loop {
           block
       }

       for pattern in collection {
           block
       }
     #+END_SRC
     + /Loops/ are also expressions, but they ONLY produce useless value ~()~.

     + ~while~ behaves exactly like the C equivalent, except Rust is stongly
       typed, which means /condition/ must be ~bool~.

     + ~loop~ is used to write /infinite loops/ (with mechanism inside to stop it,
       for instance ~break~ or ~return~ inside).

     + In the ~for~ loop, we often use /range/.
       For instance, ~0..20~ and ~std::ops::Range { start: 0, end: 20 }~ are the
       same, and they are /ranges/.

       ~Range~ can be used with ~for~ loops because ~Range~ is an /iterable type/,
       it implements the ~std::iter::IntoIterator~ /trait/.
       =TODO= Chapter 15
       The standard collections are all iterable, as are /arrays/ and /slices/.

   - In keeping with Rust's /move/ semantics, a ~for~ loop over a value *consumes*
     the value:
     #+BEGIN_SRC rust
       let strings: Vec<String> = error_messages();

       for s in strings {              // each String is moved into s here...
           println!("{}", s);
       }                               // ...and dropped here

       println!("{} error(s)", strings.len()); // error: use of moved value
     #+END_SRC
     + GOOD: This design promises the simplicity in theory.

     + Not so Good, but can be easily walked around:
       * It is very inconvenient in many cases. Use /reference/ instead!
         #+BEGIN_SRC rust
           for rs in &strings {
               println!("String {:?} is at address {:p}.", *rs, rs);
           }
         #+END_SRC
         - ~&strings~ here is ~&Vec<String>~, and
           ~rs~ is ~&String~.

       * Use ~mut~ /reference/ provides a ~mut~ /reference/ to each element:
         #+BEGIN_SRC rust
           for rs in &mut strings {  // the type of `rs` is `&mut String`
               rs.push('\n');  // add a newline to each string
           }
         #+END_SRC

   - =TODO=
     Chapter 15 covers ~for~ loops in greater detail and show many other ways to
     use /iterators/.

   - ~break~ expression exits an _enclosing loop_.

     In Rust, ~break~ works only in /loops/!
       Since ~match~ (the Rust version of C/C++ ~switch~) dosen't have the
     feature of /fall-through/, it doesn't need ~break~.

   - ~continue~

   - A /loop/ can be *labeled* with a /lifetime/.
     =From Jian= the example code below doesn't have a explicit lifetime?!
     #+BEGIN_SRC rust
       'search:
       for room in apartment {
           for spot in room.hiding_spots() {
               if spot.contains(keys) {
                   println!("Your keys are {} in the {}.", spot, room);
                   break 'search;
               }
           }
       }
     #+END_SRC
     + /Labels/ can also be used with ~continue~.

** DONE ~return~ Expressions - 132
   CLOSED: [2018-05-22 Tue 22:07]
   - ~return~ without follow-up value means return ~()~

   - ~return~ can abandon work in progress.
     If you call a function with this kind of ~return~, you may want to use ~?~
     operator to check for errors after calling.
       For instance, ~let output = File::create(filename)?;~, it is shorthand for
     a ~match~ expression:
     #+BEGIN_SRC rust
       let output = match File::create(filename) {
           Ok(f)    => f,
           Err(err) => return Err(err)
       }
     #+END_SRC
     =TODO= See "Propagating Errors" on page 152.

** DONE Why Rust Has ~loop~ - 133 =Re-Read=
   CLOSED: [2018-05-23 Wed 20:44]
   Rust compilers analyze the /control flow/ through your program.

   It is NOT convenient for the compiler to do the analysis with ~while true~
   for some reason (mentioned in the book), and the designer create ~loop~.

   =From Jian=
   This is a plausible reason.
   It is a non-fundamental solution, and a patchy solution!!!
   You should (!!!) solve the ~while true~ problem!!!

** DONE Function and Method Calls - 134
   CLOSED: [2018-05-23 Wed 21:43]
   - Rust usually makes a _sharp distinction_ between /references/ and the
     /values/ they refer to.

     + You cannot pass a /reference/ to a function requires a /value/, or vice versa.

     + However, the ~.~ operator AUTOMATICALLY *dereferences* the caller or
       *borrows* a /reference/ to it as needed.

   - SYNTAX for calling /static methods/:
     ~let mut numbers = Vec::new();~

   - One quirk of Rust syntax:
     When the invocation involves types with generic type parameter(s), the syntax
     is *NOT* intuitive:

     + Error:
       #+BEGIN_SRC rust
         return Vec<i32>::with_capacity(1000);     // error: something about chained comparisons

         let ramp = (0 .. n).collect<Vec<i32>>();  // same error
       #+END_SRC
       The compiler consider ~<~ as /less than operator/, this must be avoided.

       =From Jian= a patchy solution again!

     + Solution:
       * With wierd syntax!
         prefix the type parameter parts with ~::~
         #+BEGIN_SRC rust
           return Vec::<i32>::with_capacity(1000);     // ok, using ::<
           let ramp = (0 .. n).collect::<Vec<i32>>();  // ok, using ::<
         #+END_SRC

       * (_PREFERED_) With the help of /type inference/:
         #+BEGIN_SRC rust
           return Vec::with_capacity(10);            // ok, if the fn return type is Vec<i32>
           let ramp: Vec<i32> = (0 .. n).collect();  // ok, variable's type is given
         #+END_SRC

** DONE Fields and Elements - 135
   CLOSED: [2018-05-23 Wed 22:02]
   - For example:
     #+BEGIN_SRC rust
       game.black_pawns  // struct field
       coords.1          // tuple elements
     #+END_SRC

   - If the left of the dot is a /reference/ or /smart pointer type/, it is
     AUTOMATICALLY *dereferenced*, just as for /method/ calls.

   - SYNTAX like ~pieces[i]~ for /arrays/, /slices/ and /vectors/.

   - The ~..~ operator allows either operand to be omitted.
     #+BEGIN_SRC rust
       ..      // RangeFull
       a ..    // RangeFrom { start: a }
       .. b    // RangeTo { end: b }
       a .. b  // RangeFrom { start: a, end: b }
     #+END_SRC
     + =TODO= =???=
       Only /ranges/ that include a /start value/ are /iterable/,
       =???=

** DONE Reference Operators - 137
   CLOSED: [2018-05-23 Wed 22:18]
   The /address-of operators/, ~&~ and ~&mut~ (covered in Chapter 5).

   The unary ~*~ operator is used to access the value pointed to by a /reference/.
   1. When there is the caller before ~.~, who is a /reference/, /auto dereference/
      will happen.

   2. Therefore, ONLY when we want to read or write the entire value that the
      reference points to. For instance, pass its value as a parameter.
      #+BEGIN_SRC rust
        let padovan: Vec<u64> = compute_padovan_sequence(n);

        for elem in &padovan {
            draw_triangle(turtle, *elem);
        }
      #+END_SRC

** DONE Arithmetic, Bitwise, Comparison, and Logical Operators - 137 =TODO=
   CLOSED: [2018-05-23 Wed 22:30]
   Rust has the usual arithmetic operators, ~+~, ~-~, ~*~, ~/~, and ~%~.
   These operators are mostly like their counterpart in the other languages.

   We'll focus on the few points where Rust departs from tradition:

   - As mentioned in Chapter 3,
     + integer overflow is detected, and causes a /panic/, *in debug builds*.

     + The standard library provides /methods/ LIKE ~a.wrapping_add(b)~ for
       *unchecked* arithmetic.

   - Dividing an integer by zero triggers a /panic/ *even in release builds*.

     Integers have a method ~a.checked_div(b)~ that returns an ~Option~ (~None~
     if ~b~ is zero) and NEVER /panics/.

   - ~%~ can be applied to BOTH /integers/ and /floating numbers/.
     As in C, the result has the same sign as the LHS of the ~%~.

   - Rust use ~!~ rather than the ~~~ for bitwise NOT.

   - /Bit shifting/ is ALWAYS
     + sign-extending on /signed integer types/

     + zero-extending on /unsigned integer types/.

     Since Rust has /unsigned integers/, it does NOT need Java's ~>>>~ operator.

   - *UNLIKE C*, =TODO=
     /Bitwise operations/ have _higher PRECEDENCE_ than comparisons,
     unlike C, so if you write ~x & BIT != 0~ , that means ~(x & BIT) != 0~ , as
     you probably intended.
       This is much more useful than C's interpretation, ~x &(BIT != 0)~ , which
     tests the wrong bit!

** DONE Assignment 138
   CLOSED: [2018-05-23 Wed 22:36]
   - /assignment/ *moves* values of /non-copyable types/.

   - You _cannot_ make a chain of element assignment, and there -- the rightmost
     one will return a ~()~

   - Rust doesn't have ~++~ and ~--~
** TODO Type Casts 139
** DONE Closures - 140
   CLOSED: [2018-05-23 Wed 22:40]
   - Example:
     ~let is_even = |x| x % 2 == 0~

   - The body must a /brace block/.
** TODO Precedence and Associativity - 140 =TODO=
** DONE Onward - 142
   CLOSED: [2018-05-23 Wed 22:43]
   
* TODO 7. Error Handling - 145
  - There are two kinds of errors-handling in Rust:
    + /panic/

    + ~Results~

  - Ordinary errors are handled using ~Result~'s.

    These are typically caused by things _outside_ the program, and such situations
    occur is NOT up to us; even a bug-free program will encounter them from time to
    time. For instance, erroneous input, a network outage, or a permissions problem.

    =TODO=
    Most of this chapter is dedicated to that kind of error.

  - /Panic/ is for the other kind of error, the kind that *should NEVER happen*.

** DONE Panic - 145
   CLOSED: [2018-06-04 Mon 17:23]
   - A program /panics/ when it encounters something so messed up that there MUST
     BE a _bug_ in the program itself. Something like:
     + Out-of-bounds array access

     + Integer division by zero

     + Calling ~.unwrap()~ on an Option that happens to be ~None~

     + Assertion failure

     + the /macro/ ~panic!()~, for cases where your own code find some inconsistency
       during the calculation and discovers that it has gone wrong, and therefore
       need to trigger a /panic/ directly by your code, the ~panic!()~.

       * ~panic!()~ accepts optional ~println!()~-style arguments, for building
         an error message.

   - Check the examples given above, you see that /panics/ are programmer's fault!

   - When a /panic/ happen, Rust gives you a choice:
     + *unwind* the /stack/, which is the *default*!

     + *abort* the /process/

*** TODO Unwinding - 146
    - =EN=
      + pirates divvy up the booty from a raid - 海盜們從突襲中分出戰利品

      + loot - 贓物

    - =TODO= NOTE

    - /Panic/ is _NOT crash_!

      /Panic/ is _NOT undefined behavior_!

    - /Panic/ is more like Java's ~RuntimeException~, or C++'s ~std::logic_error~.

    - The behavior of a /panic/ is *well-defined*;
      it just *shouldn't be happening*!

    - /Panic/ is *safe*!
      It doesn't violate any of Rust's safety rules!

      The idea is that Rust catches the invalid operations, or whatever it is,
      *before* anything bad happens. Since it would be unsafe to proceed, so Rust
      _unwinds the stack_. But the rest of the process can continue running.

    - /Panic/ is *per* /thread/.
      =IMPORTANT=
      =TODO= In Chapter 19, we'll show how a parent thread can find out when a
      child thread panics and handle the error gracefully.

    - There is also a way to *catch* /stack unwinding/, _allowing_ the /thread/
      to *survive and continue running*.
        The standard library function ~std::panic::catch_unwind()~ does this.

        We won't cover how to use it, but this is the mechanism used by Rust's
      /test/ harness to *recover* when an /assertion fails/ in a /test/. (It can
      also be necessary when writing Rust code that can be called from C or C++,
      because *unwinding across non-Rust code is undefined behavior*; =TODO= see
      Chapter 21.) =IMPORTANT=

*** TODO Aborting - 147

** TODO Result - 148
   - Rust does NOT have /exception/!
     Instead, /functions/ that can fail have a /return type/ that says so.
     For instance,
     ~fn get_weather(location: LatLng) -> Result<WeatherReport, io::Error>~

*** DONE Catching Errors - 148
    CLOSED: [2018-06-10 Sun 13:42]
    - Pattern matching is the most thorough way of dealing with a ~Result~.
      It is the equivalent of ~try/catch~ in other languages.

    - ~match~ is a bit verbose, so ~Result<T, E>~ offers a variety of /methods/
      that are useful in particular common cases. Each of these /methods/ has a
      ~match~ expression in its implementation.

      + ~result.is_ok()~ and ~result.is_err()~

      + ~result.ok()~ returns the success value, if any, as an ~Option<T>~.

      + ~result.err()~ returns the error value, if any, as an ~Option<E>~.

      + ~result.unwrap_or(fallback)~ returns the success value, if ~result~ is a
        success result. Otherwise, it returns ~fallback~, discarding the error
        value.

        If you have a appropriate fallback value, this is a good alternative to
        ~.ok()~ because the /return type/ is ~T~, not ~Option<T>~.

      + ~result.unwrap_or_else(fallback_fn)~ returns the success value, ...
        This is good for the case that the computation of the ~fallback~ value is
        costly.

      + ~result.unwrap()~ returns the success value, or panic if the ~result~ is
        an error.

      + ~result.expect(message)~ is similar to the ~unwrap~ method, but with an
        error message in case of panic.

      + Two /methods/ for /borrowing references/ to the value in a ~Result~:
        * ~result.as_ref()~ converts a ~Result<T, E>~ to a ~Result<&T, &E>~,
          borrowing a reference to the success or error value in the existing
          ~result~.

        * ~result.as_mut()~
          ~Result<&mut T, &mut E>~

        These two /methods/ are very useful -- all the other /methods/ introduced
        here, except the ~result.is_ok()~ and the ~result.is_err()~ consumes the
        ~self~, this may not be what you want.

*** DONE Result Type Aliases - 150
    CLOSED: [2018-06-10 Sun 13:46]
    Sometimes you may see a type like ~Result<()>~, which means this ~Result~ /type
    alias/ is being used.

    ~pub type Result<T> = result::Result<T, Error>;~. This example is in the /module/
    of ~std::io~, and the ~Error~ is the ~std::io::Error~.

*** DONE Printing Errors - 150
    CLOSED: [2018-06-10 Sun 14:08]
    Sometimes the only way to handle an error is by dumping it to the terminal and
    moving on.

    - All the errors, such as ~std::io::Error~, ~std::fmt::Error~, and
      ~std::str::Utf8Error~, implement the ~std::error:Error~ /trait/, which means
      they share the following features:
      + Use ~{}~ format specifier to display a brief error message.
        Use ~{:?}~ format specifier to display a ~Debug~ view of the error.

      + ~err.description()~ returns an error message as a ~&str~.

      + ~err.cause()~ returns an ~Option<&Error>~: the underlying error, if any,
        that triggered ~err~.

        =RE-READ= More details!!!

    - Printing an error value does NOT also print out its cause.

      If you want to be sure to print all the available information, use this function:
      #+BEGIN_SRC rust
        use std::error::Error;
        use std::io::{Write, stderr};

        /// Dump an error message to `stderr`.
        ///
        /// If another error happens while building the error message or
        /// writing to `stderr`, it is ignored.
        fn print_error(mut err: &Error) {
            let _ = writeln!(stderr(), "error: {}", err);
            while let Some(cause) = err.cause() {
                let _ = writeln!(stderr(), "caused by: {}", cause);
                err = cause;
            }
        }
      #+END_SRC

    - The standard library's error types do NOT include a /stack trace/,

      but the ~error-chain~ *crate* makes it easy to define your own custom
      error type that supports grabbing a /stack trace/ when it's created.

      It uses the ~backtrace~ /crate/ to capture the stack.

*** TODO Propagating Errors - 152
*** TODO Working with Multiple Error Types - 153
*** TODO Dealing with Errors That "Can't Happen" - 155
*** TODO Ignoring Errors - 156
*** TODO Handling Errors in ~main()~ - 156
*** TODO Declaring a Custom Error Type - 157
*** DONE Why Results? - 158
    CLOSED: [2018-06-10 Sun 14:19]
    Here are the key points of the design:
    + Rust requires the programmer to make some sort of decision, and record it in the
      code, at every point where an error could occur. This is good because otherwise,
      it's easy to get error handling wrong through neglect.
      =SIMPIFY THIS NOTE=

      =From Jian= You cannot neglect it, but much better than Java's /checked
      exception/.

    + Use ~?~ to do error propagation.
      Thus error plumbing does not clutter up your code the way it does in C and Go.
      Yet it's still visible.

    + Since the possibility of errors is part of every function's /return type/,
      it's clear which functions can fail and which can't.
      =From Jian= It is visible, but much better than Java's /checked exception/.

      If you change a function to be fallible, you're _changing_ its /return type/,
      so the compiler will make you update that function's downstream users.

    + Rust checks that ~Result~ values are used, so you can't accidentally let an
      error pass silently (a common mistake in C).

    + Since ~Result~ is a data type like any other, it's easy to store success and
      error results in the same collection. _This makes it easy to model PARTIAL
      success._
        For example, if you’re writing a program that loads millions of records
      from a text file, and you need a way to cope with the likely outcome that
      most will succeed, but some will fail, you can represent that situation in
      memory using a vector of ~Result~'s.

* TODO 8. Crates and Modules - 161
  - This chapter covers the features of Rust that help keep your program organized:
    /crates/ and /modules/.

  - We'll also cover a wide range of topics that come up naturally as your project
    grows, including
    + how to *document* and *test* Rust code,
    + how to *silence* unwanted /compiler warnings/,
    + how to use Cargo to *manage* project /dependencies/ and /versioning/,
    + how to *publish* open source libraries on _crates.io_, and more.

** DONE Crates - 161
   CLOSED: [2018-06-04 Mon 03:34]
   - Rust programs are made of /creates/.

   - Each /crate/ is a /Rust project/:
     + all the source code for a single library or executable

     + plus
       * any associated tests
       * examples
       * tools
       * configuration
       * other things.

   - Later on, we'll see how to tell Cargo to fetch source code from
     + a /Git repository/
       OR 
     + the /local filesystem/ rather than /crates.io/.

   - Once it has obtained all the source code, Cargo compiles all the crates.
     It runs ~rustc~, the Rust compiler, _ONCE_ for each /crate/ in the
     project's dependency graph.

     + When compiling libraries, Cargo uses the =--crate-type lib= option.
       This tells ~rustc~ _NOT_ to look for a ~main()~ function _BUT_ instead to
       produce an =.rlib= file containing compiled code in a form that later
       ~rustc~ commands can use as input.

       When compiling a program, Cargo uses ~--crate-type bin~, and the result
       is a binary executable for the target platform: =mandelbrot.exe= on
       Windows, for example.

   - =TODO= NOTE !!!
   - =TODO= NOTE !!!
   - =TODO= NOTE !!!

   - ~cargo build~ supports all sorts of options, most of which are beyond the
     scope of this book, but we will mention one here:
     ~cargo build --release~ produces an optimized build.

     + Release builds run faster,

     + but
       * they take _longer_ to compile,

       * they _don't check_ for /integer overflow/,

       * they _skip_ ~debug_assert!()~ assertions, and

       * the /stack traces/ they generate on /panic/ are generally *less* reliable.

*** DONE Build Profiles - 164
    CLOSED: [2018-06-04 Mon 03:34]
    - There are several _configuration settings_ you can put in your =Cargo.toml=
      file that affect the ~rustc~ command lines that ~cargo~ generates.
      | Command line            | Cargo.toml section used |
      |-------------------------+-------------------------|
      | ~cargo build~           | ~[profile.debug]~       |
      | ~cargo build --release~ | ~[profile.release]~     |
      | ~cargo test~            | ~[profile.test]~        |

    - The *defaults* are usually fine,
      but one _EXCEPTION_ we've found is when you want to use a /profiler/ -- a
      tool that measures where your program is spending its CPU time. 

      + To get the best data from a /profiler/, you need both
        * optimizations (usually enabled ONLY in release builds)
        * debug symbols (usually enabled ONLY in debug builds).

      To enable both, add this to your =Cargo.toml=:
      #+BEGIN_SRC toml
        [profile.release]
        debug = true  # enable debug symbols in release builds
      #+END_SRC
      + The ~debug~ setting controls the =-g= option to =rustc=.

      With this configuration, when you type =cargo build --release=, you'll get
      a binary with /debug symbols/. The optimization settings are unaffected.

    - *The Cargo documentation* lists many other settings you can adjust.
      =TODO= =IMPORTANT= =READ=

** DONE Modules - 165
   CLOSED: [2018-06-04 Mon 14:36]
   - modules :: Rust's namespaces.

   - /Modules/ are containers for the /functions/, /types/, /constants/, and so on
     that make up your Rust program or library.

     Whereas /crates/ are about code sharing *between* projects, modules are about
     code organization *within* a project. The look like:
     #+BEGIN_SRC rust
       mod spores {
           use cells::Cell;

           /// A cell mode by an adult fern. It disperses on the wind as part of
           /// the fern life cycle. A spore grows into a prothallus -- a whole
           /// separate organism, up to 5mm across -- which produces the zygote
           /// that grows into a new fern. (Plant sex is complicated.)
           pub struct Spore {
               // ...
           }

           // Simulate the production of a spore by meiosis.
           pub fn produce_spore(factory: &mut Sporangium) -> Spore {
               // ...
           }

           // Mix genes to prepare for meiosis (part of interphase).
           fn recombine(parent: &mut Cell) {
               // ...
           }

           // ...
       }
     #+END_SRC

   - Anything that isn't marked ~pub~ is /private/.

   - /Modules/ can _nest_.
     It's fairly common to see a /module/ that's just a collection of /submodules/.
     #+BEGIN_SRC rust
       mod plant_structures {
           pub mod roots {
               // ...
           }

           pub mod stems {
               // ...
           }

           pub mod leaves {
               // ...
           }
       }
     #+END_SRC

*** DONE Modules in Separate Files - 166
    CLOSED: [2018-06-04 Mon 13:18]
    - A module can also be written like this:
      ~mod spores;~

      This tells the compiler that the ~spores~ /module/ lives in a separate file,
      called =spores.rs=:

    - Rust _NEVER_ compiles /modules/ separately, even if they're in separate files:
      when you build a Rust /crate/, you're *recompiling* _ALL_ of its /modules/.

    - A /module/ can have _its own directory_.

      When Rust sees ~mod spores;~, it checks for both =spores.rs= and =spores/mod.rs;=
      *if neither file exists, or both exist, that's an error.*

    - For example (the earlier example ~plant_structures~)
      + Directory Structure:
        #+BEGIN_SRC text
          fern_sim/
          ├── Cargo.toml
          └── src/
              ├── main.rs
              ├── spores.rs
              └── plant_structures/
                  ├── mod.rs
                  ├── leaves.rs
                  ├── roots.rs
                  └── stems.rs
        #+END_SRC

      + Declare /modules/ 
        Declare ~pub mod plant_structures;~ in the =main.rs= causes Rust to load
        =plant_structures/mod.rs=, which declares the three /submodules/:
        #+BEGIN_SRC rust
          // in plant_structures/mod.rs
          pub mod roots;
          pub mod stem;
          pub mod leaves;
        #+END_SRC

        The content of those three /modules/ is stored in separate files named
        =leaves.rs=, =roots.rs=, and =stem.rs=, located alongside =mod.rs= in the
        =plant_structures= directory.

*** DONE Paths and Imports - 167
    CLOSED: [2018-06-04 Mon 13:43]
    - ~::~ is used to access features of a /module/.
      Code anywhere in your project can refer to any standard library feature by
      writing out its /absolute path/:
      #+BEGIN_SRC rust
        if s1 > s2 {
            ::std::mem::swap(&mut s1, &mut s2);
        }
      #+END_SRC
      + It is obvious we have a function call.
        Since it starts with a double colon, it is an absolute path.

        * The path ~::std~ refers to the /top-level module/ of the standard
          library.

        * ~::std::mem~ is a /submodules/ within the standard library, and
          ~::std::mem::swap~ is a /public function/ in that /module/.

    - You can /import/ features into the modules where they're used with ~use~:
      #+BEGIN_SRC rust
        use std::mem;

        if s1 > s2 {
            mem::swap(&mut s1, &mut s2);
        }
      #+END_SRC
      + /Paths/ in ~use~ declarations are automatically /absolute paths/, so there
        is no need for a leading ~::~.

    - /Import/ multiple features at once:
      + ~use std::collections::{HashMap, HashSet};~
      + ~use std::io::prelude::*;~

    - /Modules/ do not automatically inherit names from their /parent modules/.
      For example, suppose we have this in our =proteins/mod.rs=:
      #+BEGIN_SRC rust
        // proteins/mod.rs
        pub enum AminoAcid { ... }
        pub mod synthesis;
      #+END_SRC
      Then the code in =synthesis.rs= does NOT automatically see the type ~AminoAcid~.
      Instead, each module starts with a black slate and must import the names it
      uses:
      #+BEGIN_SRC rust
        // proteins/synthesis.rs
        use super::AminoAcid;  // explicitly import from parent

        pub fn synthesize(seq: &[AminoAcid]) // ...
      #+END_SRC

    - As in the example above, ~super~ is used to access the /parent module/.

    - ~self~ is used to represent /current module/, and you may use it to import
      /current modules/' /submodules/' features:
      #+BEGIN_SRC rust
        // in protein/mod.rs

        // import from a submodule
        use self::synthesis::synthesize;

        // import names from an enum,
        // so we can write `Lys` for lysine, rather than `AminoAcid::Lys`
        use self::AminoAcid::*;
      #+END_SRC

    - Use ~self~ and ~super~ to write /relative paths/.

    - /Submodules/ *can access* /private items/ in their /parent modules/, but they
      have to *import each one by name*.

      use ~super::*;~ ONLY imports items that are marked ~pub~.

    - There is a natural analogy between /modules/ and the /files and
      directories/ of a /Unix filesystem/.
      + ~super~ like ~..~
      + ~self~ like ~.~
      + ~use~ like ~ln~
      + ~extern crate~ like mount a filesystem

*** DONE The Standard Prelude - 169
    CLOSED: [2018-06-04 Mon 13:50]
    - The standard library ~std~ is *automatically* linked with every project.
      It's as though your =lib.rs= or =main.rs= contained an _invisible declaration_
      for it: ~extern crate std;~

    - The /standard prelude/, where is the place ~Vec~ and ~Result~ reside, is
      automatically imported.
        Rust behaves as though every /module/, including the /root module/, started
      with the following import: ~use std::prelude::v1::*;~

    - Naming a /module/ ~prelude~ is just a _convention_ that tells users it's
      meant to be imported using ~*~.
        Ususlly, this is the only use of ~*~, which is encouraged.

*** DONE Items, the Building Blocks of Rust - 170 =RE-READ=
    CLOSED: [2018-06-04 Mon 14:35]
    - A /module/ is made up of /items/.

    - There are several kinds of /item/, and the list is really a list of the
      language's major features:
      + Functions

      + Types =TODO= =RE-READ=
        * User-defined types are introduced using the ~struct~, ~enum~, and ~trait~
          keywords. =TODO= We'll dedicate a chapter to each of them.

        * A /struct's fields/, even /private fields/, are accessible *throughout*
          the /module/ where the /struct/ is declared.

          *Outside* the /module/, only /public fields/ are accessible.

        * It turns out that *enforcing /access control/ by /module/,* rather than
          by /class/ as in Java or C++, is surprisingly helpful for software design.
          - It cuts down on boilerplate /getter/ and /setter/ methods.

          - it largely eliminates the need for anything like C++ ~friend~ declarations.

          - A single /module/ can define several types that work closely together,
            such as perhaps ~frond::LeafMap~ and ~frond::LeafMapIter~, accessing
            each other's /private fields/ as needed, while still hiding those
            implementation details from the rest of your program.

      + Type aliases
        The Rust's ~type~ keyword is like the ~typedef~ in C++.
        ~type Table = HashMap<String, Vec<String>>;~

      + ~impl~ blocks
        It is used to attach /methods/ to /types/.
        For instance,
        #+BEGIN_SRC rust
          impl Cell {
              pub fn distance_from_origin(&self) -> f64 {
                  f64::hypot(self.x, self.y)
              }
          }
        #+END_SRC
        + ~impl~ blocks *CANNOT* be marked ~pub~.

        + /individual methods/ can be marked ~pub~ to make them visible outside
          the current /module/.

        + /Private methods/, like /private struct fields/, are *visible throughout
          the /module/ where they're declared.*

      + Constants =RE-READ=
        The ~const~ keyword introduces a constant.
        The syntax is just LIKE ~let~ except that it may be marked ~pub~, and
        the /type/ is *required*.

        * Uppercase names are conventional for constants.
          For instance: ~pub const ROOM_TEMPERATURE: f64 = 20.0; // Celsius~

        * The ~static~ keyword introduces a /static item/, which is nearly the
          same thing: ~pub static ROOM_TEMPERATURE: f64 = 68.0; // Fahrenheit~

        * A constant is a bit like a C++ ~#define:~ the value is compiled into
          your code every place it's used.

          A ~static~ is a variable that's set up *before* your program starts
          running and lasts until it exits.

        * Use /constants/ for /magic numbers and strings/ in your code.

          Use /statics/ for larger amounts of data, or any time you'll need to
          /borrow a reference/ to the constant value. =TODO= =???=

          =TODO=
          =From Jian=  What are the restrictions for ~const~ and ~static~ values???

        * /constants/ cannot be marked as ~mut~.

          /statics/ can be marked as ~mut~, but as discussed in Chapter 5 =TODO=,
          Rust has no way to enforce its rules about exclusive access on ~mut
          statics~ -- which means a /mut static/ is inherently *non-thread-safe*,
          and /safe code/ cannot use them at all:
          #+BEGIN_SRC rust
            static mut PACKETS_SERVED: usize = 0;
            println!("{} served", PACKETS_SERVED);  // error: use of mutable static
          #+END_SRC

          - Rust discourages global mutable state. For a discussion of the alternatives,
            see "Global Variables" on page 496. =TODO=

      + Modules
        A /module/ can contain /submodules/.
        It can be /public/ or /private/, like any other named item.

      + Imports
        ~use~ and ~extern crate~ declarations are /items/ too.

        Even though they're just aliases, they can be ~pub~!
        #+BEGIN_SRC rust
          // in plant_structures/mod.rs
          // ...
          pub use self::leaves::Leaf;
          pub use self::roots::Root;
        #+END_SRC
        * This means that ~Leaf~ and ~Root~ are /public items/ of the ~plant_structures~
          /module/. They're still simple aliases for ~plant_structures::leaves::Leaf~
          and ~plant_structures::roots::Root~.

        * Another example,
          The /standard prelude/ is written as just such a series of ~pub~ imports.

      + ~extern~ blocks
        Declare a collection of functions written in some other language
        (typically C or C++), and that your Rust code can call them.
        =TODO= See Chapter 21

    - Rust *warns* about /items/ that are _declared_, but _never used_:
      For example,
      #+BEGIN_SRC text
        warning: function is never used: `is_square`
          --> src/crates_unused_items.rs:23:9
           |
        23 | /         pub fn is_square(root: &Root) -> bool {
        24 | |             root.cross_section_shape().is_square()
        25 | |         }
           | |_________^
           |
      #+END_SRC
      This warning can be puzzling, because there are _TWO_ very different
      possible causes:
      + Perhaps this function really is dead code at the moment.
        OR
      + Maybe you meant to use it in other /crates/. =TODO= =TODO= =TODO=
        In that case, you need to *mark it and all enclosing modules as public.*

** DONE Turning a Program into a Library - 172
   CLOSED: [2018-06-04 Mon 17:44]
   You have a executable, and you want to add more facilities.

   You first want to factor out some of functionalities from the executable to a
   /library/.

   - The first step is to factor your existing project into _two_ parts:
     + a /library crate/, which contains all the shared code;

     + an /executable/, which contains the code that's only needed for your existing
       command-line program.

   - Read the (grossly simplified) original code:
     #+BEGIN_SRC rust
       struct Fern {
           size: f64,
           growth_rate: f64
       }

       impl Fern {
           /// Simulate a fern growing for one day.
           fn grow(&mut self) {
               self.size *= 1.0 + self.growth_rate;
           }
       }

       /// Run a fern simulation for some number of days.
       fn run_simulation(fern: &mut Fern, days: usize) {
           for _ in 0 .. days {
               fern.grow();
           }
       }

       fn main() {
           let mut fern = Fern {
               size: 1.0,
               growth_rate: 0.001
           };
           run_simulation(&mut fern, 1000);
           println!("final fern size: {}", fern.size);
       }
     #+END_SRC
     + Assume you have a trivial =Cargo.toml= file:
       #+BEGIN_SRC toml
         [package]
         name = "fern_sim"
         version = "0.1.0"
         authors = ["You <you@example.com>"]
       #+END_SRC

   - Turning this program into a library is easy. Here are the STEPS:
     1. *Rename* the file =src/main.rs= to =src/lib.rs=.

     2. *Add* the ~pub~ keyword to items in =src/lib.rs= that will be public features
        of our library.

     3. *Move* the ~main~ function to a temporary file somewhere.
        =TODO=
        We'll come back to it in a minute.

     The resulting =src/lib.rs= file looks like this:
     #+BEGIN_SRC rust
       pub struct Fern {
           pub size: f64,
           pub growth_rate: f64
       }

       impl Fern {
           /// Simulate a fern growing for one day.
           pub fn grow(&mut self) {
               self.size *= 1.0 + self.growth_rate;
           }
       }

       /// Run a fern simulation for some number of days.
       pub fn run_simulation(fern: &mut Fern, days: usize) {
           for _ in 0 .. days {
               fern.grow();
           }
       }
     #+END_SRC

   - We did nothing to the =Cargo.toml= file.
     By default, =cargo build= looks at the files in our source directory and
     figures out what to build. When it sees the file =src/lib.rs=, it knows to
     build a library.

   - The code in =src/lib.rs= forms the /root module/ of the library.
     Other /crates/ that USE our /library/ can ONLY access the /public items/ of
     this /root module/.

** DONE The =src/bin= Directory - 174
   CLOSED: [2018-06-04 Mon 17:58]
   - *Cargo has some built-in support for _small programs_ that live in the SAME
     codebase as a library.*

   - You can put our program and our library in the same codebase.
     Move the ~main~ function code to the file =src/bin/efern.rs=:
     #+BEGIN_SRC rust
       extern crate fern_sim;
       use fern_sim::{Fern, run_simulation};

       fn main() {
           let mut fern = Fern {
               size: 1.0,
               growth_rate: 0.001
           };

           run_simulation(&mut fern, 1000);
           println!("final fern size: {}", fern.size);
       }
     #+END_SRC

   - Because we've put this file into =src/bin=, the next time we run =cargo build=,
     Cargo will compile _BOTH_
     + the ~fern_sim~ library
       and
     + this program

   - Then you can run the ~efern~ program using =cargo run --bin efern=.
     Use =--verbose= to show the commands Cargo is running:
     #+BEGIN_SRC bash
       #$
       cargo build --verbose
       #Compiling fern_sim v0.1.0 (file:///.../fern_sim)
       #  Running `rustc src/lib.rs --crate-name fern_sim --crate-type lib ...`
       #  Running `rustc src/bin/efern.rs --crate-name efern --crate-type bin ...`

       #$
       cargo run --bin efern --verbose
       #    Fresh fern_sim v0.1.0 (file:///.../fern_sim)
       #  Running `target/debug/efern`

       # final fern size: 2.7169239322355985
     #+END_SRC

   - This time, we still didn't have to make any changes to =Cargo.toml=.
     Thanks to the Cargo default behavior -- it automatically treats =.rs= files
     in =src/bin= as extra programs to build.

   - If you decide to put the executable to its own isolated project, in a
     completely separate directory, you need to add a =Cargo.toml= listing
     ~fern_sim~ as a dependency (suppose these two projects in reside in the
     same directory):
     #+BEGIN_SRC toml
       [dependencies]
       fern_sim = { path = "../fern_sim" }
     #+END_SRC

** DONE Attributes - 175
   CLOSED: [2018-06-04 Mon 18:30]
   Any /item/ in a Rust program can be decorated with /attributes/.

   - /Attributes/ are Rust's catch-all syntax for writing
     + miscellaneous instructions
       and
     + advice to the compiler.

     =From Jian= This is like Java's /annotations/.

   - For example, suppose you're getting this warning:
     + You see a warning like:
       #+BEGIN_SRC text
         libgit2.rs: warning: type `git_revspec` should have a camel case name
             such as `GitRevspec`, #[warn(non_camel_case_types)] on by default
       #+END_SRC

       But you chose this name for a reason, and you wish Rust would shut up about
       it. You can use ~#[allow]~:
       #+BEGIN_SRC rust
         #[allow(non_camel_case_types)]
         pub struct git_revspec {
             // ...
         }
       #+END_SRC

     + /Canditional compilation/ is another feature that's written using an /attribute/,
       the ~#[cfg]~:
       #+BEGIN_SRC rust
         // Only include this module in the project if we're building for Android.
         #[cfg(target_os = "android")]
         mod mobile;
       #+END_SRC

   - You can find a COMPREHENSIVE /attributes/ usage in the *Rust Reference*.
     =TODO= The most commonly used options for ~#[cfg]~ are listed here:
     =TODO= table.

   - The ~#[inline]~ /attribute/.
     #+BEGIN_SRC rust
       /// Adjust levels of ions etc. in two adjacent cells
       /// due to osmosis between them.
       #[inline]
       fn do_osmosis(c1: &mut Cell, c2: &mut Cell) {
           // ...
       }
     #+END_SRC

     + There's one situation where /inlining/ _WON'T happen WITHOUT_ ~#[inline]~.

       When a function or method defined in one /crate/ is _called in another_
       /crate/, Rust WON'T /inline/ it UNLESS
       * it's /generic/ (it has /type parameters/)
         OR 
       * it's explicitly marked ~#[inline]~.

   - This ~#[inline]~ is only a suggestion.
     Rust also supports
     + the more insistent ~#[inline(always)]~;
     + never /inline/ ~#[inline(never)]~.

   - Some /attributes/, like ~#[cfg]~ and ~#[allow]~, can be attached to _a *whole*
     module_ and _apply to everything in it_.

     Others, like ~#[test]~ and ~#[inline]~ , must be attached to _individual_
     /items/.

   - The Rust Reference documents *the full set of supported attributes* in detail.

   - To attach an attribute to _a *whole* crate_, add it at the top of the =main.rs=
     or =lib.rs= file, *before* any /items/, and write ~#!~ instead of ~#~ , like
     this:
     #+BEGIN_SRC rust
       // libgit2_sys/lib.rs
       #![allow(non_camel_case_types)]

       pub struct git_revspec {
           // ...
       }

       pub struct git_error {
           // ...
       }
     #+END_SRC
     + The ~#!~ tells Rust to attach an /attribute/ to the _ENCLOSING_ /item/ rather
       than whatever comes next: in this case, the ~#![allow]~ /attribute/ attaches
       to the _WHOLE_ ~libgit2_sys~ crate, *not just* /struct/ ~git_revspec~.

   - ~#!~ can also be used *inside* /functions/, /structs/, and so on, *but it's
     only TYPICALLY used at the beginning of a file*, to attach an /attribute/ to
     the *whole* /module/ or /crate/.

     Some /attributes/ always use the ~#!~ syntax because they can *only be applied
     to a WHOLE /crate/.*

   - For example, the ~#![feature]~ attribute is used to *turn on* /unstable features/
     of the Rust language and libraries, /features/ that are EXPERIMENTAL, and therefore
     might _have bugs_ or might be _changed or removed in the future_.

     For instance, as we're writing this, Rust has experimental support for
     128-bit integer types ~i128~ and ~u128~ ; but since these types are
     experimental, you can only use them by

     + installing the Nightly version of Rust
       and
     + explicitly declaring that your crate uses them:
       #+BEGIN_SRC rust
         #![feature(i128_type)]

         fn main() {
             // Do my math homework, Rust!
             println!("{}", 9204093811595833589_u128 * 19973810893143440503_u128);
         }
       #+END_SRC

     Over time, the Rust team sometimes /stabilizes/ an /experimental feature/, so
     that it becomes a standard part of the language. The ~#![feature]~ /attribute/
     then becomes superfluous, and Rust generates a warning advising you to remove
     it.

** TODO Tests and Documentation - 178
   - tests :: /ordinary functions/ marked with the ~#[test]~ /attribute/.

   - For example,
     #+BEGIN_SRC rust
       #[test]
       fn math_works() {
           let x: i32 = 1;
           assert!(x.is_positive());
           assert!(x + 1, 2);
       }
     #+END_SRC

     Use ~cargo test~ to run all the tests.
     #+BEGIN_SRC bash
       #$
       cargo test
       #   Compiling math_test v0.1.0 (file:///.../math_test)
       #     Running target/release/math_test-e31ed91ae51ebf22
       #
       # running 1 test
       # test math_works ... ok
       #
       # test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
     #+END_SRC
     =TODO= You'll also see some output about “doc-tests,” which we’ll get to in
     a minute.

   - This works the same whether your /crate/ is an /executable/ or a /library/.

   - Use command like =cargo test math= to run tests that contains the word "math".

   - ~assert!(expr)~

   - ~assert_eq!(v1, v2)~ is just like ~assert!(v1 == v2)~,
     except that if the /assertion/ fails, the error message shows both values.

   - ~assert!~ and ~assert_eq!~ are even used in /release builds/.

     Use ~debug_assert!~ and ~debug_assert_eq!~ if you only want them in /debug
     builds/.

   - To TEST error cases, add the ~#[should_panic]~ /attribute/ to your test to
     specify the error that should happen:
     #+BEGIN_SRC rust
       /// This test passes only if division by zero causes a panic
       /// as we claimed in the previous chapter.

       #[test]
       #[should_panic(expected="divide by zero")]
       fn test_divide_by_zero_error() {
           1 / 0; // should panic!
       }
     #+END_SRC

   - =cargo build --release= skip the testing code.

   - By convention, when your tests get substantial enough to require support
     code, is to put them in a ~tests~ /module/ and declare the WHOLE /module/
     to be testing-only using the ~#[cfg(test)]~ /attribute/:
     #+BEGIN_SRC rust
       #[cfg(test)]
       // include this module only when testing
       mod tests {
           fn roughly_equal(a: f64, b: f64) -> bool {
               (a - b).abs() < 1e-6
           }

           #[test]
           fn trig_works() {
               use std::f64::consts::PI;
               assert!(roughly_equal(PI.sin(), 0.0));
           }
       }
     #+END_SRC

   - /Rust's test/ harness uses _multiple threads_ to run several tests at a time,
     a nice side benefit of your Rust code being *thread-safe by default*.

     To disable this,
     + either run a single test, =cargo test testname=;
       or
     + set the /environment variable/ ~RUST_TEST_THREADS~ to ~1.~



*** TODO Integration Tests - 180
*** TODO Documentation - 181
*** TODO Doc-Tests - 182

** DONE Specifying Dependencies - 185
   CLOSED: [2018-06-04 Mon 20:14]
   - =EN=
     nuanced - 细微差别的

   - Several ways to specify dependencies:
     + NOT published on crate.io
       For instance, specify a Git repository URL and revision:
       ~image = { git = "https://github.com/Piston/image.git", rev = "528f19c" }~

       * As shown here, you can specify the particular ~rev~, ~tag~ , or ~branch~
         to use. (These are all ways of telling Git which revision of the source
         code to check out.)

     + Specify a directory that contains the crate's source code:
       ~image = { path = "vendor/image" }~

*** DONE Versions - 186
    CLOSED: [2018-06-04 Mon 20:09]
    - Cargo interprets the library /crates/ versions info in =Cargo.toml= *rather
      loosely*.

    - It uses the most recent version of a /crate/ that considered compatible with
      the given version base on the rules of /Semantic Versioning/.
      =TODO= Details Note

    - Ways to specify versions in a =Cargo.toml= file:
      | Cargo.toml line         | Meaning                                                       |
      |-------------------------+---------------------------------------------------------------|
      | image = "=0.10.0"       | Use only the exact version 0.10.0                             |
      | image = ">=1.0.5"       | Use 1.0.5 or any higher version (even 2.9, if it's available) |
      | image = ">1.0.5 <1.1.9" | Use a version that's higher than 1.0.5, but lower than 1.1.9  |
      | image = "<=2.7.10"      | Use any version up to 2.7.10                                  |

      + Another version specification you'll occasionally see is the wild card ~*~.
        This tells Cargo that any version will do. Unless some other =Cargo.toml=
        file contains a more specific constraint, Cargo will use _the latest
        available version_.

        =TODO=
        See https://doc.rust-lang.org/cargo/reference/publishing.html to learn
        more details.

    - All the above rules mentioned above is a convention that Cargo will use.
      A developer should follow this convention!!!

      If you break the compatibility, you should bump the version!!!

*** DONE ~Cargo.lock~ - 187
    CLOSED: [2018-06-04 Mon 20:14]
    - Rationale: =TODO=

    - Cargo has a built-in mechanism, the first time you build a project, Cargo
      outputs a =Cargo.lock= file that *records* the _exact version_ of every
      /crate/ it used.

    - Cargo upgrade to newer versions only when you tell it to,
      + either by manually bumping up the version number in your =Cargo.toml=

      + or by runing =cargo update=.

    - If your project is an /executable/, you should commit =Cargo.lock= to version
      control. That way, everyone who builds your project will consistently get the
      same versions.

      The HISTORY of your =Cargo.lock= file will record your dependency updates.

** TODO Publishing Crates to crates.io - 188
** DONE Workspaces - 190
   CLOSED: [2018-06-04 Mon 19:48]
   Suppose you have written many /crates/. They live side by side in a SINGLE
   source repository:
   #+BEGIN_SRC text
     fernsoft/
     ├── .git/...
     ├── fern_sim/
     │   ├── Cargo.toml
     │   ├── Cargo.lock
     │   ├── src/...
     │   └── target/...
     ├── fern_img/
     │   ├── Cargo.toml
     │   ├── Cargo.lock
     │   ├── src/...
     │   └── target/...
     └── fern_video/
         ├── Cargo.toml
         ├── Cargo.lock
         ├── src/...
         └── target/...
   #+END_SRC
   Each /crate/ has its own /build directory/, =target=, which contains a separate
   build of all the crate's dependencies.

   These /build directories/ are *completely independent*.

   Even if two crates have a common dependency, they can’t share any compiled
   code.

   - Q :: This is wasteful. Do we have another way?

   - A :: You can save compilation time and disk space by using a Cargo /workspace/,
          a collection of /crates/ that share a COMMON /build directory/ and
          =Cargo.lock= file.
     1. Details:
       * Create a =Cargo.toml= file in your _repository's root directory_ and put
         these lines in it;
         #+BEGIN_SRC toml
           [workspace]
           members = ["fern_sim", "fern_img", "fern_video"]
         #+END_SRC
         =fern_sim=, =fern_img"=, and =fern_video= are your /crate/ directory names.

       * You also need to delete all the =Cargo.lock= files and =target= directories
         that exist in those subdirectories.

     2. Once you've done these steps above, =cargo build= in ANY /crate/ will
        automatically create and use a _shared_ /build directory/ under the root
        directory (in this case, =fernsoft/target=).

        The command =cargo build --all= builds all /crates/ in the CURRENT /workspace/.
        =cargo test= and =cargo doc= accept the =--all= option as well.

** DONE More Nice Things - 191
   CLOSED: [2018-06-04 Mon 19:26]
   In case you're NOT delighted yet, the Rust community has a few more odds and
   ends for you:
   - When you publish an open source /crate/ on *crates.io*, your documentation
     is _AUTOMATICALLY_ rendered and hosted on =docs.rs= thanks to Onur Aslan.

   - If your project is on GitHub, /Travis CI/ can build and test your code on
     EVERY push.

     It's surprisingly easy to set up; see travis-ci.org for details. If you're
     already familiar with Travis, this =.travis.yml= file will get you started:
     #+BEGIN_SRC yaml
       language: rust
       rust:
         - stable
     #+END_SRC

   - You can generate a =README.md= file _from_ your /crate/'s top-level doc-comment.
     This feature is offered as a _third-party Cargo plugin_ by Livio Ribeiro.

     Run =cargo install readme= to install the plugin, then =cargo readme --help=
     to learn how to use it.

   We could go on.

* DONE 9. Structs - 193
  CLOSED: [2018-06-06 Wed 22:19]
  - Rust has *three* kinds of /struct types/:
    + named-field,
    + tuple-like,
    + unit-like,

    which _differ in_ HOW YOU REFER TO THEIR COMPONENTS:
    + a named-field struct gives a name to each component

    + a tuple-like struct identifies them by the order in which they appear

    + a unit-like structs have no components at all; these are not common, but
      more useful than you might think. =TODO= =???=

  - In this chapter, we'll
    + explain each kind in DETAIL

    + show what they look like IN MEMORY.

    + cover
      * HOW to ADD /methods/ to them

      * HOW to DEFINE /generic struct types/ that work with many different component types

      * HOW to ask Rust to GENERATE implementations of common handy /traits/ for
        your /structs/.

** DONE Named-Field Structs - 193
   CLOSED: [2018-06-05 Tue 13:49]
   - Define (by example):
     #+BEGIN_SRC rust
       /// A rectangle of eight-bit grayscale pixels.
       struct GrayscaleMap {
           pixels: Vec<u8>,
           size: (usize, usize)
       }
     #+END_SRC
     + By convention
       * Use CamelCase for the name of /types/.
       * Use snake\under{}case for the name of /fields/ and /methods/.

   - Use (by example):
     #+BEGIN_SRC rust
       let width = 1024;
       let height = 576;
       let image = GrayscaleMap {
           pixels: vec![0; width * height],
           size: (width, height)
       };
     #+END_SRC

     A shorthand for populating fields from local variables or arguments with the
     same name:
     #+BEGIN_SRC rust
       fn new_map(size: (usize, usize), pixels: Vec<u8>) -> GrayscaleMap {
           assert_eq!(pixels.len(), size.8 * size.1);
           GrayscaleMap { pixels, size }
       }
     #+END_SRC

   - A /struct/ and its /fields/ are _private by default_, which means they can
     only be seen in the /module/ where it is defined.

     Use ~pub~ to make a /struct/ public! Don't forget to also add ~pub~ to
     fields.

   - =TODO= The first paragraph of Page 195 =???=

   - Use ~.. EXPR~ to initialize some /fields/ that has not been initialized.
     #+BEGIN_SRC rust
       struct Broom {
           name: String,
           height: u32,
           health: u32,
           position: (f32, f32, f32),
           intent: BroomIntent
       }

       /// Two possible alternatives for what a `Broom` could be working on.
       #[derive(Copy, Clone)]
       enum BroomIntent { FetchWater, DumpWater }

       // Receive the input Broom by value, taking ownership.
       fn chop(b: Broom) -> (Broom, Broom) {
           // Initialize `broom1` mostly from `b`, changing only `height`. Since
           // `String` is not `Copy`, `broom1` takes ownership of `b`'s name.
           let mut broom1 = Broom { height: b.height / 2, .. b };

           // Initialize `broom2` mostly from `broom1`. Since `String` is not
           // `Copy`, we must clone `name` explicitly.
           let mut broom2 = Broom { name: broom1.name.clone(), .. broom1 };

           // Give each fragment a distinct name.
           broom1.name.push_str(" I");
           broom2.name.push_str(" II");

           (broom1, broom2)
       }
     #+END_SRC

** DONE Tuple-Like Structs - 196
   CLOSED: [2018-06-05 Tue 14:01]
   - Example:
     ~struct Bounds(usize, usize);~

     It's like a tuple, but it must be created with the /struct/ name.
     ~let image_bounds = Bounds(1024, 768);~

   - The values held by a tuple-like /struct/ are called /elements/.

   - Access the /elements/ of a tuple just as you would a tuple's:
     ~assert_eq!(image_bounds.0 * image_bounds.1, 786432);~

   - Use ~pub~:
     ~pub struct Bounds(pub usize, pub usize);~

   - The expression ~Bounds(1024, 768)~ _looks like_ a /function call/, and in
     fact it is: defining the type also _implicitly defines_ a function:
     ~fn Bounds(elem0: usize, elem1: usize) -> Bounds { ... }~

   - At the most fundamental level,
     _named-field_ and _tuple-like_ /structs/ are very similar.

   - /Tuple-like structs/ are good for /newtypes/, /structs/ with a single component
     that you define to get stricter type checking. For example, if you are working
     with ASCII-only text, you might define a /newtype/ like this:
     ~struct Ascii(Vec<u8>);~

     Using this /type/ for your ASCII strings is much better than simply passing
     around ~Vec<u8>~ buffers and explaining what they are in the comments.

     =TODO=
     We'll give an example of using /newtypes/ for efficient type conversions in
     Chapter 21.

** DONE Unit-Like Structs - 197
   CLOSED: [2018-06-05 Tue 14:09]
   - Define (by example):
     #+BEGIN_SRC rust
       struct Onesuch;
     #+END_SRC

   - A value of such a type occupies no memory, much like the unit type ~()~.

     Rust doesn't bother actually storing /unit-like struct/ values in memory or
     generating code to operate on them, because it can tell everything it might
     need to know about the value from its type alone.
       But logically, an empty struct is a type with values like any other -- or
     more precisely, a type of which there is only a single value: ~let o = Onesuch;~

   - =TODO= =???= =???= =???= =???= =???= =???= =???= =???= =???=
     You've already encountered a /unit-like struct/ when reading about "Fields
     and Elements” on page 135. Whereas an expression like ~3..5~ is shorthand
     for the /struct value/ ~Range { start: 3, end: 5 }~ , the expression ~..~, a
     range omitting both end-points, is shorthand for the /unit-like struct/
     value ~RangeFull~.

   - =TODO= =TODO= =TODO=
     /Unit-like structs/ can also be useful when working with /traits/, which
     we'll describe in Chapter 11.

** DONE Struct Layout - 197
   CLOSED: [2018-06-05 Tue 14:20]
   - Figure 9-1. A ~GrayscaleMap~ structure in memory

     + UNLIKE C and C++, Rust _doesn't make specific promises_ about how it will
       order a struct's fields or elements in memory;
         Figure 9-1 shows only one possible arrangement.

     + However, Rust does promise to *store fields' values directly* IN the _struct's
       block of memory_.

       Whereas JavaScript, Python, and Java would put the ~pixels~ and ~size~ values
       each in their own heap-allocated blocks and have ~GrayscaleMap~'s fields
       point at them,
       =TODO= =???= =???= =???= =???= =???= =???= =???= =???= =???= =???= =???=
         Rust embeds pixels and size directly in the GrayscaleMap value. Only the
       heap-allocated buffer owned by the pixels vector remains in its own
       block.

   - You can ask Rust to lay out our structures in a way compatible with C and C++,
     using the ~#[repr(C)]~ /attribute/. =TODO= We'll cover this in detail in
     Chapter 21.

** DONE Defining Methods with ~impl~ - 198
   CLOSED: [2018-06-05 Tue 19:16]
   You can define /methods/ on ANY /struct type/ you define in a SEPARATE
   ~impl~ block.
   For example,
   #+BEGIN_SRC rust
     /// A last-in, first-out queue of characters.
     pub struct Queue {
         older: Vec<char>,  // older elements, eldest last.
         younger: Vec<char> // younger elements, youngest last.
     }

     impl Queue {
         pub fn new() -> Queue {
             Queue { older: Vec::new(), younger: Vec::new() }
         }

         /// Push a character onto the back of a queue.
         pub fn push(&mut self, c: char) {
             self.younger.push(c);
         }

         /// Pop a character off the front of a queue. Return `Some(c)` if there
         /// was a character to pop, or `None` if the queue was empty.
         pub fn pop(&mut self) -> Option<char> {
             if self.older.is_empty() {
                 if self.younger.is_empty() {
                     return None;
                 }

                 // Bring the elements in younger over to older, and put them in
                 // the promised order.
                 use std::mem::swap;
                 swap(&mut self.older, &mut self.younger);
                 self.older.reverse();
             }

             // Now older is guaranteed to have something. Vec's pop method
             // already returns an Option, so we're set.
             self.older.pop()
         }
     }
   #+END_SRC

   - /Methods/ are also known as /associated functions/.
     + /static method/: ~new~ -- usage: ~TypeName::method~
     + /instance methods/: ~push~ and ~pop~ -- usage: ~instanceName::method~

   - Rust lets you omit the type, and write ~self~, ~&self~, or ~&mut self~ as
     shorthand for ~self: Queue~, ~self: &Queue~ or ~self: &mut Queue~.

   - UNLIKE C++ and Java, the ~self~ must be used explicitly everytime!

   - _SYNTACTIC SUGAR_:
     Simply writing ~q.push(...)~ _borrows a mutable reference_ to ~q~ , as if
     you had written ~(&mut q).push(...)~, since that's what the ~push~
     /method/'s ~self~ requires.

   - Although you can have many separate ~impl~ blocks for a single type, they
     *MUST* all be in the SAME /crate/ that defines that type.

     =TODO=
     However, Rust does let you attach your own methods to other types; we'll
     explain how in Chapter 11.

   - Pros of separating a type's /methods/ from its definition:
     + It's always easy to find a type's /data members/.

       /Data members/ are NOT mixed with tens of /functoin members/ as in C++.

     + Although one can imagine fitting /methods/ into the syntax for /named-field
       structs/, it's not so neat for /tuple-like and unit-like structs/.
       =From Jian= TODO ??? IMAGINE ??

       Pulling methods out into an ~impl~ block allows a single syntax for all
       three.

     + The same ~impl~ syntax also serves neatly for implementing /traits/, which
       we will go into in Chapter 11.

** DONE Generic Structs - 202
   CLOSED: [2018-06-05 Tue 20:14]
   - For example,
     #+BEGIN_SRC rust
       pub struct Queue<T> {
           older: Vec<T>,
           younger: Vec<T>
       }
     #+END_SRC

     The corresponding ~impl~ block:
     #+BEGIN_SRC rust
       impl<T> Queue<T> {
           pub fn new() -> Queue<T> {
               Queue { older: Vec::new(), younger: Vec::new() }
           }

           pub fn push(&mut self, t: T) {
               self.younger.push(t);
           }

           pub fn is_empty(&self) -> bool {
               self.older.is_empty() && self.younger.is_empty()
           }

           // ...
       }
     #+END_SRC

   - Inside the ~impl~ block of ~Queue<T>~, you can use ~Self~ to represent ~Queue<T>~.

   - In the body of ~new~ you didn't write the /type parameter/ in the construction
     expression; simply writing ~Queue { ... }~ was good enough due to /type inference/
     -- since there is only one type that works for the function's return value.

   - However, you'll always need to supply /type parameters/ in /function signatures/
     and /type definitions/. Rust doesn't infer those; instead, it uses those
     /explicit types/ as the *basis* from which it infers types within function bodies.

   - With the help of /type inference/, you usully don't write code like:
     ~let mut q = Queue::<char>::new();~

     You can write:
     #+BEGIN_SRC rust
       let mut q = Queue::new();
       let mut r = Queue::new();

       q.push("CAD");  // apparently a Queue<&'static str>
       r.push(0.74);   // apparently a Queue<f64>

       q.push("BTC");  // Bitcoins per USD, 2017-5
       r.push(2737.7); // Rust fails to detect irrational exuberance
     #+END_SRC

** DONE Structs with Lifetime Parameters - 203
   CLOSED: [2018-06-05 Tue 21:03]
   For example, here's a structure that might hold references to the greatest
   and least elements of some slice:
   #+BEGIN_SRC rust
     struct Extrema<'elt> {
         greatest: &'elt i32,
         least: &'elt i32
     }

     fn find_extrema<'s>(slice: &'s [i32]) -> Extrema<'s> {
         let mut greatest = &slice[0];
         let mut least = &slice[0];

         for i in 1..slice.len() {
             if slice[i] < *least    { least    = &slice[i]; }
             if slice[i] > *greatest { greatest = &slice[i]; }
         }

         Extrema { greatest, least }
     }
   #+END_SRC
   - Since in the ~find_extrema~ function, the ~'s~ is the only /lifetime/, you
     can write ~fn find_extrema<'s>(slice: &'s [i32]) -> Extrema~ for short.

     You might have meant ~Extrema<'static>~, but that's pretty unusual.
     *Rust provides a shorthand for the common case!*

** DONE Deriving Common Traits for Struct Types - 204
   CLOSED: [2018-06-05 Tue 14:37]
   - After defining a /struct/, you would quickly notice that it's a bit of a pain:
     + you can't print it with ~println!("{:?}", point);~

     + it does NOT support the ~==~ and ~!=~ operators.

     Each of these features has a name in Rust -- ~Copy~, ~Clone~, ~Debug~, and
     ~PartialEq~. They are called /traits/. You can add these features to your
     /struct/:
     #+BEGIN_SRC rust
       #[derive(Copy, Clone, Debug, PartialEq)]
       struct Point {
           x: f64,
           y: f64
       }
     #+END_SRC

   - ~PartialCmp~ can also be derived to support the comparison operators ~<~, ~>~,
     ~<=~, and ~>=~. We haven't done so here, because comparing two points to see
     if one is "less than" the other is actually a pretty weird thing to do.

   - Implementing a /trait/ is automatically a *public* feature, so copyability,
     cloneability, and so forth are all part of your /struct's public API/ and
     should be chosen deliberately. =IMPORTANT=

   - =TODO=
     We'll describe Rust's standard /traits/ in detail, and tell which ones are
     ~#[derive]~ able, in Chapter 13.

** TODO Interior Mutability - 205
   - =EN=
     Interior - 內部

   - /Mutability/ is like anything else:
     in excess, it causes problems, but you often want just a little bit of it.

* DONE 10. Enums and patterns - 211
  CLOSED: [2018-06-06 Wed 22:19]
  - Rust /enumerations/ (simply /enums/) are the analog of /algebraic data types/
    (or known as /sum types/ or /discriminated unions/) in ML and Haskell.

** DONE Enums - 212
   CLOSED: [2018-06-06 Wed 19:59]
   - Simple, C-style enums are straightforward:
     #+BEGIN_SRC rust
       enum Ordering {
           Less,
           Equal,
           Greater
       }
     #+END_SRC
     + The ~Less~, ~Equal~, and ~Greater~ are called /constructors/.

     + /Function/ that use this /enum/:
       #+BEGIN_SRC rust
         use std::cmp::Ordering;

         fn compare(n: i32, m: i32) -> Ordering {
             if n < m {
                 Ordering::Less
             } else if n > m {
                 Ordering::Greater
             } else {
                 Ordering::Equal
             }
         }
       #+END_SRC
       * If you don't want the ~Ordering::~ part, you can ~use std::cmp::Ordering::*;~.
         However, this is NOT recommended.

       * If a /enums/ is in the current module, you can ~use self::EnumName::*;~

   - In memory, values of C-style enums are stored as integers.
     Occasionally it's useful to tell Rust which integers to use:
     #+BEGIN_SRC rust
       enum HttpStatus {
           Ok = 200,
           NotModified = 304,
           NotFound = 404,
           // ...
       }
     #+END_SRC
     Otherwise Rust will assign the numbers for you, starting at 0.

   - By default, Rust stores C-style enums using the smallest built-in integer type
     that can accomodate them.
     #+BEGIN_SRC rust
       use std::mem::size_of;

       assert_eq!(size_of::<Ordering>(), 1);
       assert_eq!(size_of::<HttpStatus>(), 2);  // The number `404` doesn't fit in a `u8`
     #+END_SRC

   - You can override Rust's choice of in-memory representation by adding a ~#[repr]~
     /attribute/ to the /enum/.
     =TODO=
     For details, see Chapter 21.

   - Casting a C-style /enum/ to an integer is allowed:
     ~assert_eq!(HttpStatus::Ok as i32, 200);~

     You cannot cast an integer to a /enum/ with ~as~.
     If you still want this, try
     #+BEGIN_SRC rust
       fn http_status_from_u32(n: u32) -> Option<HttpStatus> {
           match n {
               200 => Some(HttpStatus::Ok),
               200 => Some(HttpStatus::NotModified),
               200 => Some(HttpStatus::NotFound),
               // ...
               _   => None
           }
       }
     #+END_SRC
     or use the ~enum_primitive~ /crate/. =TODO=
     It contains a /macro/ that _autogenerates_ this kind of conversion code for
     you.

   - As with /structs/, the compiler will implement features like the ~==~ operator
     for you, but you have to ask.
     #+BEGIN_SRC rust
       #[derive(Copy, Clone, Debug, PartialEq)]
       enum TimeUnit {
           Seconds, Minutes, Hours, Days, Months, Years
       }
     #+END_SRC

   - /Enums/ can have /methods/, just like /structs/:
     #+BEGIN_SRC rust
       impl TimeUnit {
           /// Return the plural noun for this time unit.
           fn plural(self) -> &'static str {
               match self {
                   TimeUnit::Seconds => "seconds",
                   TimeUnit::Minutes => "minutes",
                   TimeUnit::Hours   => "hours",
                   TimeUnit::Days    => "days",
                   TimeUnit::Months  => "months",
                   TimeUnit::Years   => "years"
               }
           }

           // Return the singular noun for this time unit.
           fn singular(self) -> &'static str {
               self.plural().trim_right_matches('s')
           }
       }
     #+END_SRC

*** DONE Enums with Data - 214 - =Re-Write Notes=
    CLOSED: [2018-06-06 Wed 17:59]
    - Example:
      #+BEGIN_SRC rust
        /// A timestamp that has been deliberately rounded off, so our program
        /// says "6 months ago" instead of "February 9, 2016, at 9:49 AM".
        #[derive(Copy, Clone, Debug, PartialEq)]
        enum RoughTime {
            InThePast(TimeUnit, u32),
            JustNow,
            InTheFuture(TimeUnit, u32)
        }
      #+END_SRC
      The /enum variants/ that takes argument(s) are called /tuple variants/.

    - /Enums/ can also have /struct variants/, which contain /named fields/, just
      like ordinary structs:
      #+BEGIN_SRC rust
        enum Shape {
            Sphere { center: Point3d, radius: f32 },
            Cuboid { corner1: Point3d, corner2: Point3d }
        }

        let unit_sphere = Shape::Sphere { center: ORIGIN, radius: 1.0 };
      #+END_SRC

    - In all, Rust has *three* kinds of /enum variant/,
      echoing the *three* kinds of /struct/ we showed in the previous chapter.
      + /Variants with no data/ correspond to /unit-like structs/.

      + /Tuple variants/ look and function just like /tuple structs/.

      + /Struct variants/ have curly braces and /named fields/.

      *A single /enum/ can have /variants/ of _ALL three_ kinds.*
      #+BEGIN_SRC rust
        enum RelationshipStatus {
            Single,
            InARelationship,
            ItsComplicated(Option<String>),
            ItsExtremelyComplicated {
                car: DifferentialEquation,
                cdr: EarlyModernistPoem
            }
        }
      #+END_SRC

    - All constructors and fields of a public enum are automatically public.

*** DONE Enums in Memory - 215
    CLOSED: [2018-06-06 Wed 19:18]
    - In memory, /enums with data/ are stored as
      + a SMALL /integer tag/
      + enough memory to hold all the /fields/ of the /largest variant/.

    - The /tag field/ is for _Rust's INTERNAL USE_.
      It tells
      1. which /constructor/ created the value
      2. (therefore) which /fields/ it has.

    - As of Rust 1.17, ~RoughTime~ fits in _8 bytes_, as shown in Figure 10-1

      *Rust makes NO PROMISES about enum LAYOUT,* however, in order to leave the
      door open for future optimizations.
        In some cases, it would be possible to pack an /enum/ more efficiently
      than the figure suggests. We'll show later in this chapter how Rust can
      already *OPTIMIZE AWAY the /tag field/ for some enums*.
      =TODO= See the /Generic Enums with ~Box~ types/ in "Generic Enums" section.

*** DONE Rich Data Structures Using Enums - 216
    CLOSED: [2018-06-06 Wed 19:59]
    - Enums are also useful for quickly implementing tree-like data structures.

    - For example, suppose a Rust program needs to work with arbitrary JSON data.
      In memory, any JSON document can be represented as a value of this Rust
      type:
      #+BEGIN_SRC rust
        enum Json {
            Null,
            Boolean(bool),
            Number(f64),
            String(String),
            Array(Vec<Json>),
            Object(Box<HashMap<String, Json>>)
        }
      #+END_SRC

    - The JSON standard specifies the various data types that can appear in a JSON
      document:
      + ~null~
      + Boolean values
      + numbers
      + strings
      + arrays of JSON values
      + objects with string keys and JSON values.

      The ~Json~ /enum/ simply spells out these types.

    - This is not a hypothetical example.
      A very similar /enum/ can be found in ~serde_json~, _a serialization
      library for Rust structs_ that is one of the most-downloaded crates on
      _crates.io_.

    - The ~Box~ around the ~HashMap~ that represents an ~Object~ serves only to
      make all ~Json~ values more compact. =From Jian= eliminate /tag fields/???

      In memory, values of type ~Json~ take up *FOUR machine words*:

      + ~String~ and ~Vec~ values are THREE words, and Rust adds A /tag/ byte.

      + ~Null~ and ~Boolean~ values don't have enough data in them to use up all
        that space, but all values of one /enum/, here the ~Json~, must be the
        same size. The extra space goes unused.

        Figure 10-2 shows some examples of how ~Json~ values actually look in
        memory.

    - A ~HashMap~ is larger still.
      If we had to leave room for it in every ~Json~ value, they would be quite
      large, eight words or so.

      *But a ~Box<HashMap>~ is a single word*: it's just a pointer to
      heap-allocated data.

      We could make ~Json~ even _more compact_ *by boxing more fields*.

    - C++ Version of ~Json~:
      =TODO= =NOTE=

*** DONE Generic Enums - 218
    CLOSED: [2018-06-06 Wed 18:48]
    - Examples:
      #+BEGIN_SRC rust
        enum Option<T> {
            None,
            Some(T)
        }

        enum Result<T, E> {
            Ok(T),
            Err(E)
        }
      #+END_SRC

    - These types are familiar enough by now, and the syntax for /generic enums/
      is the _same as_ for /generic structs/.

    - =TODO= =???= =???=
      One unobvious detail is
      that Rust can eliminate the /tag field/ (See the Enums in Memory section)
      of ~Option<T>~ when the type ~T~ is a ~Box~ or some other /smart pointer
      type/. An ~Option<Box<i32>>~ is stored in memory as a single machine word,
      + 0 for ~None~
      + nonzero for ~Some~ boxed value.

    - Generic data structures can be built with just a few lines of code:
      #+BEGIN_SRC rust
        // An ordered collection of `T`s.
        enum BinaryTree<T> {
            Empty,
            NonEmpty(Box<TreeNode<T>>)
        }

        // A part of a `BinaryTree`.
        struct TreeNode<T> {
            element: T,
            left: BinaryTree<T>,
            right: BinaryTree<T>,
        }
      #+END_SRC
      These few lines of code define a ~BinaryTree~ type that can store any number
      of values of type ~T~.

      + Use it:
        #+BEGIN_SRC rust
          use self::BinaryTree::*;

          let jupiter_tree = NonEmpty(Box::new(TreeNode {
              element: "Jupiter",
              left: Empty,
              right: Empty
          }));

          let mercury_tree = Empty;

          let mars_tree = NonEmpty(Box::new(TreeNode {
              element: "Mars",
              left:     jupiter_tree,
              right:    mercury_tree,
          }));
        #+END_SRC

    - =TODO=
      Later in this chapter, we'll show how to implement an ~add~ /method/ on the
      ~BinaryTree~ type, so that we can instead write:
      #+BEGIN_SRC rust
        let mut tree = BinaryTree::Empty;

        for planet in planets {
            tree.add(planet);
        }
      #+END_SRC

    - =Re-Read= =TODO=
      No matter what language you’re coming from, creating data structures like
      BinaryTree in Rust will likely take some practice. It won’t be obvious at first where to
      put the Box es. One way to find a design that will work is to draw a picture like
      Figure 10-3 that shows how you want things laid out in memory. Then work back‐
      ward from the picture to the code. Each collection of rectangles is a struct or tuple;
      each arrow is a Box or other smart pointer. Figuring out the type of each field is a bit
      of a puzzle, but a manageable one. The reward for solving the puzzle is control over
      your program’s memory usage.

    - The price (real costs, costs at the first glance but actually investment)
      of using Rust's /enums/:
      + The memory cost of the /tag field/ in memory.
        Up to 8 bytes in the worst case, but that is usually negligible.

      + You cannot access fields of a /enum/ regardless of whether they are acutally
        present in the value -- even you know, you must also let the compiler know.

        =TODO= Use /patterns/ to solve this problem, and you will like this solution.

        =From Jian= This is NOT a cost. It's a cost at the first glance, and it
        is actually a good investment!

** DONE Patterns - 221
   CLOSED: [2018-06-06 Wed 22:19]
   - Example:
     #+BEGIN_SRC rust
       enum RoughTime {
           InThePast(TimeUnit, u32),
           JustNow,
           InTheFuture(TimeUnit, u32)
       }

       fn rough_time_to_english(rt: RoughTime) -> String {
           match rt {
               RoughTime::InThePast(units, count)   => format!("{} {} ago", count, units.plural()),
               RoughTime::JustNow                   => format!("just now"),
               RoughTime::InTheFuture(units, count) => format!("{} {} from now", count, units.plural())
           }
       }
     #+END_SRC

   - /Expressions/ *produce* values; /patterns/ *consume* values.
     The two use a lot of the same syntax.

   - Rust /patterns/ are their own little language, _summarized in Table 10-1_.
     | Pattern type            | Example                             | Notes                                         |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Literal                 | ~100~                               | Matches an exact value; the name of a ~const~ |
     |                         | ~"name"~                            | is also allowed                               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Range                   | ~0 ... 100~                         | Matches any value in range, including the end |
     |                         | ~'a' ... 'k'~                       | value                                         |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Wildcard                | ~_~                                 | Matches any value and ignores it              |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Variable                | ~name~                              | Like ~_~ but moves or copies the value into a |
     |                         | ~mut count~                         | new local variable                            |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | ref variable            | ~ref field~                         | Borrows a reference to the matched value      |
     |                         | ~ref mut field~                     | instead of moving or copying it               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Binding with subpattern | ~val @ 0 ... 99~                    | Matches the pattern to the right of ~@~,      |
     |                         | ~ref circle @ Shape::Circle { .. }~ | using the variable name to the left           |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Enum pattern            | ~Some(value)~                       |                                               |
     |                         | ~None~                              |                                               |
     |                         | ~Pet::Orca~                         |                                               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Tuple pattern           | ~(key, value)~                      |                                               |
     |                         | ~(r, g, b)~                         |                                               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Struct pattern          | ~Color(r, g, b)~                    |                                               |
     |                         | ~Point { x, y }~                    |                                               |
     |                         | ~Card { suit: Clubs, rank: n }~     |                                               |
     |                         | ~Account { id, name, .. }~          |                                               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Reference               | ~&value~                            | Matches only reference values                 |
     |                         | ~&(k, v)~                           |                                               |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Multiple patterns       | ~'a' \vert{} 'A'~                         | In ~match~ only (not valid in ~let~ , etc.)   |
     |-------------------------+-------------------------------------+-----------------------------------------------|
     |-------------------------+-------------------------------------+-----------------------------------------------|
     | Guard expression        | ~x if x * x <= r2~                  | In ~match~ only (not valid in ~let~ , etc.)   |
     |-------------------------+-------------------------------------+-----------------------------------------------|

*** DONE Literals, Variables, and Wildcards in Patterns - 223
    CLOSED: [2018-06-06 Wed 20:38]
*** DONE Tuple and Struct Patterns - 225
    CLOSED: [2018-06-06 Wed 20:43]
    - /Patterns/ like ~Point { x: x, y: y }~ are common when MATCHING /structs/,
      and the redundant names are visual clutter, so Rust has a _shorthand_ for
      this: ~Point {x, y}~.

    - Even with the shorthand, it is cumbersome to match a large struct when we
      only care about a few fields:
      #+BEGIN_SRC rust
        match get_account(id) {
            // ...
            Some(Account {
                    name, language, // <--- the 2 things we care about
                    id: _, status: _, address: _, birthday: _, eye_color: _,
                    pet: _, security_question: _, hashed_innermost_secret: _,
                    is_adamantium_preferred_customer: _ }) =>
                language.show_custom_greeting(name)
        }
      #+END_SRC

      =IMPORTANT=
      To avoid this, use ~..~ to tell Rust you don't care about any of the other fields:
      #+BEGIN_SRC rust
        Some(Account { name, language, .. }) =>
            language.show_custom_greeting(name)
      #+END_SRC

*** DONE Reference Patterns - 226
    CLOSED: [2018-06-06 Wed 22:00]
    - Example:
      + With compiler error
        #+BEGIN_SRC rust
          match account {
              Account { name, language, .. } => {
                  ui.greet(&name, &language);
                  ui.show_settings(&account);  // error: use of moved value `account`
              }
          }
        #+END_SRC
        * This code works if ~name~ and ~language~ are copiable.

        * If ~name~ and ~language~ are NOT copiable, we bind ~name~ and ~language~
          with *moving* them, we cannot use ~account~ in the
          ~ui.show_settings(&account);~ line.
          
      + Fix it:
        #+BEGIN_SRC rust
          match account {
              Account { ref name, ref language, .. } => {
                  ui.greet(&name, &language);
                  ui.show_settings(&account);
              }
          }
        #+END_SRC

    - Use ~ref mut~ to /borrow/ /mutable reference/.

    - Match /reference/:
      #+BEGIN_SRC rust
        match sphere.center() {
            &Point3d { x, y, z } => ......
        }
      #+END_SRC

    - =NOTE= =TODO=
      This is a bit tricky because Rust is following a pointer here, an action
      we usually associate with the ~*~ operator, not the ~&~ operator.

      + Rationale:
        The thing to remember is that *patterns and expressions are natural
        opposites*. For instance,
        * The expression ~(x, y)~ makes two values into a new /tuple/,
          but the pattern ~(x, y)~ does the opposite: it matches a /tuple/ and
          _breaks_ out the two values.

        * It's the same with ~&~.
          - In an /expression/, ~&~ *creates* a /reference/.
          - In a /pattern/, ~&~ *matches* a /reference/.

    - Matching a reference follows all the rules we’ve come to expect.

      + Lifetimes are enforced.

      + You CANNOT get ~mut~ access via a /shared reference/.

      + You CANNOT /move/ a value out of a /reference/, even a ~mut~ /reference/.

        (When we match ~&Point3d { x, y, z }~, the variables ~x~, ~y~, and ~z~
        receive copies of the coordinates, leaving the original ~Point3d~ value
        intact. It works because those fields are /copyable/.)

        If we try the same thing on a ~struct~ with *noncopyable* /fields/,
        we'll get an error:

        #+BEGIN_SRC rust
          match friend.borrow_car() {
              Some(&Car { engine, .. }) => // error: can't move out of borrow
                  //     ...
              None => {}
          }

        #+END_SRC

        Scrapping a borrowed car for parts is not nice, and Rust won't stand for
        it. You can use a ~ref~ pattern to /borrow/ a /reference/ to a part. You
        just don't own it.
        ~Some(&Car { ref engine, .. }) => // ok, engine is a reference~

*** DONE Matching Multiple Possibilities - 229
    CLOSED: [2018-06-06 Wed 20:44]
    - Use ~|~ to match several /patterns/.

    - Use ~...~ to match a whole /range/ (=IMPORTANT= INCLUSIVE) of values.
      #+BEGIN_SRC rust
        match next_char {
            '0' ... '9' =>
                self.read_number(),
            'a' ... 'z' | 'A' ... 'Z' =>
                self.read_word(),
            ' ' | '\t' | '\n' =>
                self.skip_whitespace(),
            _ =>
                self.handle_punctuation()
        }
      #+END_SRC

*** DONE Pattern Guards - 229
    CLOSED: [2018-06-06 Wed 20:49]
    #+BEGIN_SRC rust
      match robot.last_known_location() {
          Some(point) if self.distance_to(point) < 10 =>
              short_distance_strategy(point),
          Some(point) =>
              long_distance_strategy(point),
          None =>
              searching_strategy()
      }
    #+END_SRC
    + Use ~Some(ref point)~
      if the ~point~ above is NOT copyable.

*** DONE ~@~ patterns - 230
    CLOSED: [2018-06-06 Wed 20:57]
    - On success, instead of creating variables for parts of the matched value,
      it creates a single variable ~x~ and *moves* or *copies* the whole value
      into it. =Re-Read=

    - For example, say you have this code:
      #+BEGIN_SRC rust
        match self.get_selection() {
            rect @ Shape::Rect(..) =>
                optimized_paint(&rect),
            // Shape::Rect(top_left, bottom_right) =>
            //     optimized_paint(&Shape::Rect(top_left, bottom_right)),

            other_shape =>
                paint_outline(other_shape.get_outline()),
        }
      #+END_SRC

    - ~@~ patterns are also useful with ranges:
      #+BEGIN_SRC rust
        match chars.next() {
            Some(digit @ '0' ... '9') => read_number(digit, chars),
            // ...
        }
      #+END_SRC

*** DONE Where Patterns Are Allowed - 230
    CLOSED: [2018-06-06 Wed 22:14]
    - Although patterns are most prominent in match expressions, they are also
      allowed in several other places, _typically in place of an identifier._

    - For example:
      #+BEGIN_SRC rust
        // ...unpack a struct into three new local variables
        let Track { album, track_number, title, .. } = song;

        // ...unpack a function argument that's a tuple
        fn distance_to((x, y): (f64, f64)) -> f64 { ... }

        // ...iterate over keys and values of a HashMap
        for (id, document) in &cache_map {
            println!("Document #{}: {}", id, document.title);
        }

        // ...automatically dereference an argument to a closure
        // (handy because sometimes other code passes you a reference
        // when you'd rather have a copy)
        let sum = numbers.fold(0, |a, &num| a + num);
      #+END_SRC

      + =From Jian= I don't quite understand the last line? I mean what's special???

    - irrefutable patterns :: patterns that always match.

    - /Irrefutable patterns/ are special in Rust.
      They're the only /patterns/ allowed in the four places shown here (after
      ~let~ , in /function/ arguments, after ~for~ , and in /closure/ arguments).

    - /Refutable patterns/ are allowed in ~match~, ~if let~, and ~while let~.

*** DONE Populating a Binary Tree 232
    CLOSED: [2018-06-06 Wed 22:19]
    #+BEGIN_SRC rust
      impl<T: Ord> BinaryTree<T> {

          fn add(&mut self, value: T) {
              match *self {
                  BinaryTree::Empty =>
                      ,*self = BinaryTree::NonEmpty(Box::new(TreeNode {
                          element: value,
                          left: BinaryTree::Empty,
                          right: BinaryTree::Empty
                      })),
                  BinaryTree::NonEmpty(ref mut node) =>
                      if value <= node.element { node.left.add(value); }
                      else                     { node.right.add(value); }
              }
          }

      }

      let mut tree = BinaryTree::Empty;
      tree.add("Mercury");
      tree.add("Venus");
    #+END_SRC

** DONE The Big Picture - 233 =Re-Read=
   CLOSED: [2018-06-06 Wed 20:03]
   TODO: NOTES

* TODO 11. Traits and Generics - 235
  - Rust supports /polymorphism/ with two related features: /traits/ and /generics/.

    These concepts will be familiar to many programmers,
    =???=
    *but Rust takes a fresh approach inspired by Haskell's /typeclasses/.*

  - About /traits/:
    + We'll also use /traits/ to add /extension methods/ to EXISTING types, even
      built-in types like ~str~ and ~bool~.

    + We'll explain why adding a trait to a type costs no extra memory and how to
      use traits without virtual method call overhead.

    + We'll see that built-in /traits/ are the hook into the language that Rust
      provides for /operator overloading/ and other features.

    + =TODO=
      We'll cover /the ~Self~ type/, /associated methods/, and /associated types/,
      *three features Rust lifted from Haskell* that elegantly solve problems that
      other languages address with workarounds and hacks.

  - About /generics/.

  - /Generics/ and /traits/ are closely related.

    Rust makes us declare the ~T: Ord~ requirement (called a /bound/) up front,
    before using the ~<=~ operator to compare two values of type ~T~.

    + So we'll also talk about
      * how ~&mut Write~ and ~<T: Write>~ are *similar*,
      * how they're *different*, and
      * how to *choose between* these two ways of using /traits/.

** TODO Using Traits - 237
   - There is one UNUSUAL RULE about /trait methods/:
     *the /trait/ itself must be in scope. Otherwise, all its /methods/ are HIDDEN.*

*** TODO Trait Objects - 238
*** TODO Trait Object Layout - 239
    - Rust AUTOMATICALLY *converts* /ordinary references/ into /trait objects/
      when needed. This is why we're able to pass ~&mut local_file to say_hello~
      in this example:
      #+BEGIN_SRC rust
        let mut local_file = File::create("hello.txt")?;
        say_hello(&mut local_file)?;
      #+END_SRC

      + Likewise, Rust will happily convert a ~Box<File>~ to a ~Box<Write>~, a
        value that owns a writer in the /heap/:
        ~let w: Box<Write> = Box::new(local_file);~

    - This kind of conversion is the *ONLY WAY* to create a /trait object/.

      What the computer is actually doing here is very simple. At the point
      where the conversion happens, Rust knows the referent's true type (in this
      case, ~File~), so it just adds the address of the appropriate /vtable/,
      turning the regular pointer into a fat pointer.

*** TODO Generic Functions - 240
    - TODO

    - It's also possible for a /type parameter/ to have _no bounds_ at all,
      but you cannot do much with a value if you haven't specified any bounds for
      it. You can
      + move it
      + put it into a box or vector

      That's about it.

*** TODO Which to Use - 243

** TODO Defining and Implementing Traits - 245
*** TODO Default Methods - 246
*** TODO Traits and Other People's Types - 247
*** TODO ~Self~ in Traits - 249
*** TODO Subtraits - 250
*** TODO Static Methods - 251

** TODO Fully Qualified Method Calls - 252
** TODO Traits That Define Relationships Between Types - 253
*** TODO Associated Types (or How Iterators Work) - 254
*** TODO Generic Traits (or How Operator Overloading Works) - 257
*** TODO Buddy Traits (or How ~rand::random()~ Works) - 258

** TODO Reverse-Engineering Bounds - 260
** TODO Conclusion - 263

* TODO 12. Operator Overloading - 265 - =Reading=
  - Table 12-1. Summary of /traits/ for /operator overloading/
    =From Jian= Categories:
    + Unary operators
    + Arithmetic operators
    + Bitwise operators
    + Compound assignment arithmetic operators
    + Compound assignment bitwise operators
    + Comparison
    + Indexing

** DONE Arithmetic and Bitwise Operators - 266
   CLOSED: [2018-06-07 Thu 18:33]
   - Examples:
     + ~a + b~ is a shorthand for ~a.add(b)~,
       this operator comes from ~std::ops::Add~.

     + ~a * b~ is a shorthand for ~a.mul(b)~,
       this operator comes from ~std::ops::Mul~.

     + ~-a~ is a shorthand for ~a.neg()~,
       this operator comes from ~std::ops::Neg~.

     You can use these methods calls ONLY WHEN you import the corresponding
     /traits/.

   - The definition of ~std::ops::Add~:
     #+BEGIN_SRC rust
       trait Add<RHS=Self> {
           type Output;
           fn add(self, rhs: RHS) -> Self::Output;
       }
     #+END_SRC

     + Implement the ~Add~ for a fixed type, for example, ~i32~:
       #+BEGIN_SRC rust
         use std::ops::Add;

         impl Add for Complex<i32> {
             type Output = Complex<i32>;

             fn add(self, rhs: Self) -> Self {
                 Complex { re: self.re + rhs.re, im: self.im + rhs.im }
             }
         }
       #+END_SRC

     + Implement the ~Add~ for with generics, and keep the lhs and rhs have the
       same types. This is the most preferred one in Rust:
       #+BEGIN_SRC rust
         use std::ops::Add;

         impl<T> Add for Complex<T>
             where T: Add<Output=T>
         {
             type Output = Self;

             fn add(self, rhs: Self) -> Self {
                 Complex { re: self.re + rhs.re, im: self.im + rhs.im }
             }
         }
       #+END_SRC

     + The most general solution, which is NOT preferred in Rust -- in practice,
       Rust tends to avoid supporting mixed-type operations:
       #+BEGIN_SRC rust
         use std::ops::Add;

         impl<L, R, O> Add<Complex<R>> for Complex<L>
             where L: Add<R, Output=O>
         {
             type Output = Complex<O>;

             fn add(self, rhs: Complex<R>) -> Self::Output {
                 Complex { re: self.re + rhs.re, im: self.im + rhs.im }
             }
         }
       #+END_SRC

   - Rust's /built-in traits/ for /arithmetic/ and /bitwise/ operators come in
       *three* groups:
     + unary operators

     + binary operators

     + compound assignment operators

*** DONE Unary Operators - 268
    CLOSED: [2018-06-07 Thu 17:48]
    =TODO=
    Aside from the /dereferencing operator/ ~*~, which we'll cover separately in
    "Deref and DerefMut" on page 289, Rust has *two* /unary operators/:

    - Table 12-2. Built-in traits for unary operators
      | Trait name      | Expression | Equivalent expression |
      |-----------------+------------+-----------------------|
      | ~std::ops::Neg~ | ~-x~       | ~x.neg()~             |
      | ~std::ops::Not~ | ~!x~       | ~x.not()~             |

    - ~std::ops::Neg~ corresponds to /unary negation operator/ ~-~:
      + ALL of Rust's /numeric types/ implement

    - ~std::ops::Not~ corresponds to /unary complement operator/ ~!~,
      it behaves as the two functionalities ~!~ and ~~~ in C/C++.
      + For /integer types/, it is /bitwise complement/ (flips the bits);

      + For /bool/, it is /bool complement/.

    - There are also ~std::ops::Neg~ and ~std::ops::Not~ implementations for
      /references/ to those types.

    - These /traits/' definitions:
      #+BEGIN_SRC rust
        trait Neg {
            type Output;
            fn neg(self) -> Self::Output;
        }

        trait Not {
            type Output;
            fn not(self) -> Self::Output;
        }
      #+END_SRC

    - Example (the generics implementation of negating complex numbers):
      #+BEGIN_SRC rust
        use std::ops::Neg;

        impl<T, O> Neg for Complex<T>
            where T: Neg<Output=O>
        {
            type Output = Complex<O>;

            fn neg(self) -> Complex<O> {
                Complex { re: -self.re, im: -self.im }
            }
        }
      #+END_SRC

*** DONE Binary Operators - 269
    CLOSED: [2018-06-07 Thu 18:08]
    Table 12-3. Built-in traits for binary operators
    |----------------------+--------------------+------------+-----------------------|
    | Category             | Trait name         | Expression | Equivalent expression |
    |----------------------+--------------------+------------+-----------------------|
    | Arithmetic operators | ~std::ops::Add~    | ~x + y~    | ~x.add(y)~            |
    |                      | ~std::ops::Sub~    | ~x - y~    | ~x.sub(y)~            |
    |                      | ~std::ops::Mul~    | ~x * y~    | ~x.mul(y)~            |
    |                      | ~std::ops::Div~    | ~x / y~    | ~x.div(y)~            |
    |                      | ~std::ops::Rem~    | ~x % y~    | ~x.rem(y)~            |
    |----------------------+--------------------+------------+-----------------------|
    | Bitwise operators    | ~std::ops::BitAnd~ | ~x & y~    | ~x.bitand(y)~         |
    |                      | ~std::ops::BitOr~  | ~x \vert{} y~    | ~x.bitor(y)~          |
    |                      | ~std::ops::BitXor~ | ~x ^ y~    | ~x.bitxor(y)~         |
    |                      | ~std::ops::Shl~    | ~x << y~   | ~x.shl(y)~            |
    |                      | ~std::ops::Shr~    | ~x >> y~   | ~x.shr(y)~            |
    |----------------------+--------------------+------------+-----------------------|

    - ALL of Rust's /numeric types/ implement the /arithmetic operators/.

    - All of these /traits/ here have the same general form.
      For example:
      #+BEGIN_SRC rust
        trait BitXor<RHS=Self> {
            type Output;
            fn bitxor(self, rhs: RHS) -> Self::Output;
        }
      #+END_SRC
      + The ~Shl~ and ~Shr~ /traits/ *DEVIATE slightly from this pattern*:
        they do not default their ~RHS~ type parameter to ~Self~,
        so you *must always supply the righthand operand type explicitly*.

    - You can use the ~+~ operator to *concatenate* a ~String~ with a ~&str~ /slice/
      or another ~String~.

      However, Rust does not permit the left operand of ~+~ to be a ~&str~, to
      discourage building up LONG strings by repeatedly concatenating small
      pieces on the left. (This performs poorly, requiring time QUADRATIC in the
      final length of the string.)

      + Generally, the ~write!~ /macro/ is better for building up strings _piece
        by piece_;
        =TODO=
        we show how to do this in “Appending and Inserting Text” on page 399.

*** DONE Compound Assignment Operators - 270
    CLOSED: [2018-06-07 Thu 18:33]
    Table 12-4. Built-in /traits/ for /compound assignment operators/
    |----------------------+-----------------------+------------+-----------------------|
    | Category             | Trait name            | Expression | Equivalent expression |
    |----------------------+-----------------------+------------+-----------------------|
    | Arithmetic operators | ~std::ops::AddAssign~ | ~x += y~   | ~x.add_assign(y)~     |
    |                      | ~std::ops::SubAssign~ | ~x -= y~   | ~x.sub_assign(y)~     |
    |                      | ~std::ops::MulAssign~ | ~x *= y~   | ~x.mul_assign(y)~     |
    |                      | ~std::ops::DivAssign~ | ~x /= y~   | ~x.div_assign(y)~     |
    |                      | ~std::ops::RemAssign~ | ~x %= y~   | ~x.rem_assign(y)~     |
    |----------------------+-----------------------+------------+-----------------------|
    | Bitwise operators    | ~std::ops::BitAnd~    | ~x &= y~   | ~x.bitand_assign(y)~  |
    |                      | ~std::ops::BitOr~     | ~x \vert{}= y~   | ~x.bitor_assign(y)~   |
    |                      | ~std::ops::BitXor~    | ~x ^= y~   | ~x.bitxor_assign(y)~  |
    |                      | ~std::ops::Shl~       | ~x <<= y~  | ~x.shl_assign(y)~     |
    |                      | ~std::ops::Shr~       | ~x >>= y~  | ~x.shr_assign(y)~     |
    |----------------------+-----------------------+------------+-----------------------|

    - ALL of Rust's /numeric types/ implement the /arithmetic compound assignment
      operators/.

      Rust's /integer types/ and /bool/ implement the /bitwise compound assignment
      operators/.

    - /Compound assignment operators/ always return ~()~ -- they are all used for
      side-effect.

    - The way how Rust's /compound assignment operators/ are defined are different
      from /compound assignment operators/ in other languages:
      + In other languages,
        ~x += y~ is considered as a shorthand of ~x = x + y~, which means it is
        a composition of two operations.

      + In Rust,
        The /built-in trait/ for a /compound assignment operator/ is *completely
        independent* of the /built-in trait/ for the CORRESPONDING /binary operator/.

        ~x += y~ corresponds to the ~x.add_assign(y)~, which is the ONLY /method/
        of /trait/ ~std::ops::AddAssign~ /trait/:
        #+BEGIN_SRC rust
          trait AddAssign<RHS=Self> {
              fn add_assign(&mut self, RHS);
          }
        #+END_SRC

    - A _generic implementation_ of ~AddAssign~ for our ~Complex~ type is straightforward:
      #+BEGIN_SRC rust
        use std::ops::AddAssign;

        impl<T> AddAssign for Complex<T>
            where T: AddAssign<T>
        {
            fn add_assign(&mut self, rhs: Complex<T>) {
                self.re += rhs.re;
                self.im += rhs.im;
            }
        }
      #+END_SRC

    - As with the /binary traits/ ~Shl~ and ~Shr~, the ~ShlAssign~ and ~ShrAssign~
      /traits/ _deviate slightly_ from the pattern followed by the other
      /compound assignment traits/:
      they do NOT default their ~RHS~ /type parameter/ to ~Self~ , so you MUST
      ALWAYS supply the righthand operand type EXPLICITLY.

** TODO Equality Tests - 272
** TODO Ordered Comparisons - 275
** TODO ~Index~ and ~IndexMut~ - 277
** DONE Other Operators - 280
   CLOSED: [2018-06-07 Thu 18:18]
   - *NOT ALL* /operators/ can be /overloaded/ in Rust.

     For example, as of Rust 1.17,
     + the /error-checking operator/ ~?~ works _ONLY_ with ~Result~ values;
     + the /logical operators/ ~&&~ and ~||~ are limited to ~Boolean~ values _ONLY_;
     + The ~..~ operator _ALWAYS_ creates ~Range~ values;
     + the ~&~ operator _ALWAYS_ /borrows references/;
     + the ~=~ operator _ALWAYS_ /moves/ or /copies/ values.

     None of them can be overloaded.

   - ~Deref~ and ~DerefMut~ are explained in the next Chapter.
     They do more than just overload a few operators.

   - Rust does NOT support /overloading/ the /function call operator/, ~f(x)~.

     Instead, when you need a /callable value/, you'll typically just write a
     /closure/.

     =TODO= We'll explain how this works and cover the ~Fn~, ~FnMut~, and
     ~FnOnce~ special /traits/ in Chapter 14.

* TODO 13. Utility Traits - 281
  - Several other /built-in traits/ let you hook into parts of the Rust language
    and standard library:
    + You can use the ~Drop~ /trait/ to _clean up_ values when they _go out of scope_,
      like /destructors/ in C++.

    + /Smart pointer types/, like ~Box<T>~ and ~Rc<T>~, can implement the ~Deref~ /trait/
      to make the pointer reflect the /methods/ of the wrapped value.

    + By implementing the ~From<T>~ and ~Into<T>~ /traits/, you can tell Rust how
      to convert a value from one type to another.

  - We'll cover each of the /traits/ shown in Table 13-1:
    | Trait                    | Description                                                          |
    |--------------------------+----------------------------------------------------------------------|
    | ~Drop~                   | Destructors. Cleanup code that Rust runs automatically               |
    |                          | whenever a value is dropped.                                         |
    |--------------------------+----------------------------------------------------------------------|
    | ~Sized~                  | Marker /trait/ for types with a _fixed size_ known at                |
    |                          | /compile time/, as opposed to types (such as slices)                 |
    |                          | that are dynamically sized.                                          |
    |--------------------------+----------------------------------------------------------------------|
    | ~Clone~                  | Types that support cloning values.                                   |
    |--------------------------+----------------------------------------------------------------------|
    | ~Copy~                   | Marker /trait/ for types that can be cloned simply by                |
    |                          | making a byte-for-byte copy of the memory containing the value.      |
    |--------------------------+----------------------------------------------------------------------|
    | ~Deref~ and ~DerefMut~   | /Traits/ for /smart pointer types/.                                  |
    |--------------------------+----------------------------------------------------------------------|
    | ~Default~                | Types that have a sensible "default value."                          |
    |--------------------------+----------------------------------------------------------------------|
    | ~AsRef~ and ~AsMut~      | Conversion /traits/ for borrowing one type of reference              |
    |                          | from another.                                                        |
    |--------------------------+----------------------------------------------------------------------|
    | ~Borrow~ and ~BorrowMut~ | Conversion /traits/, like ~AsRef~ / ~AsMut~ , but additionally       |
    |                          | guaranteeing consistent hashing, ordering, and equality.             |
    |--------------------------+----------------------------------------------------------------------|
    | ~From~ and ~Into~        | Conversion /traits/ for transforming one type of value into another. |
    |--------------------------+----------------------------------------------------------------------|
    | ~ToOwned~                | Conversion /trait/ for converting a reference to an owned value.     |

** ~Drop~ - 282
** ~Sized~ - 285
** ~Clone~ - 287
** ~Copy~ - 289
** ~Deref~ and ~DerefMut~ - 289
** ~Default~
** ~AsRef~ and ~AsMut~ - 294
** ~Borrow~ and ~BorrowMut~ - 296
** ~From~ and ~Into~ - 297
** ~ToOwned~ - 300
** ~Borrow~ and ~ToOwned~ at Work: The Humble ~Cow~ - 300

* DONE 14. Closures - 303 - =Re-READ=
  CLOSED: [2018-06-12 Tue 19:33]
  - Example:
    #+BEGIN_SRC rust
      struct City {
          name: String,
          population: i64,
          country: String,
          // ...
      }
    #+END_SRC

    + WITHOUT a /closure/:
      #+BEGIN_SRC rust
        /// Helper function for sorting cities by population.
        fn city_population_descending(city: &City) -> i64 {
            -city.population
        }
        fn sort_cities(cities: &mut Vec<City>) {
            cities.sort_by_key(city_population_descending);
        }
      #+END_SRC

    + WITH a /closure/:
      #+BEGIN_SRC rust
        fn sort_cities(cities: &mut Vec<City>) {
            cities.sort_by_key(|city| -city.population);
        }
      #+END_SRC

  - In this chapter,
    + you'll learn
      * how to use closures with standard library methods
      * how a closure can “capture” variables in its scope
      * how to write your own functions and methods that take closures as arguments
      * how to store closures for later use as callbacks.

    + We'll also explain
      * how /Rust closures/ work
      * why they're *faster* than you might expect.

** DONE Capturing Variables - 305
   CLOSED: [2018-06-12 Tue 19:33]
   - A /closure/ can USE DATA that belongs to an /enclosing function/.

*** DONE Closures That Borrow - 306
    CLOSED: [2018-06-11 Mon 17:37]
    Example code:
    #+BEGIN_SRC rust
      fn sort_by_statistic(cities: &mut Vec<City>, stat: Statistic) {
          cities.sort_by_key(|city| -city.get_statistic(stat));
      }
    #+END_SRC
    + When Rust creates the /closure/, it /automatically borrows/ a /reference/
      to ~stat~.

    + Since this /closure/ contains a /reference/ to ~stat~, Rust WON'T let it
      outlive ~stat~.

*** DONE Closures That Steal - 306
    CLOSED: [2018-06-11 Mon 17:49]
    #+BEGIN_SRC rust
      fn start_sorting_thread(mut cities: Vec<City>, stat: Statistic)
                              -> thread::JoinHandle<Vec<City>>
      {
          let key_fn = move |city: &City| -> i64 { -city.get_statistic(stat) };

          thread::spawn(move || {
              cities.sort_by_key(key_fn);
              cities
          })
      }
    #+END_SRC
    - The FIRST /closure/, ~key_fn~, takes /ownership/ of ~stat~.
      Then the SECOND /closure/ takes /ownership/ of both ~cities~ and ~key_fn~.

    - We get something important by accepting Rust's strict rules: /thread safety/.

      Values are moved rather than being shared across /threads/.

** TODO Function and Closure Types - 308
   - For example,
     ~fn city_population_descending(city: &City) -> i64 { -city.population }~ has
     type ~fn(&City) -> i64~.

   - /Structs/ may have /function-typed fields/.

   - /Generic types/ like ~Vec~ can store scads of functions, as long as they all
     share the same ~fn~ type.

   - /Function values/ are *tiny*:
     a ~fn~ value is the memory address of the function's machine code, just LIKE
     a /function pointer/ in C++.

** TODO Closure Performance - 310
** TODO Closures and Safety - 311
*** TODO Closures That Kill - 312
*** TODO ~FnOnce~ - 312
*** TODO ~FnMut~ - 314
    - =EN=
      swath - 大片

** TODO Callbacks - 316
** TODO Using Closures Effectively - 319
   - Some code patterns that are commonplace in languages with GC like Java, C#,
     and JavaScript will *NOT* work in Rust WITHOUT CHANGES.

   - =EN=
     divvy up - 分紅

* TODO 15. Iterators - 321 - =Reading=
  The rest of this chapter falls into *five* parts:
  1. We'll explain the ~Iterator~ and ~IntoIterator~ /traits/, which are the
     foundation of Rust's /iterators/.

  2. Then we'll go over the *three* stages of a typical /iterator/ pipeline:
     1. *creating* an /iterator/ from some sort of _value source_;

     2. *adapting* one sort of /iterator/ into another by *selecting* or *processing*
        values as they go by;

     3. *consuming* the values the /iterator/ produces.

  3. We'll show how to *implement* /iterators/ for your own types.

** DONE The ~Iterator~ and ~IntoIterator~ Traits - 322
   CLOSED: [2018-06-12 Tue 22:08]
   - iterator :: Any value that implements the ~std::iter::Iterator~ /trait/.

   - The ~Iterator~ trait:
     #+BEGIN_SRC rust
       trait Iterator {
           type Item;

           fn next(&mut self) -> Option<Self::Item>;
           // ... // many default methods
       }
     #+END_SRC

   - If there's a natural way to iterate over certain type, this type can implement
     ~std::iter::IntoIterator~, whose ~into_iter~ /method/ takes a value and
     returns an /iterator/ over it:
     #+BEGIN_SRC rust
       trait IntoIterator where Self::IntoIter::Item == Self::Item {
           type Item;
           type IntoIter: Iterator;
           fn into_iter(self) -> Self::IntoIter;
       }
     #+END_SRC

   - ~IntoIter~ is the type of the /iterator/ value ITSELF, and ~Item~ is the type
     of value it produces.

     The /vector reference/ ~&v~ is the /iterable/ in this case.

   - iterable :: Any type that implements ~IntoIterator~ (because it's something
                 you could iterate over if you asked)

   - Under the hood, every ~for~ loop is just shorthand for calls to IntoIterator
     and Iterator methods:
     #+BEGIN_SRC rust
       let mut iterator = (&v).into_iter();

       while let Some(element) = iterator.next() {
           println!("{}", element);
       }
     #+END_SRC
     Although a ~for~ loop always calls ~into_iter~ on its operand, you can also
     pass /iterators/ to ~for~ loops directly; this occurs when you loop over a
     ~Range~.

     + Rationale:
       ALL /iterators/ AUTOMATICALLY implement ~IntoIterator~, with an ~into_iter~
       /method/ that simply returns the /iterator/.

   - After a /iterator/'s ~next~ /method/ returns ~None~, in most cases, it will
     keep returning ~None~, but NOT all /iterators/ have this behavior.

     See page 338 -- use the ~fuse~ /adapter method/ to force the ~None~ values
     after the first ~None~ value.

   - Here's some terminology for /iterators/:
     + An /iterator/ produces /values/.

     + The /values/ an /iterator/ produces are /items/.

     + The code that receives the /items/ an /iterator/ produces is the /consumer/.
       In this example, the ~for~ loop *consumes* the /iterator/'s /items/.

** TODO Creating ~Iterator~'s - 324 =NOTE=
*** TODO ~iter~ and ~iter_mut~ Methods - 324
*** TODO ~IntoIterator~ Implementations - 325
    - MOST /collections/ actually provide _several_ implementations of ~IntoIterator~,
      for /shared references/, /mutable references/, and /moves/:
      + Given a /shared reference/ to the /collection/, ~into_iter~ returns an
        /iterator/ that produces /shared references/ to its items.

        For example,
        ~favorites~ is a ~Vec<String>~, and the call ~(&favorites).into_iter()~
        would return an /iterator/ whose ~Item~ type is ~&String~.

        ~for element in &collection { ... }~

      + Given a /mutable reference/ to the /collection/, ~into_iter~ returns an
        /iterator/ that produces /mutable references/ to the items.

        For example,
        ~vector~ is some ~Vec<String>~, and the call ~(&mut vector).into_iter()~
        returns an /iterator/ whose ~Item~ type is ~&mut String~.

        ~for element in &mut collection { ... }~

      + When passed the /collection/ by value, ~into_iter~ returns an /iterator/
        that takes /ownership/ of the /collection/ and returns /items/ by /value/;

        the items' /ownership/ moves from the /collection/ to the /consumer/, and
        the _ORIGINAL_ /collection/ is *consumed* in the process.

        For example, the call ~favorites.into_iter()~ in the preceding code
        returns an /iterator/ that produces each string by value; the consumer
        receives /ownership/ of each string. When the /iterator/ is /dropped/,
        any elements remaining in the ~BTreeSet~ are /dropped/ too, and the set's
        now-empty husk is disposed of.

        ~for element in collection { ... }~

    - =EN=
      husk - 壳

    - *NOT every type provides all THREE implementations.*
      =page= 326 start

*** DONE ~drain~ Methods - 327 =???=
    CLOSED: [2018-06-13 Wed 08:59]
    - Many collection types provide a ~drain~ method.

    - ~drain~ :: a kind of /method/ that takes a /mutable reference/ to the /collection/
                 and returns an /iterator/ that passes /ownership/ of each element to
                 the consumer.

      + However,
        _UNLIKE_ the ~into_iter()~ /method/, which takes the /collection/
        _by value_ and _consumes_ it,

        ~drain~ merely _borrows_ a /mutable reference/ to the /collection/,
        =TODO= =???= =???=
        and when the /iterator/ is _dropped_, it _removes_ any remaining elements
        from the /collection/, and leaves it empty.

    - On types that can be indexed by a range, like ~String~'s, /vectors/, and
      ~VecDeque~'s, the ~drain~ /method/
      + takes a range of elements to remove,
      + _rather than_ draining the entire sequence:

      #+BEGIN_SRC rust
        use std::iter::FromIterator;

        let mut outer = "Earth".to_string();
        let inner = String::from_iter(outer.drain(1..4));

        assert_eq!(outer, "Eh");
        assert_eq!(inner, "art");
      #+END_SRC
      + If you do need to ~drain~ the ENTIRE sequence, use the full range, ~..~,
        as the argument.
    
*** DONE Other ~Iterator~ Sources - 328
    CLOSED: [2018-06-13 Wed 09:07]
    =IMPORTANT= =!!!!!!=
    Table 15-1. Other /iterators/ in the standard library

** TODO ~Iterator~ Adapters - 330
*** DONE ~map~ and ~filter~ - 330
    CLOSED: [2018-06-13 Wed 09:24]
    - Example:
      #+BEGIN_SRC rust
        let text = " ponies   \n   giraffes\niguanas  \nsquid".to_string();
        let v: Vec<&str> = text.lines()
            .map(str::trim)
            .filter(|s| *s != "iguanas")
            .collect();
        assert_eq!(v, ["ponies", "giraffes", "iguanas", "squid"]);
      #+END_SRC

    - A chain of /iterator adapters/ is like a pipeline in the Unix shell.

    - These adapters' signatures:
      #+BEGIN_SRC rust
        fn map<B, F>(self, f: F) -> some Iterator<Item=B>
            where Self: Sized, F: FnMut(Self::Item) -> B;

        fn filter<P>(self, predicate: P) -> some Iterator<Item=Self::Item>
            where Self: Sized, P: FnMut(&Self::Item) -> bool;
      #+END_SRC
      + The ~some~ part is NOT Valid Rust.
        * footnote: =TODO=
          Rust RFC 1522 will add syntax to the language very much like our some
          Iterator notation. As of Rust 1.17, it is not yet included in the
          language by default.

        The real /return types/ are opaque ~struct~ types, which aren't
        informative (therefore not be presented here).

    - Since most /adapters/ take ~self~ _by value_, they require ~Self~ to be ~Sized~
      (which all COMMON /iterators/ are).

    - There are two important points to notice about iterator adapters.
      =TODO= =NOTE=
      + Laziness =TODO=

      + Efficiency =TODO=

*** DONE ~filter_map~ and ~flat_map~ - 332
    CLOSED: [2018-06-13 Wed 09:49]
    - The signature of the ~filter_map~ /method/:
      #+BEGIN_SRC rust
        fn filter_map<B, F>(self, f: F) -> some Iterator<Item=B>
            where Self: Sized, F: FnMut(Self::Item) -> Option<B>;
      #+END_SRC
      This signature is similar to ~map~, but the /return type/ of ~F~ is
      different. The one for ~map~ is ~B~, and the one for ~filter_map~ is
      ~Option<B>~.

      Here ~Option~ type is used to do something similar to the ~predicate~ for
      the ~filter~ /method/ -- this time we use ~Option~, instead of ~bool~, to
      filter out the values we don't want (when the value is ~None~).

    - Example:
      #+BEGIN_SRC rust
        use std::str::FromStr;

        let text = "1\nfrond .25 289\n3.1415 estuary\n";
        for number in text.split_whitespace()
            .filter_map(|w| f64::from_str(w).ok()) {
                println!("{:4.2}", number.sqrt());
        }

        // 1.00
        // 0.50
        // 17.00
        // 1.77
      #+END_SRC

      The equivalent but more verbose version of only using ~map~ and ~filter~:
      #+BEGIN_SRC rust
        text.split_whitespace()
            .map(|w| f64::from_str(w))
            .filter(|r| r.is_ok())
            .map(|r| r.unwrap())
      #+END_SRC

    - The signature of the ~flat_map~ /method/:
      #+BEGIN_SRC rust
        fn flat_map<U, F>(self, f: F) -> some Iterator<Item=U::Item>
            where F: FnMut(Self::Item) -> U, U: IntoIterator;
      #+END_SRC
      + The /closure/ passed to ~flat_map~ must return an /iterable/, but any sort
        of /iterable/ will do.

        footnote 2:
        Since ~Option~ is an /iterable/, for the /closures/ that returns ~Option~
        types, ~flat_map~ is equivalent to the ~filter_map~.

    - Example:
      Map countries to their major cities:
      #+BEGIN_SRC rust
        use std::collections::HashMap;

        let mut major_cities = HashMap::new();
        major_cities.insert("Japan", vec!["Tokyo", "Kyoto"]);
        major_cities.insert("The United States", vec!["Portland", "Nashville"]);
        major_cities.insert("Brazil", vec!["São Paulo", "Brasília"]);
        major_cities.insert("Kenya", vec!["Nairobi", "Mombasa"]);
        major_cities.insert("The Netherlands", vec!["Amsterdam", "Utrecht"]);

        let countries = ["Japan", "Brazil", "Kenya"];

        for &city in countries.iter().flat_map(|country| &major_cities[country]) {
            println!("{}", city);
        }
      #+END_SRC
      Because of the /laziness/,
      *use ~next~ to retrive every element will NOT trigger concatenation operations.*

*** DONE ~scan~ - 335
    CLOSED: [2018-06-13 Wed 10:04]
    =From Jian=
    LIKE a ~reduce~ /method/ in other languages, but this one can stop in the
    middle by some condition -- last returning value is ~None~.

    This ~scan~ is totally different in semantics from the one in Scala.

    - Example:
      #+BEGIN_SRC rust
        let iter = (0..10)
            .scan(0, |sum, item| {
                *sum += item;
                if *sum > 10 {
                    None
                } else {
                    Some(item * item)
                }
            });

        assert_eq!(iter.collect::<Vec<i32>>(), vec![0, 1, 4, 9, 16]);
      #+END_SRC

    - =From Jian=
      Try to find or create a function of:
      #+BEGIN_SRC rust
        fn to_option<T>(b: bool, v: T) -> Option<T> {
            match b {
                true => Some(v),
                _ => None
            }
        }
      #+END_SRC
      Then the code in the last example can be re-written as:
      ~(0..10).scan(0, |sum, item| {*sum += item; to_option(*sum > 10, item * item)});~

      =TODO= How to make the second parameter ~v~ /laziness/!!!!!!!!!

*** DONE ~take~ and ~take_while~ - 335
    CLOSED: [2018-06-13 Wed 14:59]
    - The ~take~ /method/:
      #+BEGIN_SRC rust
        fn take(self, n: usize) -> some Iterator<Item=Self::Item>
            where Self: Sized;

        fn take_when<P>(self, predicate: P) -> some Iterator<Item=Self::Item>
            where Self: Sized, P: FnMut(&Self::Item) -> bool;
      #+END_SRC

*** DONE ~skip~ and ~skip_while~ - 336
    CLOSED: [2018-06-13 Wed 15:02]
    These two /methods/ are like the ~drop~ and ~dropWhile~ /methods/ in Scala.

    Not use the word "drop" to avoid miss-leading name -- "drop" has a special
    meaning in the context of Rust.

    #+BEGIN_SRC rust
      fn skip(self, n: usize) -> some Iterator<Item=Self::Item>
          where Self: Sized;

      fn skip_while<P>(self, predicate: P) -> some Iterator<Item=Self::Item>
          where Self: Sized, P: FnMut(&Self::Item) -> bool;
    #+END_SRC
    - xxx

*** DONE ~peekable~ - 337
    CLOSED: [2018-06-13 Wed 16:09]
    - peekable iterator :: You can peek at the next item that will be produced
         _WITHOUT_ actually consuming it.

    - You can turn almost *ANY* /iterator/ into a /peekable iterator/ by calling
      the ~Iterator~ /trait/'s ~peekable~ /method/:
      #+BEGIN_SRC rust
        fn peekable(self) -> std::iter::Peekable<Self>
            where Self: Sized;
      #+END_SRC
      + ~Peekable<Self>~ is a /struct/ that implements ~Iterator<Item=Self::Item>~;

      + ~Self~ is the type of the underlying /iterator/.

    - A ~Peekable~ /iterator/ has an additional /method/ ~peek~ that returns an
      ~Option<&Item>~:
      + ~None~ if the underlying /iterator/ is done

      + ~Some(r)~, where ~r~ is a /shared reference/ to the _NEXT_ /item/.

      (Note that, if the /iterator/'s /item/ type is already a /reference/ to
      something, this ends up being a /reference to a reference/.)

    - Calling ~peek~, and the result will be cached.
      All the other ~Iterator~ methods on ~Peekable~ know about this cache.

    - /Peekable iterators/ are essential when you can't decide how many /items/
      to consume from an /iterator/ until you've gone too far.

    - For example, if you're parsing numbers from a stream of characters, you can't
      decide where the number ends until you've seen the first non-number
      character following it:
      #+BEGIN_SRC rust
        use std::iter::Peekable;

        fn parse_number<I>(tokens: &mut Peekable<I>) -> u32
            where I: Iterator<Item=char>
        {
            let mut n = 0;

            loop {
                match tokens.peek() {
                    Some(r) if r.is_digit(10) => {
                        n = n * 10 + r.to_digit(10).unwrap();
                    }

                    _ => return n
                }
                tokens.next();
            }
        }

        let mut chars = "226153980,1766319049".chars().peekable();
        assert_eq!(parse_number(&mut chars), 226153980);
        // Look, `parse_number` didn't consume the comma! So we will.
        assert_eq!(chars.next(), Some(','));
        assert_eq!(parse_number(&mut chars), 1766319049);
        assert_eq!(chars.next(), None);
      #+END_SRC

*** DONE ~fuse~ - 338
    CLOSED: [2018-06-13 Wed 09:34]
    The subsequent behavior of a ~Iterator~ that has returned ~None~ if NOT forced.

    Most /iterators/ just return ~None~ again, but NOT ALL.
    You cannot make a general assumption!

    The ~fuse~ adapter takes any /iterator/ and turns into one that will definitely
    continue to return ~None~ once it has done so the first time:
    #+BEGIN_SRC rust
      struct Flaky(bool);

      impl Iterator for Flaky {
          type Item = &'static str;
          fn next(&mut self) -> Option<Self::Item> {
              if self.0 {
                  self.0 = false;
                  Some("totally the last item")
              } else {
                  self.0 = true; // D'oh!
                  None
              }
          }
      }
      let mut flaky = Flaky(true);
      assert_eq!(flaky.next(), Some("totally the last item"));
      assert_eq!(flaky.next(), None);
      assert_eq!(flaky.next(), Some("totally the last item"));

      let mut not_flaky = Flaky(true).fuse();
      assert_eq!(not_flaky.next(), Some("totally the last item"));
      assert_eq!(not_flaky.next(), None);
      assert_eq!(not_flaky.next(), None);
    #+END_SRC
    Here we first introduce /struct/ that has a wierd-behaved /interator/ that
    can return other values after returning ~None~, and then we use ~fuse~ to
    convert the original /iterator/ to a well-behaved /iterator/ -- always return
    ~None~ after returning the first ~None~.

    *The fuse adapter is probably most useful in generic code that needs to work
    with iterators of uncertain origin.*
      Rather than hoping that every /iterator/ you'll have to deal with will be
    well-behaved, you can use ~fuse~ to make sure.

*** DONE Reversible ~Iterator~'s and ~rev~ - 339
    CLOSED: [2018-06-13 Wed 16:22]
    Some /iterators/ are able to draw /items/ from both ends of the sequence.
    - Reversible iterators implement ~DoubleEndedIterator~:
      #+BEGIN_SRC rust
        trait DoubleEndedIterator: Iterator {
            fn next_back(&mut self) -> Option<Self::Item>;
        }
      #+END_SRC

    - Example:
      #+BEGIN_SRC rust
        use std::iter::DoubleEndedIterator;
        let bee_parts = ["head", "thorax", "abdomen"];
        let mut iter = bee_parts.iter();

        assert_eq!(iter.next(), Some(&"head"));
        assert_eq!(iter.next_back(), Some(&"abdomen"));
        assert_eq!(iter.next(), Some(&"thorax"));
        assert_eq!(iter.next_back(), None);
        assert_eq!(iter.next(), None);
      #+END_SRC

    - In general, the standard library provides double-ended iteration *whenever
      it's practical*. For instance, ~Vec~, ~BTreeSet~, and ~BTreeMap~.

    - NOT all /iterators/ can do this so easily:
      an /iterator/ producing values from other /threads/ arriving at a /channel/'s
      ~Receiver~ has _NO WAY to anticipate_ what the last value received might be.

    - If an /iterator/ is double-ended, you can reverse it with the ~rev~ /adapter/:
      #+BEGIN_SRC rust
        fn rev(self) -> some Iterator<Item=Self>
            where Self: Sized + DoubleEndedIterator;
      #+END_SRC

    - Most /iterator/ adapters, when possible, preserve the input /iterator/'s
      reversibility in the result /iterator/.

*** DONE ~inspect~ - 340
    CLOSED: [2018-06-13 Wed 16:46]
    - The ~inspect~ adapter is handy for *debugging* pipelines of /iterator/ adapters,
      BUT *it isn't used much in production code*.

    - It simply applies a /closure/ to a /shared reference/ to each /item/, and
      then passes the /item/ through.

      The closure CANNOT affect the /items/,
      but it can do things like _print_ them or _make assertions_ about them.

    - Example:
      #+BEGIN_SRC rust
        let upper_case: String = "große".chars()
            .inspect(|c| println!("before: {:?}", c))
            .flat_map(|c| c.to_uppercase())
            .inspect(|c| println!(" after:     {:?}", c))
            .collect();

        assert_eq!(upper_case, "GROSSE");

        // before: 'g'
        //  after:     'G'
        // before: 'r'
        //  after:     'R'
        // before: 'o'
        //  after:     'O'
        // before: 'ß'
        //  after:     'S'
        //  after:     'S'
        // before: 'e'
        //  after:     'E'
      #+END_SRC
      + The uppercase equivalent of the lowercase German letter ~ß~ is ~SS~, which
        is why ~char::to_uppercase~ returns an /iterator/ over characters, _NOT_
        a single replacement character.

*** DONE ~chain~ - 341
    CLOSED: [2018-06-13 Wed 16:35]
    - The ~chain~ adapter's signature is as follows:
      #+BEGIN_SRC rust
        fn chain<U>(self, other: U) -> some Iterator<Item=Self::Item>
            where Self: Sized, U: IntoIterator<Item=Self::Item>;
      #+END_SRC
      In other words, you can *chain* an /iterator/ together with any /iterable/
      that produces the _SAME_ /item type/.

    - Example,
      ~let v: Vec<i32> = (1..4).chain(vec![20, 30, 40]).collect();~
      Here, the ~v~ is [1, 2, 3, 20, 30, 40]).

    - A /chain iterator/ is _reversible_, if *BOTH* of its underlying /iterators/
      are.

*** DONE ~enumerate~ - 341
    CLOSED: [2018-06-13 Wed 16:31]
    This /method/ returns an /iterator/ with elements of ~(0, A), (1, B), (2,
    C), ......~.

*** DONE ~zip~ - 342
    CLOSED: [2018-06-13 Wed 16:26]
    - The /zipped iterator/
      ends when either of the two underlying /iterators/ ends.

      The length of a /zipped iterator/ depends on the shorter one.

    - Example (~enumerate~-like):
      ~let v: Vec<_> = (0..).zip("ABCD".chars()).collect();~
      The ~v~ here is of value ~vec![(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D')]~.

*** DONE ~by_ref~ - 342
    CLOSED: [2018-06-14 Thu 01:54]
    All the /adapters/ we mentioned take ownership of the underlying /iterator/,
    and provide _NO_ /method/ to give it back.

    You can Use the ~by_ref~ /method/ to /borrow/ a /mutable reference/ to the
    /iterator/, and then apply /adapters/ to the reference. When you are done,
    you drop it, and you can re-gain access to your ORIGINAL /iterator/.

    - Example:
      #+BEGIN_SRC rust
        let message = "To: jimb\r\n\
                       From: id\r\n\
                       \r\n\
                       Oooooh, donuts!!\r\n";

        let mut lines = message.lines();

        println!("Headers:");
        for header in lines.by_ref().take_while(|l| !l.is_empty()) {
            println!("{}" , header);
        }

        println!("\nBody:");
        for body in lines {
            println!("{}" , body);
        }

        // Headers:
        // To: jimb
        // From: id
        //
        // Body:
        // Oooooh, donuts!!
      #+END_SRC

    - The implementation of the ~by_ref~:
      #+BEGIN_SRC rust
        impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {
            type Item = I::Item;

            fn next(&mut self) -> Option<I::Item> {
                (**self).next()
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (**self).size_hint()
            }
        }
      #+END_SRC
      + In other words, if ~I~ is some /iterator type/, then ~&mut I~ is an
        /iterator/ too, whose ~next~ and ~size_hint~ /methods/ defer to its referent.

        When you call an /adapter/ on a /mutable reference/ to an /iterator/, the
        /adapter/ takes /ownership/ of the /reference/, _NOT_ the /iterator/ ITSELF.

        That's just a /borrow/ that ends when the /adapter/ goes out of scope.

*** DONE ~cloned~ - 344
    CLOSED: [2018-06-14 Thu 01:58]
    The ~cloned~ /adapter/ takes an /iterator/ _that produces /references/,_ and
    returns an /iterator/ _that produces /values/ cloned from those /references/._

    Naturally, the referent type *MUST* implement ~Clone~. For example:
    #+BEGIN_SRC rust
      let a = ['1', '2', '3', '∞'];
      assert_eq!(a.iter().next(),          Some(&'1'));
      assert_eq!(a.iter().cloned().next(), Some('1')); 
    #+END_SRC

*** TODO ~cycle~ - 344

** TODO Consuming Iterators - 345
*** DONE Simple Accumulation: ~count~, ~sum~, ~product~ - 345
    CLOSED: [2018-06-13 Wed 16:49]
    You can extend ~sum~ and ~product~ to work with other types by implementing
    the ~std::iter::Sum~ and ~std::iter::Product~ /traits/, which we won't
    describe in this book.

*** DONE ~max~, ~min~ - 346
    CLOSED: [2018-06-13 Wed 16:54]
    The /iterator/'s /item type/ must implement ~std::cmp::Ord~ to use the ~max~
    and ~min~ /methods/.

    - ~f32~ and ~f64~ implement ONLY ~std::cmp::PartialOrd~, not ~std::cmp::Ord~,
      so you *CANNOT* use the ~min~ and ~max~ /methods/ to compute the least or
      greatest of a sequence of floating-point numbers.

      This is NOT a popular design, but it is deliberate:
      it's NOT clear what such functions should do with IEEE ~NaN~ values.

    - If you know how you would like to handle ~NaN~ values, you can use ~min_by~
      and ~max_by~ /iterator methods/ instead.

*** DONE ~max_by~, ~min_by~ - 346
    CLOSED: [2018-06-13 Wed 16:57]
    Example:
    #+BEGIN_SRC rust
      use std::cmp::{PartialOrd, Ordering};

      // Compare two f64 values. Panic if given a NaN.
      fn cmp(lhs: &&f64, rhs: &&f64) -> Ordering {
          lhs.partial_cmp(rhs).unwrap()
      }

      let numbers = [1.0, 4.0, 2.0];
      assert_eq!(numbers.iter().max_by(cmp), Some(&4.0));
      assert_eq!(numbers.iter().min_by(cmp), Some(&1.0));

      let numbers = [1.0, 4.0, std::f64::NAN, 2.0];

      assert_eq!(numbers.iter().max_by(cmp), Some(&4.0)); // panics
    #+END_SRC
    - The _DOUBLE_ /references/ in ~cmp~'s parameters arise because ~numbers.iter()~
      produces /references/ to the elements, and then ~max_by~ and ~min_by~ pass
      the /closure references/ to the /iterator/'s /items/.

*** TODO ~max_by_key~, ~min_by_key~ - 347
*** TODO Comparing ~Item~ Sequences - 347
*** DONE ~any~ and ~all~ - 348
    CLOSED: [2018-06-13 Wed 16:58]
*** TODO ~position~, ~rposition~, and ~ExactSizeIterator~ - 348
*** TODO ~fold~ - 349
*** DONE ~nth~ - 350
    CLOSED: [2018-06-13 Wed 17:02]
    Skip ~n~ /items/ from the /iterator/, and returns the _NEXT_ /item/, or
    ~None~ if the sequence ends before the point.

    - ~.nth(0)~ is equivalent to ~.next()~.

    - Example:
      #+BEGIN_SRC rust
        let mut squares = (0..10).map(|i| i*i);

        assert_eq!(squares.nth(4), Some(16));
        assert_eq!(squares.nth(0), Some(25));
        assert_eq!(squares.nth(6), None);
      #+END_SRC

    - Its signature is shown here:
      #+BEGIN_SRC rust
        fn nth(&mut self, n: usize) -> Option<Self::Item>
            where Self: Sized;
      #+END_SRC

*** DONE ~last~ - 350
    CLOSED: [2018-06-13 Wed 17:06]
    The ~last~ /method/ *consumes* /items/ until the /iterator/ returns ~None~,
    and then returns the _last_ /item/.

    - Return ~None~ if no /items/ in this /iterator/.

    - Signature:
      ~fn last(self) -> Option<Self::Item>;~

    - Tips:
      If you have a /reversible iterator/, you may prefer ~iter.rev().next()~,
      rather than using the ~last()~ /method/.

*** DONE ~find~ - 351
    CLOSED: [2018-06-13 Wed 17:10]
    - Signature:
      #+BEGIN_SRC rust
        fn find<P>(&mut self, predicate: P) -> Option<Self::Item>
            where Self: Sized,
                  P: FnMut(&Self::Item) -> bool;
      #+END_SRC

      + It returns ~Some~ with the found element when the first time the passed
        in /closure/ returns ~true~.

      + It returns ~None~ if nothing found.

*** TODO Building Collections: ~collect~ and ~FromIterator~ - 351
*** TODO The ~Extend~ Trait - 353
*** TODO ~partition~ - 353

** TODO Implementing Your Own Iterators - 354

* TODO 16. Collections - 359
** TODO Overview - 360
   - Table 16-1. Summary of the standard collections
     =IMPORTANT=

** TODO ~Vec<T>~ - 361
*** TODO Accessing Elements - 362
*** TODO Iteration - 364
*** TODO Growing and Shrinking Vectors - 364
*** DONE Joining - 367
    CLOSED: [2018-06-13 Wed 17:25]
    TWO /methods/ work on _arrays of arrays_, by which we mean ANY /array/, /slice/,
    or /vector/ whose elements are themselves /arrays/, /slices/, or /vectors/.

    - ~slices.concat()~
      Example:
      #+BEGIN_SRC rust
        assert_eq!([[1, 2], [3, 4], [5, 6]].concat(),
                   vec![1, 2, 3, 4, 5, 6]);
      #+END_SRC

    - ~slices.join(&separator)~
      Example:
      #+BEGIN_SRC rust
        assert_eq!([[1, 2], [3, 4], [5, 6]].join(&0),
                   vec![1, 2, 0, 3, 4, 0, 5, 6]);
      #+END_SRC

    - 

*** TODO Splitting - 368
*** DONE Swapping - 370
    CLOSED: [2018-06-13 Wed 17:29]
    There's a convenience /method/ for swapping two elements:
    ~slice.swap(i, j)~ swaps the two elements ~slice[i]~ and ~slice[j]~.

    Vectors have a related method for efficiently removing any element:

    - ~vec.swap_remove(i)~ removes and returns ~vec[i]~. But no sliding.
        This is like ~vec.remove(i)~ except that instead of sliding the rest of
      the vector's elements over to close the gap, *it simply moves ~vec~'s last
      element into the gap.*

      *It's useful when you don't care about the order of the items left in the
      vector.*

*** TODO Sorting and Searching - 370
*** DONE Comparing Slices - 372
    CLOSED: [2018-06-13 Wed 18:15]
    - If a type ~T~ implements ~PartialEq~ /trait/ (~==~ and ~!=~) or
      ~PartialOrd~ /trait/ (~<~, ~<=~, ~>~, and ~>=~), then the corresponding
      /arrays/ ~[T; N]~, /slices/ ~[T]~, and /vectors/ ~Vec<T>~ support them
      too.

    - If ~T~ supports the operators ~<~, ~<=~, ~>~, and ~>=~ (the ~PartialOrd~
      /trait/, described in "Ordered Comparisons" on page 275), then /arrays/,
      /slices/, and /vectors/ of ~T~ do too.

      /Slice comparisons/ are lexicographical.

    - TWO convenience /methods/ perform common /slice comparisons/:
      + ~slice.starts_with(other)~
        Example:
        ~assert_eq!([1, 2, 3, 4].starts_with(&[1, 2]), true);~
        ~assert_eq!([1, 2, 3, 4].starts_with(&[2, 3]), false);~

      + ~slice.ends_with(other)~
        Example:
        ~assert_eq!([1, 2, 3, 4].ends_with(&[3, 4]), true);~

*** TODO Random Elements - 373
*** TODO Rust Rules Out Invalidation Errors - 373

** TODO ~VecDeque<T>~ - 374
** TODO ~LinkedList<T>~ - 376
** TODO ~BinaryHeap<T>~ - 377
** TODO ~HashMap<K, V>~ and ~BTreeMap<K, V>~ - 378
*** TODO Entries - 381
*** TODO Map Iteration - 383

** TODO ~HashSet<T>~ and ~BTreeSet<T>~ - 384
*** TODO Set Iteration - 384
*** TODO When Equal Values Are Different - 385
*** TODO Whole-Set Operations - 385

** TODO Hashing - 387
*** TODO Using a Custom Hashing Algorithm - 388

** DONE Beyond the Standard Collections 389
   CLOSED: [2018-06-13 Wed 18:28]
   - Rust collection, as much of Rust standard library, they're designed to ensure
     that the need to write ~unsafe~ is as rare as possible.

* TODO 17. Strings and Text - 391
** TODO Some Unicode Background - 392
*** TODO ASCII, Latin-1, and Unicode - 392
*** TODO UTF-8 - 392
*** TODO Text Directionality - 394

** TODO Characters (~char~) - 394
*** TODO Classifying Characters - 395
*** TODO Handling Digits - 395
*** TODO Case Conversion for Characters - 396
*** TODO Conversions to and from Integers - 396

** TODO ~String~ and ~str~ - 397
*** TODO Creating String Values - 398
*** TODO Simple Inspection - 398
*** TODO Appending and Inserting Text - 399
*** TODO Removing Text - 401
*** TODO Conventions for Searching and Iterating - 401
*** TODO Patterns for Searching Text - 402
*** TODO Searching and Replacing - 403
*** TODO Iterating over Text - 403
*** TODO Trimming - 406
*** TODO Case Conversion for Strings - 406
*** TODO Parsing Other Types from Strings - 406
*** TODO Converting Other Types to Strings - 407
*** TODO Borrowing as Other Text-Like Types - 408
*** TODO Accessing Text as UTF-8 - 409
*** TODO Producing Text from UTF-8 Data - 409
*** TODO Putting Off Allocation - 410
*** TODO Strings as Generic Collections - 412

** TODO Formatting Values - 413
   - The /template string/ must be a _constant_, so that _Rust can check it against
     the types of the arguments at compile time_.

   - Each argument *must be used*; Rust reports a compile-time error otherwise.

   - Several standard library features _SHARE_ this little language for formatting strings:
     + ~format!~ uses it to *build* ~String~'s.
     + ~println!~ and ~print!~ *write* formatted text to the /standard output stream/.
     + ~writeln!~ and ~write!~ *write* it to a /designated output stream/.
     + ~panic!~ uses it to *build* a (hopefully informative) expression of terminal dismay.

   - =EN=
     dismay - 驚

   - Rust's formatting facilities are designed to be open-ended -- you can extend
     these /macros/ to support your own types by *implementing* _the ~std::fmt~
     module's /formatting traits/._
       And you can use ~format_args!~ and the ~std::fmt::Arguments~ type to make your
     own /functions/ and /macros/ support the /formatting language/.

   - /Formatting macros/ *ALWAYS borrow shared references* to their arguments;
     they *NEVER take ownership* of them or mutate them.

   - The template's ~{...}~ forms are called /format parameters/, and have the form
     ~{which:how}~. *Both parts are optional; ~{}~ is frequently used.*

     + The =which= value selects which argument following the template should take
       the parameter's place -- you can select arguments _by index or by name_.

       Parameters with no =which= value are simply paired with arguments from left
       to right.

     + The =how= value says how the argument should be formatted:
       * how much padding,
       * to which precision,
       * in which numeric radix,
       * and so on.

       If =how= is present, the colon before it is _required_.

   - Examples table - page 414

   - In a /template string/, use _DOUBLE_ '{' or '}' to show the literal '{' and
     '}'. For example,
     #+BEGIN_SRC rust
       assert_eq!(
           format!("{{a, c}} ⊂ {{a, b, c}}"),
           "{a, c} ⊂ {a, b, c}"
       );
     #+END_SRC

*** TODO Formatting Text Values - 414
    - When formatting a textual type like &str or String ( char is treated like a single-
      character string), the how value of a parameter has several parts, all optional.
      =TODO= =RE-NOTE= =START=

*** TODO Formatting Numbers - 415
    - xxx

*** TODO Formatting Other Types - 417
    - xxx

*** DONE Formatting Values for Debugging - 418
    CLOSED: [2018-06-17 Sun 20:42]
    ~{:?}~
    - You can use ~{:?}~ to inspect /vectors/, /slices/, /tuples/, /hash tables/,
      /threads/, and hundreds of other types.
      #+BEGIN_SRC rust
        use std::collections::HashMap;
        let mut map = HashMap::new();
        map.insert("Portland", (45.5237606,-122.6819273));
        map.insert("Taipei",   (25.0375167, 121.5637));
        println!("{:?}", map);

        // {"Taipei": (25.0375167, 121.5637), "Portland": (45.5237606, -122.6819273)}
      #+END_SRC

    - If you include the ~#~ character in the /format parameter/, Rust will
      _pretty-print_ the value.
      #+BEGIN_SRC text
        {
            "Taipei": (
                25.0375167,
                121.5637
            ),
            "Portland": (
                45.5237606,
                -122.6819273
            )
        }
      #+END_SRC
      *These exact forms are _NOT guaranteed_, and do sometimes _CHANGE_ from one Rust
      release to the next.*

    - You can use the ~#[derive(Debug)]~ syntax to make your own types work with ~{:?}~:
      #+BEGIN_SRC rust
        #[derive(Copy, Clone, Debug)]
        struct Complex { r: f64, i: f64 }
        let third = Complex { r: -0.5, i: f64::sqrt(0.75) };
        println!("{:?}", third);
        // Complex { r: -0.5, i: 0.8660254037844386 }
      #+END_SRC

      + This is fine for debugging,
        BUT it might be nice if ~{}~ could print them in a more traditional form,
        like =-0.5 + 0.8660254037844386i=.
        =TODO=
        In "Formatting Your Own Types" on page 421, we'll show how to do exactly
        that.

*** DONE Formatting Pointers for Debugging - 419
    CLOSED: [2018-06-17 Sun 19:03]
    Example:
    #+BEGIN_SRC rust
      use std::rc::Rc;

      let original = Rc::new("mazurka".to_string());
      let cloned = original.clone();
      let impostor = Rc::new("mazurka".to_string());
      println!("text:     {}, {}, {}",       original, cloned, imposter);
      println!("pointers: {:p}, {:p}, {:p}", original, cloned, imposter);
    #+END_SRC

    - If you pass ANY sort of /pointer/ to a /formatting macro/ -- a /reference/,
      a ~Box~, an ~Rc~ -- the /macro/ simply follows the /pointer/ and formats its
      referent; the pointer itself is not of interest.

      However, _when you're debugging_, you usually want an address served as a
      rough "name" for an individual value, which can _be illuminating when examining
      structures with cycles or sharing_.

    - You may want to find more refined visualizations rather than a hexadecimal
      soup, BUT ~{:p}~ still the simplest and the most foundamental way, though
      it is a quick-and-dirty solution.

*** DONE Referring to Arguments by Index or Name - 419
    CLOSED: [2018-06-17 Sun 20:44]
    - You can *mix* /indexed/, /named/, and /positional/ (that is, no index or name)
      parameters together in a single /formatting macro/ use.

*** DONE Dynamic Widths and Precisions - 420
    CLOSED: [2018-06-17 Sun 21:28]
    - A parameter's
      + minimum field width,
      + text length limit,
      + numeric precision

      _need NOT_ always be fixed values; you can choose them AT /runtime/.

    - Explain by examples:
      + ~format!("{:>1$}", content, get_width())~
        Use the 1st arguments (count from 0th), here is the ~get_width()~, as the
        width.

      + ~format!("{:>width$}", content, width=get_width())~
        Same as above, but refer to the argument _by name_.

      + The same approach works for the _text length limit_ as well:
        ~format!("{:>width$.limit$}", content, width=get_width(), limit=get_limit())~

      + =???=
        In place of the _text length limit_ or _floating-point precision_, you can
        also write ~*~, which says to take the _NEXT positional argument_ as the
        precision. The following clips ~content~ to at most ~get_limit()~ characters:
        ~format!("{:.*}", get_limit(), content)~

    - The argument taken as the precision *must be* a ~usize~.
      There is _NO_ corresponding syntax for the _field width_.

*** TODO Formatting Your Own Types - 421
    - xxx

*** TODO Using the Formatting Language in Your Own Code - 423
    - xxx

** TODO Regular Expressions - 424
*** TODO Basic Regex Use - 425
*** TODO Building Regex Values Lazily - 426

** TODO Normalization - 427
*** TODO Normalization Forms - 428
*** TODO The unicode-normalization Crate - 429

* TODO 18. Input and Output - 431
  - Rust's /standard library/ features for /input/ and /output/ are organized
    around *three* /traits/:
    + ~Read~
    + ~BufRead~
    + ~Write~

    and the various types that implement them:

    + Values that implement ~Read~ have /methods/ for *byte-oriented input*.
      They're called /readers/.

    + Values that implement ~BufRead~ have
      * all the /methods/ of ~Read~
      * (plus) /methods/ for _reading lines of text_ and so forth.

      They're called /buffered readers/.

    + Values that implement ~Write~ support _BOTH_
      * *byte-oriented output*
      * *UTF-8 text output*.

      They're called /writers/.

  - Figure 18-1. Selected /reader (bufferd or non-buffered)/ and /writer/ types
    from the Rust standard library.

** TODO Readers and Writers - 432
   - /Readers/ are values that your program can _read bytes from_.
     Examples include:
     + _Files opened_ using ~std::fs::File::open(filename)~;

     + ~std::net::TcpStream~'s, for *receiving* data over the _network_;


     + ~std::io::stdin()~, for *reading* from the /process's standard input stream/;

     + ~std::io::Cursor<&[u8]>~ values, which are /readers/ that "read" from a
       /byte array/ that's _ALREADY in memory_.

   - /Writers/ are values that your program can _write bytes to_.
     Examples include:
     + _Files opened_ using ~std::fs::File::create(filename)~;

     + ~std::net::TcpStream~'s, for *sending* data over the _network_;

     + ~std::io::stdout()~ and ~std::io:stderr()~, for *writing* to the terminal;

     + ~std::io::Cursor<&mut [u8]>~ values, which let you treat any /mutable slice
       of bytes/ *as a file* for *writing*;

     + ~Vec<u8>~, a /writer/ whose ~write~ /methods/ *append* to the vector =TODO= =???=

   - For example, here's a function that *copies all bytes* _from_ ANY /reader/
     _to_ ANY /writer/:
     #+BEGIN_SRC rust
       use std::io::{self, Read, Write, ErrorKind};

       const DEFAULT_BUF_SIZE: usize = 8 * 1024;

       pub fn copy<R: ?Size, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>
           where R: Read, W: Write
       {
           let mut buf = [0; DEFAULT_BUF_SIZE];
           let mut written = 0;
           loop {
               let len = match reader.read(&mut buf) {
                   Ok(0)                                            => return Ok(written),
                   Ok(len)                                          => len,
                   Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,
                   Err(e)                                           => return Err(e),
               };
               writer.write_all(&buf[..len])?;
               written += len as u64;
           }
       }
     #+END_SRC
     + This is the implementation of ~std::io::copy()~ from /Rust's standard
       library/.

       Since it's /generic/, you can use it to copy data from a ~File~ to a
       ~TcpStream~, from ~Stdin~ to an in-memory ~Vec<u8>~, etc.

   - The *four* ~std::io~ /traits/ ~Read~, ~BufRead~, ~Write~, and ~Seek~ are so
     commonly used that there's a /prelude module/ containing _ONLY_ those /traits/:
     ~use std::io::prelude::*;~

   - The ~self~ in the statement ~use std::io::{self, Read, Write, ErrorKind};~ is
     an alias to the ~std::io~. This means you can, for example, write ~io::Result~,
     rather than ~std::io::Result~.

*** TODO Readers - 433
    ~std::io::Read~ has several /methods/ for _reading data_.
    All of them take the /reader/ itself _by ~mut~ /reference/._

    - The main /methods/ of the ~Read~ /trait/.
      + ~reader.read(&mut buffer)~
        * Read some bytes from the data source
          and
          store them in the given ~buffer~.

        * The type of the ~buffer~ argument is ~&mut [u8]~.

        * This reads up to ~buffer.len()~ bytes.

        * The /return type/ is ~io::Result<u64>~ (an alias for ~Result<u64, io::Error>~).
          - One success, the ~u64~ value is the number of bytes read.
            ~Ok(0)~ means there is no more input to read.

        * One error, this /method/ returns ~Err(err)~, here the ~err~ is an
          ~io::Error~ value.
          - An ~io::Error~ is printable, for the benefit of humans;

          - ~io::Error~ has a ~kind()~ method that returns an error code of type
            ~io::ErrorKind~, of course, as you can guess, it is a /enum/.

          - ~io::ErrorKind~ has members like ~PermissionDenied~ and ~ConnectionReset~.

            Most of them indicate serious errors that you can't ignore,
            _BUT_ one /kind/ of error, ~io::ErrorKind::Interrupted~, should be
            handled specially -- it corresponds to the Unix error code ~EINTER~,
            which means the read happened to be interrupted by a /signal/.

            _UNLESS_ the program is designed to do something clever with /signals/,
            it SHOULD JUST RETRY the ~read~.
              The code for ~copy()~, in the preceding section, shows an example
            of this.

        * As you can see, the ~read~ /method/ is very low-level, even inheriting
          quirks of the underlying operating system
          - if you're implementing the ~Read~ /trait/ for a new type of data source,
            this gives you a lot of leeway.

          - to relif the pain of using this ~read~ /method/,
            Rust provides several *higher-level CONVENIENCE* methods. All of them
            have default implementations in terms of ~.read()~. They all handle
            ~ErrorKind::Interrupted~, so you don't have to.

      + ~reader.read_to_end(&mut byte_vec)~
        Read all _remaining input_ from this ~reader~, appending it to ~byte_vec~,
        which is a ~Vec<u8>~.

        * Return ~io::Result<()>~.

        * *CAUTION*
          There is _no limit_ on the amount of data this method will pile into
          the /vector/, so *don't use it on an UNTRUSTED SOURCE.* (You can impose
          a limit using the ~.take()~ method, described below.)

      + ~reader.read_to_string(&mut string)~
        It is similar to ~reader.read_to_end(&mut byte_vec)~,
        BUT append the data to the given ~String~.

        If the stream isn't valid UTF-8, this returns an ~ErrorKind::InvalidData~ error.

        =RE-READ= =???=
        In some languages, byte input and character input are handled by
        different types. These days, UTF-8 is so dominant that Rust acknowledges
        this de facto standard and supports UTF-8 everywhere. Other character
        sets are supported with the open source encoding crate.

      + ~reader.read_exact(&mut buf)~
        Read exactly enough data to fill the given buffer ~buf~.

        * The /argument type/ is ~&[u8]~.

        * IF the /reader/ runs out of data before reading ~buf.len()~ bytes,
          this returns an ~ErrorKind::UnexpectedEof~ error.


    - Four adapter /methods/ that take the /reader/ by value, transforming it into
      an /iterator/ or a DIFFERENT /reader/:
      + ~reader.bytes()~
        Return an /iterator/ over the bytes of the input stream.

        The item type is ~io::Result<u8>~, so _an error check is required for
        every byte_.

        Furthermore, this calls ~reader.read()~ once per byte, which will be
        very *INEFFICIENT* IF the /reader/ is *NOT buffered*.

      + ~reader.chars()~
        Similar to ~reader.bytes()~ but the item contains ~char~.
        Treat the input as UTF-8. Invalid UTF-8 causes an ~InvalidData~ error.

      + ~reader.chain(reader2)~
        Return a new /reader/ that produces all the input from /reader/,
        followed by all the input from ~reader2~.

      + ~reader.take(n)~
        Return a new /reader/ that reads from the same source as ~reader~,
        BUT is limited to ~n~ /bytes/ of input.

    - There is *NO* /method/ for _closing_ a /reader/.

      /Readers/ and /writers/ typically implement ~Drop~ so that they are
      _closed AUTOMATICALLY_.

*** DONE Buffered Readers - 435
    CLOSED: [2018-06-16 Sat 22:42]
    - For efficiency, /readers/ and /writers/ can be *buffered*,
      which simply means they have a chunk of memory (a /buffer/) that holds some
      input or output data in memory.

    - Figure 18-2   =Re-Read=

    - ~BufReader~ get a large chunk of input from the OS to its /buffer/.
      When the user use a ~BufReader~ implementation to read, it reads from the
      /buffer/.

    - The actual default size of a ~BufReader~'s /buffer/ is _several kilobytes_.

    - /Buffered readers/ implement both ~Read~ and a SECOND /trait/, ~BufRead~,
      which adds the following /methods/:
      + ~buf_reader.read_line(&mut line)~
        * Read a line of text and appends it to line, which is a ~String~.
          The /newline character/ at the end of the line is included in line.

        * The /return value/ is an ~io::Result<usize>~, _the number of bytes read,
          including the line ending, if any._

        * If the /buffered reader/ is at the end of the input, this
          1. leaves line unchanged;
          2. returns ~Ok(0)~.

      + ~buf_reader.lines()~
        Return an /iterator/ over the lines of the input.

        The /item type/ is ~io::Result<String>~.
        /Newline characters/ are _NOT included_ in the strings.

        *This /method/ is _ALMOST ALWAYS what you want for text input_.*
        =TODO= The next two sections show some examples of its use.
        
      + ~buf_reader.read_until(stop_byte, &mut byte_vec)~ and
        ~reader.split(stop_byte)~

        They are just like ~.read_line()~ and ~.lines()~, but byte-oriented, producing
        ~Vec<u8>~'s instead of ~String~'s. You choose the delimiter ~stop_byte~ .

    - ~BufRead~ also provides a pair of LOW-LEVEL /methods/, ~.fill_buf()~ and
      ~.consume(n)~, for _direct access_ to the /reader's internal buffer/.
      For more about these methods, see the online documentation. =TODO= =TODO=

    - =TODO= The next two sections cover buffered readers in more detail.

*** TODO Reading Lines - 436
*** DONE Collecting Lines - 439
    CLOSED: [2018-06-17 Sun 14:58]
    For several _reader methods_ that returns /iterators/, including ~.lines()~,
    produce ~Result~ /item values/.
      You may want to collect all the lines in to a vector. If you call the ~.collect()~
    /method/ directly, the result is NOT what you usually want -- we usually want
    a vector of string, and this vector can be wrapped by something; but what we
    get is of type ~Vec<io::Result<String>>~. Mostly, we want types like ~Vec<String>~
    or ~<io::Result<Vec<String>>>~.

    - Solution: =IMPORTANT=
      ~let lines = reader.lines().collect::<io::Result<Vec<String>>>()?;~
      The ~lines~ has type ~Vec<String>~.
      If you drop the ~?~, the type is ~<io::Result<Vec<String>>>~.

      + Q :: How does this work?

      + A :: The standard library contains an implementation of ~FromIterator~ for
             ~Result~ -- easy to overlook in the online documentation -- that makes
             this possbile:
             #+BEGIN_SRC rust
               impl<T, E C> FromIterator<Result<T, E>> for Result<C, E>
                   where C: FromIterator<T>
               {
                   // ...
               }
             #+END_SRC

        - This says:
          if you can collect items of type ~T~ into a collection of type ~C~
          (~where C: FromIterator<T>~)
          then you can collect items of type ~Result<T, E>~ into a result of type
          ~Result<C, E>~ (~FromIterator<Result<T, E>> for Result<C, E>~).

          In other words, io::Result<Vec<String>> is a collection type, so the
          ~.collect()~ /method/ can create and populate values of that type. 

*** TODO Writers - 439
    - As we've seen, input is mostly done using /methods/.
      Output is a bit _different_.

    - 

*** TODO Files - 441
    - 

*** TODO Seeking - 441
    - 

*** TODO Other Reader and Writer Types - 442
    - 

*** TODO Binary Data, Compression, and Serialization - 444
    - 

** DONE Files and Directories - 445
   CLOSED: [2018-06-08 Fri 22:22]
   The next few sections cover Rust's features for working with _files_ and
   _directories_, which live in the ~std::path~ and ~std::fs~ /modules/. All of
   these features involve _working with filenames_, so we'll start with the
   /filename types/.

*** DONE ~OsStr~ and ~Path~ - 445
    CLOSED: [2018-06-08 Fri 20:30]
    - Inconveniently, your operating system _does *NOT force VALID* Unicode_
      filenames.

      + Linux: 
        Any string of bytes (excluding null bytes and slashes) is an acceptable
        filename.

      + Windows: 
        ALMOST ANY (=???=) string of 16-bit "wide characters" is an acceptable
        filename, even strings the operating system handles, like /command-line
        arguments/ and /environment variables/.

    - Rust strings (~str~ and ~String~) are always *valid* Unicode.
      Rust has to cope with the rare case where the filenames are NOT Unicode.
      Rust has ~std::ffi::OsStr~ and ~OsString~.

    - =NOTE= TODO

    - ~std::path::Path~ and its /owning type/ ~PathBuf~.
      ~Path~ is purely a convenience -- it is exactly like ~OsStr~, but it _adds
      many handy /filename-related methods/._ ~Path~ is be used for both /absolute
      and relative paths/. For individual component of a /path/, use ~OsStr~.

    - Lastly, for each string type, there's a corresponding owning type:
      a ~String~ _owns_ a *heap-allocated* ~str~, a ~std::ffi::OsString~ _owns_ a
      *heap-allocated* ~OsStr~ , and a ~std::path::PathBuf~ _owns_ a *heap-allocated*
      ~Path~.
      |                                            | ~str~          | ~OsStr~           | ~Path~           |
      |--------------------------------------------+----------------+-------------------+------------------|
      | Unsized type, always passed by reference   | Yes            | Yes               | Yes              |
      | Can contain any Unicode text               | Yes            | Yes               | Yes              |
      | Looks just like UTF-8, normally            | Yes            | Yes               | Yes              |
      | Can contain non-Unicode data               | No             | Yes               | Yes              |
      | Text processing methods                    | Yes            | No                | No               |
      | Filename-related methods                   | No             | No                | Yes              |
      | Owned, growable, heap-allocated equivalent | ~String~       | ~OsString~        | ~PathBuf~        |
      | Convert to owned type                      | ~.to_string()~ | ~.to_os_string()~ | ~.to_path_buf()~ |

      =TODO= =???=
      All three of these types implement a common /trait/, ~AsRef<Path>~, so we
      can easily declare a /generic function/ that accepts "any filename type" as
      an argument. This uses a technique we showed in "AsRef and AsMut" on page 294. =TODO=
      #+BEGIN_SRC rust
        use std::path::Path;
        use std::io;

        fn swizzle_file<P>(path_arg: P) -> io::Result<()>
            where P: AsRef<Path>
        {
            let path = path_arg.as_ref();
            // ...
        }
      #+END_SRC
      =???= =TODO=
      All the standard functions and methods that take path arguments use this
      technique, so you can freely pass string literals to any of them.

*** DONE ~Path~ and ~PathBuf~ Methods - 447
    CLOSED: [2018-06-08 Fri 20:30]
    ~Path~ offers the following methods, among others:
    + ~Path::new(str)~
      Convert a ~&str~ or ~&OsStr~ to a ~&Path~.

      This does *NOT copy* the string:
      the new ~&Path~ *points to* the same bytes as the ORIGINAL ~&str~ or ~&OsStr~.

    + ~path.parent()~
      The /return type/ is ~Option<&Path>~.
      *NO string copy*, the result path just *point to* the substring of the ~path~.

      For instance, 
      ~Path::new("/home/fwolfe/program.txt").parent()~
      returns ~Path::new("/home/fwolfe")~

    + ~path.file_name()~
      Return the last component of ~path~, if any.
      The /return type/ is ~Option<&OsStr>~.

      For instance,
      * ~Path::new("/home/fwolfe/program.txt").file_name()~
        returns ~Some(OsStr::new("program.txt"))~.

      * ~Path::new("/home/fwolfe/").file_name()~
        returns ~Some(OsStr::new("fwolfe"))~.

    + ~path.is_absolute()~ and ~path.is_relative()~

    + ~path1.join(path2)~
      #+BEGIN_SRC rust
        let path1 = Path::new("/usr/share/dict");
        assert_eq!(path1.join("words"),
                   Path::new("/usr/share/dict/words"));
      #+END_SRC
      IF ~path2~ is an /absolute path/, this just returns a _copy_ of ~path2~,
      so _this /method/ can be used to *convert* ANY /path/ to an /absolute
      path/:_ ~let abs_path = std::env::current_dir()?.join(any_path);~

    + ~path1.components()~
      Returns an /iterator/ over the components of the given path, from left to
      right.

      The item type of this /iterator/ is ~std::path::Component~, and /enum/ that
      can represent all the different pieces that can appear in filenames:
      #+BEGIN_SRC rust
        pub enum Component<'a> {
            Prefix(PrefixComponent<'a>),  // Windows-only: a drive letter or share
            RootDir,                      // the root directory, `/` or `\`
            CurDir,                       // the `.` special directory
            ParentDir,                    // the `..` special directory
            Normal(&'a OsStr),            // plain file and directory names
        }
      #+END_SRC
      * For instance,
        A Windows path =\\venice\Music\A Love Supreme\04-Psalm.mp3= consists of
        1. a ~Prefix~ representing =\\venice\Music=
        2. a ~RootDir~
        3. two ~Normal~ components representing =A Love supreme= and =04-Psalm.mp3=.

    + /methods/ that query the filesystem:
      * ~.exists()~
      * ~.is_file()~
      * ~.is_dir()~
      * ~.read_dir()~
      * ~.canonicalize()~, and so on.

    + /methods/ that convert ~Path~'s to strings.
      Each one allows for the posibility of invalid UTF-8 in the ~Path~.
      * ~path.to_str()~
        Convert ~Path~ to an ~Option<&str>~.
        If the ~Path~ content isn't valid UTF-8, this returns ~None~.

      * ~path.to_string_lossy()~
        If path is _NOT valid UTF-8_, this /method/ _make a copy_, *replacing*
        each _invalid byte sequence_ with the /Unicode replacement character/,
        =U+FFFD (‘�’)=.

        The /return type/ is ~std::borrow::Cow<str>~.
        =TOOD= See "Borrow and ToOwned at Work: The Humble Cow"

      * ~path.display()~
        The value this returns is _NOT a string_, but it implements ~std::fmt::Display~,
        so it can be used with ~format!()~, ~println!()~, and friends.

        If the path is *NOT valid* UTF-8, the output may contain the ~�~ character.

*** DONE Filesystem Access Functions - 449
    CLOSED: [2018-06-08 Fri 21:38]
    - Table 18-1. Summary of filesystem access functions

    - For creating /symbolic links/, see "Platform-Specific Features" on page 451.
      =TODO=

    - NOTE ......

    - As a convenience,
      the ~Path~ type has a few of these built in as /methods/:
      ~path.metadata()~, for example, is the same thing as ~std::fs::metadata(path)~.

*** DONE Reading Directories - 450
    CLOSED: [2018-06-08 Fri 22:16]
    Use ~std::fs::read_dir(path)~ and the ~.read_dir()~ /method/ of a ~Path~:

    - Example:
      #+BEGIN_SRC rust
        for entry_result in path.read_dir()? {
            let entry = entry_result?;
            println!("{}", entry.file_name().to_string_lossy());
        }
      #+END_SRC

    - Note the *two* uses of ~?~ in this code.
      + The first line checks for errors *opening the directory*.
      + The second line checks for errors *reading the next entry*.

    - The type of ~entry~ is ~std::fs::DirEntry~, and it's a /struct/ with just a
      few /methods/:
      + ~entry.file_name()~ is the name of the file or directory, as an ~OsString~.

      + ~entry.path()~ is the same, but with the original path joined to it, producing
        a new ~PathBuf~. If the directory we're listing is =/home/jimb=, and
        ~entry.file_name()~ is =.emacs=, then ~entry.path()~ would return
        ~PathBuf::from("\slash{}home\slash{}jimb\slash{}.emacs")~.

      + ~entry.file_type()~ returns an ~io::Result<FileType>~.
        ~FileType~ has ~.is_file()~, ~.is_dir()~, and ~.is_symlink()~ /methods/.

      + ~entry.metadata()~ gets the rest of the metadata about this /entry/.

    - The special directories ~.~ and ~..~ are not listed when reading a directory.
      =TIPs=

    - Example, recursively copies a directory tree from one place to another on
      disk:
      #+BEGIN_SRC rust
        use std::fs;
        use std::io;
        use std::path::Path;

        /// Copy the existing directory `src` to the target path `dst`.
        fn copy_dir_to(src: &Path, dst: &Path) -> io::Result<()> {
            if !dst.is_dir() {
                fs::create_dir(dst)?;
            }

            for entry_result in src.read_dir()? {
                let entry = entry_result?;
                let file_type = entry.file_type()?;
                copy_to(&entry.path(), &file_type, &dst.join(entry.file_name()))?;
            }

            Ok(())
        }
      #+END_SRC

      A separate function, ~copy_to~, copies individual directory entries:

      #+BEGIN_SRC rust
        /// Copy whatever is at `src` to the target path `dst`.
        fn copy_to(src: &Path, src_type: &fs::FileType, dst: &Path) -> io::Result<()> {
            if src_type.is_file() {
                fs::copy(src, dst)?;
            } else if src_type.is_dir() {
                copy_dir_to(src, dst)?;
            } else {
                return Err(io::Error::new(io::ErrorKind::Other,
                                          format!("don't know how to copy: {}", src.display())));
            }

            Ok(())
        }
      #+END_SRC

*** TODO Platform-Specific Features - 451 =RE-READ= =TAKE NOTES=

** DONE Networking - 453
   CLOSED: [2018-06-08 Fri 23:00]
   =From Jian= I only take nots, I don't understand /network programing/.
   Re-read later when I understand.

   - For _low-level networking code_, start with the ~std::net module~, which
     provides _cross-platform_ SUPPORT _for TCP and UDP networking_.

   - Use the ~native_tls~ /crate/ for _SSL/TLS_ SUPPORT.

   - For high-performance servers, you'll need to use /ASYNCHRONOUS input and
     output/. The ~mio~ /crate/ provides the needed support.

   - There's also the EXPERIMENTAL ~tokio~ /crate/, which wraps the ~mio~ event
     loop in a futures-based API, reminiscent of JavaScript promises.

   - Higher-level protocols are supported by third-party crates.
     For example, the ~reqwest~ /crate/ offers a beautiful API for HTTP clients.

   - The ~iron~ framework for HTTP servers offers high-level touches such as the
     ~BeforeMiddleware~ and ~AfterMiddleware~ traits, which help you compose an
     app from pluggable parts.

   - The ~websocket~ /crate/ implements the _WebSocket protocol_.

   - And so on. Rust is a young language with a busy open source ecosystem. Support
     for networking is rapidly expanding.

* TODO 19. Concurrency - 457
** TODO Fork-Join Parallelism - 459
*** TODO ~spawn~ and ~join~ - 461
*** TODO Error Handling Across Threads - 463
*** TODO Sharing Immutable Data Across Threads - 464
*** TODO Rayon - 466
*** TODO Revisiting the Mandelbrot Set - 468

** TODO Channels - 470
*** TODO Sending Values - 472
*** TODO Receiving Values - 475
*** TODO Running the Pipeline - 476
*** TODO Channel Features and Performance - 478
*** TODO Thread Safety: Send and Sync - 479
*** TODO Piping Almost Any Iterator to a Channel - 482
*** TODO Beyond Pipelines - 483

** TODO Shared Mutable State - 484
*** TODO What Is a Mutex? - 484
*** TODO ~Mutex<T>~ - 486
*** TODO mut and Mutex - 488
*** TODO Why Mutexes Are Not Always a Good Idea - 488
*** TODO Deadlock - 489
*** TODO Poisoned Mutexes - 490
*** TODO Multi-producer Channels Using Mutexes - 490
*** TODO Read/Write Locks (~RwLock<T>~) - 491
*** TODO Condition Variables (Condvar) - 493
*** TODO Atomics - 494
*** TODO Global Variables - 496

** TODO What Hacking Concurrent Code in Rust Is Like - 497

* TODO 20. Macros - 499
  - Rust supports /macros/,
    a way to extend the language in ways that go *beyond* what you can do with
    /functions/ ALONE.

  - Example:
    ~assert_eq!(gcd(6, 10), 2);~

    + This could have been written as a /generic function/,

      _BUT_ the ~assert_eq!~ /macro/ does several things _that /functions/ *CANNOT*
      do_.

      One is that when an assertion fails, ~assert_eq!~
      _generates an error message containing the FILENAME and LINE NUMBER of the
      assertion._

      *Functions have no way of getting that information*.
      *Macros can*, because the way they work is completely different.

  - /Macros/ are a kind of shorthand.
    During compilation,
    + _BEFORE_ types are checked
      and
    + _LONG BEFORE_ any machine code is generated, each /macro/ call is /expanded/
      -- that is, it's replaced with some Rust code.

  - The preceding /macro/ call /expands/ to this:
    #+BEGIN_SRC rust
      match (&gcd(6, 10), &2) {
          (left_val, right_val) => {
              if !(*left_val == *right_val) {
                  panic!("assertion failed: `(left == right)`, \
                          (left: `{:?}`, right: `{:?}`)", left_val, right_val);
              }
          }
      }
    #+END_SRC
    + ~panic!~ is also a /macro/, so it then expands to some more Rust code.
      That code uses TWO other /macros/, ~file!()~ and ~line!()~.

      Once every /macro/ call in the /crate/ is *FULLY* /expanded/, Rust moves on
      to the next phase of compilation.

    + At run time, an assertion failure would look like this (and would indicate
      a bug in the ~gcd()~ function, since ~2~ is the correct answer):
      #+BEGIN_SRC text
        thread 'main' panicked at 'assertion failed: `(left == right)`, (left: `17`,
        right: `2`)', gcd.rs:7
      #+END_SRC

    + Rust /macros/ NEVER insert _unmatched brackets or parentheses._

** TODO Macro Basics - 500
   - Figure 20-1 shows part of the source code for the ~assert_eq!~ /macro/.
     + /pattern/ and /template/

     + Code:
       #+BEGIN_SRC rust
         macro_rules! assert_eq {
             ($left:expr, $right:expr) => ({
                 match (&$left, &$right) {
                     if !(*left_val = *right_val) {
                         panic!("assertion failed: `(left == right)` (left: `{:?}`, right: `{:?}`)",
                                left_val, right_val)
                     }
                 }
             });
         }
       #+END_SRC


   - ~macro_rules!~ is the *MAIN* way to define /macros/ in Rust.

     Note that there is *NO* ~!~ after ~assert_eq~ in this /macro/ definition:
     the ~!~ is
     + _ONLY_ included when *calling* a /macro/,
     + NOT when *defining* it.

   - =TODO=
     We'll talk about another approach, called /procedural macros/, at the end of
     this chapter.

     But for the most part, we'll focus on ~macro_rules!~.

   - A macro defined with ~macro_rules!~ works *entirely* by /pattern matching/.
     The _body_ of a /macro/ is just *a series of RULES*:
     #+BEGIN_SRC rust
       ( pattern1 ) => ( template1 );
       ( pattern2 ) => ( template2 );
       ...
     #+END_SRC

   - Incidentally, you _can use square brackets or curly braces_ instead of parentheses
     around the pattern or the template; it makes no difference to Rust. Likewise, when
     you call a /macro/, these are all equivalent:
     #+BEGIN_SRC rust
       assert_eq!(gcd(6, 10), 2);
       assert_eq![gcd(6, 10), 2];
       assert_eq!{gcd(6, 10), 2}
     #+END_SRC

     + The only difference is that _semicolons_ are usually _optional_ after curly
       braces.

       _By convention_, we use
       * parentheses when calling ~assert_eq!~,
       * square brackets for ~vec!~,
         and
       * curly braces for ~macro_rules!~;

       but it's just a convention.

*** TODO Basics of Macro Expansion - 501
    - x

*** TODO Unintended Consequences - 503
    - x

*** TODO Repetition - 505
    | Pattern      | Meaning                                        |
    | ~$( ... )*~  | Match _0_ or more times with no separator        |
    | ~$( ... ),*~ | Match _0_ or more times, separated by commas     |
    | ~$( ... );*~ | Match _0_ or more times, separated by semicolons |
    | ~$( ... )+~  | Match _1_ or more times with no separator        |
    | ~$( ... ),+~ | Match _1_ or more times, separated by commas     |
    | ~$( ... );+~ | Match _1_ or more times, separated by semicolons |

** DONE Built-In Macros - 507
   CLOSED: [2018-06-05 Tue 22:12]
   - The Rust compiler supplies several /macros/ that are helpful when you're
     defining your own /macros/.

     *None* of these could be implemented using ~macro_rules!~ alone -- they're
     *hardcoded* in /rustc/:

     + ~file!()~ expands to a /string literal/: the _current filename_.

       ~line!()~ expand to a ~u32 literal~ giving the _current line_ (counting
       from 1).

       ~column!()~ expand to a ~u32 literal~ giving the _current column_ (counting
       from 0).

       =REMEMBER=
       If one /macro/ calls another, which calls another, _all in DIFFERENT files_,
       and the *LAST* /macro/ calls ~file!()~, ~line!()~, or ~column!()~, it will
       expand to *indicate the location of the first macro call*.

     + ~stringify!(...tokens...)~ expands to a /string literal/ containing the
       given tokens.
       =From Jian= Here ~...tokens...~ means anything in side the parentheses.
       For instance, ~stringify!(1 2 3 4)~ generates "1 2 3 4", ~stringify!(1 , 2)~
       generates "1, 2", and ~stringify!(1 + 1)~ generates "1 + 1".

       * The ~assert!~ macro uses ~stringify!~ to generate an error message that
         includes the code of the assertion.

       * /Macro calls/ in the argument are *NOT* expanded: ~stringify!(line!())~
         expands to the string ~"line!()"~ .

       * Rust constructs the string ONLY from the tokens, so there are *NO* _line
         breaks_ or _comments_ in the string.

     + ~concat!(str0, str1, ...)~ expands to a single /string literal/ made by
       concatenating its arguments.

   - Rust also defines these /macros/ for _querying the build environment_:
     + ~cfg!(...)~ expands to a Boolean constant, true if the current build
       configuration matches the condition in parentheses. For example,
       ~cfg!(debug_assertions)~ is true if you’re compiling with debug
       assertions enabled.

       This macro supports exactly the same syntax as the #[cfg(...)] attribute
       described in “Attributes” on page 175 but instead of conditional
       compilation, you get a true or false answer.

     + ~env!("VAR_NAME")~ expands to a string: the value of the specified environment
       variable at compile time. If the variable doesn’t exist, it’s a compilation error.
       This would be fairly worthless except that Cargo sets several interesting environ‐
       ment variables when it compiles a crate. For example, to get your crate’s current
       version string, you can write: ~let version = env!("CARGO_PKG_VERSION");~
       A full list of these environment variables is included in the Cargo documentation.

     + ~option_env!("VAR_NAME")~ is the same as ~env!~ except that it returns an
       ~Option<&'static str>~ that is None if the specified variable is not set.

   - Three more /built-in macros/ let you _bring in code or data from another file_.
     + ~include!("file.rs")~ expands to the contents of the specified file, which
       must be valid Rust code -- either an expression or a sequence of items.

     + ~include_str!("file.txt")~ expands to a ~&'static str~ containing the _text_
       of the specified file. You can use it like this:
       #+BEGIN_SRC rust
         const COMPOSITOR_SHADER: &str =
             include_str!("../resources/compositor.glsl");
       #+END_SRC

       If the file doesn't exist, or is not valid UTF-8, you'll get a
       _compilation error_.

     + ~include_bytes!("file.dat")~ is the same except the file is treated as _binary
       data_, NOT UTF-8 text. The result is a ~&'static [u8]~.

** DONE Debugging Macros - 508
   CLOSED: [2018-06-10 Sun 20:58]
   - Debugging a wayward /macro/ can be challenging.

     + The biggest problem is
       the lack of visibility into the process of macro expansion.

   - Rust will often *expand* all /macros/, find some kind of error, and then print
     an error message that does _NOT show the fully expanded code_ that contains
     the error!

   - Here are _THREE_ tools to help *troubleshoot* /macros/.
     (These features are ALL *unstable*,
     but since they're really designed to be used during development, not in
     code that you’d check in, that isn’t a big problem in practice.)

     + The simplest, you can ask ~rustc~ to show what your code looks like _after
       expanding_ ALL /macros/.

       Use ~cargo build --verbose~ to see how Cargo is invoking ~rustc~.
       1. Copy the ~rustc~ command line
          and
       2. add ~-Z unstable-options --pretty expanded~ as options.

       Then the _fully expanded code_ is dumped to your terminal.

       _Unfortunately, this ONLY WORKS if your code is free of syntax errors._

     + Rust provides a ~log_syntax!()~ /macro/ that simply prints its
       arguments to the terminal at /compile time/. You can use this for
       ~println!~-style debugging. This macro requires the ~#![feature(log_syntax)]~
       feature flag.
       =From Jian= Not clear! Try this!

     + You can ask the Rust compiler to _log ALL /macro/ calls_ to the terminal.
       Insert ~trace_macros!(true);~ somewhere in your code.
         From that point on, each time Rust *expands* a /macro/, it will print the
       /macro/ _name_ and _arguments_. For example, this program:
       For example:
       #+BEGIN_SRC rust
         #![feature(trace_macros)]

         fn main() {
             trace_macros!(true);
             let numbers = vec![1, 2, 3];
             trace_macros!(false);
             println!("total: {}", numbers,iter().sum::<u64>());
         }


       #+END_SRC

       Compile it

       #+BEGIN_SRC bash
         # $
         rustup override set nightly
         ## ...

         # $
         rustc trace_example.rs
         ## note: trace_macro
         ##  --> trace_example.rs:5:19
         ##   |
         ## 5 |     let numbers = vec![1, 2, 3];
         ##   |                   ^^^^^^^^^^^^^
         ##   |
         ##   = note: expanding `vec! { 1 , 2 , 3 }`
         ##   = note: to `< [ _ ] > :: into_vec ( box [ 1 , 2 , 3 ] )`
       #+END_SRC
       * The compiler shows the code of EACH /macro/ call, both *before* and
         *after* _expansion_. The line ~trace_macros!(false);~ turns tracing off
         again, so the call to ~println!()~ is not traced.

** TODO The ~json!~ Macro - 509
*** TODO Fragment Types - 510
*** TODO Recursion in Macros - 513
*** TODO Using Traits with Macros - 514
*** TODO Scoping and Hygiene - 516
*** TODO Importing and Exporting Macros - 519

** TODO Avoiding Syntax Errors During Matching - 521
** TODO Beyond ~macro_rules!~ - 522

* TODO 21. Unsafe Code - 525
** TODO Unsafe from What? - 526
** TODO Unsafe Blocks - 527
*** TODO Example: An Efficient ASCII String Type - 529

** TODO Unsafe Functions - 531
** TODO Unsafe Block or Unsafe Function? - 533
** TODO Undefined Behavior - 533
** TODO Unsafe Traits - 536
** TODO Raw Pointers - 538
*** TODO Dereferencing Raw Pointers Safely - 540
*** TODO Example: ~RefWithFlag~ - 541
*** TODO Nullable Pointers - 544
*** TODO Type Sizes and Alignments - 544
*** TODO Pointer Arithmetic - 545
*** TODO Moving into and out of Memory - 546
*** TODO Example: ~GapBuffer~ - 550
*** TODO Panic Safety in Unsafe Code - 556

** TODO Foreign Functions: Calling C and C++ from Rust - 557
*** TODO Finding Common Data Representations - 558
*** TODO Declaring Foreign Functions and Variables - 561
*** TODO Using Functions from Libraries - 562
*** TODO A Raw Interface to libgit2 - 566
*** TODO A Safe Interface to libgit2 - 572

** TODO Conclusion - 583

* Index - 585
