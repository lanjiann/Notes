#+TITLE: Real World Haskell
#+VERSION: 2009
#+AUTHOR: Bryan O'Sullivan, John Goerzen & Don Stewart
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Preface - xxiii][Preface - xxiii]]
- [[1 Getting Started - 1][1 Getting Started - 1]]
  - [[Your Haskell Environment - 1][Your Haskell Environment - 1]]
  - [[Getting Started with ghci, the Interpreter - 2][Getting Started with ghci, the Interpreter - 2]]
  - [[Basic Interaction: Using ghci as a Calculator - 3][Basic Interaction: Using ghci as a Calculator - 3]]
    - [[Simple Arithmetic - 3][Simple Arithmetic - 3]]
    - [[An Arithmetic Quirk: Writing Negative Numbers - 4][An Arithmetic Quirk: Writing Negative Numbers - 4]]
    - [[Boolean Logic, Operators, and Value Comparisons - 5][Boolean Logic, Operators, and Value Comparisons - 5]]
    - [[Operator Precedence and Associativity - 7][Operator Precedence and Associativity - 7]]
    - [[Undefined Values, and Introducing Variables - 8][Undefined Values, and Introducing Variables - 8]]
    - [[Dealing with Precedence and Associativity Variables - 8][Dealing with Precedence and Associativity Variables - 8]]
  - [[Command-Line Editing in ghci - 9][Command-Line Editing in ghci - 9]]
  - [[Lists - 9][Lists - 9]]
    - [[Operators on List - 11][Operators on List - 11]]
  - [[Strings and Characters - 11][Strings and Characters - 11]]
  - [[First Steps and Characters - 12][First Steps and Characters - 12]]
  - [[A Simple Program - 15][A Simple Program - 15]]
- [[2 Types and Functions - 17][2 Types and Functions - 17]]
  - [[Why Care About Types? - 17][Why Care About Types? - 17]]
  - [[Haskell's Type System - 18][Haskell's Type System - 18]]
    - [[Strong Types - 18][Strong Types - 18]]
    - [[Static Types - 19][Static Types - 19]]
    - [[Type Inference - 20][Type Inference - 20]]
  - [[What to Expect from the Type System - 20][What to Expect from the Type System - 20]]
  - [[Some Common Basic Types - 21][Some Common Basic Types - 21]]
  - [[Function Application - 22][Function Application - 22]]
  - [[Useful Composite Data Types: Lists and Tuples - 23][Useful Composite Data Types: Lists and Tuples - 23]]
  - [[Functions over Lists and Tuples - 25][Functions over Lists and Tuples - 25]]
    - [[Passing an Expression to a Function - 26][Passing an Expression to a Function - 26]]
  - [[Function Types and Purity - 27][Function Types and Purity - 27]]
  - [[Haskell Source Files, and Writing Simple Functions - 27][Haskell Source Files, and Writing Simple Functions - 27]]
    - [[Just What Is a Variable, Anyway? - 28][Just What Is a Variable, Anyway? - 28]]
    - [[Conditional Evaluation - 29][Conditional Evaluation - 29]]
  - [[Understanding Evaluation by Example - 32][Understanding Evaluation by Example - 32]]
    - [[Lazy Evaluation - 32][Lazy Evaluation - 32]]
    - [[A More Involved Example - 33][A More Involved Example - 33]]
    - [[Recursion - 34][Recursion - 34]]
    - [[Ending the Recursion - 35][Ending the Recursion - 35]]
    - [[Returning from the Recursion - 35][Returning from the Recursion - 35]]
    - [[What Have We Learned? - 36][What Have We Learned? - 36]]
  - [[Polymorphism in Haskell - 36][Polymorphism in Haskell - 36]]
    - [[Reasoning About Polymorphic Functions - 38][Reasoning About Polymorphic Functions - 38]]
    - [[Further Reading - 38][Further Reading - 38]]
  - [[The Type of a Function of More Than One Argument - 38][The Type of a Function of More Than One Argument - 38]]
  - [[Why the Fuss over Purity? - 39][Why the Fuss over Purity? - 39]]
  - [[Conclusion - 40][Conclusion - 40]]
- [[3 Defining Types, Streamlining Functions - 41][3 Defining Types, Streamlining Functions - 41]]
  - [[Defining a New Data Type - 41][Defining a New Data Type - 41]]
    - [[Naming Types and Values - 43][Naming Types and Values - 43]]
  - [[Type Synonyms - 43][Type Synonyms - 43]]
  - [[Algebraic Data Types - 44][Algebraic Data Types - 44]]
    - [[Tuples, Algebraic Data Types, and When to Use Each - 45][Tuples, Algebraic Data Types, and When to Use Each - 45]]
    - [[Analogues to Algebraic Data Types in Other Languages - 47][Analogues to Algebraic Data Types in Other Languages - 47]]
      - [[The structure - 47][The structure - 47]]
      - [[The enumeration - 48][The enumeration - 48]]
      - [[The discriminated union - 49][The discriminated union - 49]]
  - [[Pattern Matching - 50][Pattern Matching - 50]]
    - [[Construction and Deconstruction - 51][Construction and Deconstruction - 51]]
    - [[Further Adventures - 52][Further Adventures - 52]]
    - [[Variable Naming in Patterns - 53][Variable Naming in Patterns - 53]]
    - [[The Wild Card Pattern - 53][The Wild Card Pattern - 53]]
    - [[Exhaustive Patterns and Wild Cards - 54][Exhaustive Patterns and Wild Cards - 54]]
  - [[Record Syntax - 55][Record Syntax - 55]]
  - [[Parameterized Types - 57][Parameterized Types - 57]]
  - [[Recursive Types - 58][Recursive Types - 58]]
  - [[Reporting Errors - 60][Reporting Errors - 60]]
    - [[A More Controlled Approach - 61][A More Controlled Approach - 61]]
  - [[Introducing Local Variables - 61][Introducing Local Variables - 61]]
    - [[Shadowing - 62][Shadowing - 62]]
    - [[The where Clause - 63][The where Clause - 63]]
    - [[Local Functions, Global Variables - 63][Local Functions, Global Variables - 63]]
  - [[The Offside Rule and Whitespace in an Expression - 64][The Offside Rule and Whitespace in an Expression - 64]]
    - [[A Note About Tabs Versus Spaces - 66][A Note About Tabs Versus Spaces - 66]]
    - [[The Offside Rule Is Not Mandatory - 66][The Offside Rule Is Not Mandatory - 66]]
  - [[The ~case~ Expression - 66][The ~case~ Expression - 66]]
  - [[Common Beginner Mistakes with Patterns - 67][Common Beginner Mistakes with Patterns - 67]]
    - [[Incorrectly Matching Against a Variable - 67][Incorrectly Matching Against a Variable - 67]]
    - [[Incorrectly Trying to Compare for Equality - 68][Incorrectly Trying to Compare for Equality - 68]]
  - [[Conditional Evaluation with Guards - 68][Conditional Evaluation with Guards - 68]]
- [[4 Functional Programming - 71][4 Functional Programming - 71]]
  - [[Thinking in Haskell - 71][Thinking in Haskell - 71]]
  - [[A Simple Command-Line Framework - 71][A Simple Command-Line Framework - 71]]
  - [[Warming Up: Portably Splitting Lines of Text - 72][Warming Up: Portably Splitting Lines of Text - 72]]
    - [[A Line-Ending Conversion Program - 75][A Line-Ending Conversion Program - 75]]
  - [[Infix Functions - 76][Infix Functions - 76]]
  - [[Working with Lists - 77][Working with Lists - 77]]
    - [[Basic List Manipulation - 78][Basic List Manipulation - 78]]
    - [[Safely and Sanely Working with Crashy Functions - 79][Safely and Sanely Working with Crashy Functions - 79]]
    - [[Partial and Total Functions - 79][Partial and Total Functions - 79]]
    - [[More Simple List Manipulations - 80][More Simple List Manipulations - 80]]
    - [[Working with Sublists - 81][Working with Sublists - 81]]
    - [[Searching Lists - 82][Searching Lists - 82]]
    - [[Working with Several Lists at Once - 83][Working with Several Lists at Once - 83]]
    - [[Special String-Handling Functions - 84][Special String-Handling Functions - 84]]
  - [[How to Think About Loops - 84][How to Think About Loops - 84]]
    - [[Explicit Recursion - 85][Explicit Recursion - 85]]
    - [[Transforming Every Piece of Input - 87][Transforming Every Piece of Input - 87]]
    - [[Mapping over a List - 88][Mapping over a List - 88]]
    - [[Selecting Pieces of Input - 90][Selecting Pieces of Input - 90]]
    - [[Computing One Answer over a Collection - 90][Computing One Answer over a Collection - 90]]
    - [[The Left Fold - 92][The Left Fold - 92]]
    - [[Why Use Folds, Maps, and Filters? - 93][Why Use Folds, Maps, and Filters? - 93]]
    - [[Folding from the Right - 94][Folding from the Right - 94]]
    - [[Left Folds, Laziness, and Space Leaks - 96][Left Folds, Laziness, and Space Leaks - 96]]
    - [[Further Reading - 99][Further Reading - 99]]
  - [[Anonymous (lambda) Functions - 99][Anonymous (lambda) Functions - 99]]
  - [[Partial Function Application and Currying - 100][Partial Function Application and Currying - 100]]
    - [[Sections - 102][Sections - 102]]
  - [[As-patterns - 103][As-patterns - 103]]
  - [[Code Reuse Through Composition - 104][Code Reuse Through Composition - 104]]
    - [[Use Your Head Wisely - 107][Use Your Head Wisely - 107]]
  - [[Tips for Writing Readable Code - 107][Tips for Writing Readable Code - 107]]
  - [[Space Leaks and Strict Evaluation - 108][Space Leaks and Strict Evaluation - 108]]
    - [[Avoiding Space Leaks with ~seq~ - 108][Avoiding Space Leaks with ~seq~ - 108]]
    - [[Learning to Use ~seq~ - 109][Learning to Use ~seq~ - 109]]
- [[5 Writing a Library: Working with JSON Data - 111][5 Writing a Library: Working with JSON Data - 111]]
  - [[A Whirlwind Tour of JSON - 111][A Whirlwind Tour of JSON - 111]]
  - [[Representing JSON Data in Haskell - 111][Representing JSON Data in Haskell - 111]]
  - [[The Anatomy of a Haskell Module - 113][The Anatomy of a Haskell Module - 113]]
  - [[Compiling Haskell Source - 114][Compiling Haskell Source - 114]]
  - [[Generating a Haskell Program and Importing Modules - 114][Generating a Haskell Program and Importing Modules - 114]]
  - [[Printing JSON Data - 115][Printing JSON Data - 115]]
  - [[Type Inference Is a Double-Edged Sword - 117][Type Inference Is a Double-Edged Sword - 117]]
  - [[A More General Look at Rendering - 118][A More General Look at Rendering - 118]]
  - [[Developing Haskell Code Without Going Nuts - 119][Developing Haskell Code Without Going Nuts - 119]]
  - [[Pretty Printing a String - 120][Pretty Printing a String - 120]]
  - [[Arrays and Objects, and the Module Header - 122][Arrays and Objects, and the Module Header - 122]]
  - [[Writing a Module Header - 123][Writing a Module Header - 123]]
  - [[Fleshing Out the Pretty-Printing Library - 124][Fleshing Out the Pretty-Printing Library - 124]]
    - [[Compact Rendering - 127][Compact Rendering - 127]]
    - [[True Pretty Printing - 128][True Pretty Printing - 128]]
    - [[Following the Pretty Printer - 129][Following the Pretty Printer - 129]]
  - [[Creating a Package - 131][Creating a Package - 131]]
    - [[Writing a Package Description - 131][Writing a Package Description - 131]]
    - [[GHC’s Package Manager - 133][GHC’s Package Manager - 133]]
    - [[Setting Up, Building, and Installing - 133][Setting Up, Building, and Installing - 133]]
  - [[Practical Pointers and Further Reading - 134][Practical Pointers and Further Reading - 134]]
- [[6 Using Typeclasses - 135][6 Using Typeclasses - 135]]
  - [[The Need for Typeclasses - 135][The Need for Typeclasses - 135]]
  - [[What Are Typeclasses? - 136][What Are Typeclasses? - 136]]
  - [[Declaring Typeclass Instances - 139][Declaring Typeclass Instances - 139]]
  - [[Important Built-in Typeclasses - 139][Important Built-in Typeclasses - 139]]
    - [[Show - 139][Show - 139]]
    - [[Read - 141][Read - 141]]
    - [[Serialization with read and show - 143][Serialization with read and show - 143]]
    - [[Numeric Types - 144][Numeric Types - 144]]
    - [[Equality, Ordering, and Comparisons - 148][Equality, Ordering, and Comparisons - 148]]
  - [[Automatic Derivation - 148][Automatic Derivation - 148]]
  - [[Typeclasses at Work: Making JSON Easier to Use - 149][Typeclasses at Work: Making JSON Easier to Use - 149]]
    - [[More Helpful Errors - 151][More Helpful Errors - 151]]
    - [[Making an Instance with a Type Synonym - 151][Making an Instance with a Type Synonym - 151]]
  - [[Living in an Open World - 152][Living in an Open World - 152]]
    - [[When Do Overlapping Instances Cause Problems? - 153][When Do Overlapping Instances Cause Problems? - 153]]
    - [[Relaxing Some Restrictions on Typeclasses - 154][Relaxing Some Restrictions on Typeclasses - 154]]
    - [[How Does Show Work for Strings? - 155][How Does Show Work for Strings? - 155]]
  - [[How to Give a Type a New Identity - 155][How to Give a Type a New Identity - 155]]
    - [[Differences Between Data and Newtype Declarations - 157][Differences Between Data and Newtype Declarations - 157]]
    - [[Summary: The Three Ways of Naming Types - 158][Summary: The Three Ways of Naming Types - 158]]
  - [[JSON Typeclasses Without Overlapping Instances - 159][JSON Typeclasses Without Overlapping Instances - 159]]
  - [[The Dreaded Monomorphism Restriction - 162][The Dreaded Monomorphism Restriction - 162]]
  - [[Conclusion - 163][Conclusion - 163]]
- [[7 I/O - 165][7 I/O - 165]]
  - [[Classic I/O in Haskell - 165][Classic I/O in Haskell - 165]]
    - [[Pure Versus I/O - 168][Pure Versus I/O - 168]]
    - [[Why Purity Matters - 169][Why Purity Matters - 169]]
  - [[Working with Files and Handles - 169][Working with Files and Handles - 169]]
    - [[More on openFile - 171][More on openFile - 171]]
    - [[Closing Handles - 172][Closing Handles - 172]]
    - [[Seek and Tell - 172][Seek and Tell - 172]]
    - [[Standard Input, Output, and Error - 173][Standard Input, Output, and Error - 173]]
    - [[Deleting and Renaming Files - 174][Deleting and Renaming Files - 174]]
    - [[Temporary Files - 174][Temporary Files - 174]]
  - [[Extended Example: Functional I/O and Temporary Files - 175][Extended Example: Functional I/O and Temporary Files - 175]]
  - [[Lazy I/O - 178][Lazy I/O - 178]]
    - [[hGetContents - 178][hGetContents - 178]]
    - [[readFile and writeFile - 180][readFile and writeFile - 180]]
    - [[A Word on Lazy Output - 181][A Word on Lazy Output - 181]]
    - [[interact - 181][interact - 181]]
  - [[The IO Monad - 183][The IO Monad - 183]]
    - [[Actions - 183][Actions - 183]]
    - [[Sequencing - 186][Sequencing - 186]]
    - [[The True Nature of Return - 187][The True Nature of Return - 187]]
  - [[Is Haskell Really Imperative? - 188][Is Haskell Really Imperative? - 188]]
  - [[Side Effects with Lazy I/O - 188][Side Effects with Lazy I/O - 188]]
  - [[Buffering - 189][Buffering - 189]]
    - [[Buffering Modes - 189][Buffering Modes - 189]]
    - [[Flushing The Buffer - 190][Flushing The Buffer - 190]]
  - [[Reading Command-Line Arguments - 190][Reading Command-Line Arguments - 190]]
  - [[Environment Variables - 191][Environment Variables - 191]]
- [[8 Efficient File Processing, Regular Expressions, and Filename Matching - 193][8 Efficient File Processing, Regular Expressions, and Filename Matching - 193]]
  - [[Efficient File Processing - 193][Efficient File Processing - 193]]
    - [[Binary I/O and Qualified Imports - 194][Binary I/O and Qualified Imports - 194]]
    - [[Text I/O - 195][Text I/O - 195]]
  - [[Filename Matching - 187][Filename Matching - 187]]
  - [[Regular Expressions in Haskell - 198][Regular Expressions in Haskell - 198]]
    - [[The Many Types of Result - 198][The Many Types of Result - 198]]
  - [[More About Regular Expressions - 200][More About Regular Expressions - 200]]
    - [[Mixing and Matching String Types - 200][Mixing and Matching String Types - 200]]
    - [[Other Things You Should Know - 201][Other Things You Should Know - 201]]
  - [[Translating a glob Pattern into a Regular Expression - 202][Translating a glob Pattern into a Regular Expression - 202]]
  - [[An important Aside: Writing Lazy Functions - 205][An important Aside: Writing Lazy Functions - 205]]
  - [[Making Use of Our Pattern Matcher - 206][Making Use of Our Pattern Matcher - 206]]
  - [[Handling Errors Through API Design - 210][Handling Errors Through API Design - 210]]
  - [[Putting Our Code to Work - 211][Putting Our Code to Work - 211]]
- [[9 I/O Case Study: A Library for Searching the Filesystem - 213][9 I/O Case Study: A Library for Searching the Filesystem - 213]]
  - [[The find Command - 213][The find Command - 213]]
  - [[Starting Simple: Recursively Listing a Directory - 213][Starting Simple: Recursively Listing a Directory - 213]]
    - [[Revisiting Anonymous and Named Functions - 214][Revisiting Anonymous and Named Functions - 214]]
    - [[Why Provide Both mapM and forM? - 215][Why Provide Both mapM and forM? - 215]]
  - [[A Naive Finding Function - 215][A Naive Finding Function - 215]]
  - [[Predicates: From Poverty to Riches, While Remaining Pure - 217][Predicates: From Poverty to Riches, While Remaining Pure - 217]]
  - [[Sizing a File Safely - 219][Sizing a File Safely - 219]]
    - [[The Acquire-Use-Release Cycle - 221][The Acquire-Use-Release Cycle - 221]]
  - [[A Domain-Specific Language for Predicates - 221][A Domain-Specific Language for Predicates - 221]]
    - [[Avoiding Boilerplate with Lifting - 223][Avoiding Boilerplate with Lifting - 223]]
    - [[Gluing Predicates Together - 224][Gluing Predicates Together - 224]]
    - [[Defining and Using New Operators - 225][Defining and Using New Operators - 225]]
  - [[Controlling Traversal - 226][Controlling Traversal - 226]]
  - [[Density, Readability, and the Learning Process - 228][Density, Readability, and the Learning Process - 228]]
  - [[Another Way of Looking at Traversal - 229][Another Way of Looking at Traversal - 229]]
  - [[Useful Coding Guidelines - 232][Useful Coding Guidelines - 232]]
    - [[Common Layout Styles - 233][Common Layout Styles - 233]]
- [[10 Code Case Study: Parsing a Binary Data Format - 235][10 Code Case Study: Parsing a Binary Data Format - 235]]
  - [[Grayscale Files - 235][Grayscale Files - 235]]
  - [[Parsing a Raw PGM File - 236][Parsing a Raw PGM File - 236]]
  - [[Getting Rid of Boilerplate Code - 238][Getting Rid of Boilerplate Code - 238]]
  - [[Implicit State - 239][Implicit State - 239]]
    - [[The Identity Parser - 240][The Identity Parser - 240]]
    - [[Record Syntax, Updates, and Pattern Matching - 241][Record Syntax, Updates, and Pattern Matching - 241]]
    - [[A More Interesting Parser - 242][A More Interesting Parser - 242]]
    - [[Obtaining and Modifying the Parse State - 242][Obtaining and Modifying the Parse State - 242]]
    - [[Reporting Parse Errors - 243][Reporting Parse Errors - 243]]
    - [[Chaining Parsers Together - 243][Chaining Parsers Together - 243]]
  - [[Introducing Functors - 244][Introducing Functors - 244]]
    - [[Constraints on Type Definitions Are Bad - 247][Constraints on Type Definitions Are Bad - 247]]
    - [[Infix Use of fmap - 248][Infix Use of fmap - 248]]
    - [[Flexible Instances - 248][Flexible Instances - 248]]
    - [[Thinking More About Functors - 249][Thinking More About Functors - 249]]
  - [[Writing a Functor Instance for Parse - 250][Writing a Functor Instance for Parse - 250]]
  - [[Using Functors for Parsing - 251][Using Functors for Parsing - 251]]
  - [[Rewriting Our PGM Parser - 252][Rewriting Our PGM Parser - 252]]
  - [[Future Directions - 254][Future Directions - 254]]
- [[11 Testing and Quality Assurance - 255][11 Testing and Quality Assurance - 255]]
  - [[QuickCheck: Type-Based Testing - 256][QuickCheck: Type-Based Testing - 256]]
    - [[Testing for Properties - 257][Testing for Properties - 257]]
    - [[Testing Against a Model - 259][Testing Against a Model - 259]]
  - [[Testing Case Study: Specifying a Pretty Printer - 259][Testing Case Study: Specifying a Pretty Printer - 259]]
    - [[Generating Test Data - 259][Generating Test Data - 259]]
    - [[Testing Document Construction - 262][Testing Document Construction - 262]]
    - [[Using Lists as a Model - 263][Using Lists as a Model - 263]]
    - [[Putting It All Together - 264][Putting It All Together - 264]]
  - [[Measuring Test Coverage with HPC - 265][Measuring Test Coverage with HPC - 265]]
- [[12 Barcode Recognition - 269][12 Barcode Recognition - 269]]
  - [[A Little Bit About Barcodes - 269][A Little Bit About Barcodes - 269]]
    - [[EAN-13 Encoding - 270][EAN-13 Encoding - 270]]
  - [[Introducing Arrays - 270][Introducing Arrays - 270]]
    - [[Arrays and Laziness - 273][Arrays and Laziness - 273]]
    - [[Folding over Arrays - 273][Folding over Arrays - 273]]
    - [[Modifying Array Elements - 274][Modifying Array Elements - 274]]
  - [[Encoding an EAN-13 Barcode - 275][Encoding an EAN-13 Barcode - 275]]
  - [[Constraints on Our Decoder - 275][Constraints on Our Decoder - 275]]
  - [[Divide and Conquer - 276][Divide and Conquer - 276]]
  - [[Turning a Color Image into Something Tractable - 278][Turning a Color Image into Something Tractable - 278]]
    - [[Parsing a Color Image - 278][Parsing a Color Image - 278]]
    - [[Grayscale Conversion - 279][Grayscale Conversion - 279]]
    - [[Grayscale to Binary and Type Safety - 279][Grayscale to Binary and Type Safety - 279]]
  - [[What Have We Done to Our Image? - 280][What Have We Done to Our Image? - 280]]
  - [[Finding Matching Digits - 282][Finding Matching Digits - 282]]
    - [[Run Length Encoding - 282][Run Length Encoding - 282]]
    - [[Scaling Run Lengths, and Finding Approximate Matches - 283][Scaling Run Lengths, and Finding Approximate Matches - 283]]
    - [[List Comprehensions - 284][List Comprehensions - 284]]
    - [[Remembering a Match's Parity - 285][Remembering a Match's Parity - 285]]
    - [[Chunking a List - 287][Chunking a List - 287]]
    - [[Generating a List of Candidate Digits - 287][Generating a List of Candidate Digits - 287]]
  - [[Life Without Arrays or Hash Tables - 288][Life Without Arrays or Hash Tables - 288]]
    - [[A Forest of Solutions - 288][A Forest of Solutions - 288]]
    - [[A Brief Introduction to Maps - 289][A Brief Introduction to Maps - 289]]
    - [[Further Reading - 292][Further Reading - 292]]
  - [[Turning Digit Soup into an Answer - 292][Turning Digit Soup into an Answer - 292]]
    - [[Solving for Check Digits in Parallel - 292][Solving for Check Digits in Parallel - 292]]
    - [[Completing the Solution Map with the First Digit - 294][Completing the Solution Map with the First Digit - 294]]
    - [[Finding the Correct Sequence - 295][Finding the Correct Sequence - 295]]
  - [[Working with Row Data - 295][Working with Row Data - 295]]
  - [[Pulling It All Together - 296][Pulling It All Together - 296]]
  - [[A Few Comments on Development Style - 297][A Few Comments on Development Style - 297]]
- [[13 Data Structures - 299][13 Data Structures - 299]]
  - [[Association Lists - 299][Association Lists - 299]]
  - [[Maps - 301][Maps - 301]]
  - [[Functions Are Data, Too - 303][Functions Are Data, Too - 303]]
  - [[Extended Example: /etc/passwd - 304][Extended Example: /etc/passwd - 304]]
  - [[Extended Example: Numeric Types - 307][Extended Example: Numeric Types - 307]]
    - [[First Steps - 309][First Steps - 309]]
    - [[Completed Code - 311][Completed Code - 311]]
  - [[Taking Advantage of Functions as Data - 317][Taking Advantage of Functions as Data - 317]]
    - [[Turning Difference Lists into a Proper Library - 318][Turning Difference Lists into a Proper Library - 318]]
    - [[Lists, Difference Lists, and Monoids - 320][Lists, Difference Lists, and Monoids - 320]]
  - [[General-Purpose Sequences - 322][General-Purpose Sequences - 322]]
- [[14 Monads - 325][14 Monads - 325]]
  - [[Revisiting Earlier Code Examples - 325][Revisiting Earlier Code Examples - 325]]
    - [[Maybe Chaining - 325][Maybe Chaining - 325]]
    - [[Implicit State - 326][Implicit State - 326]]
  - [[Looking for Shared Patterns - 327][Looking for Shared Patterns - 327]]
  - [[The Monad Typeclass - 329][The Monad Typeclass - 329]]
  - [[And Now, a Jargon Moment - 330][And Now, a Jargon Moment - 330]]
  - [[Using a New Monad: Show Your Work! - 331][Using a New Monad: Show Your Work! - 331]]
    - [[Information Hiding - 331][Information Hiding - 331]]
    - [[Controlled Escape - 332][Controlled Escape - 332]]
    - [[Leaving a Trace - 332][Leaving a Trace - 332]]
    - [[Using the Logger Monad - 333][Using the Logger Monad - 333]]
  - [[Mixing Pure and Monadic Code - 334][Mixing Pure and Monadic Code - 334]]
  - [[Putting a Few Misconceptions to Rest - 336][Putting a Few Misconceptions to Rest - 336]]
  - [[Building the Logger Monad - 336][Building the Logger Monad - 336]]
    - [[Sequential Logging, Not Sequential Evaluation - 337][Sequential Logging, Not Sequential Evaluation - 337]]
    - [[The Writer Monad - 337][The Writer Monad - 337]]
  - [[The Maybe Monad - 338][The Maybe Monad - 338]]
    - [[Executing the Maybe Monad - 338][Executing the Maybe Monad - 338]]
    - [[Maybe at Work, and Good API Design - 338][Maybe at Work, and Good API Design - 338]]
  - [[The List Monad - 340][The List Monad - 340]]
    - [[Understanding the List Monad - 342][Understanding the List Monad - 342]]
    - [[Putting the List Monad to Work - 343][Putting the List Monad to Work - 343]]
  - [[Desugaring of do Blocks - 344][Desugaring of do Blocks - 344]]
    - [[Monads as a Programmable Semicolon - 345][Monads as a Programmable Semicolon - 345]]
    - [[Why Go Sugar-Free? - 346][Why Go Sugar-Free? - 346]]
  - [[The State Monad - 346][The State Monad - 346]]
    - [[Almost a State Monad - 347][Almost a State Monad - 347]]
    - [[Reading and Modifying the State - 348][Reading and Modifying the State - 348]]
    - [[Will the Real State Monad Please Stand Up? - 348][Will the Real State Monad Please Stand Up? - 348]]
    - [[Using the State Monad: Generating Random Values - 349][Using the State Monad: Generating Random Values - 349]]
    - [[A First Attempt at Purity - 350][A First Attempt at Purity - 350]]
    - [[Random Values in the State Monad - 351][Random Values in the State Monad - 351]]
    - [[Running the State Monad - 352][Running the State Monad - 352]]
    - [[What About a Bit More State? - 352][What About a Bit More State? - 352]]
  - [[Monads and Functors - 354][Monads and Functors - 354]]
    - [[Another Way of Looking at Monads - 354][Another Way of Looking at Monads - 354]]
  - [[The Monad Laws and Good Coding Style - 355][The Monad Laws and Good Coding Style - 355]]
- [[15 Programming with Monads - 359][15 Programming with Monads - 359]]
  - [[Golfing Practice: Association Lists - 359][Golfing Practice: Association Lists - 359]]
  - [[Generalized Lifting - 360][Generalized Lifting - 360]]
  - [[Looking for Alternatives - 362][Looking for Alternatives - 362]]
    - [[The Name mplus Does Not Imply Addition - 364][The Name mplus Does Not Imply Addition - 364]]
    - [[Rules for Working with MonadPlus - 364][Rules for Working with MonadPlus - 364]]
    - [[Failing Safely with MonadPlus - 364][Failing Safely with MonadPlus - 364]]
  - [[Adventures in Hiding the Plumbing - 365][Adventures in Hiding the Plumbing - 365]]
    - [[Supplying Random Numbers - 368][Supplying Random Numbers - 368]]
    - [[Another Round of Golf - 369][Another Round of Golf - 369]]
  - [[Separating Interface from Implementation - 369][Separating Interface from Implementation - 369]]
    - [[Multiparameter Typeclasses - 370][Multiparameter Typeclasses - 370]]
    - [[Functional Dependencies - 370][Functional Dependencies - 370]]
    - [[Rounding Out Our Module - 371][Rounding Out Our Module - 371]]
    - [[Programming to a Monad’s Interface - 372][Programming to a Monad’s Interface - 372]]
  - [[The Reader Monad - 373][The Reader Monad - 373]]
  - [[A Return to Automated Deriving - 374][A Return to Automated Deriving - 374]]
  - [[Hiding the IO Monad - 375][Hiding the IO Monad - 375]]
    - [[Using a newtype - 376][Using a newtype - 376]]
    - [[Designing for Unexpected Uses - 377][Designing for Unexpected Uses - 377]]
    - [[Using Typeclasses - 378][Using Typeclasses - 378]]
    - [[Isolation and Testing - 379][Isolation and Testing - 379]]
    - [[The Writer Monad and Lists - 380][The Writer Monad and Lists - 380]]
    - [[Arbitrary I/O Revisited - 381][Arbitrary I/O Revisited - 381]]
- [[16 Using ~Parsec~ - 383][16 Using ~Parsec~ - 383]]
  - [[First Steps with Parsec: Simple CSV Parsing - 383][First Steps with Parsec: Simple CSV Parsing - 383]]
  - [[The sepBy and endBy Combinators - 386][The sepBy and endBy Combinators - 386]]
  - [[Choices and Errors - 387][Choices and Errors - 387]]
    - [[Lookahead - 389][Lookahead - 389]]
    - [[Error Handling - 390][Error Handling - 390]]
  - [[Extended Example: Full CSV Parser - 391][Extended Example: Full CSV Parser - 391]]
  - [[Parsec and MonadPlus - 393][Parsec and MonadPlus - 393]]
  - [[Parsing a URL-Encoded Query String - 393][Parsing a URL-Encoded Query String - 393]]
  - [[Supplanting Regular Expressions for Casual Parsing - 395][Supplanting Regular Expressions for Casual Parsing - 395]]
  - [[Parsing Without Variables - 395][Parsing Without Variables - 395]]
  - [[Applicative Functors for Parsing - 395][Applicative Functors for Parsing - 395]]
  - [[Applicative Parsing by Example - 396][Applicative Parsing by Example - 396]]
  - [[Parsing JSON Data - 398][Parsing JSON Data - 398]]
  - [[Parsing a HTTP Request - 401][Parsing a HTTP Request - 401]]
    - [[Backtracking and Its Discontents - 402][Backtracking and Its Discontents - 402]]
    - [[Parsing Headers - 402][Parsing Headers - 402]]
- [[17 Interfacing with C: The FFI - 405][17 Interfacing with C: The FFI - 405]]
  - [[Foreign Language Bindings: The Basics - 406][Foreign Language Bindings: The Basics - 406]]
    - [[Be Careful of Side Effects - 407][Be Careful of Side Effects - 407]]
    - [[A High-Level Wrapper - 408][A High-Level Wrapper - 408]]
  - [[Regular Expressions for Haskell: A Binding for PCRE - 409][Regular Expressions for Haskell: A Binding for PCRE - 409]]
    - [[Simple Tasks: Using the C Preprocessor - 410][Simple Tasks: Using the C Preprocessor - 410]]
    - [[Binding Haskell to C with hsc - 2hs - 411][Binding Haskell to C with hsc - 2hs - 411]]
    - [[Adding Type Safety to PCRE - 411][Adding Type Safety to PCRE - 411]]
    - [[Binding to Constants - 412][Binding to Constants - 412]]
    - [[Automating the Binding - 413][Automating the Binding - 413]]
  - [[Passing String Data Between Haskell and C - 414][Passing String Data Between Haskell and C - 414]]
    - [[Typed Pointers - 416][Typed Pointers - 416]]
    - [[Memory Management: Let the Garbage Collector Do the Work - 417][Memory Management: Let the Garbage Collector Do the Work - 417]]
    - [[A High-Level Interface: Marshaling Data - 418][A High-Level Interface: Marshaling Data - 418]]
    - [[Marshaling ByteStrings - 419][Marshaling ByteStrings - 419]]
    - [[Allocating Local C Data: The Storable Class - 419][Allocating Local C Data: The Storable Class - 419]]
    - [[Putting It All Together - 420][Putting It All Together - 420]]
  - [[Matching on Strings - 422][Matching on Strings - 422]]
    - [[Extracting Information About the Pattern - 423][Extracting Information About the Pattern - 423]]
    - [[Pattern Matching with Substrings - 424][Pattern Matching with Substrings - 424]]
    - [[The Real Deal: Compiling and Matching Regular Expressions - 426][The Real Deal: Compiling and Matching Regular Expressions - 426]]
- [[18 Monad Transformers - 429][18 Monad Transformers - 429]]
  - [[Motivation: Boilerplate Avoidance - 429][Motivation: Boilerplate Avoidance - 429]]
  - [[A Simple Monad Transformer Example - 430][A Simple Monad Transformer Example - 430]]
  - [[Common Patterns in Monads and Monad Transformers - 431][Common Patterns in Monads and Monad Transformers - 431]]
  - [[Stacking Multiple Monad Transformers - 433][Stacking Multiple Monad Transformers - 433]]
    - [[Hiding Our Work - 435][Hiding Our Work - 435]]
  - [[Moving Down the Stack - 436][Moving Down the Stack - 436]]
    - [[When Explicit Lifting Is Necessary - 437][When Explicit Lifting Is Necessary - 437]]
  - [[Understanding Monad Transformers by Building One - 438][Understanding Monad Transformers by Building One - 438]]
    - [[Creating a Monad Transformer - 439][Creating a Monad Transformer - 439]]
    - [[More Typeclass Instances - 440][More Typeclass Instances - 440]]
    - [[Replacing the Parse Type with a Monad Stack - 440][Replacing the Parse Type with a Monad Stack - 440]]
  - [[Transformer Stacking Order Is Important - 441][Transformer Stacking Order Is Important - 441]]
  - [[Putting Monads and Monad Transformers into Perspective - 443][Putting Monads and Monad Transformers into Perspective - 443]]
    - [[Interference with Pure Code - 443][Interference with Pure Code - 443]]
    - [[Overdetermined Ordering - 444][Overdetermined Ordering - 444]]
    - [[Runtime Overhead - 444][Runtime Overhead - 444]]
    - [[Unwieldy Interfaces - 444][Unwieldy Interfaces - 444]]
    - [[Pulling It All Together - 445][Pulling It All Together - 445]]
- [[19. Error Handling - 447][19. Error Handling - 447]]
  - [[Error Handling with Data Types - 447][Error Handling with Data Types - 447]]
    - [[Use of Maybe - 448][Use of Maybe - 448]]
    - [[Use of Either - 452][Use of Either - 452]]
  - [[Exceptions - 454][Exceptions - 454]]
    - [[First Steps with Exceptions - 454][First Steps with Exceptions - 454]]
    - [[Laziness and Exception Handling - 455][Laziness and Exception Handling - 455]]
    - [[Using handle - 456][Using handle - 456]]
    - [[Selective Handling of Exceptions - 456][Selective Handling of Exceptions - 456]]
    - [[I/O Exceptions - 457][I/O Exceptions - 457]]
    - [[Throwing Exceptions - 459][Throwing Exceptions - 459]]
    - [[Dynamic Exceptions - 459][Dynamic Exceptions - 459]]
  - [[Error Handling in Monads - 462][Error Handling in Monads - 462]]
    - [[A Tiny Parsing Framework - 463][A Tiny Parsing Framework - 463]]
- [[20. Systems Programming in Haskell - 467][20. Systems Programming in Haskell - 467]]
  - [[Running External Programs - 467][Running External Programs - 467]]
  - [[Directory and File Information - 468][Directory and File Information - 468]]
  - [[Program Termination - 469][Program Termination - 469]]
  - [[Dates and Times - 470][Dates and Times - 470]]
    - [[ClockTime and CalendarTime - 470][ClockTime and CalendarTime - 470]]
    - [[File Modification Times - 475][File Modification Times - 475]]
  - [[Extended Example: Piping - 476][Extended Example: Piping - 476]]
    - [[Using Pipes for Redirection - 477][Using Pipes for Redirection - 477]]
    - [[Better Piping - 483][Better Piping - 483]]
    - [[Final Words on Pipes - 491][Final Words on Pipes - 491]]
- [[21. Using Databases - 493][21. Using Databases - 493]]
  - [[Overview of HDBC - 493][Overview of HDBC - 493]]
  - [[Installing HDBC and Drivers - 494][Installing HDBC and Drivers - 494]]
  - [[Connecting to Databases - 495][Connecting to Databases - 495]]
  - [[Transactions - 495][Transactions - 495]]
  - [[Simple Queries - 496][Simple Queries - 496]]
  - [[SqlValue - 497][SqlValue - 497]]
  - [[Query Parameters - 497][Query Parameters - 497]]
  - [[Prepared Statements - 498][Prepared Statements - 498]]
  - [[Reading Results - 499][Reading Results - 499]]
    - [[Reading with Statements - 501][Reading with Statements - 501]]
    - [[Lazy Reading - 501][Lazy Reading - 501]]
  - [[Database Metadata - 502][Database Metadata - 502]]
  - [[Error Handling - 503][Error Handling - 503]]
- [[22 Extended Example: Web Client Programming - 505][22 Extended Example: Web Client Programming - 505]]
  - [[Basic Types - 506][Basic Types - 506]]
  - [[The Database - 506][The Database - 506]]
  - [[The Parser - 510][The Parser - 510]]
  - [[Downloading - 513][Downloading - 513]]
  - [[Main Program - 513][Main Program - 513]]
- [[23 GUI Programming with gtk2hs - 517][23 GUI Programming with gtk2hs - 517]]
  - [[Installing gtk - 2hs - 517][Installing gtk - 2hs - 517]]
  - [[Overview of the GTK+ Stack - 517][Overview of the GTK+ Stack - 517]]
  - [[User Interface Design with Glade - 518][User Interface Design with Glade - 518]]
    - [[Glade Concepts - 518][Glade Concepts - 518]]
  - [[Event-Driven Programming - 519][Event-Driven Programming - 519]]
  - [[Initializing the GUI - 520][Initializing the GUI - 520]]
  - [[The Add Podcast Window - 524][The Add Podcast Window - 524]]
  - [[Long-Running Tasks - 525][Long-Running Tasks - 525]]
  - [[Using Cabal - 528][Using Cabal - 528]]
- [[24 Concurrent and Multicore Programming - 531][24 Concurrent and Multicore Programming - 531]]
  - [[Defining Concurrency and Parallelism - 531][Defining Concurrency and Parallelism - 531]]
  - [[Concurrent Programming with Threads - 532][Concurrent Programming with Threads - 532]]
    - [[Threads Are Nondeterministic - 532][Threads Are Nondeterministic - 532]]
    - [[Hiding Latency - 532][Hiding Latency - 532]]
  - [[Simple Communication Between Threads - 533][Simple Communication Between Threads - 533]]
  - [[The Main Thread and Waiting for Other Threads - 534][The Main Thread and Waiting for Other Threads - 534]]
    - [[Safely Modifying an MVar - 536][Safely Modifying an MVar - 536]]
    - [[Safe Resource Management: A Good Idea, and Easy Besides - 536][Safe Resource Management: A Good Idea, and Easy Besides - 536]]
    - [[Finding the Status of a Thread - 537][Finding the Status of a Thread - 537]]
    - [[Writing Tighter Code - 538][Writing Tighter Code - 538]]
  - [[Communicating over Channels - 539][Communicating over Channels - 539]]
  - [[Useful Things to Know About - 539][Useful Things to Know About - 539]]
    - [[MVar and Chan Are Nonstrict - 539][MVar and Chan Are Nonstrict - 539]]
    - [[Chan Is Unbounded - 540][Chan Is Unbounded - 540]]
  - [[Shared-State Concurrency Is Still Hard - 540][Shared-State Concurrency Is Still Hard - 540]]
    - [[Deadlock - 541][Deadlock - 541]]
    - [[Starvation - 541][Starvation - 541]]
    - [[Is There Any Hope? - 542][Is There Any Hope? - 542]]
  - [[Using Multiple Cores with GHC - 542][Using Multiple Cores with GHC - 542]]
    - [[Runtime Options - 543][Runtime Options - 543]]
    - [[Finding the Number of Available Cores from Haskell - 543][Finding the Number of Available Cores from Haskell - 543]]
    - [[Choosing the Right Runtime - 544][Choosing the Right Runtime - 544]]
  - [[Parallel Programming in Haskell - 544][Parallel Programming in Haskell - 544]]
    - [[Normal Form and Head Normal Form - 545][Normal Form and Head Normal Form - 545]]
    - [[Sequential Sorting - 545][Sequential Sorting - 545]]
    - [[Transforming Our Code into Parallel Code - 545][Transforming Our Code into Parallel Code - 545]]
    - [[Knowing What to Evaluate in Parallel - 546][Knowing What to Evaluate in Parallel - 546]]
    - [[What Promises Does par Make? - 547][What Promises Does par Make? - 547]]
    - [[Running Our Code and Measuring Performance - 547][Running Our Code and Measuring Performance - 547]]
    - [[Tuning for Performance - 550][Tuning for Performance - 550]]
  - [[Parallel Strategies and MapReduce - 551][Parallel Strategies and MapReduce - 551]]
    - [[Separating Algorithm from Evaluation - 552][Separating Algorithm from Evaluation - 552]]
    - [[Separating Algorithm from Strategy - 554][Separating Algorithm from Strategy - 554]]
    - [[Writing a Simple MapReduce Definition - 554][Writing a Simple MapReduce Definition - 554]]
    - [[MapReduce and Strategies - 555][MapReduce and Strategies - 555]]
    - [[Sizing Work Appropriately - 555][Sizing Work Appropriately - 555]]
    - [[Efficiently Finding Line-Aligned Chunks - 557][Efficiently Finding Line-Aligned Chunks - 557]]
    - [[Counting Lines - 558][Counting Lines - 558]]
    - [[Finding the Most Popular URLs - 559][Finding the Most Popular URLs - 559]]
    - [[Conclusions - 560][Conclusions - 560]]
- [[25 Profiling and Optimization - 561][25 Profiling and Optimization - 561]]
  - [[Profiling Haskell Programs - 561][Profiling Haskell Programs - 561]]
    - [[Collecting Runtime Statistics - 562][Collecting Runtime Statistics - 562]]
    - [[Time Profiling - 563][Time Profiling - 563]]
    - [[Space Profiling - 566][Space Profiling - 566]]
  - [[Controlling Evaluation - 570][Controlling Evaluation - 570]]
    - [[Strictness and Tail Recursion - 571][Strictness and Tail Recursion - 571]]
    - [[Adding Strictness - 572][Adding Strictness - 572]]
  - [[Understanding Core - 575][Understanding Core - 575]]
  - [[Advanced Techniques: Fusion - 578][Advanced Techniques: Fusion - 578]]
    - [[Tuning the Generated Assembly - 579][Tuning the Generated Assembly - 579]]
  - [[Conclusions - 580][Conclusions - 580]]
- [[26. Advanced Library Design: Building a Bloom Filter - 581][26. Advanced Library Design: Building a Bloom Filter - 581]]
  - [[Introducing the Bloom Filter - 581][Introducing the Bloom Filter - 581]]
  - [[Use Cases and Package Layout - 582][Use Cases and Package Layout - 582]]
  - [[Basic Design - 583][Basic Design - 583]]
    - [[Unboxing, Lifting, and Bottom - 583][Unboxing, Lifting, and Bottom - 583]]
  - [[The ST Monad - 584][The ST Monad - 584]]
  - [[Designing an API for Qualified Import - 585][Designing an API for Qualified Import - 585]]
  - [[Creating a Mutable Bloom Filter - 586][Creating a Mutable Bloom Filter - 586]]
  - [[The Immutable API - 587][The Immutable API - 587]]
  - [[Creating a Friendly Interface - 588][Creating a Friendly Interface - 588]]
    - [[Re-Exporting Names for Convenience - 589][Re-Exporting Names for Convenience - 589]]
    - [[Hashing Values - 589][Hashing Values - 589]]
    - [[Turning Two Hashes into Many - 593][Turning Two Hashes into Many - 593]]
    - [[Implementing the Easy Creation Function - 593][Implementing the Easy Creation Function - 593]]
  - [[Creating a Cabal Package - 595][Creating a Cabal Package - 595]]
    - [[Dealing with Different Build Setups - 596][Dealing with Different Build Setups - 596]]
    - [[Compilation Options and Interfacing to C - 598][Compilation Options and Interfacing to C - 598]]
  - [[Testing with QuickCheck - 599][Testing with QuickCheck - 599]]
    - [[Polymorphic Testing - 600][Polymorphic Testing - 600]]
    - [[Writing Arbitrary Instances for ByteStrings - 601][Writing Arbitrary Instances for ByteStrings - 601]]
    - [[Are Suggested Sizes Correct? - 602][Are Suggested Sizes Correct? - 602]]
  - [[Performance Analysis and Tuning - 604][Performance Analysis and Tuning - 604]]
    - [[Profile-Driven Performance Tuning - 605][Profile-Driven Performance Tuning - 605]]
- [[27. Sockets and Syslog - 611][27. Sockets and Syslog - 611]]
  - [[Basic Networking - 611][Basic Networking - 611]]
  - [[Communicating with UDP - 611][Communicating with UDP - 611]]
    - [[UDP Client Example: syslog - 612][UDP Client Example: syslog - 612]]
    - [[UDP Syslog Server - 615][UDP Syslog Server - 615]]
  - [[Communicating with TCP - 616][Communicating with TCP - 616]]
    - [[Handling Multiple TCP Streams - 616][Handling Multiple TCP Streams - 616]]
    - [[TCP Syslog Server - 617][TCP Syslog Server - 617]]
    - [[TCP Syslog Client - 619][TCP Syslog Client - 619]]
- [[28 Software Transactional Memory - 623][28 Software Transactional Memory - 623]]
  - [[The Basics - 623][The Basics - 623]]
  - [[Some Simple Examples - 624][Some Simple Examples - 624]]
  - [[STM and Safety - 626][STM and Safety - 626]]
  - [[Retrying a Transaction - 626][Retrying a Transaction - 626]]
    - [[What Happens When We Retry? - 628][What Happens When We Retry? - 628]]
  - [[Choosing Between Alternatives - 628][Choosing Between Alternatives - 628]]
    - [[Using Higher Order Code with Transactions - 628][Using Higher Order Code with Transactions - 628]]
  - [[I/O and STM - 629][I/O and STM - 629]]
  - [[Communication Between Threads - 630][Communication Between Threads - 630]]
  - [[A Concurrent Web Link Checker - 631][A Concurrent Web Link Checker - 631]]
    - [[Checking a Link - 633][Checking a Link - 633]]
    - [[Worker Threads - 634][Worker Threads - 634]]
    - [[Finding Links - 635][Finding Links - 635]]
    - [[Command-Line Parsing - 636][Command-Line Parsing - 636]]
    - [[Pattern Guards - 637][Pattern Guards - 637]]
  - [[Practical Aspects of STM - 638][Practical Aspects of STM - 638]]
    - [[Getting Comfortable with Giving Up Control - 638][Getting Comfortable with Giving Up Control - 638]]
    - [[Using Invariants - 639][Using Invariants - 639]]
- [[A. Installing GHC and Haskell Libraries - 641][A. Installing GHC and Haskell Libraries - 641]]
  - [[Installing GHC - 641][Installing GHC - 641]]
    - [[Windows - 641][Windows - 641]]
    - [[Mac OS X - 642][Mac OS X - 642]]
      - [[Alternatives - 643][Alternatives - 643]]
    - [[Ubuntu and Debian Linux - 643][Ubuntu and Debian Linux - 643]]
    - [[Fedora Linux - 645][Fedora Linux - 645]]
    - [[FreeBSD - 645][FreeBSD - 645]]
  - [[Installing Haskell Software - 646][Installing Haskell Software - 646]]
    - [[Automated Download and Installation with /cabal/ - 646][Automated Download and Installation with /cabal/ - 646]]
      - [[Installing cabal - 646][Installing cabal - 646]]
      - [[Updating cabal's package list - 646][Updating cabal's package list - 646]]
      - [[Installing a library or program - 646][Installing a library or program - 646]]
    - [[Building Packages by Hand - 647][Building Packages by Hand - 647]]
- [[B. Characters, Strings, and Escaping Rules - 649][B. Characters, Strings, and Escaping Rules - 649]]
  - [[Writing Character and String Literals - 649][Writing Character and String Literals - 649]]
  - [[International Language Support - 649][International Language Support - 649]]
  - [[Escaping Text - 650][Escaping Text - 650]]
    - [[Single-Character Escape Codes - 650][Single-Character Escape Codes - 650]]
    - [[Multiline String Literals - 651][Multiline String Literals - 651]]
    - [[ASCII Control Codes - 651][ASCII Control Codes - 651]]
    - [[Control-with-Character Escapes - 652][Control-with-Character Escapes - 652]]
    - [[Numeric Escapes - 652][Numeric Escapes - 652]]
    - [[The Zero-Width Escape Sequence - 653][The Zero-Width Escape Sequence - 653]]
- [[Tips][Tips]]

* TODO Preface - xxiii
* TODO 1 Getting Started - 1
** Your Haskell Environment - 1
** Getting Started with ghci, the Interpreter - 2
** Basic Interaction: Using ghci as a Calculator - 3
*** Simple Arithmetic - 3
*** An Arithmetic Quirk: Writing Negative Numbers - 4
*** Boolean Logic, Operators, and Value Comparisons - 5
*** Operator Precedence and Associativity - 7
*** Undefined Values, and Introducing Variables - 8
*** Dealing with Precedence and Associativity Variables - 8
** Command-Line Editing in ghci - 9
** Lists - 9
*** Operators on List - 11
** Strings and Characters - 11
** First Steps and Characters - 12
** A Simple Program - 15

* TODO 2 Types and Functions - 17
** DONE Why Care About Types? - 17
   CLOSED: [2018-05-19 Sat 15:54]
   - What a /type system/ gives us is *abstraction* --
     a type adds meaning to plain bytes.

     Usually, a /type system/ goes _beyond_ this to *prevent* us from
     accidentally mixing up types.

   - The benefit of introducing *abstraction* is that it lets us _forget or
     ignore_ low-level details.

   - /Type systrems/ are NOT equal.
     Different /type systems/ are often NOT even concerned with the same kinds of
     problems.

     _A programming language's type system deeply colors the way we think and
     write code in that language!_

** DONE Haskell's Type System - 18
   CLOSED: [2018-05-19 Sat 17:43]
   We'll talk about _three_ aspects to types in Haskell.

   =???=
   (When possible, we’ll present similarities between concepts from Haskell's
    type system and related ideas in other languages. We'll also touch on the
    respective strengths and weaknesses of each of these properties.)

*** DONE Strong Types - 18
    CLOSED: [2018-05-19 Sat 17:29]
    - *Reject* wrong /type/.
      + /well typed/
      + /ill typed/ --> /type error/

    - NO _automatically_ *coerce* (also known as /casting/ or /conversion/)
      values from one /type/ to another.

    - Strong typing _DOES_ occasioinally make it _more difficult_ to write
      certain kinds of code. Check the =EXAMPLE= given in the book! - page 18

    - The huge benefit of /strong typing/:
      catch real bugs in our code (earlier) before they cause problems.

    - *Weaker and Stronger Types*

*** DONE Static Types - 19
    CLOSED: [2018-05-19 Sat 17:43]
    - static type system :: that the compiler knows the type of every value and
         expression at compile time, before any code is executed.

    - /Static typing/ can occasionally make it _difficult_ to write some useful
      kinds of code.

    - Fortunately, Haskell's system of /typeclasses/, which we will cover in
      Chapter 6, provides almost all of the benefits of /dynamic typing/, in a
      safe and convenient form.

*** DONE Type Inference - 20
    CLOSED: [2018-05-19 Sat 17:43]

** TODO What to Expect from the Type System - 20
** TODO Some Common Basic Types - 21
** TODO Function Application - 22
** TODO Useful Composite Data Types: Lists and Tuples - 23
** TODO Functions over Lists and Tuples - 25
*** Passing an Expression to a Function - 26

** TODO Function Types and Purity - 27
** TODO Haskell Source Files, and Writing Simple Functions - 27
*** Just What Is a Variable, Anyway? - 28
*** Conditional Evaluation - 29

** TODO Understanding Evaluation by Example - 32
*** Lazy Evaluation - 32
*** A More Involved Example - 33
*** Recursion - 34
*** Ending the Recursion - 35
*** Returning from the Recursion - 35
*** What Have We Learned? - 36

** TODO Polymorphism in Haskell - 36
*** Reasoning About Polymorphic Functions - 38
*** Further Reading - 38

** TODO The Type of a Function of More Than One Argument - 38
** TODO Why the Fuss over Purity? - 39
** TODO Conclusion - 40

* TODO 3 Defining Types, Streamlining Functions - 41
** Defining a New Data Type - 41
*** Naming Types and Values - 43

** Type Synonyms - 43
** Algebraic Data Types - 44
*** Tuples, Algebraic Data Types, and When to Use Each - 45
*** Analogues to Algebraic Data Types in Other Languages - 47
**** The structure - 47
**** The enumeration - 48
**** The discriminated union - 49

** Pattern Matching - 50
*** Construction and Deconstruction - 51
*** Further Adventures - 52
*** Variable Naming in Patterns - 53
*** The Wild Card Pattern - 53
*** Exhaustive Patterns and Wild Cards - 54

** Record Syntax - 55
** Parameterized Types - 57
** Recursive Types - 58
** Reporting Errors - 60
*** A More Controlled Approach - 61

** Introducing Local Variables - 61
*** Shadowing - 62
*** The where Clause - 63
*** Local Functions, Global Variables - 63

** The Offside Rule and Whitespace in an Expression - 64
*** A Note About Tabs Versus Spaces - 66
*** The Offside Rule Is Not Mandatory - 66

** The ~case~ Expression - 66
** Common Beginner Mistakes with Patterns - 67
*** Incorrectly Matching Against a Variable - 67
*** Incorrectly Trying to Compare for Equality - 68

** Conditional Evaluation with Guards - 68

* TODO 4 Functional Programming - 71
** Thinking in Haskell - 71
** A Simple Command-Line Framework - 71
** Warming Up: Portably Splitting Lines of Text - 72
*** A Line-Ending Conversion Program - 75

** Infix Functions - 76
** Working with Lists - 77
*** Basic List Manipulation - 78
*** Safely and Sanely Working with Crashy Functions - 79
*** Partial and Total Functions - 79
*** More Simple List Manipulations - 80
*** Working with Sublists - 81
*** Searching Lists - 82
*** Working with Several Lists at Once - 83
*** Special String-Handling Functions - 84

** How to Think About Loops - 84
*** Explicit Recursion - 85
*** Transforming Every Piece of Input - 87
*** Mapping over a List - 88
*** Selecting Pieces of Input - 90
*** Computing One Answer over a Collection - 90
*** The Left Fold - 92
*** Why Use Folds, Maps, and Filters? - 93
*** Folding from the Right - 94
*** Left Folds, Laziness, and Space Leaks - 96
*** Further Reading - 99

** Anonymous (lambda) Functions - 99
** Partial Function Application and Currying - 100
*** Sections - 102

** As-patterns - 103
** Code Reuse Through Composition - 104
*** Use Your Head Wisely - 107

** Tips for Writing Readable Code - 107
** Space Leaks and Strict Evaluation - 108
*** Avoiding Space Leaks with ~seq~ - 108
*** Learning to Use ~seq~ - 109

* TODO 5 Writing a Library: Working with JSON Data - 111
** A Whirlwind Tour of JSON - 111
** Representing JSON Data in Haskell - 111
** The Anatomy of a Haskell Module - 113
** Compiling Haskell Source - 114
** Generating a Haskell Program and Importing Modules - 114
** Printing JSON Data - 115
** Type Inference Is a Double-Edged Sword - 117
** A More General Look at Rendering - 118
** Developing Haskell Code Without Going Nuts - 119
** Pretty Printing a String - 120
** Arrays and Objects, and the Module Header - 122
** Writing a Module Header - 123
** Fleshing Out the Pretty-Printing Library - 124
*** Compact Rendering - 127
*** True Pretty Printing - 128
*** Following the Pretty Printer - 129

** Creating a Package - 131
*** Writing a Package Description - 131
*** GHC’s Package Manager - 133
*** Setting Up, Building, and Installing - 133

** Practical Pointers and Further Reading - 134

* TODO 6 Using Typeclasses - 135
** The Need for Typeclasses - 135
** What Are Typeclasses? - 136
** Declaring Typeclass Instances - 139
** Important Built-in Typeclasses - 139
*** Show - 139
*** Read - 141
*** Serialization with read and show - 143
*** Numeric Types - 144
*** Equality, Ordering, and Comparisons - 148

** Automatic Derivation - 148
** Typeclasses at Work: Making JSON Easier to Use - 149
*** More Helpful Errors - 151
*** Making an Instance with a Type Synonym - 151

** Living in an Open World - 152
*** When Do Overlapping Instances Cause Problems? - 153
*** Relaxing Some Restrictions on Typeclasses - 154
*** How Does Show Work for Strings? - 155

** How to Give a Type a New Identity - 155
*** Differences Between Data and Newtype Declarations - 157
*** Summary: The Three Ways of Naming Types - 158

** JSON Typeclasses Without Overlapping Instances - 159
** The Dreaded Monomorphism Restriction - 162
** Conclusion - 163

* TODO 7 I/O - 165
** Classic I/O in Haskell - 165
*** Pure Versus I/O - 168
*** Why Purity Matters - 169
*
** Working with Files and Handles - 169
*** More on openFile - 171
*** Closing Handles - 172
*** Seek and Tell - 172
*** Standard Input, Output, and Error - 173
*** Deleting and Renaming Files - 174
*** Temporary Files - 174
*
** Extended Example: Functional I/O and Temporary Files - 175
** Lazy I/O - 178
*** hGetContents - 178
*** readFile and writeFile - 180
*** A Word on Lazy Output - 181
*** interact - 181
*
** The IO Monad - 183
*** Actions - 183
*** Sequencing - 186
*** The True Nature of Return - 187
*
** Is Haskell Really Imperative? - 188
** Side Effects with Lazy I/O - 188
** Buffering - 189
*** Buffering Modes - 189
*** Flushing The Buffer - 190
*
** Reading Command-Line Arguments - 190
** Environment Variables - 191

* TODO 8 Efficient File Processing, Regular Expressions, and Filename Matching - 193
** Efficient File Processing - 193
*** Binary I/O and Qualified Imports - 194
*** Text I/O - 195

** Filename Matching - 187
** Regular Expressions in Haskell - 198
*** The Many Types of Result - 198

** More About Regular Expressions - 200
*** Mixing and Matching String Types - 200
*** Other Things You Should Know - 201

** Translating a glob Pattern into a Regular Expression - 202
** An important Aside: Writing Lazy Functions - 205
** Making Use of Our Pattern Matcher - 206
** Handling Errors Through API Design - 210
** Putting Our Code to Work - 211

* TODO 9 I/O Case Study: A Library for Searching the Filesystem - 213
** The find Command - 213
** Starting Simple: Recursively Listing a Directory - 213
*** Revisiting Anonymous and Named Functions - 214
*** Why Provide Both mapM and forM? - 215

** A Naive Finding Function - 215
** Predicates: From Poverty to Riches, While Remaining Pure - 217
** Sizing a File Safely - 219
*** The Acquire-Use-Release Cycle - 221

** A Domain-Specific Language for Predicates - 221
*** Avoiding Boilerplate with Lifting - 223
*** Gluing Predicates Together - 224
*** Defining and Using New Operators - 225

** Controlling Traversal - 226
** Density, Readability, and the Learning Process - 228
** Another Way of Looking at Traversal - 229
** Useful Coding Guidelines - 232
*** Common Layout Styles - 233

* TODO 10 Code Case Study: Parsing a Binary Data Format - 235
** Grayscale Files - 235
** Parsing a Raw PGM File - 236
** Getting Rid of Boilerplate Code - 238
** Implicit State - 239
*** The Identity Parser - 240
*** Record Syntax, Updates, and Pattern Matching - 241
*** A More Interesting Parser - 242
*** Obtaining and Modifying the Parse State - 242
*** Reporting Parse Errors - 243
*** Chaining Parsers Together - 243
** Introducing Functors - 244
*** Constraints on Type Definitions Are Bad - 247
*** Infix Use of fmap - 248
*** Flexible Instances - 248
*** Thinking More About Functors - 249
** Writing a Functor Instance for Parse - 250
** Using Functors for Parsing - 251
** Rewriting Our PGM Parser - 252
** Future Directions - 254
























* TODO 11 Testing and Quality Assurance - 255
** QuickCheck: Type-Based Testing - 256
*** Testing for Properties - 257
*** Testing Against a Model - 259

** Testing Case Study: Specifying a Pretty Printer - 259
*** Generating Test Data - 259
*** Testing Document Construction - 262
*** Using Lists as a Model - 263
*** Putting It All Together - 264

** Measuring Test Coverage with HPC - 265

* TODO 12 Barcode Recognition - 269
** A Little Bit About Barcodes - 269
*** EAN-13 Encoding - 270

** Introducing Arrays - 270
*** Arrays and Laziness - 273
*** Folding over Arrays - 273
*** Modifying Array Elements - 274

** Encoding an EAN-13 Barcode - 275
** Constraints on Our Decoder - 275
** Divide and Conquer - 276
** Turning a Color Image into Something Tractable - 278
*** Parsing a Color Image - 278
*** Grayscale Conversion - 279
*** Grayscale to Binary and Type Safety - 279

** What Have We Done to Our Image? - 280
** Finding Matching Digits - 282
*** Run Length Encoding - 282
*** Scaling Run Lengths, and Finding Approximate Matches - 283
*** List Comprehensions - 284
*** Remembering a Match's Parity - 285
*** Chunking a List - 287
*** Generating a List of Candidate Digits - 287

** Life Without Arrays or Hash Tables - 288
*** A Forest of Solutions - 288
*** A Brief Introduction to Maps - 289
*** Further Reading - 292

** Turning Digit Soup into an Answer - 292
*** Solving for Check Digits in Parallel - 292
*** Completing the Solution Map with the First Digit - 294
*** Finding the Correct Sequence - 295

** Working with Row Data - 295
** Pulling It All Together - 296
** A Few Comments on Development Style - 297

* TODO 13 Data Structures - 299
** Association Lists - 299
** Maps - 301
** Functions Are Data, Too - 303
** Extended Example: /etc/passwd - 304
** Extended Example: Numeric Types - 307
*** First Steps - 309
*** Completed Code - 311

** Taking Advantage of Functions as Data - 317
*** Turning Difference Lists into a Proper Library - 318
*** Lists, Difference Lists, and Monoids - 320

** General-Purpose Sequences - 322

* TODO 14 Monads - 325
** Revisiting Earlier Code Examples - 325
*** Maybe Chaining - 325
*** Implicit State - 326

** Looking for Shared Patterns - 327
** The Monad Typeclass - 329
** And Now, a Jargon Moment - 330
** Using a New Monad: Show Your Work! - 331
*** Information Hiding - 331
*** Controlled Escape - 332
*** Leaving a Trace - 332
*** Using the Logger Monad - 333

** Mixing Pure and Monadic Code - 334
** Putting a Few Misconceptions to Rest - 336
** Building the Logger Monad - 336
*** Sequential Logging, Not Sequential Evaluation - 337
*** The Writer Monad - 337

** The Maybe Monad - 338
*** Executing the Maybe Monad - 338
*** Maybe at Work, and Good API Design - 338

** The List Monad - 340
*** Understanding the List Monad - 342
*** Putting the List Monad to Work - 343

** Desugaring of do Blocks - 344
*** Monads as a Programmable Semicolon - 345
*** Why Go Sugar-Free? - 346

** The State Monad - 346
*** Almost a State Monad - 347
*** Reading and Modifying the State - 348
*** Will the Real State Monad Please Stand Up? - 348
*** Using the State Monad: Generating Random Values - 349
*** A First Attempt at Purity - 350
*** Random Values in the State Monad - 351
*** Running the State Monad - 352
*** What About a Bit More State? - 352

** Monads and Functors - 354
*** Another Way of Looking at Monads - 354

** The Monad Laws and Good Coding Style - 355

* TODO 15 Programming with Monads - 359
** Golfing Practice: Association Lists - 359
** Generalized Lifting - 360
** Looking for Alternatives - 362
*** The Name mplus Does Not Imply Addition - 364
*** Rules for Working with MonadPlus - 364
*** Failing Safely with MonadPlus - 364

** Adventures in Hiding the Plumbing - 365
*** Supplying Random Numbers - 368
*** Another Round of Golf - 369

** Separating Interface from Implementation - 369
*** Multiparameter Typeclasses - 370
*** Functional Dependencies - 370
*** Rounding Out Our Module - 371
*** Programming to a Monad’s Interface - 372

** The Reader Monad - 373
** A Return to Automated Deriving - 374
** Hiding the IO Monad - 375
*** Using a newtype - 376
*** Designing for Unexpected Uses - 377
*** Using Typeclasses - 378
*** Isolation and Testing - 379
*** The Writer Monad and Lists - 380
*** Arbitrary I/O Revisited - 381

* TODO 16 Using ~Parsec~ - 383
** First Steps with Parsec: Simple CSV Parsing - 383
** The sepBy and endBy Combinators - 386
** Choices and Errors - 387
*** Lookahead - 389
*** Error Handling - 390

** Extended Example: Full CSV Parser - 391
** Parsec and MonadPlus - 393
** Parsing a URL-Encoded Query String - 393
** Supplanting Regular Expressions for Casual Parsing - 395
** Parsing Without Variables - 395
** Applicative Functors for Parsing - 395
** Applicative Parsing by Example - 396
** Parsing JSON Data - 398
** Parsing a HTTP Request - 401
*** Backtracking and Its Discontents - 402
*** Parsing Headers - 402

* TODO 17 Interfacing with C: The FFI - 405
** Foreign Language Bindings: The Basics - 406
*** Be Careful of Side Effects - 407
*** A High-Level Wrapper - 408

** Regular Expressions for Haskell: A Binding for PCRE - 409
*** Simple Tasks: Using the C Preprocessor - 410
*** Binding Haskell to C with hsc - 2hs - 411
*** Adding Type Safety to PCRE - 411
*** Binding to Constants - 412
*** Automating the Binding - 413

** Passing String Data Between Haskell and C - 414
*** Typed Pointers - 416
*** Memory Management: Let the Garbage Collector Do the Work - 417
*** A High-Level Interface: Marshaling Data - 418
*** Marshaling ByteStrings - 419
*** Allocating Local C Data: The Storable Class - 419
*** Putting It All Together - 420

** Matching on Strings - 422
*** Extracting Information About the Pattern - 423
*** Pattern Matching with Substrings - 424
*** The Real Deal: Compiling and Matching Regular Expressions - 426

* TODO 18 Monad Transformers - 429
** TODO Motivation: Boilerplate Avoidance - 429
** A Simple Monad Transformer Example - 430
** Common Patterns in Monads and Monad Transformers - 431
** Stacking Multiple Monad Transformers - 433
*** Hiding Our Work - 435

** TODO Moving Down the Stack - 436
*** When Explicit Lifting Is Necessary - 437

** TODO Understanding Monad Transformers by Building One - 438
*** Creating a Monad Transformer - 439
*** More Typeclass Instances - 440
*** Replacing the Parse Type with a Monad Stack - 440

** TODO Transformer Stacking Order Is Important - 441
** TODO Putting Monads and Monad Transformers into Perspective - 443
*** Interference with Pure Code - 443
*** Overdetermined Ordering - 444
*** Runtime Overhead - 444
*** Unwieldy Interfaces - 444
*** Pulling It All Together - 445

* TODO 19. Error Handling - 447
** TODO Error Handling with Data Types - 447
*** Use of Maybe - 448
*** Use of Either - 452

** TODO Exceptions - 454
*** First Steps with Exceptions - 454
*** Laziness and Exception Handling - 455
*** Using handle - 456
*** Selective Handling of Exceptions - 456
*** I/O Exceptions - 457
*** Throwing Exceptions - 459
*** Dynamic Exceptions - 459

** TODO Error Handling in Monads - 462
*** A Tiny Parsing Framework - 463

* TODO 20. Systems Programming in Haskell - 467
** Running External Programs - 467
** Directory and File Information - 468
** Program Termination - 469
** Dates and Times - 470
*** ClockTime and CalendarTime - 470
*** File Modification Times - 475

** Extended Example: Piping - 476
*** Using Pipes for Redirection - 477
*** Better Piping - 483
*** Final Words on Pipes - 491









* TODO 21. Using Databases - 493
** Overview of HDBC - 493
** Installing HDBC and Drivers - 494
** Connecting to Databases - 495
** Transactions - 495
** Simple Queries - 496
** SqlValue - 497
** Query Parameters - 497
** Prepared Statements - 498
** Reading Results - 499
*** Reading with Statements - 501
*** Lazy Reading - 501

** Database Metadata - 502
** Error Handling - 503

* TODO 22 Extended Example: Web Client Programming - 505
** Basic Types - 506
** The Database - 506
** The Parser - 510
** Downloading - 513
** Main Program - 513

* TODO 23 GUI Programming with gtk2hs - 517
** Installing gtk - 2hs - 517
** Overview of the GTK+ Stack - 517
** User Interface Design with Glade - 518
*** Glade Concepts - 518

** Event-Driven Programming - 519
** Initializing the GUI - 520
** The Add Podcast Window - 524
** Long-Running Tasks - 525
** Using Cabal - 528

* TODO 24 Concurrent and Multicore Programming - 531
** Defining Concurrency and Parallelism - 531
** Concurrent Programming with Threads - 532
*** Threads Are Nondeterministic - 532
*** Hiding Latency - 532

** Simple Communication Between Threads - 533
** The Main Thread and Waiting for Other Threads - 534
*** Safely Modifying an MVar - 536
*** Safe Resource Management: A Good Idea, and Easy Besides - 536
*** Finding the Status of a Thread - 537
*** Writing Tighter Code - 538

** Communicating over Channels - 539
** Useful Things to Know About - 539
*** MVar and Chan Are Nonstrict - 539
*** Chan Is Unbounded - 540

** Shared-State Concurrency Is Still Hard - 540
*** Deadlock - 541
*** Starvation - 541
*** Is There Any Hope? - 542

** Using Multiple Cores with GHC - 542
*** Runtime Options - 543
*** Finding the Number of Available Cores from Haskell - 543
*** Choosing the Right Runtime - 544

** Parallel Programming in Haskell - 544
*** Normal Form and Head Normal Form - 545
*** Sequential Sorting - 545
*** Transforming Our Code into Parallel Code - 545
*** Knowing What to Evaluate in Parallel - 546
*** What Promises Does par Make? - 547
*** Running Our Code and Measuring Performance - 547
*** Tuning for Performance - 550

** Parallel Strategies and MapReduce - 551
*** Separating Algorithm from Evaluation - 552
*** Separating Algorithm from Strategy - 554
*** Writing a Simple MapReduce Definition - 554
*** MapReduce and Strategies - 555
*** Sizing Work Appropriately - 555
*** Efficiently Finding Line-Aligned Chunks - 557
*** Counting Lines - 558
*** Finding the Most Popular URLs - 559
*** Conclusions - 560

* TODO 25 Profiling and Optimization - 561
** Profiling Haskell Programs - 561
*** Collecting Runtime Statistics - 562
*** Time Profiling - 563
*** Space Profiling - 566

** Controlling Evaluation - 570
*** Strictness and Tail Recursion - 571
*** Adding Strictness - 572

** Understanding Core - 575
** Advanced Techniques: Fusion - 578
*** Tuning the Generated Assembly - 579

** Conclusions - 580










* TODO 26. Advanced Library Design: Building a Bloom Filter - 581
** Introducing the Bloom Filter - 581
** Use Cases and Package Layout - 582
** Basic Design - 583
*** Unboxing, Lifting, and Bottom - 583

** The ST Monad - 584
** Designing an API for Qualified Import - 585
** Creating a Mutable Bloom Filter - 586
** The Immutable API - 587
** Creating a Friendly Interface - 588
*** Re-Exporting Names for Convenience - 589
*** Hashing Values - 589
*** Turning Two Hashes into Many - 593
*** Implementing the Easy Creation Function - 593

** Creating a Cabal Package - 595
*** Dealing with Different Build Setups - 596
*** Compilation Options and Interfacing to C - 598

** Testing with QuickCheck - 599
*** Polymorphic Testing - 600
*** Writing Arbitrary Instances for ByteStrings - 601
*** Are Suggested Sizes Correct? - 602

** Performance Analysis and Tuning - 604
*** Profile-Driven Performance Tuning - 605

* TODO 27. Sockets and Syslog - 611
** Basic Networking - 611
** Communicating with UDP - 611
*** UDP Client Example: syslog - 612
*** UDP Syslog Server - 615

** Communicating with TCP - 616
*** Handling Multiple TCP Streams - 616
*** TCP Syslog Server - 617
*** TCP Syslog Client - 619

* TODO 28 Software Transactional Memory - 623
** The Basics - 623
** Some Simple Examples - 624
** STM and Safety - 626
** Retrying a Transaction - 626
*** What Happens When We Retry? - 628

** Choosing Between Alternatives - 628
*** Using Higher Order Code with Transactions - 628

** I/O and STM - 629
** Communication Between Threads - 630
** A Concurrent Web Link Checker - 631
*** Checking a Link - 633
*** Worker Threads - 634
*** Finding Links - 635
*** Command-Line Parsing - 636
*** Pattern Guards - 637

** Practical Aspects of STM - 638
*** Getting Comfortable with Giving Up Control - 638
*** Using Invariants - 639

* TODO A. Installing GHC and Haskell Libraries - 641
** DONE Installing GHC - 641
   CLOSED: [2018-04-08 Sun 11:47]
   =From Jian=  Don't follow this section! Always use /stack/!!!

*** Windows - 641
*** Mac OS X - 642
**** Alternatives - 643

*** Ubuntu and Debian Linux - 643
*** Fedora Linux - 645
*** FreeBSD - 645

** TODO Installing Haskell Software - 646
*** Automated Download and Installation with /cabal/ - 646
**** Installing cabal - 646
**** Updating cabal's package list - 646
**** Installing a library or program - 646
    
*** Building Packages by Hand - 647

* TODO B. Characters, Strings, and Escaping Rules - 649
** Writing Character and String Literals - 649
** International Language Support - 649
** Escaping Text - 650
*** Single-Character Escape Codes - 650
*** Multiline String Literals - 651
*** ASCII Control Codes - 651
*** Control-with-Character Escapes - 652
*** Numeric Escapes - 652
*** The Zero-Width Escape Sequence - 653

* Tips
