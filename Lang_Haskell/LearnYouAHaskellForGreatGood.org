#+TITLE: Learn You a Haskell for Great Good!
#+AUTHOR: Miran LipovaÄa
#+YEAR: 2011
#+STARTUP: overview
#+STARTUP: entitiespretty


* Table of Contents                                      :TOC_4_org:noexport:
- [[Introduction][Introduction]]
  - [[About this tutorial][About this tutorial]]
  - [[So what's Haskell?][So what's Haskell?]]
  - [[What you need to dive in][What you need to dive in]]
- [[Starting Out][Starting Out]]
  - [[Ready, set, go!][Ready, set, go!]]
  - [[Baby's first functions][Baby's first functions]]
  - [[An intro to lists][An intro to lists]]
  - [[Texas ranges][Texas ranges]]
  - [[I'm a list comprehension][I'm a list comprehension]]
  - [[Tuples][Tuples]]
- [[Types and Typeclasses][Types and Typeclasses]]
  - [[Believe the type][Believe the type]]
  - [[Type variables][Type variables]]
  - [[Typeclasses 101][Typeclasses 101]]
- [[Syntax in Functions][Syntax in Functions]]
  - [[Pattern matching][Pattern matching]]
  - [[Guards, guards!][Guards, guards!]]
  - [[Where!?][Where!?]]
  - [[Let it be][Let it be]]
  - [[Case expressions][Case expressions]]
- [[Recursion][Recursion]]
  - [[Hello recursion!][Hello recursion!]]
  - [[Maximum awesome][Maximum awesome]]
  - [[A few more recursive functions][A few more recursive functions]]
  - [[Quick, sort!][Quick, sort!]]
  - [[Thinking recursively][Thinking recursively]]
- [[Higher Order Functions][Higher Order Functions]]
  - [[Curried functions][Curried functions]]
  - [[Some higher-orderism is in order][Some higher-orderism is in order]]
  - [[Maps and filters][Maps and filters]]
  - [[Lambdas][Lambdas]]
  - [[Only folds and horses][Only folds and horses]]
  - [[Function application with ~$~][Function application with ~$~]]
  - [[Function composition][Function composition]]
- [[Modules][Modules]]
  - [[Loading modules][Loading modules]]
  - [[~Data.List~][~Data.List~]]
  - [[~Data.Char~][~Data.Char~]]
  - [[~Data.Map~][~Data.Map~]]
  - [[~Data.Set~][~Data.Set~]]
  - [[Making our own modules][Making our own modules]]
- [[Making Our Own Types and Typeclasses][Making Our Own Types and Typeclasses]]
  - [[Algebraic data types intro][Algebraic data types intro]]
  - [[Record syntax][Record syntax]]
  - [[Type parameters][Type parameters]]
  - [[Derived instances][Derived instances]]
  - [[Type synonyms][Type synonyms]]
  - [[Recursive data structures][Recursive data structures]]
  - [[Typeclasses 102][Typeclasses 102]]
  - [[A yes-no typeclass][A yes-no typeclass]]
  - [[The Functor typeclass][The Functor typeclass]]
  - [[Kinds and some type-foo][Kinds and some type-foo]]
- [[Input and Output][Input and Output]]
  - [[Hello, world!][Hello, world!]]
  - [[Files and streams][Files and streams]]
  - [[Command line arguments][Command line arguments]]
  - [[Randomness][Randomness]]
  - [[Bytestrings][Bytestrings]]
  - [[Exceptions][Exceptions]]
- [[Functionally Solving Problems][Functionally Solving Problems]]
  - [[Reverse Polish notation calculator][Reverse Polish notation calculator]]
  - [[Heathrow to London][Heathrow to London]]
- [[Functors, Applicative Functors and Monoids][Functors, Applicative Functors and Monoids]]
  - [[Functors redux][Functors redux]]
  - [[Applicative functors][Applicative functors]]
    - [[~Maybe~ Applicative Functors (Title Add by Jian)][~Maybe~ Applicative Functors (Title Add by Jian)]]
    - [[~[]~ Applicative Functors (Title Add by Jian)][~[]~ Applicative Functors (Title Add by Jian)]]
    - [[~IO~ Applicative Functors (Title Add by Jian)][~IO~ Applicative Functors (Title Add by Jian)]]
    - [[~(->) r~ Applicative Functors (Title Add by Jian)][~(->) r~ Applicative Functors (Title Add by Jian)]]
    - [[~ZipList~ Applicative Functors (Title Add by Jian)][~ZipList~ Applicative Functors (Title Add by Jian)]]
    - [[The ~liftA2~ Funciton (Title Add by Jian)][The ~liftA2~ Funciton (Title Add by Jian)]]
    - [[The ~sequenceA~ Funciton (Title Add by Jian)][The ~sequenceA~ Funciton (Title Add by Jian)]]
    - [[Applicative Functor Laws (Title Add by Jian) -- =Try to Verify them in examples=][Applicative Functor Laws (Title Add by Jian) -- =Try to Verify them in examples=]]
    - [[Conclusion (Title Add by Jian)][Conclusion (Title Add by Jian)]]
  - [[The ~newtype~ keyword][The ~newtype~ keyword]]
    - [[Using ~newtype~ to make type class instances][Using ~newtype~ to make type class instances]]
    - [[On ~newtype~ laziness][On ~newtype~ laziness]]
    - [[~type~ vs. ~newtype~ vs. ~data~][~type~ vs. ~newtype~ vs. ~data~]]
  - [[Monoids][Monoids]]
- [[A Fistful of Monads][A Fistful of Monads]]
  - [[Getting our feet wet with Maybe][Getting our feet wet with Maybe]]
  - [[The Monad type class][The Monad type class]]
  - [[Walk the line][Walk the line]]
  - [[do notation][do notation]]
  - [[The list monad][The list monad]]
  - [[Monad laws][Monad laws]]
- [[For a Few Monads More][For a Few Monads More]]
  - [[Writer? I hardly know her!][Writer? I hardly know her!]]
  - [[Reader? Ugh, not this joke again.][Reader? Ugh, not this joke again.]]
  - [[Tasteful stateful computations][Tasteful stateful computations]]
  - [[Error error on the wall][Error error on the wall]]
  - [[Some useful monadic functions][Some useful monadic functions]]
  - [[Making monads][Making monads]]
- [[Zippers][Zippers]]
  - [[Taking a walk][Taking a walk]]
  - [[A trail of breadcrumbs][A trail of breadcrumbs]]
    - [[Going back up][Going back up]]
    - [[Manipulating trees under focus][Manipulating trees under focus]]
    - [[I'm going straight to top, oh yeah, up where the air is fresh and clean!][I'm going straight to top, oh yeah, up where the air is fresh and clean!]]
  - [[Focusing on lists][Focusing on lists]]
  - [[A very simple file system][A very simple file system]]
    - [[A zipper for our file system][A zipper for our file system]]
    - [[Manipulating our file system][Manipulating our file system]]
  - [[Watch your step][Watch your step]]
- [[Tips][Tips]]

* Introduction
** About this tutorial
** So what's Haskell?
** What you need to dive in

* Starting Out
** Ready, set, go!
** Baby's first functions
** An intro to lists
** Texas ranges
** I'm a list comprehension
** Tuples

* Types and Typeclasses
** Believe the type
** Type variables
** Typeclasses 101

* Syntax in Functions
** Pattern matching
** Guards, guards!
** Where!?
** Let it be
** Case expressions

* Recursion
** Hello recursion!
** Maximum awesome
** A few more recursive functions
** Quick, sort!
** Thinking recursively

* Higher Order Functions
** Curried functions
** Some higher-orderism is in order
** Maps and filters
** Lambdas
** Only folds and horses
** Function application with ~$~
** Function composition

* Modules
** Loading modules
** ~Data.List~
** ~Data.Char~
** ~Data.Map~
** ~Data.Set~
** Making our own modules

* Making Our Own Types and Typeclasses
** Algebraic data types intro
** Record syntax
** Type parameters
** Derived instances
** Type synonyms
** Recursive data structures
** Typeclasses 102
** A yes-no typeclass
** The Functor typeclass
** Kinds and some type-foo

* Input and Output
** Hello, world!
** Files and streams
** Command line arguments
** Randomness
** Bytestrings
** Exceptions

* Functionally Solving Problems
** Reverse Polish notation calculator
** Heathrow to London

* Functors, Applicative Functors and Monoids
  - =TODO=
    We'll talk about a slightly stronger and more useful versions of /functors/
    called /applicative functors/.

** DONE Functors redux
   CLOSED: [2018-08-31 Fri 17:10]
   - Refresh:
     The /typeclass/ ~Functor~ has ONLY ONE /typeclass method/:
     ~fmap :: (a -> b) -> f a -> f b~

   - *A word of advice*:
     We often use "box analogy" to describe /functors/, and later we will also
     use it to describe /applicative functors/ and /monads/.

     Do NOT take the phrase"box analogy" to literally.
     *The /computational context/ is a better term!*

   - We have seen some ~Functor~'s instances (by theirselves they are /type
     constructors/), like ~[]~, ~Maybe~, ~Either a~ (with one of the two type
     parameters), and /Tree/.

   - In this section, we'll take a look at two more /instances of functor/, namely
     ~IO~ and ~(->) r~.

   - ~IO~ =TODO=

   - ~(->) r~
     How are functions functors? Well, let's take a look at the implementation,
     which lies in ~Control.Monad.Instances~.
     #+BEGIN_SRC haskell
       instance Functor ((->) r) where
         fmap f g = (\x -> f (g x))
     #+END_SRC

     + Let's check the type of ~fmap~, in this case, in details.
       1. ~fmap :: (a -> b) -> f a -> f b~

       2. ~fmap :: (a -> b) -> ((->) r a) -> ((->) r b)~

       3. ~fmap :: (a -> b) -> (r -> a) -> (r -> b)~

       Yes! You fmap a function to a function, and get a new function.
       You may notice this is a /composition/!
       #+BEGIN_SRC haskell
         instance Functor ((->) r) where
           fmap = (.)
       #+END_SRC

   - =From Jian=
     + Q :: Why NOT implement ~fmap f g = \x -> g (f x)~ in the /Functor instance/
            of ~((->) r)~?
       * =From Jian=
         This is a naive guess reasoning by considering /functor/ with the
         _box metaphor_.

     + A :: Because this implementation violate the second *Functor LAWS* below!
            It satisfies that ~fmap (f . g) = fmap g . fmap f~.
       * There is NO guarantee that the types are compatible.

       * This is NOT the REAL law we require: ~fmap (f . g) = fmap f . fmap g~.

   - From another point of view, we can re-group the types in the signature of
     ~fmap~:
     #+BEGIN_SRC haskell
       fmap :: (a -> b) -> (f a -> f b)
     #+END_SRC
     This re-group is reasonable and nothing real changed.

     + We can think of ~fmap~
       * _NOT_ as a function that takes one function and a /functor/ and returns a
         /functor/,

       * _BUT_ as a function that
         - takes a function
           and
         - returns a new function

     + lifting :: We call the operation from ~a -> b~ to ~f a -> f b~ as _lifting_.

   - The *Functor LAWS* are *NOT enforced* by Haskell automatically,
     and you have to test them out yourself.
     + ~fmap id = id~

     + ~fmap (f . g) = fmap f . fmap g~

       Or write in another way:
       ~fmap (f . g) F = fmap f . (fmap g F)~

   - Counter example (even if you make a ~Functor~ instance, it can be non-functor
     if it does NOT obey those two laws):
     #+BEGIN_SRC haskell
       -- NOT functor --
       data CMaybe a = CNothing | CJust Int a deriving (Show)

       -- NO guarantee!!!
       instance Functor CMaybe where
           fmap f CNothing = CNothing
           fmap f (CJust counter x) = CJust (counter+1) (f x)

       -- Violate the first law!!!
       fmap id (CJust 0 "haha")  -- CJust 1 "haha"
       id (CJust 0 "haha")       -- CJust 0 "haha"
     #+END_SRC

** TODO Applicative functors
   /Applicative functors/ are beefed up /functors/.

   This chapter will will talk about the /applicative functors/ of ~Maybe~, ~[]~,
   ~IO~, and ~(->) r~.

   - You can find the ~Applicative~ typeclass in the ~Control.Applicative~ module.

   - Q :: WHY do we need ~Applicative~

   - A :: Consider some use cases:
     1. If we ~fmap~ a function, which takes a value and generate another function
        (~g~), over a /functor/, we get a functor of function ~g~. 

        For example,
        #+BEGIN_SRC haskell
          ghci> :t fmap (++) (Just "hey")
          fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])
  
          ghci> :t fmap compare (Just 'a')
          fmap compare (Just 'a') :: Maybe (Char -> Ordering)
  
          ghci> :t fmap compare "A LIST OF CHARS"
          fmap compare "A LIST OF CHARS" :: [Char -> Ordering]
  
          ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]
          fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]
        #+END_SRC
  
        This is reasonable, and interesting.
        *However, sometimes we need more!*

     2. Can we /map/ the function in a /functor/ to the value in another /functor/?

        At least, we *cannot ONLY use* the ~Functor~'s ~fmap~ to write a concise
        solution!

        *We need ~Applicative~!*

   - ~Control.Applicative~ Definition:
     #+BEGIN_SRC haskell
       class (Functor f) => Applicative f where
           pure :: a -> f a
           (<*>) :: f (a -> b) -> f a -> f b
     #+END_SRC

     + Q :: How to think ~pure~?

     + A :: ~pure~ would be to say that it takes a value and puts it in some sort
            of *default (or pure) context* -- a *minimal context* that still yields
            that value.

     + ~<*>~ is like a beefed up ~fmap~:
       #+BEGIN_SRC haskell
         (<*>) :: f (a -> b) -> f a -> f b

         fmap :: (a -> b) -> f a -> f b
       #+END_SRC

*** DONE ~Maybe~ Applicative Functors (Title Add by Jian)
    CLOSED: [2018-09-01 Sat 01:00]
    - Definition:
      #+BEGIN_SRC haskell
        instance Applicative Maybe where
            pure = Just
            Nothing <*> _ = Nothing
            (Just f) <*> something = fmap f something
      #+END_SRC
      + Again, from the _class definition_ we see that the ~f~ that plays the role
        of the /applicative functor/ should take one *concrete type* as a parameter,

        so we write ~instance Applicative Maybe where~ _instead of_ writing
        ~instance Applicative (Maybe a) where~.

      + Example:
        #+BEGIN_SRC haskell
          Just (+3) <*> Just 9         -- Just 12
          pure (+3) <*> Just 10        -- Just 13
          pure (+3) <*> Just 9         -- Just 12
          Just (++"hahah") <*> Nothing -- Nothing
          Nothing <*> Just "woot"      -- Nothing
        #+END_SRC

    - ~Applicative~ provide a way to combine /functors/ DIRECTLY, which can't be
      done _concisely_ ONLY with the operations of /non-applicative functors/ --
      for example, you *can't get the result out from a /non-applicative functor/
      in any _GENERAL_ way*, even if the result is a /partially applied
      function/.

      =IMPORTANT=
      /Applicative functors/, on the other hand, allow you to operate on several
      functors with a single function. Check out this piece of code:
      #+BEGIN_SRC haskell
        pure (+) <*> Just 3 <*> Just 5     -- Just 8
        pure (+) <*> Just 3 <*> Nothing    -- Nothing
        pure (+) <*> Nothing <*> Just 5    -- Nothing
      #+END_SRC

    - *This is one of the /applicative/ laws*.
      ~pure f <*> x equals fmap f x~.

    - ~pure f <*> x <*> y <*> ...~

      is equivalent to

      ~fmap f x <*> y <*> ...~

      This is why ~Control.Applicative~ exports a function called ~<$>~, which is
      just ~fmap~ as an infix operator.
      #+BEGIN_SRC haskell
        (<$>) :: (Functor f) => (a -> b) -> f a -> f b
        f <$> x = fmap f x
      #+END_SRC

    - ~<$>~ is NOT ONLY for convenient!

      By using ~<$>~, the /applicative/ style really shines,
      because now if we want to apply a function ~f~ between _three_ /applicative
      functors/, we can write ~f <$> x <*> y <*> z~.

      If the parameters weren't /applicative functors/ but normal values, we'd write
      ~f x y z~

      + A concrete example:
        #+BEGIN_SRC haskell
          (++) <$> Just "johntra" <*> Just "Volta"   -- Just "johntravolta"
          (++) "johntra" "Volta"                     -- "johntravolta"
        #+END_SRC

*** DONE ~[]~ Applicative Functors (Title Add by Jian)
    CLOSED: [2018-09-01 Sat 01:00]
    - Definition:
      #+BEGIN_SRC haskell
        instance Applicative [] where
          pure x = [x]
          fs <*> xs = [f x | f <- fs, x <- xs]
      #+END_SRC

      + ~pure~ examples
        #+BEGIN_SRC haskell
          pure "Hey" :: [String]
          -- ["Hey"]

          pure "Hey" :: Maybe String
          -- Just "Hey" 
        #+END_SRC

      + ~<*>~ example (with /list applicative functors/):
        #+BEGIN_SRC haskell
          [(*0), (+100), (^2)] <*> [1, 2, 3]
          -- [0, 0, 0, 101, 102, 103, 1, 4, 9]

          [(+), (*)] <*> [1, 2] <*> [3, 4]
          -- [4, 5, 5, 6, 3, 4, 6, 8]
        #+END_SRC

    - Using the /applicative style/ _on lists_ is often a *good replacement* for
      /list comprehensions/.

      + /list comprehensions/
        #+BEGIN_SRC haskell
          [ x*y | x <- [2,5,10], y <- [8,10,11]]
          -- [16,20,22,40,50,55,80,100,110]
        #+END_SRC

      + /applicative style/
        #+BEGIN_SRC haskell
          (*) <$> [2, 5, 10] <*> [8, 10, 11]
          -- [16,20,22,40,50,55,80,100,110]
        #+END_SRC

    - An example, still replace /list comprehensions/ with /applicative style/ code.
      #+BEGIN_SRC haskell
        filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
        -- [55,80,100,110]
      #+END_SRC

*** DONE ~IO~ Applicative Functors (Title Add by Jian)
    CLOSED: [2018-09-01 Sat 01:05]
    - The ~IO~ is also an /applicative/:
      #+BEGIN_SRC haskell
        instance Applicative IO where
          pure = return
          a <*> b = do
            f <- a
            x <- b
            return (f x)
      #+END_SRC

    - If you ever find yourself
      1. binding some I/O actions to names and then

      2. calling some function on them and presenting that as the result by using
         ~return~,

      consider using the /applicative style/ because it's arguably *a bit more
      concise and terse*.

    - do-notation style:
      #+BEGIN_SRC haskell
        myAction :: IO String
        myAction = do
            a <- getLine
            b <- getLine
            return $ a ++ b
      #+END_SRC

    - applicative style:
      #+BEGIN_SRC haskell
        myAction :: IO String
        myAction = (++) <$> getLine <*> getLine
      #+END_SRC

*** TODO ~(->) r~ Applicative Functors (Title Add by Jian)
    - Definition:
      #+BEGIN_SRC haskell
        instance Applicative ((->) r) where
          pure x = (\_ -> x)
          f <*> g = \x -> f x (g x)
      #+END_SRC
      + ~pure 3 "blah~ is ~3~

      + ~(+) <$> (+3) <*> (*100) $ 5~

        =From Jian=
        If consider /functors/ as a box, the ~fmap~ implementation of the ~((->) r)~
        /functor/ is a little wierd! This is the reason why I am confused!!!

        * Intuitively, if I consider /functors/ as boxes, I may expect
          #+BEGIN_SRC haskell
            ------------------------------------
            -- NOT the one used by Haskell!!! --
            ------------------------------------
            instance Functor ((->) r) where
              fmap f g = (\x -> g (f x))
          #+END_SRC

        * The actual ~fmap~ of ~((->) r)~ is
          ~fmap f g = (\x -> f (g x))~

          Use this we can write down the evaluation process of
          ~(+) <$> (+3) <*> (*100) $ 5~:
          1. ~((+) . (+3)) <*> (*100) $ 5~
          2. ~(\x -> ((+) . (+3)) x (x * 100))) 5~
          3. ~((+) . (+3)) 5 500)~
          4. ~(\x y -> (3 + x) + y) 5 500~
          5. ~3 + 5 + 500~
          6. ~508~

*** TODO ~ZipList~ Applicative Functors (Title Add by Jian)
    For the /list applicative functors/, why do we define ~<*>~ that way above?

    - Q :: Can we define it like zip two list, and combine them with a given function.

    - A :: Yes you can!!!
           However, *one type can only instantiate once*.

           The solution is we define a new type called ~ZipList~, and it has only
           ONE field, which is a ~List~.

    - Definition:
      #+BEGIN_SRC haskell
        instance Applicative ZipList where
          pure x = ZipList (repeat x)
          ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)
      #+END_SRC

*** TODO The ~liftA2~ Funciton (Title Add by Jian)
    - xxx

*** TODO The ~sequenceA~ Funciton (Title Add by Jian)
    - xxx

*** TODO Applicative Functor Laws (Title Add by Jian) -- =Try to Verify them in examples=
    - ~pure f <*> x = fmap f x~

    - ~pure id <*> v = v~

    - ~pure (.) <*> u <*> v <*> w = u <*> (v <*> w)~

    - ~pure f <*> pure x = pure (f x)~

    - ~u <*> pure y = pure ($ y) <*> u~

*** DONE Conclusion (Title Add by Jian)
    CLOSED: [2018-09-01 Sat 17:25]
    - /Applicative functors/ aren't just interesting, they're also useful -- they
      allow us to combine different computations, such as
      + I/O computations
      + non-deterministic computations
      + computations that might have failed, etc.

    - By using the /applicative style/. Just by using ~<$>~ and ~<*>~ we can use
      + normal functions to uniformly operate on *any number* of /applicative
        functors/

      + take advantage of the semantics of each one. =???= =TODO=

** TODO The ~newtype~ keyword
   - We learned how to use ~data~ to make our own /algebraic data types/.
     We learned how to use ~type~ to make /types synonyms/.

   - We'll learn to use ~newtype~ to create new types out of _EXISTING_ /data types/,
     and why we'd want to do that in the first place -- why NOT keep using ~data~???

*** Using ~newtype~ to make type class instances

*** On ~newtype~ laziness

*** ~type~ vs. ~newtype~ vs. ~data~
    - ~type~ makes /type synonyms/.
      + /Type synonyms/ is chosen with better names for certain specific use.

      + The /Type synonyms/ of the same type are interchangeable.
        =From Jian=
        *NOT like* the design of _Go_'s ~type~, which is introduce to create
        _type aliases (type synonyms)_, but it's more like Haskell's ~newtype~
        like type with implicit type constructors -- you don't need to write it
        out, the compiler knows. _No implicit cast_ and _no interchangeablility_


** TODO Monoids
* A Fistful of Monads
** Getting our feet wet with Maybe
** The Monad type class
** Walk the line
** do notation
** The list monad
** Monad laws
* For a Few Monads More
** Writer? I hardly know her!
** Reader? Ugh, not this joke again.
** Tasteful stateful computations
** Error error on the wall
** Some useful monadic functions
** Making monads
* TODO Zippers
  - _While_ Haskell's *purity* comes with a whole bunch of benefits,
    it makes us tackle some problems _DIFFERENTLY_ than we would in /impure
    languages/.

    Because of /referential transparency/, one value is as good as another in
    Haskell if it represents the same thing.

  - So if we have a tree full of fives (high-fives, maybe?) and we want to change
    one of them into a six, we have to have some way of knowing exactly which
    five in our tree we want to change. *We have to know where it is in our
    tree.*

    + In impure languages, we could just note where in our memory the five is
      located and change that.

    + In Haskell,
      * _CANNOT_
        - one five is as good as another, so we *cannot discriminate* based on
          where in our memory they are.

        - We also *cannot really change anything*;
          when we say that we change a tree, we actually mean that we take a
          tree and return a new one that's similar to the original tree, but
          slightly different.

      * _CAN_
        - Remember a path from the root of the tree to the element that we want
          to change.

          + We could say, take this tree, go left, go right and then left again
            and change the element that's there. While this works, it can be
            *inefficient*:
              If we want to later change an element that's near the element that
            we previously changed, we have to walk all the way from the root of
            the tree to our element _again_!

  - In this chapter, we'll see
    how we can take some data structure and focus on a part of it in a way that
    + makes changing its elements easy
      and
    + walking around it efficient. Nice!

** DONE Taking a walk
   CLOSED: [2018-08-30 Thu 21:48]
   #+BEGIN_SRC haskell
     data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)

     freeTree :: Tree Char
     freeTree =
         Node 'P'
             (Node 'O'
                 (Node 'L'
                     (Node 'N' Empty Empty)
                     (Node 'T' Empty Empty)
                 )
                 (Node 'Y'
                     (Node 'S' Empty Empty)
                     (Node 'A' Empty Empty)
                 )
             )
             (Node 'L'
                 (Node 'W'
                     (Node 'C' Empty Empty)
                     (Node 'R' Empty Empty)
                 )
                 (Node 'A'
                     (Node 'A' Empty Empty)
                     (Node 'C' Empty Empty)
                 )
             )

     data Direction = L | R deriving (Show)
     type Directions = [Direction]

     -- Return the a new tree whoes only 'W' is replaced with 'P'
     changeToP :: Directions-> Tree Char -> Tree Char
     changeToP (L:ds) (Node x l r) = Node x (changeToP ds l) r
     changeToP (R:ds) (Node x l r) = Node x l (changeToP ds r)
     changeToP [] (Node _ l r) = Node 'P' l r

     -- Show the element at the end of a list of `Direction`'s
     elemAt :: Directions -> Tree a -> a
     elemAt (L:ds) (Node _ l _) = elemAt ds l
     elemAt (R:ds) (Node _ _ r) = elemAt ds r
     elemAt [] (Node x _ _) = x


     -- Try it!
     -- ghci>
     newTree = changeToP [R, L] freeTree
     -- ghci>
     elemAt [R, L] newTree -- 'P'
   #+END_SRC

** DONE A trail of breadcrumbs
   CLOSED: [2018-08-30 Thu 21:47]
   #+BEGIN_SRC haskell
     type Breadcrumbs = [Direction]

     goLeft :: (Tree a, Breadcrumbs) -> (Tree a, Breadcrumbs)
     goLeft (Node _ l _, bs) = (l, L:bs)

     goLeft :: (Tree a, Breadcrumbs) -> (Tree a, Breadcrumbs)
     goLeft (Node _ _ r, bs) = (r, R:bs)

     -- Try it!
     goLeft (goRight (freeTree, []))
     -- (Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])
   #+END_SRC

   - Let's try a better way -- define a pipeline like grammer:
     #+BEGIN_SRC haskell
       x -: f = f x

       (freeTree, []) -: goRight -: goLeft
       -- (Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])
     #+END_SRC

*** Going back up
    Currently, we don't have enough information to go back up.

    - In general, a single breadcrumb should contain all the data needed to re-
      construct the parent node.

      + So 
        * it should have the information from all the paths that we didn't take
          and
        * it should also know the direction that we did take,
          _BUT_ it *must not* contain the sub-tree that we're currently focusing on.
            That's because we already have that sub-tree in the first component of
          the tuple, so if we also had it in the breadcrumbs, we'd have duplicate
          information -- =From Jian= may be trapped in repeating some operation,
          and cannot stop.

      + Then, we need

        1. Instead of ~Direction~, we'll make a new data type:
           #+BEGIN_SRC haskell
             data Crumb a =
                 LeftCrumb a (Tree a)
               | RightCrumb a (Tree a)
               deriving (Show)

             type Breadcrumbs a = [Crumb a]
           #+END_SRC

        2. Modify ~goLeft~ and ~goRight~ to save enough information:

           *Notice*:
           Assume that the current tree that's under focus is NOT
           ~Empty~, which doesn't have any subtrees.

           #+BEGIN_SRC haskell
             goLeft :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)
             goLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)

             goRight :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)
             goRight (Node x l r, bs) = (r, RightCrumb x l:bs)
           #+END_SRC

        3. Let's define ~goUp~:
           #+BEGIN_SRC haskell
             goUp :: (Tree a, Brreadcrumbs a) -> (Tree a, Breadcrumbs a)
             goUp (t, LeftCrumb x r:bs) -> (Node x t r, bs)
             goUp (t, LeftCrumb x l:bs) -> (Node x l t, bs)
           #+END_SRC
           * Note that this function causes an error if we're already at the top
             of a tree and we want to move up.

             =TODO= =Solution=
             Later on, we'll use the ~Maybe~ /monad/ to represent possible
             failure when moving focus.

        4. ~type Zipper a = (Tree a, Breadcrumbs a)~
           With a pair of ~Tree a~ and ~Breadcrumbs a~,
           * we have *ALL the information* to *rebuild* the whole tree
             and
           * we also have a _focus_ on a sub-tree.

           This scheme also enables us to *EASILY* _move up, left and right_.

    - Zipper :: A pair that contains
      + a focused part of a data structure
        and
      + its surroundings

      because moving our focus up and down the data structure resembles the
      operation of a zipper on a regular pair of pants. So it's cool to make a
      type synonym ~Zipper~.

*** Manipulating trees under focus
    - Let's make a function that _modifies_ the element in the /root/ of the
      sub-tree that the /zipper/ is focusing on: 
      #+BEGIN_SRC haskell
        modify :: (a -> a) -> Zipper a -> Zipper a
        modify f (Node x l r, bs) = (Node (f x) l r, bs)
        modify f (Empty, bs) = (Empty, bs)
      #+END_SRC

    - Examples:
      #+BEGIN_SRC haskell
        newFocus = (freeTree,[]) -: goLeft -: goRight -: modify (\_ -> 'P')
        newFocus2 = newFocus -: goUp -: modify (\_ -> 'X')
      #+END_SRC

    - Take a /tree/ and a /zipper/.
      Return a NEW /zipper/ with a new focus on the given tree.
      #+BEGIN_SRC haskell
        attach :: Tree a -> Zipper a -> Zipper a
        attach t (_, bs) = (t, bs)
      #+END_SRC

      + Replace the leftmost of our ~freeTree~:
        #+BEGIN_SRC haskell
          -- In our `freeTree`, this is a empty node.
          farLeft = (freeTree, []) -: goLeft -: goLeft -: goLeft -: goLeft
          newFocus = farLeft -: attach (Node 'Z' Empty Empty)
        #+END_SRC

        After this step, if we go up and re-construct a tree, we will get a
        ~freeTree~-like /tree/, and the only difference is a new leftmost /leaf
        node/ with ~'Z'~ value.

*** I'm going straight to top, oh yeah, up where the air is fresh and clean!
    #+BEGIN_SRC haskell
      topMost :: Zipper a -> Zipper a
      topMost (t, []) = (t, [])
      topMost z = topMost (goUp z)
    #+END_SRC

** DONE Focusing on lists
   CLOSED: [2018-08-31 Fri 00:56]
   /Zippers/ can be used with pretty much any data structure -- it is a category
   of data structure or a way to construct data structures, NOT one data structure.

   - It's no surprise that they can be used to focus on sub-lists of lists.
     List is a single branch tree!

   - Code:
     #+BEGIN_SRC haskell
       data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)
       type ListZipper a = ([a], [a])  -- (focus, crumbs)

       goForward :: ListZipper a -> ListZipper a
       goForward (x:xs, bs) = (xs, x:bs)

       goBack :: ListZipper a -> ListZipper a
       goBack (xs, b:bs) = (b:xs, bs)

       -- Try it!
       xs = [1, 2, 3, 4]
       goForward(xs, [])          -- ([2, 3, 4], [1])
       goForward([2, 3, 4], [1])  -- ([3, 4], [2, 1])
       goForward([3, 4], [2, 1])  -- ([4], [3, 2, 1])
       goBack([4], [3, 2, 1])     -- ([3, 4], [2, 1])
     #+END_SRC

   - This also makes it easier to see why we call this a /zipper/,
     because this really looks like the slider of a zipper moving up and down.

** TODO A very simple file system
   Now that we know how /zippers/ work, let's use /trees/ to represent a _very
   simple file system_ and then make a /zipper/ for that _file system_, which
   will allow us to *move between folders*, just like we usually do when jumping
   around our file system.

   - xxx
     #+BEGIN_SRC haskell
       type Name = String
       type Data = String
       data FSItem = File Name Data | Folder Name [FSItem] deriving (Show)
     #+END_SRC

   - A example folder with some files and sub-folders:
     #+BEGIN_SRC haskell
       -- The author says: "That's actually what my disk contains right now."
       myDisk :: FSItem
       myDisk =
           Folder "root"
               [ File "goat_yelling_like_man.wmv" "baaaaaa"
               , File "pope_time.avi" "god bless"
               , Folder "pics"
                   [ File "ape_throwing_up.jpg" "bleargh"
                   , File "watermelon_smash.gif" "smash!!"
                   , File "skull_man(scary).bmp" "Yikes!"
                   ]
               , File "dijon_poupon.doc" "best mustard"
               , Folder "programs"
                   [ File "fartwizard.exe" "10gotofart"
                   , File "owl_bandit.dmg" "mov eax, h00t"
                   , File "not_a_virus.exe" "really not a virus"
                   , Folder "source code"
                       [ File "best_hs_prog.hs" "main = print (fix error)"
                       , File "random.hs" "main = print 4"
                       ]
                   ]
               ]
     #+END_SRC

*** TODO A zipper for our file system
    #+BEGIN_SRC haskell
      data FSCrumb = FSCrumb Name [FSItem] [FSItem] deriving (Show)
      type FSZipper = (FSItem, [FSCrumb])
    #+END_SRC

*** TODO Manipulating our file system
    
** DONE Watch your step
   CLOSED: [2018-08-30 Thu 21:47]
   - Till now we didn't consider some situations like (Use the /tree zipper/ as
     a example):
     + Go left or right when the node is an ~Empty~.
     + Go up when you have already reach the /root/ -- no crumb can be found.

     We mentioned that we will deal with them at the last.

   - For the code we have now, if we meet the situations I mentioned above, there
     will be /runtime errors/ -- failures.

     We need to find a way to deal with the failures. This remind us one thing
     -- the /monads/! More specifically, the ~Maybe~ /monad/, which adds a
     context of possible failure to normal values.

   - Use the ~Maybe~ /monnad/ to add a context of possible failure to our movements:
     #+BEGIN_SRC haskell
       goLeft :: Zipper a -> Maybe (Zipper a)
       goLeft (Node x l r, bs) = Just (l, LeftCrumb x r:bs)
       goLeft (Empty, _) = Nothing

       goRight :: Zipper a -> Maybe (Zipper a)
       goRight (Node x l r, bs) = Just (r, RightCrumb x l:bs)
       goRight (Empty, _) = Nothing

       goUp :: Zipper a -> Maybe (Zipper a)
       goUp (t, LeftCrumb x r:bs) = Just (Node x t r, bs)
       goUp (t, RightCrumb x l:bs) = Just (Node x l t, bs)
       goUp (_, []) = Nothing
     #+END_SRC

   - Use the modified /monadic functions/ above, we *cannot* use the ~-:~ to
     pipeline our operations any more!

     However, since there are /monads/, we can use ~>>=~ to replace all the
     ~-:~, and make everythings works well again.

     + Example:
       #+BEGIN_SRC haskell
         coolTree = Node 1 Empty (Node 3 Empty Empty)
         return (coolTree,[]) >>= goRight
         -- Just (Node 3 Empty Empty,[RightCrumb 1 Empty])

         return (coolTree,[]) >>= goRight >>= goRight
         -- Just (Empty,[RightCrumb 3 Empty,RightCrumb 1 Empty])

         return (coolTree,[]) >>= goRight >>= goRight >>= goRight
         -- Nothing
       #+END_SRC

* Tips
