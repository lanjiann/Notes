#+TITLE: Learn You a Haskell for Great Good!
#+AUTHOR: Miran LipovaÄa
#+YEAR: 2011
#+STARTUP: overview
#+STARTUP: entitiespretty


* Table of Contents                                      :TOC_4_org:noexport:
- [[Introduction][Introduction]]
  - [[About this tutorial][About this tutorial]]
  - [[So what's Haskell?][So what's Haskell?]]
  - [[What you need to dive in][What you need to dive in]]
- [[Starting Out][Starting Out]]
  - [[Ready, set, go!][Ready, set, go!]]
  - [[Baby's first functions][Baby's first functions]]
  - [[An intro to lists][An intro to lists]]
  - [[Texas ranges][Texas ranges]]
  - [[I'm a list comprehension][I'm a list comprehension]]
  - [[Tuples][Tuples]]
- [[Types and Typeclasses][Types and Typeclasses]]
  - [[Believe the type][Believe the type]]
  - [[Type variables][Type variables]]
  - [[Typeclasses 101][Typeclasses 101]]
- [[Syntax in Functions][Syntax in Functions]]
  - [[Pattern matching][Pattern matching]]
  - [[Guards, guards!][Guards, guards!]]
  - [[Where!?][Where!?]]
  - [[Let it be][Let it be]]
  - [[Case expressions][Case expressions]]
- [[Recursion][Recursion]]
  - [[Hello recursion!][Hello recursion!]]
  - [[Maximum awesome][Maximum awesome]]
  - [[A few more recursive functions][A few more recursive functions]]
  - [[Quick, sort!][Quick, sort!]]
  - [[Thinking recursively][Thinking recursively]]
- [[Higher Order Functions][Higher Order Functions]]
  - [[Curried functions][Curried functions]]
  - [[Some higher-orderism is in order][Some higher-orderism is in order]]
  - [[Maps and filters][Maps and filters]]
  - [[Lambdas][Lambdas]]
  - [[Only folds and horses][Only folds and horses]]
  - [[Function application with ~$~][Function application with ~$~]]
  - [[Function composition][Function composition]]
- [[Modules][Modules]]
  - [[Loading modules][Loading modules]]
  - [[~Data.List~][~Data.List~]]
  - [[~Data.Char~][~Data.Char~]]
  - [[~Data.Map~][~Data.Map~]]
  - [[~Data.Set~][~Data.Set~]]
  - [[Making our own modules][Making our own modules]]
- [[Making Our Own Types and Typeclasses][Making Our Own Types and Typeclasses]]
  - [[Algebraic data types intro][Algebraic data types intro]]
  - [[Record syntax][Record syntax]]
  - [[Type parameters][Type parameters]]
  - [[Derived instances][Derived instances]]
  - [[Type synonyms][Type synonyms]]
  - [[Recursive data structures][Recursive data structures]]
  - [[Typeclasses 102][Typeclasses 102]]
  - [[A yes-no typeclass][A yes-no typeclass]]
  - [[The Functor typeclass][The Functor typeclass]]
  - [[Kinds and some type-foo][Kinds and some type-foo]]
- [[Input and Output][Input and Output]]
  - [[Hello, world!][Hello, world!]]
  - [[Files and streams][Files and streams]]
  - [[Command line arguments][Command line arguments]]
  - [[Randomness][Randomness]]
  - [[Bytestrings][Bytestrings]]
  - [[Exceptions][Exceptions]]
- [[Functionally Solving Problems][Functionally Solving Problems]]
  - [[Reverse Polish notation calculator][Reverse Polish notation calculator]]
  - [[Heathrow to London][Heathrow to London]]
- [[Functors, Applicative Functors and Monoids][Functors, Applicative Functors and Monoids]]
  - [[Functors redux][Functors redux]]
  - [[Applicative functors][Applicative functors]]
    - [[~Maybe~ Applicative Functors (Title Add by Jian)][~Maybe~ Applicative Functors (Title Add by Jian)]]
    - [[~[]~ Applicative Functors (Title Add by Jian)][~[]~ Applicative Functors (Title Add by Jian)]]
    - [[~IO~ Applicative Functors (Title Add by Jian)][~IO~ Applicative Functors (Title Add by Jian)]]
    - [[~(->) r~ Applicative Functors (Title Add by Jian)][~(->) r~ Applicative Functors (Title Add by Jian)]]
    - [[~ZipList~ Applicative Functors (Title Add by Jian)][~ZipList~ Applicative Functors (Title Add by Jian)]]
    - [[The ~liftA2~ Funciton (Title Add by Jian)][The ~liftA2~ Funciton (Title Add by Jian)]]
    - [[The ~sequenceA~ Funciton (Title Add by Jian)][The ~sequenceA~ Funciton (Title Add by Jian)]]
    - [[Applicative Functor Laws (Title Add by Jian) -- =Try to Verify them in examples=][Applicative Functor Laws (Title Add by Jian) -- =Try to Verify them in examples=]]
    - [[Conclusion (Title Add by Jian)][Conclusion (Title Add by Jian)]]
  - [[The ~newtype~ keyword][The ~newtype~ keyword]]
    - [[Using ~newtype~ to make type class instances][Using ~newtype~ to make type class instances]]
    - [[On ~newtype~ laziness][On ~newtype~ laziness]]
    - [[~type~ vs. ~newtype~ vs. ~data~][~type~ vs. ~newtype~ vs. ~data~]]
  - [[Monoids][Monoids]]
- [[A Fistful of Monads][A Fistful of Monads]]
  - [[Getting our feet wet with ~Maybe~][Getting our feet wet with ~Maybe~]]
  - [[The ~Monad~ type class][The ~Monad~ type class]]
  - [[Walk the line][Walk the line]]
  - [[~do~ notation][~do~ notation]]
  - [[The list monad][The list monad]]
    - [[A knight's quest][A knight's quest]]
  - [[Monad laws][Monad laws]]
    - [[Left identity][Left identity]]
    - [[Right identity][Right identity]]
    - [[Associativity][Associativity]]
- [[For a Few Monads More][For a Few Monads More]]
  - [[Writer? I hardly know her!][Writer? I hardly know her!]]
    - [[Monoids to the rescue][Monoids to the rescue]]
    - [[The Writer type][The Writer type]]
    - [[Using do notation with Writer][Using do notation with Writer]]
    - [[Adding logging to programs][Adding logging to programs]]
    - [[Inefficient list construction][Inefficient list construction]]
    - [[Difference lists][Difference lists]]
    - [[Comparing Performance][Comparing Performance]]
  - [[Reader? Ugh, not this joke again.][Reader? Ugh, not this joke again.]]
  - [[Tasteful stateful computations][Tasteful stateful computations]]
    - [[Stacks and stones][Stacks and stones]]
    - [[The State monad][The State monad]]
    - [[Randomness and the state monad][Randomness and the state monad]]
  - [[Error error on the wall][Error error on the wall]]
  - [[Some useful monadic functions][Some useful monadic functions]]
    - [[~liftM~ and friends][~liftM~ and friends]]
    - [[The join function][The join function]]
    - [[~filterM~][~filterM~]]
    - [[~foldM~][~foldM~]]
    - [[Making a safe RPN calculator][Making a safe RPN calculator]]
    - [[Composing monadic functions][Composing monadic functions]]
  - [[Making monads][Making monads]]
- [[Zippers][Zippers]]
  - [[Taking a walk][Taking a walk]]
  - [[A trail of breadcrumbs][A trail of breadcrumbs]]
    - [[Going back up][Going back up]]
    - [[Manipulating trees under focus][Manipulating trees under focus]]
    - [[I'm going straight to top, oh yeah, up where the air is fresh and clean!][I'm going straight to top, oh yeah, up where the air is fresh and clean!]]
  - [[Focusing on lists][Focusing on lists]]
  - [[A very simple file system][A very simple file system]]
    - [[A zipper for our file system][A zipper for our file system]]
    - [[Manipulating our file system][Manipulating our file system]]
  - [[Watch your step][Watch your step]]
- [[Tips][Tips]]

* Introduction
** About this tutorial
** So what's Haskell?
** What you need to dive in

* TODO Starting Out
** TODO Ready, set, go!
** TODO Baby's first functions
** TODO An intro to lists
   - ~head~
   - ~tail~
   - ~last~
   - ~init~
   - ~length~
   - ~null~
   - ~reverse~
   - ~take~
   - ~drop~
   - ~maximum~
   - ~minimum~
   - ~sum~
   - ~product~
   - ~elem~

** TODO Texas ranges
   - ~cycle~
   - ~repeat~
   - ~replicate~

** TODO I'm a list comprehension
** TODO Tuples
   - ~fst~
   - ~snd~
   - ~zip~

* TODO Types and Typeclasses
** Believe the type
  - ~Int~
  - ~Integer~
  - ~Float~
  - ~Double~
  - ~Bool~
  - ~Char~

** Type variables
** Typeclasses 101
   - ~Eq~
   - ~Ord~
   - ~Show~
   - ~Read~
   - ~Enum~
   - ~Bounded~
   - ~Num~
   - ~Integral~
   - ~Floating~

* TODO Syntax in Functions
** Pattern matching
** Guards, guards!
** Where!?
** Let it be
** Case expressions

* TODO Recursion
** TODO Hello recursion!
** TODO Maximum awesome
** TODO A few more recursive functions
** TODO Quick, sort!
** TODO Thinking recursively

* TODO Higher Order Functions
** TODO Curried functions
** TODO Some higher-orderism is in order
** TODO Maps and filters
   - ~map~
   - ~filter~
   - ~takeWhile~

** TODO Lambdas
** TODO Only folds and horses
   - ~foldl~
   - ~foldr~
   - ~foldl1~
   - ~foldr1~
   - ~scanl~
   - ~scanr~

** TODO Function application with ~$~
** TODO Function composition

* TODO Modules
** TODO Loading modules
** TODO ~Data.List~
   - ~intersperse~
   - ~transpose~
   - ~foldl'~
   - ~foldl1'~
   - ~concat~
   - ~concatMap~
   - ~and~
   - ~or~
   - ~any~
   - ~all~
   - ~interate~
   - ~splitAt~
   - ~takeWhile~
   - ~dropWhile~
   - ~span~
   - ~break~
   - ~sort~
   - ~group~
   - ~inits~
   - ~tails~
   - ~isInfixOf~
   - ~isPrefixOf~
   - ~isSuffixOf~
   - ~elem~
   - ~notElem~
   - ~partition~
   - ~find~
   - ~elemIndex~
   - ~elemIndices~
   - ~findIndex~
   - ~findIndices~
   - ~zip3~
   - ~zip4~
   - ~zipWith3~
   - ~zipWith4~
   - ~lines~
   - ~unlines~
   - ~words~
   - ~unwords~
   - ~nub~
   - ~delete~
   - ~\\~
   - ~union~
   - ~intersect~
   - ~insert~
   - ~genericLength~
   - ~genericTake~
   - ~genericDrop~
   - ~genericSplitAt~
   - ~genericIndex~
   - ~genericReplicate~
   - ~nubBy~
   - ~deleteBy~
   - ~unionBy~
   - ~intersectBy~
   - ~groupBy~
   - ~on~
   - ~sortBy~
   - ~insertBy~
   - ~maximumBy~
   - ~minimumBy~

** TODO ~Data.Char~
   - ~isControl~ checks whether a character is a control character.
   - ~isSpace~ checks whether a character is a white-space characters. That includes spaces, tab characters, newlines, etc.
   - ~isLower~ checks whether a character is lower-cased.
   - ~isUpper~ checks whether a character is upper-cased.
   - ~isAlpha~ checks whether a character is a letter.
   - ~isAlphaNum~ checks whether a character is a letter or a number.
   - ~isPrint~ checks whether a character is printable. Control characters, for instance, are not printable.
   - ~isDigit~ checks whether a character is a digit.
   - ~isOctDigit~ checks whether a character is an octal digit.
   - ~isHexDigit~ checks whether a character is a hex digit.
   - ~isLetter~ checks whether a character is a letter.
   - ~isMark~ checks for Unicode mark characters. Those are characters that combine with preceding letters to form latters with accents. Use this if you are French.
   - ~isNumber~ checks whether a character is numeric.
   - ~isPunctuation~ checks whether a character is punctuation.
   - ~isSymbol~ checks whether a character is a fancy mathematical or currency symbol.
   - ~isSeparator~ checks for Unicode spaces and separators.
   - ~isAscii~ checks whether a character falls into the first 128 characters of the Unicode character set.
   - ~isLatin1~ checks whether a character falls into the first 256 characters of Unicode.
   - ~isAsciiUpper~ checks whether a character is ASCII and upper-case.
   - ~isAsciiLower~ checks whether a character is ASCII and lower-case.
   - ~toUpper~ converts a character to upper-case. Spaces, numbers, and the like remain unchanged.
   - ~toLower~ converts a character to lower-case.
   - ~toTitle~ converts a character to title-case. For most characters, title-case is the same as upper-case.
   - ~digitToInt~ converts a character to an Int. To succeed, the character must be in the ranges '0'..'9', 'a'..'f' or 'A'..'F'.
   - ~intToDigit~ is the inverse function of digitToInt. It takes an Int in the range of 0..15 and converts it to a lower-case character.
   - The ~ord~ and ~chr~ functions convert characters to their corresponding numbers and vice versa:

** ~Data.Map~
** ~Data.Set~
** Making our own modules

* TODO Making Our Own Types and Typeclasses
** TODO Algebraic data types intro
** TODO Record syntax
** TODO Type parameters
** TODO Derived instances
** TODO Type synonyms
** TODO Recursive data structures
** TODO Typeclasses 102
** TODO A yes-no typeclass
** TODO The Functor typeclass
** TODO Kinds and some type-foo

* Input and Output
** Hello, world!
** Files and streams
** Command line arguments
** Randomness
** Bytestrings
** Exceptions

* TODO Functionally Solving Problems
** TODO Reverse Polish notation calculator
** TODO Heathrow to London

* TODO Functors, Applicative Functors and Monoids
  - =TODO=
    We'll talk about a slightly stronger and more useful versions of /functors/
    called /applicative functors/.

** DONE Functors redux
   CLOSED: [2018-08-31 Fri 17:10]
   - Refresh:
     The /typeclass/ ~Functor~ has ONLY ONE /typeclass method/:
     ~fmap :: (a -> b) -> f a -> f b~

   - *A word of advice*:
     We often use "box analogy" to describe /functors/, and later we will also
     use it to describe /applicative functors/ and /monads/.

     Do NOT take the phrase"box analogy" to literally.
     *The /computational context/ is a better term!*

   - We have seen some ~Functor~'s instances (by theirselves they are /type
     constructors/), like ~[]~, ~Maybe~, ~Either a~ (with one of the two type
     parameters), and /Tree/.

   - In this section, we'll take a look at two more /instances of functor/, namely
     ~IO~ and ~(->) r~.

   - ~IO~ =TODO=

   - ~(->) r~
     How are functions functors? Well, let's take a look at the implementation,
     which lies in ~Control.Monad.Instances~.
     #+BEGIN_SRC haskell
       instance Functor ((->) r) where
         fmap f g = (\x -> f (g x))
     #+END_SRC

     + Let's check the type of ~fmap~, in this case, in details.
       1. ~fmap :: (a -> b) -> f a -> f b~

       2. ~fmap :: (a -> b) -> ((->) r a) -> ((->) r b)~

       3. ~fmap :: (a -> b) -> (r -> a) -> (r -> b)~

       Yes! You fmap a function to a function, and get a new function.
       You may notice this is a /composition/!
       #+BEGIN_SRC haskell
         instance Functor ((->) r) where
           fmap = (.)
       #+END_SRC

   - =From Jian=
     + Q :: Why NOT implement ~fmap f g = \x -> g (f x)~ in the /Functor instance/
            of ~((->) r)~?
       * =From Jian=
         This is a naive guess reasoning by considering /functor/ with the
         _box metaphor_.

     + A :: Because this implementation violate the second *Functor LAWS* below!
            It satisfies that ~fmap (f . g) = fmap g . fmap f~.
       * There is NO guarantee that the types are compatible.

       * This is NOT the REAL law we require: ~fmap (f . g) = fmap f . fmap g~.

   - From another point of view, we can re-group the types in the signature of
     ~fmap~:
     #+BEGIN_SRC haskell
       fmap :: (a -> b) -> (f a -> f b)
     #+END_SRC
     This re-group is reasonable and nothing real changed.

     + We can think of ~fmap~
       * _NOT_ as a function that takes one function and a /functor/ and returns a
         /functor/,

       * _BUT_ as a function that
         - takes a function
           and
         - returns a new function

     + lifting :: We call the operation from ~a -> b~ to ~f a -> f b~ as _lifting_.

   - The *Functor LAWS* are *NOT enforced* by Haskell automatically,
     and you have to test them out yourself.
     + ~fmap id = id~

     + ~fmap (f . g) = fmap f . fmap g~

       Or write in another way:
       ~fmap (f . g) F = fmap f . (fmap g F)~

   - Counter example (even if you make a ~Functor~ instance, it can be non-functor
     if it does NOT obey those two laws):
     #+BEGIN_SRC haskell
       -- NOT functor --
       data CMaybe a = CNothing | CJust Int a deriving (Show)

       -- NO guarantee!!!
       instance Functor CMaybe where
           fmap f CNothing = CNothing
           fmap f (CJust counter x) = CJust (counter+1) (f x)

       -- Violate the first law!!!
       fmap id (CJust 0 "haha")  -- CJust 1 "haha"
       id (CJust 0 "haha")       -- CJust 0 "haha"
     #+END_SRC

** TODO Applicative functors
   /Applicative functors/ are beefed up /functors/.

   This chapter will will talk about the /applicative functors/ of ~Maybe~, ~[]~,
   ~IO~, and ~(->) r~.

   - You can find the ~Applicative~ typeclass in the ~Control.Applicative~ module.

   - Q :: WHY do we need ~Applicative~

   - A :: Consider some use cases:
     1. If we ~fmap~ a function, which takes a value and generate another function
        (~g~), over a /functor/, we get a functor of function ~g~. 

        For example,
        #+BEGIN_SRC haskell
          ghci> :t fmap (++) (Just "hey")
          fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])
  
          ghci> :t fmap compare (Just 'a')
          fmap compare (Just 'a') :: Maybe (Char -> Ordering)
  
          ghci> :t fmap compare "A LIST OF CHARS"
          fmap compare "A LIST OF CHARS" :: [Char -> Ordering]
  
          ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]
          fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]
        #+END_SRC
  
        This is reasonable, and interesting.
        *However, sometimes we need more!*

     2. Can we /map/ the function in a /functor/ to the value in another /functor/?

        At least, we *cannot ONLY use* the ~Functor~'s ~fmap~ to write a concise
        solution!

        *We need ~Applicative~!*

   - ~Control.Applicative~ Definition:
     #+BEGIN_SRC haskell
       class (Functor f) => Applicative f where
           pure :: a -> f a
           (<*>) :: f (a -> b) -> f a -> f b
     #+END_SRC

     + Q :: How to think ~pure~?

     + A :: ~pure~ would be to say that it takes a value and puts it in some sort
            of *default (or pure) context* -- a *minimal context* that still yields
            that value.

     + ~<*>~ is like a beefed up ~fmap~:
       #+BEGIN_SRC haskell
         (<*>) :: f (a -> b) -> f a -> f b

         fmap :: (a -> b) -> f a -> f b
       #+END_SRC

*** DONE ~Maybe~ Applicative Functors (Title Add by Jian)
    CLOSED: [2018-09-01 Sat 01:00]
    - Definition:
      #+BEGIN_SRC haskell
        instance Applicative Maybe where
            pure = Just
            Nothing <*> _ = Nothing
            (Just f) <*> something = fmap f something
      #+END_SRC
      + Again, from the _class definition_ we see that the ~f~ that plays the role
        of the /applicative functor/ should take one *concrete type* as a parameter,

        so we write ~instance Applicative Maybe where~ _instead of_ writing
        ~instance Applicative (Maybe a) where~.

      + Example:
        #+BEGIN_SRC haskell
          Just (+3) <*> Just 9         -- Just 12
          pure (+3) <*> Just 10        -- Just 13
          pure (+3) <*> Just 9         -- Just 12
          Just (++"hahah") <*> Nothing -- Nothing
          Nothing <*> Just "woot"      -- Nothing
        #+END_SRC

    - ~Applicative~ provide a way to combine /functors/ DIRECTLY, which can't be
      done _concisely_ ONLY with the operations of /non-applicative functors/ --
      for example, you *can't get the result out from a /non-applicative functor/
      in any _GENERAL_ way*, even if the result is a /partially applied
      function/.

      =IMPORTANT=
      /Applicative functors/, on the other hand, allow you to operate on several
      functors with a single function. Check out this piece of code:
      #+BEGIN_SRC haskell
        pure (+) <*> Just 3 <*> Just 5     -- Just 8
        pure (+) <*> Just 3 <*> Nothing    -- Nothing
        pure (+) <*> Nothing <*> Just 5    -- Nothing
      #+END_SRC

    - *This is one of the /applicative/ laws*.
      ~pure f <*> x equals fmap f x~.

    - ~pure f <*> x <*> y <*> ...~

      is equivalent to

      ~fmap f x <*> y <*> ...~

      This is why ~Control.Applicative~ exports a function called ~<$>~, which is
      just ~fmap~ as an infix operator.
      #+BEGIN_SRC haskell
        (<$>) :: (Functor f) => (a -> b) -> f a -> f b
        f <$> x = fmap f x
      #+END_SRC

    - ~<$>~ is NOT ONLY for convenient!

      By using ~<$>~, the /applicative/ style really shines,
      because now if we want to apply a function ~f~ between _three_ /applicative
      functors/, we can write ~f <$> x <*> y <*> z~.

      If the parameters weren't /applicative functors/ but normal values, we'd write
      ~f x y z~

      + A concrete example:
        #+BEGIN_SRC haskell
          (++) <$> Just "johntra" <*> Just "Volta"   -- Just "johntravolta"
          (++) "johntra" "Volta"                     -- "johntravolta"
        #+END_SRC

*** DONE ~[]~ Applicative Functors (Title Add by Jian)
    CLOSED: [2018-09-01 Sat 01:00]
    - Definition:
      #+BEGIN_SRC haskell
        instance Applicative [] where
          pure x = [x]
          fs <*> xs = [f x | f <- fs, x <- xs]
      #+END_SRC

      + ~pure~ examples
        #+BEGIN_SRC haskell
          pure "Hey" :: [String]
          -- ["Hey"]

          pure "Hey" :: Maybe String
          -- Just "Hey" 
        #+END_SRC

      + ~<*>~ example (with /list applicative functors/):
        #+BEGIN_SRC haskell
          [(*0), (+100), (^2)] <*> [1, 2, 3]
          -- [0, 0, 0, 101, 102, 103, 1, 4, 9]

          [(+), (*)] <*> [1, 2] <*> [3, 4]
          -- [4, 5, 5, 6, 3, 4, 6, 8]
        #+END_SRC

    - Using the /applicative style/ _on lists_ is often a *good replacement* for
      /list comprehensions/.

      + /list comprehensions/
        #+BEGIN_SRC haskell
          [ x*y | x <- [2,5,10], y <- [8,10,11]]
          -- [16,20,22,40,50,55,80,100,110]
        #+END_SRC

      + /applicative style/
        #+BEGIN_SRC haskell
          (*) <$> [2, 5, 10] <*> [8, 10, 11]
          -- [16,20,22,40,50,55,80,100,110]
        #+END_SRC

    - An example, still replace /list comprehensions/ with /applicative style/ code.
      #+BEGIN_SRC haskell
        filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
        -- [55,80,100,110]
      #+END_SRC

*** DONE ~IO~ Applicative Functors (Title Add by Jian)
    CLOSED: [2018-09-01 Sat 01:05]
    - The ~IO~ is also an /applicative/:
      #+BEGIN_SRC haskell
        instance Applicative IO where
          pure = return
          a <*> b = do
            f <- a
            x <- b
            return (f x)
      #+END_SRC

    - If you ever find yourself
      1. binding some I/O actions to names and then

      2. calling some function on them and presenting that as the result by using
         ~return~,

      consider using the /applicative style/ because it's arguably *a bit more
      concise and terse*.

    - do-notation style:
      #+BEGIN_SRC haskell
        myAction :: IO String
        myAction = do
            a <- getLine
            b <- getLine
            return $ a ++ b
      #+END_SRC

    - applicative style:
      #+BEGIN_SRC haskell
        myAction :: IO String
        myAction = (++) <$> getLine <*> getLine
      #+END_SRC

*** TODO ~(->) r~ Applicative Functors (Title Add by Jian)
    - Definition:
      #+BEGIN_SRC haskell
        instance Applicative ((->) r) where
          pure x = (\_ -> x)
          f <*> g = \x -> f x (g x)
      #+END_SRC
      + ~pure 3 "blah~ is ~3~

      + ~(+) <$> (+3) <*> (*100) $ 5~

        =From Jian=
        If consider /functors/ as a box, the ~fmap~ implementation of the ~((->) r)~
        /functor/ is a little wierd! This is the reason why I am confused!!!

        * Intuitively, if I consider /functors/ as boxes, I may expect
          #+BEGIN_SRC haskell
            ------------------------------------
            -- NOT the one used by Haskell!!! --
            ------------------------------------
            instance Functor ((->) r) where
              fmap f g = (\x -> g (f x))
          #+END_SRC

        * The actual ~fmap~ of ~((->) r)~ is
          ~fmap f g = (\x -> f (g x))~

          Use this we can write down the evaluation process of
          ~(+) <$> (+3) <*> (*100) $ 5~:
          1. ~((+) . (+3)) <*> (*100) $ 5~
          2. ~(\x -> ((+) . (+3)) x (x * 100))) 5~
          3. ~((+) . (+3)) 5 500)~
          4. ~(\x y -> (3 + x) + y) 5 500~
          5. ~3 + 5 + 500~
          6. ~508~

*** TODO ~ZipList~ Applicative Functors (Title Add by Jian)
    For the /list applicative functors/, why do we define ~<*>~ that way above?

    - Q :: Can we define it like zip two list, and combine them with a given function.

    - A :: Yes you can!!!
           However, *one type can only instantiate once*.

           The solution is we define a new type called ~ZipList~, and it has only
           ONE field, which is a ~List~.

    - Definition:
      #+BEGIN_SRC haskell
        instance Applicative ZipList where
          pure x = ZipList (repeat x)
          ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)
      #+END_SRC

*** TODO The ~liftA2~ Funciton (Title Add by Jian)
    - xxx

*** TODO The ~sequenceA~ Funciton (Title Add by Jian)
    - xxx

*** TODO Applicative Functor Laws (Title Add by Jian) -- =Try to Verify them in examples=
    - ~pure f <*> x = fmap f x~

    - ~pure id <*> v = v~

    - ~pure (.) <*> u <*> v <*> w = u <*> (v <*> w)~

    - ~pure f <*> pure x = pure (f x)~

    - ~u <*> pure y = pure ($ y) <*> u~

*** DONE Conclusion (Title Add by Jian)
    CLOSED: [2018-09-01 Sat 17:25]
    - /Applicative functors/ aren't just interesting, they're also useful -- they
      allow us to combine different computations, such as
      + I/O computations
      + non-deterministic computations
      + computations that might have failed, etc.

    - By using the /applicative style/. Just by using ~<$>~ and ~<*>~ we can use
      + normal functions to uniformly operate on *any number* of /applicative
        functors/

      + take advantage of the semantics of each one. =???= =TODO=

** TODO The ~newtype~ keyword
   - We learned how to use ~data~ to make our own /algebraic data types/.
     We learned how to use ~type~ to make /types synonyms/.

   - We'll learn to use ~newtype~ to create _new types_ out of _EXISTING_ /data
     types/, and why we'd want to do that in the first place -- why NOT keep
     using ~data~ in all cases???

   - The form of ~newtype~ definition:
     Same as ~data~, _but only *ONE* /type constructor/ with *ONE* /field/ is
     permited._

     + It is faster than use ~data~ to do same definition:
       Haskell knows that you're just using it to wrap an existing type into a
       new type (hence the name), because you want it to be the _same internally_
       but have a _different type_.

       With that in mind, *Haskell can GET RID OF the wrapping and unwrapping
       once it resolves which value is of what type*.

   - You can derive instances for ~Eq~, ~Ord~, ~Enum~, ~Bounded~, ~Show~, and
     ~Read~ -- of course, the wrapped existing type should be in these
     /typeclass/, which is reasonable.

*** DONE Using ~newtype~ to make type class instances
    CLOSED: [2018-09-04 Tue 13:27]
    - Many times, we want to make our types instances of certain /type classes/,
      _BUT_ the /type parameters/ just don't match up for what we want to do. 

      Use ~Functor~ as an illustration:
      #+BEGIN_SRC haskell
        class Functor f where
          fmap :: (a -> b) -> f a -> f b
      #+END_SRC

      + One example that _does NOT_ have this problem.
        #+BEGIN_SRC haskell
          instance Functor Maybe where
            fmap :: (a -> b) -> Maybe a -> Maybe b
            fmap f Just(a) = Just(f a)
            fmap f Nothing = Nothing
        #+END_SRC

      + One example that _DOES_ have this problem.
        If we want the result of ~fmap (+3) (1,1)~ is ~(4, 1)~, since the
        /computational context/ includes the second value, not the first one, we
        *CANNOT* make a pair tuple as an instance of ~Functor~ directly.

        Now we use ~newtype~:
        #+BEGIN_SRC haskell
          newtype Pair b a = Pair { getPair :: (a, b) }

          instance Functor (Pair c) where
            fmap :: (a -> b) -> Pair c a -> Pair c b
            fmap f (Pair (x,y)) = Pair (f x, y)

          -- Use it
          getPair $ fmap (*100) (Pair (2, 3))                  -- (200, 3)
          getPair $ fmap reverse (Pair ("london calling", 3))  -- ("gnillac nodnol", 3)
        #+END_SRC

*** TODO On ~newtype~ laziness

*** TODO ~type~ vs. ~newtype~ vs. ~data~
    - ~type~ makes /type synonyms/.
      + /Type synonyms/ is chosen with better names for certain specific use.

      + The /Type synonyms/ of the same type are interchangeable.
        =From Jian=
        *NOT like* the design of _Go_'s ~type~, which is introduce to create
        _type aliases (type synonyms)_, but it's more like Haskell's ~newtype~
        like type with implicit type constructors -- you don't need to write it
        out, the compiler knows. _No implicit cast_ and _no interchangeablility_

        
** TODO Monoids
* TODO A Fistful of Monads
** TODO Getting our feet wet with ~Maybe~
** DONE The ~Monad~ type class
   CLOSED: [2018-09-04 Tue 17:04]
   - Definition:
     #+BEGIN_SRC haskell
       class Applicative m => Monad (m :: * -> *) where
         (>>=) :: m a -> (a -> m b) -> m b

         (>>) :: m a -> m b -> m b
         x >> y = x >>= \_ -> y

         return :: a -> m a

         fail :: String -> m a
         fail msg = error msg
     #+END_SRC
     + /Monad/ must be an /applicative functor/.

       However, /monad/ was introduced into Haskell before /applicative functor/.
       Before some version of GHC, the ~Applicative m~ bound above was not
       explicitly written down. I don't know from which version on (at least,
       since GHC 8.0), we have the definition above.

     + For now, we won't pay to much attention to ~>>~.

     + We never use ~fail~ explicitly in our code.
       Instead it's used by Haskell to enable failure in a special syntactic
       construct for /monads/ that we'll meet later. =TODO= =TODO= =TODO=

       For now, we won't pay to much attention to ~fail~.

   - ~Maybe~ Monad:
     #+BEGIN_SRC haskell
       instance Monad Maybe where
         (Just x) >>= k = kx
         Nothing  >>= _ = Nothing

         (>>) = (*>) -- from `Maybe`'s `Applicative` instance

         return         = Just
         fail _         = Nothing
     #+END_SRC

** DONE Walk the line
   CLOSED: [2018-09-04 Tue 19:49]
   - Question:
     Pierre walk on a line with a pole.

     1. Birds may land on the pole, left side or right side. If, at _any moment_,
        the difference of number of birds of the two sides is to big (> 4),
        Pierre cannot keep balance.

     2. Pierre can also walk on an banana peel, and lose balance.

     Let's first _concentrate on 1_, and ignore 2 at the beginning. Add code
     related to 2 later, which is simple.

   - Answer:
     1. Basic concepts:
        #+BEGIN_SRC haskell
          type Birds = Int
          type Pole = (Birds, Birds)
        #+END_SRC

     2. Basic actions:
        #+BEGIN_SRC haskell
           -- negative `n` means take off

          landLeft :: Birds -> Pole -> Pole
          landLeft n (left, right) = (left + n, right)

          langRight :: Birds -> Pole -> Pole
          langRight n (left, right) = (left, right + n)
        #+END_SRC

     3. Pipeline the operations, rather than use nested forms like:
        ~landLeft 2 (landRight 1 (landLeft 1 (0,0)))~

        #+BEGIN_SRC haskell
          x -: f = f x

          (0, 0) -: landLeft 1 -: landRight 1 -: landLeft 2
        #+END_SRC

     4. Step 3 is NOT completely right -- you cannot detect "non-balance situation"
        in the middle -- as I mentioned, Pierre would lose balance at any moment
        when the difference of number of birds is too big, NOT only at the end of
        a series of landings.
          We can introduce ~Maybe Pole~ type, and use ~Nothing~ to represent
        failure (balance lost).
        #+BEGIN_SRC haskell
          landLeft :: Birds -> Pole -> Maybe Pole
          landLeft n (left,right)
              | abs ((left + n) - right) < 4 = Just (left + n, right)
              | otherwise                    = Nothing

          landRight :: Birds -> Pole -> Maybe Pole
          landRight n (left,right)
              | abs (left - (right + n)) < 4 = Just (left, right + n)
              | otherwise                    = Nothing
        #+END_SRC

     5. Step 4 fix the bug, but the pipeline form with ~-:~ is no longer applicable!
        After each step, a ~landLeft~ or ~landRight~ generate a ~Maybe Pole~ value,
        but the next step, a ~landLeft~ or ~landRight~ requires ~Pole~ value as
        argument!
          If you notice that ~Maybe~ is an instance of ~Monad~, you may get the a
        conclusion that even though we cannot use ~-:~, we can use the ~>>=~ to
        pipeline the operations. This operation has the _right type_, it also
        maintains the the pipeline-like form.

        ~return (0, 0) >>= landRight 2 >>= landLeft 2 >>= landRight 2~

        If one step in the middle fails, the result will be ~Nothing~.

     6. Now less add banana peel:
        #+BEGIN_SRC haskell
          banana :: Pole -> Maybe Pole
          banana _ = Nothing

          return (0, 0) >>= landLeft 1 >>= banana >>= landRight 1  -- Nothing
        #+END_SRC

     7. You may notice that the type can fit into the ~(>>)~ operation (the after
        ~>>=~ part)! Then we can ignore banana, but still keep the banana in to
        this model with ~>>~:
        #+BEGIN_SRC haskell
          return (0, 0) >>= landLeft 1 >> Nothing >>= landRight
          --                           >>= banana
        #+END_SRC

   - If we worked with ~Maybe~ values without using the /monad/ concept and its
     operations, manually wrap and unwrap, we will have code like:
     #+BEGIN_SRC haskell
       -- routine = return (0, 0) >>= landLeft 1 >>= Nothing >>= landRight 1
       -- -- Nothing

       -- -- Equivalent operations without `Monad`:
       routine :: Maybe Pole  
       routine = case landLeft 1 (0,0) of  
           Nothing -> Nothing  
           Just pole1 -> case landRight 4 pole1 of   
               Nothing -> Nothing  
               Just pole2 -> case landLeft 2 pole2 of  
                   Nothing -> Nothing  
                   Just pole3 -> landLeft 1 pole3
     #+END_SRC

** DONE ~do~ notation
   CLOSED: [2018-09-04 Tue 21:00]
   Code like ~Just 3 >>= (\x -> Just (show x ++ "!"))~ is NOT complicated,
   but how about code like
   ~Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))~, which returns
   ~Just "3!"~?

   - Q :: Is their any other better way to re-write the second code example above
          to make it clearer?

   - A :: Yes! The ~do~-notation.
     1. You may notice the second code example is like
        ~let x = 3; y = "!" in show x ++ y~, which returns ~"3!"~

     2. To find a similar syntax like the ~let~ bind syntax in 1, let's first
        re-write the original code like
        #+BEGIN_SRC haskell
          foo :: Maybe String
            foo = Just 3   >>= (\x ->
                  Just "!" >>= (\y ->
                  Just (show x ++ y)))  -- Or `return (show x ++ y)`
        #+END_SRC

     3. The ~do~-notation syntax form:
        #+BEGIN_SRC haskell
          foo :: Maybe String
          foo = do
              x <- Just 3
              y <- Just "!"
              Just (show x ++ y)
        #+END_SRC

     4. An example of ~do~-notation with ~banana~
        #+BEGIN_SRC haskell
          routine :: Maybe Pole
          routine = do
              start <- return (0,0)
              first <- landLeft 2 start
              Nothing
              second <- landRight 2 first
              landLeft 1 second
        #+END_SRC

        In the ~do~-notation, a monadic value without /binding/, means ~>>~ --
        ignore this value. It's better than ~_ <- Nothing~, though they imply the
        same meaning.

   - This ~do~-notation form is not very useful for this example.
     The ~>>=~ pipeline form don't need to write down the intermediate values
     which will be consumed next, and it more succinct.

     Let's another example, which can show the usefulness of ~do~-notation:
     #+BEGIN_SRC haskell
       justH :: Maybe Char
       justH = do
         (x:xs) <- Just "hello"
         return x
     #+END_SRC

   - ~Maybe~ /monad/ does *re-write* the ~fail~ function.
     The _default_ ~fail~ function will *crash the whole program* if a binding
     fails.

     Since here ~Maybe~ use ~Nothing~ to represent failure, define ~fail _ = Nothing~
     is reasonable! For example,
     #+BEGIN_SRC haskell
       nothing :: Maybe Char
       nothing = do
         (x:xs) <- Just ""
         return x
     #+END_SRC
     ~nothing~ returns ~Nothing~.

** TODO The list monad
*** A knight's quest

** TODO Monad laws
*** DONE Left identity
    CLOSED: [2018-09-04 Tue 21:10]
    ~return x >>= f~ is the same damn thing as ~f x~

    - Remember, ~f~'s return value type must a monadic value.
      ~f~'s type must fit the requirement of ~>>=~.

    - We said that for ~IO~,
      using ~return~ makes an _I/O action_ that has *no side-effects* but just
      presents a value as its result.
        So it makes sense that this law holds for ~IO~ as well.

*** DONE Right identity
    CLOSED: [2018-09-04 Tue 21:14]
    ~m >>= return~ is no different than just ~m~

    - /The left identity law/ and /the right identity law/ are basically *laws*
      that describe *how ~return~ should behave*.
      + It's an important function for making normal values into monadic ones
        and
      + it wouldn't be good if the monadic value that it produced did a lot of
        other stuff.

*** TODO Associativity
    Doing ~(m >>= f) >>= g~ is just like doing ~m >>= (\x -> f x >>= g)~
    - If we define ~(<=<)~ as
      #+BEGIN_SRC haskell
        (<=<) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a - m c)
        f <=< g = (\x -> \g x >>= f)
      #+END_SRC

    - =TODO=
      NOTE

    - =TODO=
      NOTE

* TODO For a Few Monads More
  In this chapter, we're going to learn about a few _OTHER_ /monads/.

  We'll see how they can make our programs clearer by letting us treat all sorts
  of values as monadic ones.

  Exploring a few /monads/ more will also *solidify our intuition* for /monads/.

  - The monads that we'll be exploring are all part of the mtl package. 
    It comes with the Haskell Platform, so you probably already have it.

  - Use ~ghc-pkg list~ in the command line to check the installed Haskell packages.

** TODO Writer? I hardly know her!
*** Monoids to the rescue
*** The Writer type
*** Using do notation with Writer
*** Adding logging to programs
*** Inefficient list construction
*** Difference lists
*** Comparing Performance

** TODO Reader? Ugh, not this joke again.
** TODO Tasteful stateful computations
*** Stacks and stones
*** The State monad
*** Randomness and the state monad

** TODO Error error on the wall
** TODO Some useful monadic functions
*** ~liftM~ and friends
*** The join function
*** ~filterM~
*** ~foldM~
*** Making a safe RPN calculator
*** Composing monadic functions

** TODO Making monads

* TODO Zippers
  - _While_ Haskell's *purity* comes with a whole bunch of benefits,
    it makes us tackle some problems _DIFFERENTLY_ than we would in /impure
    languages/.

    Because of /referential transparency/, one value is as good as another in
    Haskell if it represents the same thing.

  - So if we have a tree full of fives (high-fives, maybe?) and we want to change
    one of them into a six, we have to have some way of knowing exactly which
    five in our tree we want to change. *We have to know where it is in our
    tree.*

    + In impure languages, we could just note where in our memory the five is
      located and change that.

    + In Haskell,
      * _CANNOT_
        - one five is as good as another, so we *cannot discriminate* based on
          where in our memory they are.

        - We also *cannot really change anything*;
          when we say that we change a tree, we actually mean that we take a
          tree and return a new one that's similar to the original tree, but
          slightly different.

      * _CAN_
        - Remember a path from the root of the tree to the element that we want
          to change.

          + We could say, take this tree, go left, go right and then left again
            and change the element that's there. While this works, it can be
            *inefficient*:
              If we want to later change an element that's near the element that
            we previously changed, we have to walk all the way from the root of
            the tree to our element _again_!

  - In this chapter, we'll see
    how we can take some data structure and focus on a part of it in a way that
    + makes changing its elements easy
      and
    + walking around it efficient. Nice!

** DONE Taking a walk
   CLOSED: [2018-08-30 Thu 21:48]
   #+BEGIN_SRC haskell
     data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)

     freeTree :: Tree Char
     freeTree =
         Node 'P'
             (Node 'O'
                 (Node 'L'
                     (Node 'N' Empty Empty)
                     (Node 'T' Empty Empty)
                 )
                 (Node 'Y'
                     (Node 'S' Empty Empty)
                     (Node 'A' Empty Empty)
                 )
             )
             (Node 'L'
                 (Node 'W'
                     (Node 'C' Empty Empty)
                     (Node 'R' Empty Empty)
                 )
                 (Node 'A'
                     (Node 'A' Empty Empty)
                     (Node 'C' Empty Empty)
                 )
             )

     data Direction = L | R deriving (Show)
     type Directions = [Direction]

     -- Return the a new tree whoes only 'W' is replaced with 'P'
     changeToP :: Directions-> Tree Char -> Tree Char
     changeToP (L:ds) (Node x l r) = Node x (changeToP ds l) r
     changeToP (R:ds) (Node x l r) = Node x l (changeToP ds r)
     changeToP [] (Node _ l r) = Node 'P' l r

     -- Show the element at the end of a list of `Direction`'s
     elemAt :: Directions -> Tree a -> a
     elemAt (L:ds) (Node _ l _) = elemAt ds l
     elemAt (R:ds) (Node _ _ r) = elemAt ds r
     elemAt [] (Node x _ _) = x


     -- Try it!
     -- ghci>
     newTree = changeToP [R, L] freeTree
     -- ghci>
     elemAt [R, L] newTree -- 'P'
   #+END_SRC

** DONE A trail of breadcrumbs
   CLOSED: [2018-08-30 Thu 21:47]
   #+BEGIN_SRC haskell
     type Breadcrumbs = [Direction]

     goLeft :: (Tree a, Breadcrumbs) -> (Tree a, Breadcrumbs)
     goLeft (Node _ l _, bs) = (l, L:bs)

     goLeft :: (Tree a, Breadcrumbs) -> (Tree a, Breadcrumbs)
     goLeft (Node _ _ r, bs) = (r, R:bs)

     -- Try it!
     goLeft (goRight (freeTree, []))
     -- (Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])
   #+END_SRC

   - Let's try a better way -- define a pipeline like grammer:
     #+BEGIN_SRC haskell
       x -: f = f x

       (freeTree, []) -: goRight -: goLeft
       -- (Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])
     #+END_SRC

*** Going back up
    Currently, we don't have enough information to go back up.

    - In general, a single breadcrumb should contain all the data needed to re-
      construct the parent node.

      + So 
        * it should have the information from all the paths that we didn't take
          and
        * it should also know the direction that we did take,
          _BUT_ it *must not* contain the sub-tree that we're currently focusing on.
            That's because we already have that sub-tree in the first component of
          the tuple, so if we also had it in the breadcrumbs, we'd have duplicate
          information -- =From Jian= may be trapped in repeating some operation,
          and cannot stop.

      + Then, we need

        1. Instead of ~Direction~, we'll make a new data type:
           #+BEGIN_SRC haskell
             data Crumb a =
                 LeftCrumb a (Tree a)
               | RightCrumb a (Tree a)
               deriving (Show)

             type Breadcrumbs a = [Crumb a]
           #+END_SRC

        2. Modify ~goLeft~ and ~goRight~ to save enough information:

           *Notice*:
           Assume that the current tree that's under focus is NOT
           ~Empty~, which doesn't have any subtrees.

           #+BEGIN_SRC haskell
             goLeft :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)
             goLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)

             goRight :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)
             goRight (Node x l r, bs) = (r, RightCrumb x l:bs)
           #+END_SRC

        3. Let's define ~goUp~:
           #+BEGIN_SRC haskell
             goUp :: (Tree a, Brreadcrumbs a) -> (Tree a, Breadcrumbs a)
             goUp (t, LeftCrumb x r:bs) -> (Node x t r, bs)
             goUp (t, LeftCrumb x l:bs) -> (Node x l t, bs)
           #+END_SRC
           * Note that this function causes an error if we're already at the top
             of a tree and we want to move up.

             =TODO= =Solution=
             Later on, we'll use the ~Maybe~ /monad/ to represent possible
             failure when moving focus.

        4. ~type Zipper a = (Tree a, Breadcrumbs a)~
           With a pair of ~Tree a~ and ~Breadcrumbs a~,
           * we have *ALL the information* to *rebuild* the whole tree
             and
           * we also have a _focus_ on a sub-tree.

           This scheme also enables us to *EASILY* _move up, left and right_.

    - Zipper :: A pair that contains
      + a focused part of a data structure
        and
      + its surroundings

      because moving our focus up and down the data structure resembles the
      operation of a zipper on a regular pair of pants. So it's cool to make a
      type synonym ~Zipper~.

*** Manipulating trees under focus
    - Let's make a function that _modifies_ the element in the /root/ of the
      sub-tree that the /zipper/ is focusing on: 
      #+BEGIN_SRC haskell
        modify :: (a -> a) -> Zipper a -> Zipper a
        modify f (Node x l r, bs) = (Node (f x) l r, bs)
        modify f (Empty, bs) = (Empty, bs)
      #+END_SRC

    - Examples:
      #+BEGIN_SRC haskell
        newFocus = (freeTree,[]) -: goLeft -: goRight -: modify (\_ -> 'P')
        newFocus2 = newFocus -: goUp -: modify (\_ -> 'X')
      #+END_SRC

    - Take a /tree/ and a /zipper/.
      Return a NEW /zipper/ with a new focus on the given tree.
      #+BEGIN_SRC haskell
        attach :: Tree a -> Zipper a -> Zipper a
        attach t (_, bs) = (t, bs)
      #+END_SRC

      + Replace the leftmost of our ~freeTree~:
        #+BEGIN_SRC haskell
          -- In our `freeTree`, this is a empty node.
          farLeft = (freeTree, []) -: goLeft -: goLeft -: goLeft -: goLeft
          newFocus = farLeft -: attach (Node 'Z' Empty Empty)
        #+END_SRC

        After this step, if we go up and re-construct a tree, we will get a
        ~freeTree~-like /tree/, and the only difference is a new leftmost /leaf
        node/ with ~'Z'~ value.

*** I'm going straight to top, oh yeah, up where the air is fresh and clean!
    #+BEGIN_SRC haskell
      topMost :: Zipper a -> Zipper a
      topMost (t, []) = (t, [])
      topMost z = topMost (goUp z)
    #+END_SRC

** DONE Focusing on lists
   CLOSED: [2018-08-31 Fri 00:56]
   /Zippers/ can be used with pretty much any data structure -- it is a category
   of data structure or a way to construct data structures, NOT one data structure.

   - It's no surprise that they can be used to focus on sub-lists of lists.
     List is a single branch tree!

   - Code:
     #+BEGIN_SRC haskell
       data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)
       type ListZipper a = ([a], [a])  -- (focus, crumbs)

       goForward :: ListZipper a -> ListZipper a
       goForward (x:xs, bs) = (xs, x:bs)

       goBack :: ListZipper a -> ListZipper a
       goBack (xs, b:bs) = (b:xs, bs)

       -- Try it!
       xs = [1, 2, 3, 4]
       goForward(xs, [])          -- ([2, 3, 4], [1])
       goForward([2, 3, 4], [1])  -- ([3, 4], [2, 1])
       goForward([3, 4], [2, 1])  -- ([4], [3, 2, 1])
       goBack([4], [3, 2, 1])     -- ([3, 4], [2, 1])
     #+END_SRC

   - This also makes it easier to see why we call this a /zipper/,
     because this really looks like the slider of a zipper moving up and down.

** TODO A very simple file system
   Now that we know how /zippers/ work, let's use /trees/ to represent a _very
   simple file system_ and then make a /zipper/ for that _file system_, which
   will allow us to *move between folders*, just like we usually do when jumping
   around our file system.

   - xxx
     #+BEGIN_SRC haskell
       type Name = String
       type Data = String
       data FSItem = File Name Data | Folder Name [FSItem] deriving (Show)
     #+END_SRC

   - A example folder with some files and sub-folders:
     #+BEGIN_SRC haskell
       -- The author says: "That's actually what my disk contains right now."
       myDisk :: FSItem
       myDisk =
           Folder "root"
               [ File "goat_yelling_like_man.wmv" "baaaaaa"
               , File "pope_time.avi" "god bless"
               , Folder "pics"
                   [ File "ape_throwing_up.jpg" "bleargh"
                   , File "watermelon_smash.gif" "smash!!"
                   , File "skull_man(scary).bmp" "Yikes!"
                   ]
               , File "dijon_poupon.doc" "best mustard"
               , Folder "programs"
                   [ File "fartwizard.exe" "10gotofart"
                   , File "owl_bandit.dmg" "mov eax, h00t"
                   , File "not_a_virus.exe" "really not a virus"
                   , Folder "source code"
                       [ File "best_hs_prog.hs" "main = print (fix error)"
                       , File "random.hs" "main = print 4"
                       ]
                   ]
               ]
     #+END_SRC

*** TODO A zipper for our file system
    #+BEGIN_SRC haskell
      data FSCrumb = FSCrumb Name [FSItem] [FSItem] deriving (Show)
      type FSZipper = (FSItem, [FSCrumb])
    #+END_SRC

*** TODO Manipulating our file system
    
** DONE Watch your step
   CLOSED: [2018-08-30 Thu 21:47]
   - Till now we didn't consider some situations like (Use the /tree zipper/ as
     a example):
     + Go left or right when the node is an ~Empty~.
     + Go up when you have already reach the /root/ -- no crumb can be found.

     We mentioned that we will deal with them at the last.

   - For the code we have now, if we meet the situations I mentioned above, there
     will be /runtime errors/ -- failures.

     We need to find a way to deal with the failures. This remind us one thing
     -- the /monads/! More specifically, the ~Maybe~ /monad/, which adds a
     context of possible failure to normal values.

   - Use the ~Maybe~ /monnad/ to add a context of possible failure to our movements:
     #+BEGIN_SRC haskell
       goLeft :: Zipper a -> Maybe (Zipper a)
       goLeft (Node x l r, bs) = Just (l, LeftCrumb x r:bs)
       goLeft (Empty, _) = Nothing

       goRight :: Zipper a -> Maybe (Zipper a)
       goRight (Node x l r, bs) = Just (r, RightCrumb x l:bs)
       goRight (Empty, _) = Nothing

       goUp :: Zipper a -> Maybe (Zipper a)
       goUp (t, LeftCrumb x r:bs) = Just (Node x t r, bs)
       goUp (t, RightCrumb x l:bs) = Just (Node x l t, bs)
       goUp (_, []) = Nothing
     #+END_SRC

   - Use the modified /monadic functions/ above, we *cannot* use the ~-:~ to
     pipeline our operations any more!

     However, since there are /monads/, we can use ~>>=~ to replace all the
     ~-:~, and make everythings works well again.

     + Example:
       #+BEGIN_SRC haskell
         coolTree = Node 1 Empty (Node 3 Empty Empty)
         return (coolTree,[]) >>= goRight
         -- Just (Node 3 Empty Empty,[RightCrumb 1 Empty])

         return (coolTree,[]) >>= goRight >>= goRight
         -- Just (Empty,[RightCrumb 3 Empty,RightCrumb 1 Empty])

         return (coolTree,[]) >>= goRight >>= goRight >>= goRight
         -- Nothing
       #+END_SRC

* Tips
