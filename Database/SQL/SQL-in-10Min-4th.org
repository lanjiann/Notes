#+TITLE: SQL in 10 Minutes
#+VERSION: 45h
#+AUTHOR: Ben Forta
#+YEAR: 2012
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Introduction][Introduction]]
  - [[Who Is the Teach Yourself SQL Book For?][Who Is the Teach Yourself SQL Book For?]]
  - [[DBMSs Covered in This Book][DBMSs Covered in This Book]]
  - [[Conventions Used in This Book][Conventions Used in This Book]]
- [[Lesson 1. Understanding SQL][Lesson 1. Understanding SQL]]
  - [[Database Basics][Database Basics]]
    - [[Databases][Databases]]
    - [[Tables][Tables]]
    - [[Columns and Datatypes][Columns and Datatypes]]
    - [[Rows][Rows]]
    - [[Primary Keys][Primary Keys]]
  - [[What Is SQL?][What Is SQL?]]
  - [[Try It Yourself][Try It Yourself]]
  - [[Summary][Summary]]
- [[Lesson 2. Retrieving Data][Lesson 2. Retrieving Data]]
  - [[2.1 The ~SELECT~ Statement][2.1 The ~SELECT~ Statement]]
  - [[2.2 Retrieving Individual Columns][2.2 Retrieving Individual Columns]]
  - [[2.3 Retrieving Multiple Columns][2.3 Retrieving Multiple Columns]]
  - [[2.4 Retrieving All Columns][2.4 Retrieving All Columns]]
  - [[2.5 Retrieving Distinct Rows][2.5 Retrieving Distinct Rows]]
  - [[2.6 Limiting Results][2.6 Limiting Results]]
  - [[2.7 Using Comments][2.7 Using Comments]]
  - [[2.8 Summary][2.8 Summary]]
- [[Lesson 3. Sorting Retrieved Data][Lesson 3. Sorting Retrieved Data]]
  - [[3.1 Sorting Data][3.1 Sorting Data]]
  - [[3.2 Sorting by Multiple Columns][3.2 Sorting by Multiple Columns]]
  - [[3.3 Sorting by Column Position][3.3 Sorting by Column Position]]
  - [[3.4 Specifying Sort Direction][3.4 Specifying Sort Direction]]
  - [[3.5 Summary][3.5 Summary]]
- [[Lesson 4. Filtering Data][Lesson 4. Filtering Data]]
  - [[4.1 Using the ~WHERE~ Clause][4.1 Using the ~WHERE~ Clause]]
  - [[4.2 The ~WHERE~ Clause Operations][4.2 The ~WHERE~ Clause Operations]]
    - [[4.2.1 Checking Against a Single Value][4.2.1 Checking Against a Single Value]]
    - [[4.2.2 Checking for Nonmatches][4.2.2 Checking for Nonmatches]]
    - [[4.2.3 Checking for a Range of Values][4.2.3 Checking for a Range of Values]]
    - [[4.2.4 Checking for No Value][4.2.4 Checking for No Value]]
  - [[Summary][Summary]]
- [[Lesson 5. Advanced Data Filtering][Lesson 5. Advanced Data Filtering]]
  - [[5.1 Combining ~WHERE~ Clauses][5.1 Combining ~WHERE~ Clauses]]
    - [[5.1.1 ~AND~ Operator][5.1.1 ~AND~ Operator]]
    - [[5.1.2 ~OR~ Operator][5.1.2 ~OR~ Operator]]
    - [[5.1.3 Understanding Order of Evaluation][5.1.3 Understanding Order of Evaluation]]
  - [[5.2 Using the ~IN~ Operator][5.2 Using the ~IN~ Operator]]
  - [[5.3 Using the ~NOT~ Operator][5.3 Using the ~NOT~ Operator]]
  - [[Summary][Summary]]
- [[Lesson 6. Using Wildcard Filtering][Lesson 6. Using Wildcard Filtering]]
  - [[6.1 Using the ~LIKE~ Operator][6.1 Using the ~LIKE~ Operator]]
    - [[The Percent Sign (~%~) Wildcard][The Percent Sign (~%~) Wildcard]]
    - [[The Underscore (~_~) Wildcard][The Underscore (~_~) Wildcard]]
    - [[The Brackets (~[]~) Wildcard][The Brackets (~[]~) Wildcard]]
  - [[6.2 Tips for Using Wildcards][6.2 Tips for Using Wildcards]]
  - [[6.3 Summary][6.3 Summary]]
- [[Lesson 7. Creating Calculated Fields][Lesson 7. Creating Calculated Fields]]
  - [[7.1 Understanding Calculated Fields][7.1 Understanding Calculated Fields]]
  - [[7.2 Concatenating Fields][7.2 Concatenating Fields]]
    - [[7.2.1 Using Aliases][7.2.1 Using Aliases]]
  - [[7.3 Performing Mathematical Calculations][7.3 Performing Mathematical Calculations]]
  - [[7.3 Summary][7.3 Summary]]
- [[Lesson 8. Using Data Manipulation Functions][Lesson 8. Using Data Manipulation Functions]]
  - [[Understanding Functions][Understanding Functions]]
  - [[Using Functions][Using Functions]]
  - [[Summary][Summary]]
- [[Lesson 9. Summarizing Data][Lesson 9. Summarizing Data]]
  - [[9.1 Using Aggregate Functions][9.1 Using Aggregate Functions]]
    - [[The ~AVG()~ Function][The ~AVG()~ Function]]
    - [[The ~COUNT()~ Function][The ~COUNT()~ Function]]
    - [[The ~MAX()~ Function][The ~MAX()~ Function]]
    - [[The ~MIN()~ Function][The ~MIN()~ Function]]
    - [[The ~SUM()~ Function][The ~SUM()~ Function]]
  - [[9.2 Aggregates on Distinct Values][9.2 Aggregates on Distinct Values]]
  - [[9.3 Combining Aggregate Functions][9.3 Combining Aggregate Functions]]
  - [[9.4 Summary][9.4 Summary]]
- [[Lesson 10. Grouping Data][Lesson 10. Grouping Data]]
  - [[10.1 Understanding Data Grouping][10.1 Understanding Data Grouping]]
  - [[10.2 Creating Groups][10.2 Creating Groups]]
  - [[10.3 Filtering Groups][10.3 Filtering Groups]]
  - [[10.4 Grouping and Sorting][10.4 Grouping and Sorting]]
  - [[10.5 ~SELECT~ Clause Ordering][10.5 ~SELECT~ Clause Ordering]]
  - [[10.6 Summary][10.6 Summary]]
- [[Lesson 11. Working with Subqueries][Lesson 11. Working with Subqueries]]
  - [[11.1 Understanding Subqueries][11.1 Understanding Subqueries]]
  - [[11.2 Filtering by Subquery][11.2 Filtering by Subquery]]
  - [[11.3 Using Subqueries as Calculated Fields][11.3 Using Subqueries as Calculated Fields]]
  - [[11.4 Summary][11.4 Summary]]
- [[Lesson 12. Joining Tables][Lesson 12. Joining Tables]]
  - [[12.1 Understanding Joins][12.1 Understanding Joins]]
    - [[12.1.1 Understanding Relational Tables][12.1.1 Understanding Relational Tables]]
    - [[12.1.2 Why Use Joins?][12.1.2 Why Use Joins?]]
  - [[12.2 Creating a Joins][12.2 Creating a Joins]]
    - [[12.2.1 The Importance of the ~WHERE~ Clause][12.2.1 The Importance of the ~WHERE~ Clause]]
    - [[12.2.2 Inner Joins][12.2.2 Inner Joins]]
    - [[12.2.3 Joining Multiple Tables][12.2.3 Joining Multiple Tables]]
  - [[12.3 Summary][12.3 Summary]]
- [[Lesson 13. Creating Advanced Joins][Lesson 13. Creating Advanced Joins]]
  - [[13.1 Using Table Aliases][13.1 Using Table Aliases]]
  - [[13.2 Using Different Join Types][13.2 Using Different Join Types]]
    - [[13.2.1 Self Joins][13.2.1 Self Joins]]
    - [[13.2.2 Natural Joins][13.2.2 Natural Joins]]
    - [[13.2.3 Outer Joins][13.2.3 Outer Joins]]
  - [[!3.3 Using Joins with Aggregate Functions][!3.3 Using Joins with Aggregate Functions]]
  - [[!3.4 Using Joins and Join Conditions][!3.4 Using Joins and Join Conditions]]
  - [[!3.5 Summary][!3.5 Summary]]
  - [[][]]
- [[Lesson 14. Combining Queries][Lesson 14. Combining Queries]]
  - [[14.1 Understanding Combined Queries][14.1 Understanding Combined Queries]]
  - [[14.2 Creating Combined Queries][14.2 Creating Combined Queries]]
    - [[14.2.1 Sorting Combined Query Results][14.2.1 Sorting Combined Query Results]]
  - [[14.3 Summary][14.3 Summary]]
- [[Lesson 15. Inserting Data][Lesson 15. Inserting Data]]
  - [[15.1 Understanding Data Insertion][15.1 Understanding Data Insertion]]
    - [[15.1.1 Inserting Complete Rows][15.1.1 Inserting Complete Rows]]
    - [[15.1.2 Inserting Partial Rows][15.1.2 Inserting Partial Rows]]
    - [[15.1.3 Inserting Retrieved Data][15.1.3 Inserting Retrieved Data]]
  - [[15.2 Copying from One Table to Another][15.2 Copying from One Table to Another]]
  - [[15.3 Summary][15.3 Summary]]
- [[Lesson 16. Updating and Deleting Data][Lesson 16. Updating and Deleting Data]]
  - [[16.1 Updating Data][16.1 Updating Data]]
  - [[16.2 Deleting Data][16.2 Deleting Data]]
  - [[16.3 Guidelines for Updating and Deleting Data][16.3 Guidelines for Updating and Deleting Data]]
  - [[16.4 Summary][16.4 Summary]]
- [[Lesson 17. Creating and Manipulating Tables][Lesson 17. Creating and Manipulating Tables]]
  - [[17.1 Creating Tables][17.1 Creating Tables]]
    - [[17.1.1 Basic Table Creation][17.1.1 Basic Table Creation]]
    - [[17.1.2 Working with ~NULL~ Values][17.1.2 Working with ~NULL~ Values]]
    - [[17.1.3 Specifying Default Values][17.1.3 Specifying Default Values]]
  - [[17.2 Updating Tables][17.2 Updating Tables]]
  - [[17.3 Deleting Tables][17.3 Deleting Tables]]
  - [[17.4 Renaming Tables][17.4 Renaming Tables]]
  - [[17.5 Summary][17.5 Summary]]
- [[Lesson 18. Using Views][Lesson 18. Using Views]]
  - [[18.1 Understanding Views][18.1 Understanding Views]]
    - [[18.1.1 Why Use Views][18.1.1 Why Use Views]]
    - [[18.1.2 View Rules and Restrictions][18.1.2 View Rules and Restrictions]]
  - [[18.2 Creating Views][18.2 Creating Views]]
    - [[18.2.1 Using Views to Simplify Complex Joins][18.2.1 Using Views to Simplify Complex Joins]]
    - [[18.2.2 Using Views to Reformat Retrieved Data][18.2.2 Using Views to Reformat Retrieved Data]]
    - [[18.2.3 Using Views to Filter Unwanted Data][18.2.3 Using Views to Filter Unwanted Data]]
    - [[18.2.4 Using Views with Calculated Fields][18.2.4 Using Views with Calculated Fields]]
  - [[18.3 Summary][18.3 Summary]]
- [[Lesson 19. Working with Stored Procedures][Lesson 19. Working with Stored Procedures]]
  - [[19.1 Understanding Stored Procedures][19.1 Understanding Stored Procedures]]
  - [[19.2 Why to Use Stored Procedures][19.2 Why to Use Stored Procedures]]
  - [[19.3 Executing Stored Procedures][19.3 Executing Stored Procedures]]
  - [[19.4 Creating Stored Procedures][19.4 Creating Stored Procedures]]
  - [[19.5 Summary][19.5 Summary]]
- [[Lesson 20. Managing Transaction Processing][Lesson 20. Managing Transaction Processing]]
  - [[20.1 Understanding Transaction Processing][20.1 Understanding Transaction Processing]]
  - [[20.2 Controlling Transactions][20.2 Controlling Transactions]]
  - [[20.3 Summary][20.3 Summary]]
- [[Lesson 21. Using Cursors][Lesson 21. Using Cursors]]
  - [[Understanding Cursors][Understanding Cursors]]
  - [[Working with Cursors][Working with Cursors]]
  - [[Summary][Summary]]
- [[Lesson 22. Understanding Advanced SQL Features][Lesson 22. Understanding Advanced SQL Features]]
  - [[Understanding Constraints][Understanding Constraints]]
  - [[Understanding Indexes][Understanding Indexes]]
  - [[Understanding Triggers][Understanding Triggers]]
  - [[Database Security][Database Security]]
  - [[Summary][Summary]]
- [[A Sample Table Scripts][A Sample Table Scripts]]
  - [[Understanding the Sample Tables][Understanding the Sample Tables]]
  - [[Obtaining the Sample Tables][Obtaining the Sample Tables]]
- [[B Working in Popular Applications][B Working in Popular Applications]]
  - [[Using Apache Open Office Base][Using Apache Open Office Base]]
  - [[Using Adobe ColdFusion][Using Adobe ColdFusion]]
  - [[Using IBM DB2][Using IBM DB2]]
  - [[Using MariaDB][Using MariaDB]]
  - [[Using Microsoft Access][Using Microsoft Access]]
  - [[Using Microsoft Asp][Using Microsoft Asp]]
  - [[Using Microsoft Asp.NET][Using Microsoft Asp.NET]]
  - [[Using Microsoft Query][Using Microsoft Query]]
  - [[Using Microsoft SQL Server (including Microsoft SQL Server Express)][Using Microsoft SQL Server (including Microsoft SQL Server Express)]]
  - [[Using MySQL][Using MySQL]]
  - [[Using Oracle][Using Oracle]]
  - [[Using Oracle Express][Using Oracle Express]]
  - [[Using PHP][Using PHP]]
  - [[Using PostgreSQL][Using PostgreSQL]]
  - [[Using SQLite][Using SQLite]]
  - [[Configuring ODBC Data Sources][Configuring ODBC Data Sources]]
- [[C SQL Statement Syntax][C SQL Statement Syntax]]
  - [[~ALTER~ ~TABLE~][~ALTER~ ~TABLE~]]
  - [[~COMMIT~][~COMMIT~]]
  - [[~CREATE INDEX~][~CREATE INDEX~]]
  - [[~CREATE PROCEDURE~][~CREATE PROCEDURE~]]
  - [[~CREATE TABLE~][~CREATE TABLE~]]
  - [[~CREATE VIEW~][~CREATE VIEW~]]
  - [[~DELETE~][~DELETE~]]
  - [[~DROP~][~DROP~]]
  - [[~INSERT~][~INSERT~]]
  - [[~INSERT SELECT~][~INSERT SELECT~]]
  - [[~ROLLBACK~][~ROLLBACK~]]
  - [[~SELECT~][~SELECT~]]
  - [[~UPDATE~][~UPDATE~]]
- [[D Using SQL Datatypes][D Using SQL Datatypes]]
  - [[String Datatypes][String Datatypes]]
  - [[Numeric Datatypes][Numeric Datatypes]]
  - [[Data and Time Datatypes][Data and Time Datatypes]]
  - [[Binary Datatypes][Binary Datatypes]]
- [[E SQL Reserved Words][E SQL Reserved Words]]

* TODO Introduction
** DONE Who Is the Teach Yourself SQL Book For?
   CLOSED: [2017-08-31 Thu 15:36]
** DONE DBMSs Covered in This Book
   CLOSED: [2017-08-31 Thu 15:33]
   DBMSs that explicitly covered:
   - Apache Open Office Base
   - IBM DB2
   - Microsoft Access
   - Microsoft SQL Server (including Microsoft SQL Server Express)
   - MariaDB
   - MySQL
   - Oracle (including Oracle Express)
   - PostgreSQL

** DONE Conventions Used in This Book
   CLOSED: [2017-08-31 Thu 15:36]
   AS REFERENCE

* TODO Lesson 1. Understanding SQL
** TODO Database Basics
   A good place to start our study is with a list and explanation of the most
   important database terms.

*** Databases
    Distinguish /database/ and /database management system (DBMS)/.

*** Tables
    - table :: structured files that can store data of a specific type.

    - Entries in /table/ are homogeneous.

*** Columns and Datatypes

*** Rows

*** Primary Keys

** TODO What Is SQL?
** TODO Try It Yourself
** TODO Summary

* DONE Lesson 2. Retrieving Data
  CLOSED: [2018-10-15 Mon 12:49]
** DONE 2.1 The ~SELECT~ Statement
   CLOSED: [2018-10-15 Mon 10:51]
   - *TIPs*
     Never name a column using a keyword.

     See Appendix E SQL Reserved Words for more info

   - You need provide two pieces of info to ~SELECT~
     1. WHAT to select

     2. WHERE to select

** DONE 2.2 Retrieving Individual Columns
   CLOSED: [2018-10-15 Mon 10:51]
   #+BEGIN_SRC sql
     SELECT [columnName] FROM [tableName]
   #+END_SRC

** DONE 2.3 Retrieving Multiple Columns
   CLOSED: [2018-10-15 Mon 10:51]
   #+BEGIN_SRC sql
     SELECT [columnNames ...] FROM [tableName]
   #+END_SRC

   - How to format the output depends on the specific DBSM.

** DONE 2.4 Retrieving All Columns
   CLOSED: [2018-10-15 Mon 10:51]
   #+BEGIN_SRC sql
     SELECT * FROM [tableName]
   #+END_SRC

   - Avoid using wildcard if you can -- for performance and for concise.

** DONE 2.5 Retrieving Distinct Rows
   CLOSED: [2018-10-15 Mon 12:36]
   #+BEGIN_SRC sql
     SELECT DISTINCT [columnName]
     FROM [tableName]
   #+END_SRC

** DONE 2.6 Limiting Results
   CLOSED: [2018-10-15 Mon 12:44]
   Take AT MOST n rows
   Can include /offset/

   - SQL Server
     #+BEGIN_SRC sql
       SELECT TOP 5 [columnName]
       FROM [tableName];
     #+END_SRC

   - DB2
     #+BEGIN_SRC sql
       SELECT [columnName]
       FROM [tableName]
       FETCH FIRST 5 ROWS ONLY;
     #+END_SRC

   - Oracle
     #+BEGIN_SRC sql
       SELECT [columnName]
       FROM [tableName]
       WHERE ROWNUM <= 5;
     #+END_SRC

   - MySQL, MariaDB, PostgreSQL, or SQLite
     #+BEGIN_SRC sql
       SELECT [columnName]
       FROM [tableName]
       LIMIT 5;
     #+END_SRC

     + Start from the _offset_, and take the _limit_ number of rows
       #+BEGIN_SRC sql
         SELECT [columnName]
         FROM [tableName]
         LIMIT 5 OFFSET 5;
       #+END_SRC

       * *Use base-0 index!*
         There is a column of number on the left, they are one major key, NOT
         the /index/

       * MySQL and MariaDB have a simplified version of ~LIMIT 4 OFFSET 3~:
         ~LIMIT 4, 3~. =from Jian= This simplified version is NOT clear.

** DONE 2.7 Using Comments
   CLOSED: [2018-10-15 Mon 12:49]
   - Line comment:
     + ~--~ (prefered)

     + ~#~  (not support by majority of DBMS)

   - Block comment:
     ~/* */~

** DONE 2.8 Summary
   CLOSED: [2018-10-15 Mon 12:49]

* DONE Lesson 3. Sorting Retrieved Data
  CLOSED: [2018-10-15 Mon 13:30]
  ~ORDER BY~

** DONE 3.1 Sorting Data
   CLOSED: [2018-10-15 Mon 12:56]
   - clause :: =TODO=

   - Sort (example):
     #+BEGIN_SRC sql
       SELECT prod_name
       FROM Products
       ORDER BY prod_name;
     #+END_SRC
     + You can also use the _non-selected column_ as the reference for sorting.

     + ~ORDER BY~ must be the *last clause*, or you'll trigger an error.

** DONE 3.2 Sorting by Multiple Columns
   CLOSED: [2018-10-15 Mon 12:58]
   #+BEGIN_SRC sql
     SELECT prod_id, prod_price, prod_name
     FROM Products
     ORDER BY prod_price, prod_name;
   #+END_SRC
   When multiple values in column _prod\under{}price_ are same, you _prod\under{}name_.

** DONE 3.3 Sorting by Column Position
   CLOSED: [2018-10-15 Mon 13:23]
   #+BEGIN_SRC sql
     SELECT prod_id, prod_price, prod_name
     FROM Products
     ORDER BY 2, 3;
   #+END_SRC

   - The numbers follow ~ORDER BY~ correspond to the selected columns:
     =prod_id=, =prod_price=, =prod_name=
          1          2             3

   - You can use _numbers_ and _names_ together -- _name_ is used to refer the
     _non-selected columns_.

   - Don't use _Numbers_ when you find they make any confusion.
     Use _numbers_ may also affect the _refactoring_.

** DONE 3.4 Specifying Sort Direction
   CLOSED: [2018-10-15 Mon 13:24]
   - Descending
     #+BEGIN_SRC sql
       SELECT prod_id, prod_price, prod_name
       FROM Products
       ORDER BY prod_price DESC;
     #+END_SRC
     + ~DESC~ is the shorthand of ~DESCENDING~
     
   - *Descending* for some column(s), *ascending* for other column(s):
     #+BEGIN_SRC sql
       SELECT prod_id, prod_price, prod_name
       FROM Products
       ORDER BY prod_price DESC, prod_name;
     #+END_SRC

   - *TIPS*:
     DBMS's are usually NOT case-sensitive.
     If they are designed _case-insensitive_, the ~ORDER BY~ _CAN'T be
     case-sensitive_.

** DONE 3.5 Summary
   CLOSED: [2018-10-15 Mon 13:29]

* DONE Lesson 4. Filtering Data
  CLOSED: [2018-10-15 Mon 14:12]
  Learn how to use the ~SELECT~ /statement/'s ~WHERE~ /clause/ to *specify
  search conditions*.

** DONE 4.1 Using the ~WHERE~ Clause
   CLOSED: [2018-10-15 Mon 14:01]
   The ~WHERE~ /clause/ is specified *right after* the /table name (~From
   clause~)/:
   #+BEGIN_SRC sql
     SELECT prod_name, prod_price
     FROM Products
     WHERE prod_price = 3.49;
   #+END_SRC

   - *TIP*
     + If you have choice, _try SQL filtering first_ -- Database is designed to
       do this kind of job, and it's usually much more efficient then the
       filtering operations peformed inside an application.

     + Let Database filter, and then in many cases the data need to be sent out
       can be much more less -- if send through network, you can *save a lot of
       bandwidth*!!!

   - *CAUTION*:
     + *Reminder*: ~ORDER BY~ must be at the end!!!

     + Conclusion: ~ORDER BY~ should come after ~WHERE~ clause, if it exists.

** DONE 4.2 The ~WHERE~ Clause Operations
   CLOSED: [2018-10-15 Mon 14:01]
   - The operators supported by SQL ~WHERE~ clause:
     | Operator  | Description                  |
     |-----------+------------------------------|
     | ~=~       | Equality                     |
     | ~<>~      | Non-equality                 |
     | ~!=~      | Non-equality                 |
     | ~<~       | Less than                    |
     | ~<=~      | Less than or equal to        |
     | ~!<~      | Not less than                |
     | ~>~       | Greater than                 |
     | ~>=~      | Greater than or equal to     |
     | ~!>~      | Not greater than             |
     | ~BETWEEN~ | Between two specified values |
     | ~IS NULL~ | is a ~NULL~ value            |

     + *CAUTION*
       There are some redundant operators!

       NOT ALL of these operators are supported by ALL DBMS's.
       =from Jian= I think this sentence talks about the /redundant ones/.

*** DONE 4.2.1 Checking Against a Single Value
    CLOSED: [2018-10-15 Mon 14:04]
    #+BEGIN_SRC sql
      SELECT prod_name, prod_price
      FROM Products
      WHERE prod_price < 10;
    #+END_SRC

*** DONE 4.2.2 Checking for Nonmatches
    CLOSED: [2018-10-15 Mon 14:06]
    #+BEGIN_SRC sql
      SELECT vend_id, prod_name
      FROM Products
      WHERE vend_id <> 'DLL01';
    #+END_SRC

*** DONE 4.2.3 Checking for a Range of Values
    CLOSED: [2018-10-15 Mon 14:06]
    #+BEGIN_SRC sql
      SELECT prod_name, prod_price
      FROM Products
      WHERE prod_price BETWEEN 5 AND 10;
    #+END_SRC

*** DONE 4.2.4 Checking for No Value
    CLOSED: [2018-10-15 Mon 14:08]
    *You CAN'T use check ~NULL~ euqality.*

    #+BEGIN_SRC sql
      SELECT prod_name
      FROM Products
      WHERE prod_price IS NULL;
    #+END_SRC

    #+BEGIN_SRC sql
      SELECT cust_name
      FROM CUSTOMERS
      WHERE cust_email IS NULL;
    #+END_SRC

    - *TIPS*
      Many DBMS's provide _RICHER_ /filter operations/.

** DONE Summary
   CLOSED: [2018-10-15 Mon 14:11]

* DONE Lesson 5. Advanced Data Filtering
  CLOSED: [2018-10-15 Mon 23:39]
  Learn
  - how to *combine* ~WHERE~ /clauses/ to create powerful and sophisticated
    _search conditions_.

  - how to use the ~NOT~ and ~IN~ /operators/.

** DONE 5.1 Combining ~WHERE~ Clauses
   CLOSED: [2018-10-15 Mon 23:25]
   You can use ~AND~ and ~OR~ to combine ~WHERE~ /clauses/.

*** DONE 5.1.1 ~AND~ Operator
    CLOSED: [2018-10-15 Mon 23:20]
    #+BEGIN_SRC sql
      SELECT prod_id, prod_price, prod_name
      FROM Products
      WHERE vend_id = 'DLL01' AND prod_price <= 4;
    #+END_SRC

*** DONE 5.1.2 ~OR~ Operator
    CLOSED: [2018-10-15 Mon 23:21]
    #+BEGIN_SRC sql
      SELECT prod_id, prod_price, prod_name
      FROM Products
      WHERE vend_id = 'DLL01' OR prod_id = 'BRS01';
    #+END_SRC

*** DONE 5.1.3 Understanding Order of Evaluation
    CLOSED: [2018-10-15 Mon 23:24]
    ~AND~, similar to most programming languages, has high precedence than ~OR~.
    #+BEGIN_SRC sql
      SELECT prod_name, prod_price
      FROM Products
      WHERE vend_id = 'DLL01'
            OR vend_id = 'BRS01'
            AND prod_price >= 10;

      -- means

      SELECT prod_name, prod_price
      FROM Products
      WHERE vend_id = 'DLL01'
            OR (vend_id = 'BRS01' AND prod_price >= 10);

      -- rather than

      SELECT prod_name, prod_price
      FROM Products
      WHERE (vend_id = 'DLL01' OR vend_id = 'BRS01') AND prod_price >= 10;
    #+END_SRC

** DONE 5.2 Using the ~IN~ Operator
   CLOSED: [2018-10-15 Mon 23:34]
   ~IN~ can be used to represent some logic meanings like ~OR~.

   However, ~IN~ is more flexible and powerful:
   - When there are many conjunctions, 
     ~IN~ syntax is cleaner and easier to read.

   - The order of evaluation is easier to manage when ~IN~ is used.

   - ~IN~ has better performance, which will become clear when you have a large
     number of conjunction conditions.

   - ~IN~ can contain another ~SELECT~ /statement/, enabling you to build highly
     dynamic ~WHERE~ /clauses/.
     =TODO= Lession 11 - "Working with Subqueries."

** DONE 5.3 Using the ~NOT~ Operator
   CLOSED: [2018-10-15 Mon 23:39]
   ~NOT~ is used in a ~WHERE~ /clause/ to _negate_ a condition.

   - Example:
     #+BEGIN_SRC sql
       SELECT prod_name
       FROM Products
       WHERE NOT vend_id = 'DLL01'
       ORDER BY prod_name;
     #+END_SRC
     Of course, we can use ~WHERE vend_id <> 'DLL01'~.
     A more real world example should be combine ~NOT~ and ~IN~.

   - *NOTE* =IMPORTANT=
     /MariaDB/ supports the use of ~NOT~ to *negate* ~IN~, ~BETWEEN~, and
     ~EXISTS~ /clauses/.

     _This is *different from most DBMSs* that allow ~NOT~ to be used to negate
     any conditions._

** DONE Summary
   CLOSED: [2018-10-15 Mon 23:39]
   
* DONE Lesson 6. Using Wildcard Filtering
  CLOSED: [2018-10-16 Tue 18:43]
  Learn
  - what /wildcards/ are, and how they are used

  - how to perform /wildcard searches/ using the ~LIKE~ operator for sophisticated
    filtering of retrieved data.

** DONE 6.1 Using the ~LIKE~ Operator
   CLOSED: [2018-10-16 Tue 02:07]
   - /Wildcard searching/ can *ONLY* be used with _text fields (strings)_,
     you *can NOT* use /wildcards/ to _search_ fields of non-text datatypes.

*** DONE The Percent Sign (~%~) Wildcard
    CLOSED: [2018-10-16 Tue 01:54]
    #+BEGIN_SRC sql
      SELECT prod_id, prod_name
      FROM Products
      WHERE prod_name LIKE 'Fish%';
    #+END_SRC
    ~%~ is like the ~.*~ in other language regex pattern.

    - *Note*
      Microsoft Access use ~*~ instead of ~%~

    - *Note*
      Depending on our DBMS and how it is configured, searches _MAY BE
      case-sensitive._

    - *Note* =IMPORTANT=
      Many DBMS's, including Microsoft Access, pad field contents with spaces,
      and then use a /search pattern/ without ~%~ at the end match NOTHING.

      You usually have two ways to deal with this:
      + Always add a ~%~ to the end of your /search pattern/

      + _Prefered_: trim the spaces using functions.
        =IMPORTANT= =TODO= Lesson 8. "Using Data Manipulation Functions."

    - *CAUTION*
      ~%~ will never match ~NULL~.

*** DONE The Underscore (~_~) Wildcard
    CLOSED: [2018-10-16 Tue 01:58]
    - ~_~ is like the ~.~ regex pattern in many programming languages'.

    - *NOTE*
      ~_~ is NOT supported by DB2.

    - *NOTE*
      In Microsoft Access, you need to use ~?~ _INSTEAD OF_ ~_~.

    - Example:
      #+BEGIN_SRC sql
        SELECT prod_id, prod_name
        FROM Products
        WHERE prod_name LIKE '__ inch teddy bear';
      #+END_SRC

*** DONE The Brackets (~[]~) Wildcard
    CLOSED: [2018-10-16 Tue 02:07]
    - *NOTE*
      ~[]~ is NOT supported by ALL DBMS's.

      Microsoft Access and Microsoft SQL Server *support* it.

    - Example:
      Find all contacts whose names begin with 'J' or 'M':
      #+BEGIN_SRC sql
        SELECT cust_contact
        FROM Customers
        WHERE cust_contact LIKE '[JM]%'
        ORDER BY cust_contact;
      #+END_SRC

    - The negation of ~[JM]~ is ~[^JM]~
      #+BEGIN_SRC sql
        SELECT cust_contact
        FROM Customers
        WHERE cust_contact LIKE '[^JM]%'
        ORDER BY cust_contact;
      #+END_SRC

      + *NOTE*
        Negating Sets in Microsoft Access

        The negation of ~[JM]~ is ~[!JM]~, and you *cannot* use the ~[^JM]~
        /search pattern./

      + You can also negate with ~WHERE NOT~
        #+BEGIN_SRC sql
          SELECT cust_contact
          FROM Customers
          WHERE NOT cust_contact LIKE '[JM]%'
          ORDER BY cust_contact;
        #+END_SRC

** DONE 6.2 Tips for Using Wildcards
   CLOSED: [2018-10-16 Tue 18:43]
   Use /wildcards/, and you may notice a bad performance.

   - Here are some _rules_ to keep in mind when using /wildcards/:
     + *Avoid OVERUSE* /wildcards/.
       *If another search operator will do, use it instead.*

     + Unless absolutely necessary, *DO NOT use /wildcards/ at the beginning of the
       /search pattern/.*

       /Search patterns/ that begin with /wildcards/ are the *slowest* to process.

** DONE 6.3 Summary
   CLOSED: [2018-10-16 Tue 02:11]

* DONE Lesson 7. Creating Calculated Fields
  CLOSED: [2018-10-16 Tue 23:29]
  Learn
  - *what* calculated fields are
  - how to *create* them
  - how to use *aliases* to refer to them from within your application.

** DONE 7.1 Understanding Calculated Fields
   CLOSED: [2018-10-16 Tue 23:29]
   - /Calculated fields/ do *NOT* actually exist in database tables.
       Rather, a calculated field is created _on-the-fly_ *within* a SQL
     ~SELECT~ statement.

   - field ::
     ESSENTIALLY means the SAME THING as /column/ and often used
     *interchangeably*.
       Although
     + /database columns/ are TYPICALLY called /columns/
       and

     + /fields/ is USUALLY used in conjunction with /calculated fields/.

   - _From the perspective of a client_ (for example, your application),
     a /CALCULATED field/'s data is returned in the same way as data from any
     other /column/.

   - *TIPs*
     As a rule,
     it is *far quicker* to perform these operations on the _database server_
     _THAN_
     it is to perform them within the _client_.

** DONE 7.2 Concatenating Fields
   CLOSED: [2018-10-16 Tue 23:18]
   - The /concatenation operator/ can be ~+~ or ~||~, which depends on the DBMS
     you use.

     MySQL and MariaDB *must* use specific function.

   - *Note*
     + ~+~:
       Access and SQL Server

     + ~||~
       DB2, Oracle, PostgreSQL, SQLite, and Open Office Base

   - Example
     + The usage of ~||~ is similar -- just replace the ~+~ above with ~||~.
       #+BEGIN_SRC sql
         SELECT vend_name + ' (' + vend_country + ')'
         FROM Vendors
         ORDER BY vend_name;
       #+END_SRC

     + MySQL and MariaDB
       #+BEGIN_SRC sql
         SELECT Concat(vend_name, ' (', vend_country, ')')
         FROM Vendors
         ORDER BY vend_name;
       #+END_SRC

   - If you run the code above, you will see the trailing spaces of ~vend_country~
     between ='('= and =')'=. Use the ~RTRIM~ function:
     #+BEGIN_SRC sql
       SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')'
       FROM Vendors
       ORDER BY vend_name;
     #+END_SRC

   - ~LTRIM~ delete the left spaces.
     ~TRIM~ delete spaces of two sides.

*** DONE 7.2.1 Using Aliases
    CLOSED: [2018-10-16 Tue 23:18]
    Give the a new calculated /field/ a name with ~AS~:
    #+BEGIN_SRC sql
      SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')'
      AS vend_title
      FROM Vendors
      ORDER BY vend_name;
    #+END_SRC

    - *Tip*: Other Uses for Aliases
      Aliases have other uses too. Some common uses include renaming a column if
      the real table column name contains illegal characters (for example,
      spaces), and expanding column names if the original namesare either
      ambiguous or easily misread.

    - *CAUTION*: Alias Names
      Use multiple words as an /alias/ is allowed (_quoted_), but *strongly discouraged*.

    - *NOTE*: /Derived Columns/
      Same meaning as /aliases/.

** DONE 7.3 Performing Mathematical Calculations
   CLOSED: [2018-10-16 Tue 23:24]
   - You can use ~+~, ~-~, ~*~, and ~/~:
     #+BEGIN_SRC sql
       SELECT prod_id,
              quantity,
              item_price,
              quantity*item_price AS expanded_price
       FROM OrderItems
       WHERE order_num = 20008;
     #+END_SRC

   - *Tip*: How to Test Calculations =IMPORTANT=
     Use ~SELECT~ without ~FROM~.

     For example,
     + ~SELECT 3 * 2;~
     + ~SELECT TRIM(' abc ');~

** DONE 7.3 Summary
   CLOSED: [2018-10-16 Tue 23:19]

* TODO Lesson 8. Using Data Manipulation Functions
** TODO Understanding Functions
** TODO Using Functions
** TODO Summary

* DONE Lesson 9. Summarizing Data
  CLOSED: [2018-10-17 Wed 02:36]
  Learn
  - what the /SQL *aggregate* functions/ are
    and
  - how to use them to summarize table data.

** DONE 9.1 Using Aggregate Functions
   CLOSED: [2018-10-17 Wed 01:20]
   It is often necessary to *summarize* data *without actually retrieving it
   all*, and SQL provides special functions for this purpose.

   - aggregate functions ::
        Functions that operate on a set of rows to calculate and return a single value.

*** DONE The ~AVG()~ Function
    CLOSED: [2018-10-17 Wed 01:10]
    - For a /column/
      #+BEGIN_SRC sql
        SELECT AVG(prod_price) AS avg_price
        FROM  Products;
      #+END_SRC

    - For specific lines and columns
      #+BEGIN_SRC sql
        SELECT AVG(prod_price) AS avg_price
        FROM  Products
        WHERE vend_id = 'DLL01';
      #+END_SRC

    - *CAUTION*: Individual Columns Only
      You *CANNOT* average multiple columns with one ~AVG()~ call.

    - *Note*: ~NULL~ values
      ~NULL~'s are ignored by ~AVG()~

*** DONE The ~COUNT()~ Function
    CLOSED: [2018-10-17 Wed 01:13]
    - Two ways to use ~COUNT()~:
      + ~COUNT(*)~ takes into account the number of ~NULL~.
        #+BEGIN_SRC sql
          SELECT COUNT(*) AS num_cust
          FROM Customers;
        #+END_SRC

      + ~COUNT(columnName)~ ignores ~NULL~ values.
        #+BEGIN_SRC sql
          SELECT COUNT(cust_emails) AS num_cust
          FROM Customers;
        #+END_SRC

*** DONE The ~MAX()~ Function
    CLOSED: [2018-10-17 Wed 01:17]
    #+BEGIN_SRC sql
      SELECT MAX(prod_price) AS max_price
      FROM Products;
    #+END_SRC

    - *TIPs*: Using ~MAX()~ with Non-Numeric Data
      _ALTHOUGH_ ~MAX()~ is USUALLY used to find the _highest numeric_ or _date values_,
      many (_but not all_) DBMSs allow it to be used to return the highest value
      in any columns including textual columns.

      _When used with textual data_, ~MAX()~ returns the row that would be the _last
      if the data were sorted by that column._

    - *NOTE*
      ~MAX()~ *IGNORES* ~NULL~ rows.

*** DONE The ~MIN()~ Function
    CLOSED: [2018-10-17 Wed 01:17]
    Similar to ~MAX()~

*** DONE The ~SUM()~ Function
    CLOSED: [2018-10-17 Wed 01:20]
    - Examples:
      #+BEGIN_SRC sql
        SELECT SUM(quantity) AS items_ordered
        FROM OrderItems
        WHERE order_num = 20005;
      #+END_SRC

      Sum /mutiple columns/ arithmetics result
      #+BEGIN_SRC sql
        SELECT SUM(item_price*quantity) AS total_price
        FROM OrderItems
        WHERE order_num = 20005;
      #+END_SRC

    - *NOTE*
      ~MAX()~ *IGNORES* ~NULL~ rows.

** DONE 9.2 Aggregates on Distinct Values
   CLOSED: [2018-10-17 Wed 02:32]
   - The *five* /aggregate functions/ can all be used in *two* ways:
     + To perform calculations
       on _all rows_,
       specify the ~ALL~ argument or
       specify no argument at all (because ~ALL~ is the *default behavior*).

     + To only include unique values, specify the ~DISTINCT~ argument.

   - *NOTE*: Not in _Microsoft Access_
     Microsoft Access does not support the use of ~DISTINCT~ *WITHIN* /aggregate
     functions/, and so the following example will *NOT* work with Access.

     To achieve a similar result in Access you will need to use a subquery to
     return ~DISTINCT~ data to an _OUTER ~SELECT COUNT(*)~ statement_.
     =TODO= =EXAMPLES=

   - Example
     #+BEGIN_SRC sql
       SELECT AVG(DISTINCT prod_price) AS avg_price
       FROM Products
       WHERE vend_id = 'DLL01';
     #+END_SRC

   - *CAUTION*: _No_ ~DISTINCT~ With ~COUNT(*)~
     ~DISTINCT~ may only be used with ~COUNT()~ if a column name is
     specified. ~DISTINCT~ may not be used with ~COUNT(*)~. Similarly,
     ~DISTINCT~ must be used with a /column name/ and not with a
     /calculation/ or /expression/.
     =TODO= =TODO= =TODO=
     =TODO= =TODO= =TODO=
     =TODO= =TODO= =TODO=

   - *TIPS*: Using ~DISTINCT~ with ~MIN()~ and ~MAX()~
     This is allowed, but it has no value.

   - *NOTE*: Additional Aggregate Arguments
     In addition to the ~DISTINCT~ and ~ALL~ arguments shown here, _some_ DBMSs
     support additional arguments such as ~TOP~ and ~TOP PERCENT~ that let you
     perform calculations on _subsets_ of _query results_.
       Refer to your DBMS documentation to determine exactly what arguments are
     available to you.
     =TODO= =EXAMPLES= =TODO=

** DONE 9.3 Combining Aggregate Functions
   CLOSED: [2018-10-17 Wed 02:35]
   #+BEGIN_SRC sql
     SELECT COUNT(*) AS num_items,
            MIN(prod_price) AS price_min,
            MAX(prod_price) AS price_max,
            AVG(prod_price) AS price_avg
     FROM Products;
   #+END_SRC

   - *Caution*: Naming Aliases
     Avoid using /names of actual columns/ as aliases in aggreations.

     Nothing illegal, but _MANY_ SQL implementations do *NOT SUPPORT* this and
     will generate obscure error messages if you do so.
     
** DONE 9.4 Summary
   CLOSED: [2018-10-17 Wed 02:35]

* TODO Lesson 10. Grouping Data
  
** TODO 10.1 Understanding Data Grouping
** TODO 10.2 Creating Groups
** TODO 10.3 Filtering Groups
** TODO 10.4 Grouping and Sorting
** TODO 10.5 ~SELECT~ Clause Ordering
** TODO 10.6 Summary
  
* TODO Lesson 11. Working with Subqueries
** TODO 11.1 Understanding Subqueries
** TODO 11.2 Filtering by Subquery
** TODO 11.3 Using Subqueries as Calculated Fields
** TODO 11.4 Summary

* TODO Lesson 12. Joining Tables
** TODO 12.1 Understanding Joins
*** 12.1.1 Understanding Relational Tables
*** 12.1.2 Why Use Joins?

** TODO 12.2 Creating a Joins
*** 12.2.1 The Importance of the ~WHERE~ Clause
*** 12.2.2 Inner Joins
*** 12.2.3 Joining Multiple Tables

** TODO 12.3 Summary

* TODO Lesson 13. Creating Advanced Joins
** TODO 13.1 Using Table Aliases
** TODO 13.2 Using Different Join Types
*** 13.2.1 Self Joins
*** 13.2.2 Natural Joins
*** 13.2.3 Outer Joins

** TODO !3.3 Using Joins with Aggregate Functions
** TODO !3.4 Using Joins and Join Conditions
** TODO !3.5 Summary
** 
* TODO Lesson 14. Combining Queries
** TODO 14.1 Understanding Combined Queries
** TODO 14.2 Creating Combined Queries
*** 14.2.1 Sorting Combined Query Results

** TODO 14.3 Summary

* TODO Lesson 15. Inserting Data
** TODO 15.1 Understanding Data Insertion
*** 15.1.1 Inserting Complete Rows
*** 15.1.2 Inserting Partial Rows
*** 15.1.3 Inserting Retrieved Data

** TODO 15.2 Copying from One Table to Another
** TODO 15.3 Summary

* TODO Lesson 16. Updating and Deleting Data
  Learn how to use the ~UPDATE~ and ~DELETE~ /statements/ to enable you to
  further manipulate your /table data/.

** TODO 16.1 Updating Data
** TODO 16.2 Deleting Data
** TODO 16.3 Guidelines for Updating and Deleting Data
** TODO 16.4 Summary 

* TODO Lesson 17. Creating and Manipulating Tables
** TODO 17.1 Creating Tables
*** 17.1.1 Basic Table Creation
*** 17.1.2 Working with ~NULL~ Values
*** 17.1.3 Specifying Default Values

** TODO 17.2 Updating Tables
** TODO 17.3 Deleting Tables 
** TODO 17.4 Renaming Tables
** TODO 17.5 Summary

* TODO Lesson 18. Using Views
** TODO 18.1 Understanding Views
*** 18.1.1 Why Use Views
*** 18.1.2 View Rules and Restrictions

** TODO 18.2 Creating Views
*** 18.2.1 Using Views to Simplify Complex Joins
*** 18.2.2 Using Views to Reformat Retrieved Data
*** 18.2.3 Using Views to Filter Unwanted Data
*** 18.2.4 Using Views with Calculated Fields

** TODO 18.3 Summary

* TODO Lesson 19. Working with Stored Procedures
** TODO 19.1 Understanding Stored Procedures
** TODO 19.2 Why to Use Stored Procedures
** TODO 19.3 Executing Stored Procedures
** TODO 19.4 Creating Stored Procedures
** TODO 19.5 Summary

* TODO Lesson 20. Managing Transaction Processing
** TODO 20.1 Understanding Transaction Processing
** TODO 20.2 Controlling Transactions
** TODO 20.3 Summary

* TODO Lesson 21. Using Cursors
** Understanding Cursors
** Working with Cursors
** Summary

* TODO Lesson 22. Understanding Advanced SQL Features
** TODO Understanding Constraints
** TODO Understanding Indexes
** TODO Understanding Triggers
** TODO Database Security
** TODO Summary

* TODO A Sample Table Scripts
** TODO Understanding the Sample Tables
** TODO Obtaining the Sample Tables

* TODO B Working in Popular Applications
** Using Apache Open Office Base
** Using Adobe ColdFusion
** Using IBM DB2
** Using MariaDB
** Using Microsoft Access
** Using Microsoft Asp
** Using Microsoft Asp.NET
** Using Microsoft Query
** Using Microsoft SQL Server (including Microsoft SQL Server Express)
** Using MySQL
** Using Oracle
** Using Oracle Express
** Using PHP
** Using PostgreSQL
** Using SQLite
** Configuring ODBC Data Sources

* TODO C SQL Statement Syntax
** ~ALTER~ ~TABLE~
** ~COMMIT~
** ~CREATE INDEX~
** ~CREATE PROCEDURE~
** ~CREATE TABLE~
** ~CREATE VIEW~
** ~DELETE~
** ~DROP~
** ~INSERT~
** ~INSERT SELECT~
** ~ROLLBACK~
** ~SELECT~
** ~UPDATE~

* TODO D Using SQL Datatypes
** TODO String Datatypes
** TODO Numeric Datatypes
** TODO Data and Time Datatypes
** TODO Binary Datatypes

* TODO E SQL Reserved Words
