#+TITLE: Real World Haskell
#+VERSION: 2009
#+AUTHOR: Bryan O'Sullivan, John Goerzen & Don Stewart
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Preface - xxiii][Preface - xxiii]]
- [[1 Getting Started - 1][1 Getting Started - 1]]
  - [[Your Haskell Environment - 1][Your Haskell Environment - 1]]
  - [[Getting Started with ghci, the Interpreter - 2][Getting Started with ghci, the Interpreter - 2]]
  - [[Basic Interaction: Using ghci as a Calculator - 3][Basic Interaction: Using ghci as a Calculator - 3]]
    - [[Simple Arithmetic - 3][Simple Arithmetic - 3]]
    - [[An Arithmetic Quirk: Writing Negative Numbers - 4][An Arithmetic Quirk: Writing Negative Numbers - 4]]
    - [[Boolean Logic, Operators, and Value Comparisons - 5][Boolean Logic, Operators, and Value Comparisons - 5]]
    - [[Operator Precedence and Associativity - 7][Operator Precedence and Associativity - 7]]
    - [[Undefined Values, and Introducing Variables - 8][Undefined Values, and Introducing Variables - 8]]
    - [[Dealing with Precedence and Associativity Variables - 8][Dealing with Precedence and Associativity Variables - 8]]
  - [[Command-Line Editing in ghci - 9][Command-Line Editing in ghci - 9]]
  - [[Lists - 9][Lists - 9]]
    - [[Operators on List - 11][Operators on List - 11]]
  - [[Strings and Characters - 11][Strings and Characters - 11]]
  - [[First Steps and Characters - 12][First Steps and Characters - 12]]
  - [[A Simple Program - 15][A Simple Program - 15]]
- [[2 Types and Functions - 17][2 Types and Functions - 17]]
  - [[Why Care About Types? - 17][Why Care About Types? - 17]]
  - [[Haskell's Type System - 18][Haskell's Type System - 18]]
    - [[Strong Types - 18][Strong Types - 18]]
    - [[Static Types - 19][Static Types - 19]]
    - [[Type Inference - 20][Type Inference - 20]]
  - [[What to Expect from the Type System - 20][What to Expect from the Type System - 20]]
  - [[Some Common Basic Types - 21][Some Common Basic Types - 21]]
  - [[Function Application - 22][Function Application - 22]]
  - [[Useful Composite Data Types: Lists and Tuples - 23][Useful Composite Data Types: Lists and Tuples - 23]]
  - [[Functions over Lists and Tuples - 25][Functions over Lists and Tuples - 25]]
    - [[Passing an Expression to a Function - 26][Passing an Expression to a Function - 26]]
  - [[Function Types and Purity - 27][Function Types and Purity - 27]]
  - [[Haskell Source Files, and Writing Simple Functions - 27][Haskell Source Files, and Writing Simple Functions - 27]]
    - [[Just What Is a Variable, Anyway? - 28][Just What Is a Variable, Anyway? - 28]]
    - [[Conditional Evaluation - 29][Conditional Evaluation - 29]]
  - [[Understanding Evaluation by Example - 32][Understanding Evaluation by Example - 32]]
    - [[Lazy Evaluation - 32][Lazy Evaluation - 32]]
    - [[A More Involved Example - 33][A More Involved Example - 33]]
    - [[Recursion - 34][Recursion - 34]]
    - [[Ending the Recursion - 35][Ending the Recursion - 35]]
    - [[Returning from the Recursion - 35][Returning from the Recursion - 35]]
    - [[What Have We Learned? - 36][What Have We Learned? - 36]]
  - [[Polymorphism in Haskell - 36][Polymorphism in Haskell - 36]]
    - [[Reasoning About Polymorphic Functions - 38][Reasoning About Polymorphic Functions - 38]]
    - [[Further Reading - 38][Further Reading - 38]]
  - [[The Type of a Function of More Than One Argument - 38][The Type of a Function of More Than One Argument - 38]]
  - [[Why the Fuss over Purity? - 39][Why the Fuss over Purity? - 39]]
  - [[Conclusion - 40][Conclusion - 40]]
- [[3 Defining Types, Streamlining Functions - 41][3 Defining Types, Streamlining Functions - 41]]
  - [[Defining a New Data Type - 41][Defining a New Data Type - 41]]
    - [[Naming Types and Values - 43][Naming Types and Values - 43]]
  - [[Type Synonyms - 43][Type Synonyms - 43]]
  - [[Algebraic Data Types - 44][Algebraic Data Types - 44]]
    - [[Tuples, Algebraic Data Types, and When to Use Each - 45][Tuples, Algebraic Data Types, and When to Use Each - 45]]
    - [[Analogues to Algebraic Data Types in Other Languages - 47][Analogues to Algebraic Data Types in Other Languages - 47]]
      - [[The structure - 47][The structure - 47]]
      - [[The enumeration - 48][The enumeration - 48]]
      - [[The discriminated union - 49][The discriminated union - 49]]
  - [[Pattern Matching - 50][Pattern Matching - 50]]
    - [[Construction and Deconstruction - 51][Construction and Deconstruction - 51]]
    - [[Further Adventures - 52][Further Adventures - 52]]
    - [[Variable Naming in Patterns - 53][Variable Naming in Patterns - 53]]
    - [[The Wild Card Pattern - 53][The Wild Card Pattern - 53]]
    - [[Exhaustive Patterns and Wild Cards - 54][Exhaustive Patterns and Wild Cards - 54]]
  - [[Record Syntax - 55][Record Syntax - 55]]
  - [[Parameterized Types - 57][Parameterized Types - 57]]
  - [[Recursive Types - 58][Recursive Types - 58]]
  - [[Reporting Errors - 60][Reporting Errors - 60]]
    - [[A More Controlled Approach - 61][A More Controlled Approach - 61]]
  - [[Introducing Local Variables - 61][Introducing Local Variables - 61]]
    - [[Shadowing - 62][Shadowing - 62]]
    - [[The where Clause - 63][The where Clause - 63]]
    - [[Local Functions, Global Variables - 63][Local Functions, Global Variables - 63]]
  - [[The Offside Rule and Whitespace in an Expression - 64][The Offside Rule and Whitespace in an Expression - 64]]
    - [[A Note About Tabs Versus Spaces - 66][A Note About Tabs Versus Spaces - 66]]
    - [[The Offside Rule Is Not Mandatory - 66][The Offside Rule Is Not Mandatory - 66]]
  - [[The ~case~ Expression - 66][The ~case~ Expression - 66]]
  - [[Common Beginner Mistakes with Patterns - 67][Common Beginner Mistakes with Patterns - 67]]
    - [[Incorrectly Matching Against a Variable - 67][Incorrectly Matching Against a Variable - 67]]
    - [[Incorrectly Trying to Compare for Equality - 68][Incorrectly Trying to Compare for Equality - 68]]
  - [[Conditional Evaluation with Guards - 68][Conditional Evaluation with Guards - 68]]
- [[4 Functional Programming - 71][4 Functional Programming - 71]]
  - [[Thinking in Haskell - 71][Thinking in Haskell - 71]]
  - [[A Simple Command-Line Framework - 71][A Simple Command-Line Framework - 71]]
  - [[Warming Up: Portably Splitting Lines of Text - 72][Warming Up: Portably Splitting Lines of Text - 72]]
    - [[A Line-Ending Conversion Program - 75][A Line-Ending Conversion Program - 75]]
  - [[Infix Functions - 76][Infix Functions - 76]]
  - [[Working with Lists - 77][Working with Lists - 77]]
    - [[Basic List Manipulation - 78][Basic List Manipulation - 78]]
    - [[Safely and Sanely Working with Crashy Functions - 79][Safely and Sanely Working with Crashy Functions - 79]]
    - [[Partial and Total Functions - 79][Partial and Total Functions - 79]]
    - [[More Simple List Manipulations - 80][More Simple List Manipulations - 80]]
    - [[Working with Sublists - 81][Working with Sublists - 81]]
    - [[Searching Lists - 82][Searching Lists - 82]]
    - [[Working with Several Lists at Once - 83][Working with Several Lists at Once - 83]]
    - [[Special String-Handling Functions - 84][Special String-Handling Functions - 84]]
  - [[How to Think About Loops - 84][How to Think About Loops - 84]]
    - [[Explicit Recursion - 85][Explicit Recursion - 85]]
    - [[Transforming Every Piece of Input - 87][Transforming Every Piece of Input - 87]]
    - [[Mapping over a List - 88][Mapping over a List - 88]]
    - [[Selecting Pieces of Input - 90][Selecting Pieces of Input - 90]]
    - [[Computing One Answer over a Collection - 90][Computing One Answer over a Collection - 90]]
    - [[The Left Fold - 92][The Left Fold - 92]]
    - [[Why Use Folds, Maps, and Filters? - 93][Why Use Folds, Maps, and Filters? - 93]]
    - [[Folding from the Right - 94][Folding from the Right - 94]]
    - [[Left Folds, Laziness, and Space Leaks - 96][Left Folds, Laziness, and Space Leaks - 96]]
    - [[Further Reading - 99][Further Reading - 99]]
  - [[Anonymous (lambda) Functions - 99][Anonymous (lambda) Functions - 99]]
  - [[Partial Function Application and Currying - 100][Partial Function Application and Currying - 100]]
    - [[Sections - 102][Sections - 102]]
  - [[As-patterns - 103][As-patterns - 103]]
  - [[Code Reuse Through Composition - 104][Code Reuse Through Composition - 104]]
    - [[Use Your Head Wisely - 107][Use Your Head Wisely - 107]]
  - [[Tips for Writing Readable Code - 107][Tips for Writing Readable Code - 107]]
  - [[Space Leaks and Strict Evaluation - 108][Space Leaks and Strict Evaluation - 108]]
    - [[Avoiding Space Leaks with ~seq~ - 108][Avoiding Space Leaks with ~seq~ - 108]]
    - [[Learning to Use ~seq~ - 109][Learning to Use ~seq~ - 109]]
- [[5 Writing a Library: Working with JSON Data - 111][5 Writing a Library: Working with JSON Data - 111]]
  - [[A Whirlwind Tour of JSON - 111][A Whirlwind Tour of JSON - 111]]
  - [[Representing JSON Data in Haskell - 111][Representing JSON Data in Haskell - 111]]
  - [[The Anatomy of a Haskell Module - 113][The Anatomy of a Haskell Module - 113]]
  - [[Compiling Haskell Source - 114][Compiling Haskell Source - 114]]
  - [[Generating a Haskell Program and Importing Modules - 114][Generating a Haskell Program and Importing Modules - 114]]
  - [[Printing JSON Data - 115][Printing JSON Data - 115]]
  - [[Type Inference Is a Double-Edged Sword - 117][Type Inference Is a Double-Edged Sword - 117]]
  - [[A More General Look at Rendering - 118][A More General Look at Rendering - 118]]
  - [[Developing Haskell Code Without Going Nuts - 119][Developing Haskell Code Without Going Nuts - 119]]
  - [[Pretty Printing a String - 120][Pretty Printing a String - 120]]
  - [[Arrays and Objects, and the Module Header - 122][Arrays and Objects, and the Module Header - 122]]
  - [[Writing a Module Header - 123][Writing a Module Header - 123]]
  - [[Fleshing Out the Pretty-Printing Library - 124][Fleshing Out the Pretty-Printing Library - 124]]
    - [[Compact Rendering - 127][Compact Rendering - 127]]
    - [[True Pretty Printing - 128][True Pretty Printing - 128]]
    - [[Following the Pretty Printer - 129][Following the Pretty Printer - 129]]
  - [[Creating a Package - 131][Creating a Package - 131]]
    - [[Writing a Package Description - 131][Writing a Package Description - 131]]
    - [[GHC’s Package Manager - 133][GHC’s Package Manager - 133]]
    - [[Setting Up, Building, and Installing - 133][Setting Up, Building, and Installing - 133]]
  - [[Practical Pointers and Further Reading - 134][Practical Pointers and Further Reading - 134]]
- [[6 Using Typeclasses - 135][6 Using Typeclasses - 135]]
  - [[The Need for Typeclasses - 135][The Need for Typeclasses - 135]]
  - [[What Are Typeclasses? - 136][What Are Typeclasses? - 136]]
  - [[Declaring Typeclass Instances - 139][Declaring Typeclass Instances - 139]]
  - [[Important Built-in Typeclasses - 139][Important Built-in Typeclasses - 139]]
    - [[Show - 139][Show - 139]]
    - [[Read - 141][Read - 141]]
    - [[Serialization with read and show - 143][Serialization with read and show - 143]]
    - [[Numeric Types - 144][Numeric Types - 144]]
    - [[Equality, Ordering, and Comparisons - 148][Equality, Ordering, and Comparisons - 148]]
  - [[Automatic Derivation - 148][Automatic Derivation - 148]]
  - [[Typeclasses at Work: Making JSON Easier to Use - 149][Typeclasses at Work: Making JSON Easier to Use - 149]]
    - [[More Helpful Errors - 151][More Helpful Errors - 151]]
    - [[Making an Instance with a Type Synonym - 151][Making an Instance with a Type Synonym - 151]]
  - [[Living in an Open World - 152][Living in an Open World - 152]]
    - [[When Do Overlapping Instances Cause Problems? - 153][When Do Overlapping Instances Cause Problems? - 153]]
    - [[Relaxing Some Restrictions on Typeclasses - 154][Relaxing Some Restrictions on Typeclasses - 154]]
    - [[How Does Show Work for Strings? - 155][How Does Show Work for Strings? - 155]]
  - [[How to Give a Type a New Identity - 155][How to Give a Type a New Identity - 155]]
    - [[Differences Between Data and Newtype Declarations - 157][Differences Between Data and Newtype Declarations - 157]]
    - [[Summary: The Three Ways of Naming Types - 158][Summary: The Three Ways of Naming Types - 158]]
  - [[JSON Typeclasses Without Overlapping Instances - 159][JSON Typeclasses Without Overlapping Instances - 159]]
  - [[The Dreaded Monomorphism Restriction - 162][The Dreaded Monomorphism Restriction - 162]]
  - [[Conclusion - 163][Conclusion - 163]]
- [[7 I/O][7 I/O]]
  - [[Classic I/O in Haskell][Classic I/O in Haskell]]
    - [[Pure Versus I/O][Pure Versus I/O]]
    - [[Why Purity Matters][Why Purity Matters]]
  - [[Working with Files and Handles][Working with Files and Handles]]
    - [[More on openFile][More on openFile]]
    - [[Closing Handles][Closing Handles]]
    - [[Seek and Tell][Seek and Tell]]
    - [[Standard Input, Output, and Error][Standard Input, Output, and Error]]
    - [[Deleting and Renaming Files][Deleting and Renaming Files]]
    - [[Temporary Files][Temporary Files]]
  - [[Extended Example: Functional I/O and Temporary Files][Extended Example: Functional I/O and Temporary Files]]
  - [[Lazy I/O][Lazy I/O]]
    - [[hGetContents][hGetContents]]
    - [[readFile and writeFile][readFile and writeFile]]
    - [[A Word on Lazy Output][A Word on Lazy Output]]
    - [[interact][interact]]
  - [[The IO Monad][The IO Monad]]
    - [[Actions][Actions]]
    - [[Sequencing][Sequencing]]
    - [[The True Nature of Return][The True Nature of Return]]
  - [[Is Haskell Really Imperative?][Is Haskell Really Imperative?]]
  - [[Side Effects with Lazy I/O][Side Effects with Lazy I/O]]
  - [[Buffering][Buffering]]
    - [[Buffering Modes][Buffering Modes]]
    - [[Flushing The Buffer][Flushing The Buffer]]
  - [[Reading Command-Line Arguments][Reading Command-Line Arguments]]
  - [[Environment Variables][Environment Variables]]
- [[8 Efficient File Processing, Regular Expressions, and Filename Matching][8 Efficient File Processing, Regular Expressions, and Filename Matching]]
  - [[Efficient File Processing][Efficient File Processing]]
    - [[Binary I/O and Qualified Imports][Binary I/O and Qualified Imports]]
    - [[Text I/O][Text I/O]]
  - [[Filename Matching][Filename Matching]]
  - [[Regular Expressions in Haskell][Regular Expressions in Haskell]]
    - [[The Many Types of Result][The Many Types of Result]]
  - [[More About Regular Expressions][More About Regular Expressions]]
    - [[Mixing and Matching String Types][Mixing and Matching String Types]]
    - [[Other Things You Should Know][Other Things You Should Know]]
  - [[Translating a glob Pattern into a Regular Expression][Translating a glob Pattern into a Regular Expression]]
  - [[An important Aside: Writing Lazy Functions][An important Aside: Writing Lazy Functions]]
  - [[Making Use of Our Pattern Matcher][Making Use of Our Pattern Matcher]]
  - [[Handling Errors Through API Design][Handling Errors Through API Design]]
  - [[Putting Our Code to Work][Putting Our Code to Work]]
- [[9 I/O Case Study: A Library for Searching the Filesystem][9 I/O Case Study: A Library for Searching the Filesystem]]
  - [[The find Command][The find Command]]
  - [[Starting Simple: Recursively Listing a Directory][Starting Simple: Recursively Listing a Directory]]
    - [[Revisiting Anonymous and Named Functions][Revisiting Anonymous and Named Functions]]
    - [[Why Provide Both mapM and forM?][Why Provide Both mapM and forM?]]
  - [[A Naive Finding Function][A Naive Finding Function]]
  - [[Predicates: From Poverty to Riches, While Remaining Pure][Predicates: From Poverty to Riches, While Remaining Pure]]
  - [[Sizing a File Safely][Sizing a File Safely]]
    - [[The Acquire-Use-Release Cycle][The Acquire-Use-Release Cycle]]
  - [[A Domain-Specific Language for Predicates][A Domain-Specific Language for Predicates]]
    - [[Avoiding Boilerplate with Lifting][Avoiding Boilerplate with Lifting]]
    - [[Gluing Predicates Together][Gluing Predicates Together]]
    - [[Defining and Using New Operators][Defining and Using New Operators]]
  - [[Controlling Traversal][Controlling Traversal]]
  - [[Density, Readability, and the Learning Process][Density, Readability, and the Learning Process]]
  - [[Another Way of Looking at Traversal][Another Way of Looking at Traversal]]
  - [[Useful Coding Guidelines][Useful Coding Guidelines]]
    - [[Common Layout Styles][Common Layout Styles]]
- [[10 Code Case Study: Parsing a Binary Data Format][10 Code Case Study: Parsing a Binary Data Format]]
  - [[Grayscale Files][Grayscale Files]]
  - [[Parsing a Raw PGM File][Parsing a Raw PGM File]]
  - [[Getting Rid of Boilerplate Code][Getting Rid of Boilerplate Code]]
  - [[Implicit State][Implicit State]]
    - [[The Identity Parser][The Identity Parser]]
    - [[Record Syntax, Updates, and Pattern Matching][Record Syntax, Updates, and Pattern Matching]]
    - [[A More Interesting Parser][A More Interesting Parser]]
    - [[Obtaining and Modifying the Parse State][Obtaining and Modifying the Parse State]]
    - [[Reporting Parse Errors][Reporting Parse Errors]]
    - [[Chaining Parsers Together][Chaining Parsers Together]]
  - [[Introducing Functors][Introducing Functors]]
    - [[Constraints on Type Definitions Are Bad][Constraints on Type Definitions Are Bad]]
    - [[Infix Use of fmap][Infix Use of fmap]]
    - [[Flexible Instances][Flexible Instances]]
    - [[Thinking More About Functors][Thinking More About Functors]]
  - [[Writing a Functor Instance for Parse][Writing a Functor Instance for Parse]]
  - [[Using Functors for Parsing][Using Functors for Parsing]]
  - [[Rewriting Our PGM Parser][Rewriting Our PGM Parser]]
  - [[Future Directions][Future Directions]]
- [[11 Testing and Quality Assurance][11 Testing and Quality Assurance]]
  - [[QuickCheck: Type-Based Testing][QuickCheck: Type-Based Testing]]
    - [[Testing for Properties][Testing for Properties]]
    - [[Testing Against a Model][Testing Against a Model]]
  - [[Testing Case Study: Specifying a Pretty Printer][Testing Case Study: Specifying a Pretty Printer]]
    - [[Generating Test Data][Generating Test Data]]
    - [[Testing Document Construction][Testing Document Construction]]
    - [[Using Lists as a Model][Using Lists as a Model]]
    - [[Putting It All Together][Putting It All Together]]
  - [[Measuring Test Coverage with HPC][Measuring Test Coverage with HPC]]
- [[12 Barcode Recognition][12 Barcode Recognition]]
  - [[A Little Bit About Barcodes][A Little Bit About Barcodes]]
    - [[EAN-13 Encoding][EAN-13 Encoding]]
  - [[Introducing Arrays][Introducing Arrays]]
    - [[Arrays and Laziness][Arrays and Laziness]]
    - [[Folding over Arrays][Folding over Arrays]]
    - [[Modifying Array Elements][Modifying Array Elements]]
  - [[Encoding an EAN-13 Barcode][Encoding an EAN-13 Barcode]]
  - [[Constraints on Our Decoder][Constraints on Our Decoder]]
  - [[Divide and Conquer][Divide and Conquer]]
  - [[Turning a Color Image into Something Tractable][Turning a Color Image into Something Tractable]]
    - [[Parsing a Color Image][Parsing a Color Image]]
    - [[Grayscale Conversion][Grayscale Conversion]]
    - [[Grayscale to Binary and Type Safety][Grayscale to Binary and Type Safety]]
  - [[What Have We Done to Our Image?][What Have We Done to Our Image?]]
  - [[Finding Matching Digits][Finding Matching Digits]]
    - [[Run Length Encoding][Run Length Encoding]]
    - [[Scaling Run Lengths, and Finding Approximate Matches][Scaling Run Lengths, and Finding Approximate Matches]]
    - [[List Comprehensions][List Comprehensions]]
    - [[Remembering a Match’s Parity][Remembering a Match’s Parity]]
    - [[Chunking a List][Chunking a List]]
    - [[Generating a List of Candidate Digits][Generating a List of Candidate Digits]]
  - [[Life Without Arrays or Hash Tables][Life Without Arrays or Hash Tables]]
    - [[A Forest of Solutions][A Forest of Solutions]]
    - [[A Brief Introduction to Maps][A Brief Introduction to Maps]]
    - [[Further Reading][Further Reading]]
  - [[Turning Digit Soup into an Answer][Turning Digit Soup into an Answer]]
    - [[Solving for Check Digits in Parallel][Solving for Check Digits in Parallel]]
    - [[Completing the Solution Map with the First Digit][Completing the Solution Map with the First Digit]]
    - [[Finding the Correct Sequence][Finding the Correct Sequence]]
  - [[Working with Row Data][Working with Row Data]]
  - [[Pulling It All Together][Pulling It All Together]]
  - [[A Few Comments on Development Style][A Few Comments on Development Style]]
- [[13 Data Structures][13 Data Structures]]
  - [[Association Lists][Association Lists]]
  - [[Maps][Maps]]
  - [[Functions Are Data, Too][Functions Are Data, Too]]
  - [[Extended Example: /etc/passwd][Extended Example: /etc/passwd]]
  - [[Extended Example: Numeric Types][Extended Example: Numeric Types]]
    - [[First Steps][First Steps]]
    - [[Completed Code][Completed Code]]
  - [[Taking Advantage of Functions as Data][Taking Advantage of Functions as Data]]
    - [[Turning Difference Lists into a Proper Library][Turning Difference Lists into a Proper Library]]
    - [[Lists, Difference Lists, and Monoids][Lists, Difference Lists, and Monoids]]
  - [[General-Purpose Sequences][General-Purpose Sequences]]
- [[14 Monads][14 Monads]]
  - [[Revisiting Earlier Code Examples][Revisiting Earlier Code Examples]]
    - [[Maybe Chaining][Maybe Chaining]]
    - [[Implicit State][Implicit State]]
  - [[Looking for Shared Patterns][Looking for Shared Patterns]]
  - [[The Monad Typeclass][The Monad Typeclass]]
  - [[And Now, a Jargon Moment][And Now, a Jargon Moment]]
  - [[Using a New Monad: Show Your Work!][Using a New Monad: Show Your Work!]]
    - [[Information Hiding][Information Hiding]]
    - [[Controlled Escape][Controlled Escape]]
    - [[Leaving a Trace][Leaving a Trace]]
    - [[Using the Logger Monad][Using the Logger Monad]]
  - [[Mixing Pure and Monadic Code][Mixing Pure and Monadic Code]]
  - [[Putting a Few Misconceptions to Rest][Putting a Few Misconceptions to Rest]]
  - [[Building the Logger Monad][Building the Logger Monad]]
    - [[Sequential Logging, Not Sequential Evaluation][Sequential Logging, Not Sequential Evaluation]]
    - [[The Writer Monad][The Writer Monad]]
  - [[The Maybe Monad][The Maybe Monad]]
    - [[Executing the Maybe Monad][Executing the Maybe Monad]]
    - [[Maybe at Work, and Good API Design][Maybe at Work, and Good API Design]]
  - [[The List Monad][The List Monad]]
    - [[Understanding the List Monad][Understanding the List Monad]]
    - [[Putting the List Monad to Work][Putting the List Monad to Work]]
  - [[Desugaring of do Blocks][Desugaring of do Blocks]]
    - [[Monads as a Programmable Semicolon][Monads as a Programmable Semicolon]]
    - [[Why Go Sugar-Free?][Why Go Sugar-Free?]]
  - [[The State Monad][The State Monad]]
    - [[Almost a State Monad][Almost a State Monad]]
    - [[Reading and Modifying the State][Reading and Modifying the State]]
    - [[Will the Real State Monad Please Stand Up?][Will the Real State Monad Please Stand Up?]]
    - [[Using the State Monad: Generating Random Values][Using the State Monad: Generating Random Values]]
    - [[A First Attempt at Purity][A First Attempt at Purity]]
    - [[Random Values in the State Monad][Random Values in the State Monad]]
    - [[Running the State Monad][Running the State Monad]]
    - [[What About a Bit More State?][What About a Bit More State?]]
  - [[Monads and Functors][Monads and Functors]]
    - [[Another Way of Looking at Monads][Another Way of Looking at Monads]]
  - [[The Monad Laws and Good Coding Style][The Monad Laws and Good Coding Style]]
- [[15 Programming with Monads][15 Programming with Monads]]
  - [[Golfing Practice: Association Lists][Golfing Practice: Association Lists]]
  - [[Generalized Lifting][Generalized Lifting]]
  - [[Looking for Alternatives][Looking for Alternatives]]
    - [[The Name mplus Does Not Imply Addition][The Name mplus Does Not Imply Addition]]
    - [[Rules for Working with MonadPlus][Rules for Working with MonadPlus]]
    - [[Failing Safely with MonadPlus][Failing Safely with MonadPlus]]
  - [[Adventures in Hiding the Plumbing][Adventures in Hiding the Plumbing]]
    - [[Supplying Random Numbers][Supplying Random Numbers]]
    - [[Another Round of Golf][Another Round of Golf]]
  - [[Separating Interface from Implementation][Separating Interface from Implementation]]
    - [[Multiparameter Typeclasses][Multiparameter Typeclasses]]
    - [[Functional Dependencies][Functional Dependencies]]
    - [[Rounding Out Our Module][Rounding Out Our Module]]
    - [[Programming to a Monad’s Interface][Programming to a Monad’s Interface]]
  - [[The Reader Monad][The Reader Monad]]
  - [[A Return to Automated Deriving][A Return to Automated Deriving]]
  - [[Hiding the IO Monad][Hiding the IO Monad]]
    - [[Using a newtype][Using a newtype]]
    - [[Designing for Unexpected Uses][Designing for Unexpected Uses]]
    - [[Using Typeclasses][Using Typeclasses]]
    - [[Isolation and Testing][Isolation and Testing]]
    - [[The Writer Monad and Lists][The Writer Monad and Lists]]
    - [[Arbitrary I/O Revisited][Arbitrary I/O Revisited]]
- [[16 Using Parsec][16 Using Parsec]]
  - [[First Steps with Parsec: Simple CSV Parsing][First Steps with Parsec: Simple CSV Parsing]]
  - [[The sepBy and endBy Combinators][The sepBy and endBy Combinators]]
  - [[Choices and Errors][Choices and Errors]]
    - [[Lookahead][Lookahead]]
    - [[Error Handling][Error Handling]]
  - [[Extended Example: Full CSV Parser][Extended Example: Full CSV Parser]]
  - [[Parsec and MonadPlus][Parsec and MonadPlus]]
  - [[Parsing a URL-Encoded Query String][Parsing a URL-Encoded Query String]]
  - [[Supplanting Regular Expressions for Casual Parsing][Supplanting Regular Expressions for Casual Parsing]]
  - [[Parsing Without Variables][Parsing Without Variables]]
  - [[Applicative Functors for Parsing][Applicative Functors for Parsing]]
  - [[Applicative Parsing by Example][Applicative Parsing by Example]]
  - [[Parsing JSON Data][Parsing JSON Data]]
  - [[Parsing a HTTP Request][Parsing a HTTP Request]]
    - [[Backtracking and Its Discontents][Backtracking and Its Discontents]]
    - [[Parsing Headers][Parsing Headers]]
- [[17 Interfacing with C: The FFI][17 Interfacing with C: The FFI]]
  - [[Foreign Language Bindings: The Basics][Foreign Language Bindings: The Basics]]
    - [[Be Careful of Side Effects][Be Careful of Side Effects]]
    - [[A High-Level Wrapper][A High-Level Wrapper]]
  - [[Regular Expressions for Haskell: A Binding for PCRE][Regular Expressions for Haskell: A Binding for PCRE]]
    - [[Simple Tasks: Using the C Preprocessor][Simple Tasks: Using the C Preprocessor]]
    - [[Binding Haskell to C with hsc2hs][Binding Haskell to C with hsc2hs]]
    - [[Adding Type Safety to PCRE][Adding Type Safety to PCRE]]
    - [[Binding to Constants][Binding to Constants]]
    - [[Automating the Binding][Automating the Binding]]
  - [[Passing String Data Between Haskell and C][Passing String Data Between Haskell and C]]
    - [[Typed Pointers][Typed Pointers]]
    - [[Memory Management: Let the Garbage Collector Do the Work][Memory Management: Let the Garbage Collector Do the Work]]
    - [[A High-Level Interface: Marshaling Data][A High-Level Interface: Marshaling Data]]
    - [[Marshaling ByteStrings][Marshaling ByteStrings]]
    - [[Allocating Local C Data: The Storable Class][Allocating Local C Data: The Storable Class]]
    - [[Putting It All Together][Putting It All Together]]
  - [[Matching on Strings][Matching on Strings]]
    - [[Extracting Information About the Pattern][Extracting Information About the Pattern]]
    - [[Pattern Matching with Substrings][Pattern Matching with Substrings]]
    - [[The Real Deal: Compiling and Matching Regular Expressions][The Real Deal: Compiling and Matching Regular Expressions]]
- [[18 Monad Transformers][18 Monad Transformers]]
  - [[Motivation: Boilerplate Avoidance][Motivation: Boilerplate Avoidance]]
  - [[A Simple Monad Transformer Example][A Simple Monad Transformer Example]]
  - [[Common Patterns in Monads and Monad Transformers][Common Patterns in Monads and Monad Transformers]]
  - [[Stacking Multiple Monad Transformers][Stacking Multiple Monad Transformers]]
    - [[Hiding Our Work][Hiding Our Work]]
  - [[Moving Down the Stack][Moving Down the Stack]]
    - [[When Explicit Lifting Is Necessary][When Explicit Lifting Is Necessary]]
  - [[Understanding Monad Transformers by Building One][Understanding Monad Transformers by Building One]]
    - [[Creating a Monad Transformer][Creating a Monad Transformer]]
    - [[More Typeclass Instances][More Typeclass Instances]]
    - [[Replacing the Parse Type with a Monad Stack][Replacing the Parse Type with a Monad Stack]]
  - [[Transformer Stacking Order Is Important][Transformer Stacking Order Is Important]]
  - [[Putting Monads and Monad Transformers into Perspective][Putting Monads and Monad Transformers into Perspective]]
    - [[Interference with Pure Code][Interference with Pure Code]]
    - [[Overdetermined Ordering][Overdetermined Ordering]]
    - [[Runtime Overhead][Runtime Overhead]]
    - [[Unwieldy Interfaces][Unwieldy Interfaces]]
    - [[Pulling It All Together][Pulling It All Together]]
- [[19 Error Handling][19 Error Handling]]
  - [[Error Handling with Data Types][Error Handling with Data Types]]
    - [[Use of Maybe][Use of Maybe]]
    - [[Use of Either][Use of Either]]
  - [[Exceptions][Exceptions]]
    - [[First Steps with Exceptions][First Steps with Exceptions]]
    - [[Laziness and Exception Handling][Laziness and Exception Handling]]
    - [[Using handle][Using handle]]
    - [[Selective Handling of Exceptions][Selective Handling of Exceptions]]
    - [[I/O Exceptions][I/O Exceptions]]
    - [[Throwing Exceptions][Throwing Exceptions]]
    - [[Dynamic Exceptions][Dynamic Exceptions]]
  - [[Error Handling in Monads][Error Handling in Monads]]
    - [[A Tiny Parsing Framework][A Tiny Parsing Framework]]
- [[20 Systems Programming in Haskell][20 Systems Programming in Haskell]]
  - [[Running External Programs][Running External Programs]]
  - [[Directory and File Information][Directory and File Information]]
  - [[Program Termination][Program Termination]]
  - [[Dates and Times][Dates and Times]]
    - [[ClockTime and CalendarTime][ClockTime and CalendarTime]]
    - [[File Modification Times][File Modification Times]]
  - [[Extended Example: Piping][Extended Example: Piping]]
    - [[Using Pipes for Redirection][Using Pipes for Redirection]]
    - [[Better Piping][Better Piping]]
    - [[Final Words on Pipes][Final Words on Pipes]]
- [[21 Using Databases][21 Using Databases]]
  - [[Overview of HDBC][Overview of HDBC]]
  - [[Installing HDBC and Drivers][Installing HDBC and Drivers]]
  - [[Connecting to Databases][Connecting to Databases]]
  - [[Transactions][Transactions]]
  - [[Simple Queries][Simple Queries]]
  - [[SqlValue][SqlValue]]
  - [[Query Parameters][Query Parameters]]
  - [[Prepared Statements][Prepared Statements]]
  - [[Reading Results][Reading Results]]
    - [[Reading with Statements][Reading with Statements]]
    - [[Lazy Reading][Lazy Reading]]
  - [[Database Metadata][Database Metadata]]
  - [[Error Handling][Error Handling]]
- [[22 Extended Example: Web Client Programming][22 Extended Example: Web Client Programming]]
  - [[Basic Types][Basic Types]]
  - [[The Database][The Database]]
  - [[The Parser][The Parser]]
  - [[Downloading][Downloading]]
  - [[Main Program][Main Program]]
- [[23 GUI Programming with gtk2hs][23 GUI Programming with gtk2hs]]
  - [[Installing gtk2hs][Installing gtk2hs]]
  - [[Overview of the GTK+ Stack][Overview of the GTK+ Stack]]
  - [[User Interface Design with Glade][User Interface Design with Glade]]
    - [[Glade Concepts][Glade Concepts]]
  - [[Event-Driven Programming][Event-Driven Programming]]
  - [[Initializing the GUI][Initializing the GUI]]
  - [[The Add Podcast Window][The Add Podcast Window]]
  - [[Long-Running Tasks][Long-Running Tasks]]
  - [[Using Cabal][Using Cabal]]
- [[24 Concurrent and Multicore Programming][24 Concurrent and Multicore Programming]]
  - [[Defining Concurrency and Parallelism][Defining Concurrency and Parallelism]]
  - [[Concurrent Programming with Threads][Concurrent Programming with Threads]]
    - [[Threads Are Nondeterministic][Threads Are Nondeterministic]]
    - [[Hiding Latency][Hiding Latency]]
  - [[Simple Communication Between Threads][Simple Communication Between Threads]]
  - [[The Main Thread and Waiting for Other Threads][The Main Thread and Waiting for Other Threads]]
    - [[Safely Modifying an MVar][Safely Modifying an MVar]]
    - [[Safe Resource Management: A Good Idea, and Easy Besides][Safe Resource Management: A Good Idea, and Easy Besides]]
    - [[Finding the Status of a Thread][Finding the Status of a Thread]]
    - [[Writing Tighter Code][Writing Tighter Code]]
  - [[Communicating over Channels][Communicating over Channels]]
  - [[Useful Things to Know About][Useful Things to Know About]]
    - [[MVar and Chan Are Nonstrict][MVar and Chan Are Nonstrict]]
    - [[Chan Is Unbounded][Chan Is Unbounded]]
  - [[Shared-State Concurrency Is Still Hard][Shared-State Concurrency Is Still Hard]]
    - [[Deadlock][Deadlock]]
    - [[Starvation][Starvation]]
    - [[Is There Any Hope?][Is There Any Hope?]]
  - [[Using Multiple Cores with GHC][Using Multiple Cores with GHC]]
    - [[Runtime Options][Runtime Options]]
    - [[Finding the Number of Available Cores from Haskell][Finding the Number of Available Cores from Haskell]]
    - [[Choosing the Right Runtime][Choosing the Right Runtime]]
  - [[Parallel Programming in Haskell][Parallel Programming in Haskell]]
    - [[Normal Form and Head Normal Form][Normal Form and Head Normal Form]]
    - [[Sequential Sorting][Sequential Sorting]]
    - [[Transforming Our Code into Parallel Code][Transforming Our Code into Parallel Code]]
    - [[Knowing What to Evaluate in Parallel][Knowing What to Evaluate in Parallel]]
    - [[What Promises Does par Make?][What Promises Does par Make?]]
    - [[Running Our Code and Measuring Performance][Running Our Code and Measuring Performance]]
    - [[Tuning for Performance][Tuning for Performance]]
  - [[Parallel Strategies and MapReduce][Parallel Strategies and MapReduce]]
    - [[Separating Algorithm from Evaluation][Separating Algorithm from Evaluation]]
    - [[Separating Algorithm from Strategy][Separating Algorithm from Strategy]]
    - [[Writing a Simple MapReduce Definition][Writing a Simple MapReduce Definition]]
    - [[MapReduce and Strategies][MapReduce and Strategies]]
    - [[Sizing Work Appropriately][Sizing Work Appropriately]]
    - [[Efficiently Finding Line-Aligned Chunks][Efficiently Finding Line-Aligned Chunks]]
    - [[Counting Lines][Counting Lines]]
    - [[Finding the Most Popular URLs][Finding the Most Popular URLs]]
    - [[Conclusions][Conclusions]]
- [[25 Profiling and Optimization][25 Profiling and Optimization]]
  - [[Profiling Haskell Programs][Profiling Haskell Programs]]
    - [[Collecting Runtime Statistics][Collecting Runtime Statistics]]
    - [[Time Profiling][Time Profiling]]
    - [[Space Profiling][Space Profiling]]
  - [[Controlling Evaluation][Controlling Evaluation]]
    - [[Strictness and Tail Recursion][Strictness and Tail Recursion]]
    - [[Adding Strictness][Adding Strictness]]
  - [[Understanding Core][Understanding Core]]
  - [[Advanced Techniques: Fusion][Advanced Techniques: Fusion]]
    - [[Tuning the Generated Assembly][Tuning the Generated Assembly]]
  - [[Conclusions][Conclusions]]
- [[26 Advanced Library Design: Building a Bloom Filter][26 Advanced Library Design: Building a Bloom Filter]]
  - [[Introducing the Bloom Filter][Introducing the Bloom Filter]]
  - [[Use Cases and Package Layout][Use Cases and Package Layout]]
  - [[Basic Design][Basic Design]]
    - [[Unboxing, Lifting, and Bottom][Unboxing, Lifting, and Bottom]]
  - [[The ST Monad][The ST Monad]]
  - [[Designing an API for Qualified Import][Designing an API for Qualified Import]]
  - [[Creating a Mutable Bloom Filter][Creating a Mutable Bloom Filter]]
  - [[The Immutable API][The Immutable API]]
  - [[Creating a Friendly Interface][Creating a Friendly Interface]]
    - [[Re-Exporting Names for Convenience][Re-Exporting Names for Convenience]]
    - [[Hashing Values][Hashing Values]]
    - [[Turning Two Hashes into Many][Turning Two Hashes into Many]]
    - [[Implementing the Easy Creation Function][Implementing the Easy Creation Function]]
  - [[Creating a Cabal Package][Creating a Cabal Package]]
    - [[Dealing with Different Build Setups][Dealing with Different Build Setups]]
    - [[Compilation Options and Interfacing to C][Compilation Options and Interfacing to C]]
  - [[Testing with QuickCheck][Testing with QuickCheck]]
    - [[Polymorphic Testing][Polymorphic Testing]]
    - [[Writing Arbitrary Instances for ByteStrings][Writing Arbitrary Instances for ByteStrings]]
    - [[Are Suggested Sizes Correct?][Are Suggested Sizes Correct?]]
  - [[Performance Analysis and Tuning][Performance Analysis and Tuning]]
    - [[Profile-Driven Performance Tuning][Profile-Driven Performance Tuning]]
- [[27 Sockets and Syslog][27 Sockets and Syslog]]
  - [[Basic Networking][Basic Networking]]
  - [[Communicating with UDP][Communicating with UDP]]
    - [[UDP Client Example: syslog][UDP Client Example: syslog]]
    - [[UDP Syslog Server][UDP Syslog Server]]
  - [[Communicating with TCP][Communicating with TCP]]
    - [[Handling Multiple TCP Streams][Handling Multiple TCP Streams]]
    - [[TCP Syslog Server][TCP Syslog Server]]
    - [[TCP Syslog Client][TCP Syslog Client]]
- [[28 Software Transactional Memory - 623][28 Software Transactional Memory - 623]]
  - [[The Basics - 623][The Basics - 623]]
  - [[Some Simple Examples - 624][Some Simple Examples - 624]]
  - [[STM and Safety - 626][STM and Safety - 626]]
  - [[Retrying a Transaction - 626][Retrying a Transaction - 626]]
    - [[What Happens When We Retry? - 628][What Happens When We Retry? - 628]]
  - [[Choosing Between Alternatives - 628][Choosing Between Alternatives - 628]]
    - [[Using Higher Order Code with Transactions - 628][Using Higher Order Code with Transactions - 628]]
  - [[I/O and STM - 629][I/O and STM - 629]]
  - [[Communication Between Threads - 630][Communication Between Threads - 630]]
  - [[A Concurrent Web Link Checker - 631][A Concurrent Web Link Checker - 631]]
    - [[Checking a Link - 633][Checking a Link - 633]]
    - [[Worker Threads - 634][Worker Threads - 634]]
    - [[Finding Links - 635][Finding Links - 635]]
    - [[Command-Line Parsing - 636][Command-Line Parsing - 636]]
    - [[Pattern Guards - 637][Pattern Guards - 637]]
  - [[Practical Aspects of STM - 638][Practical Aspects of STM - 638]]
    - [[Getting Comfortable with Giving Up Control - 638][Getting Comfortable with Giving Up Control - 638]]
    - [[Using Invariants - 639][Using Invariants - 639]]
- [[A. Installing GHC and Haskell Libraries - 641][A. Installing GHC and Haskell Libraries - 641]]
  - [[Installing GHC - 641][Installing GHC - 641]]
    - [[Windows - 641][Windows - 641]]
    - [[Mac OS X - 642][Mac OS X - 642]]
      - [[Alternatives - 643][Alternatives - 643]]
    - [[Ubuntu and Debian Linux - 643][Ubuntu and Debian Linux - 643]]
    - [[Fedora Linux - 645][Fedora Linux - 645]]
    - [[FreeBSD - 645][FreeBSD - 645]]
  - [[Installing Haskell Software - 646][Installing Haskell Software - 646]]
    - [[Automated Download and Installation with /cabal/ - 646][Automated Download and Installation with /cabal/ - 646]]
      - [[Installing cabal - 646][Installing cabal - 646]]
      - [[Updating cabal's package list - 646][Updating cabal's package list - 646]]
      - [[Installing a library or program - 646][Installing a library or program - 646]]
    - [[Building Packages by Hand - 647][Building Packages by Hand - 647]]
- [[B. Characters, Strings, and Escaping Rules - 649][B. Characters, Strings, and Escaping Rules - 649]]
  - [[Writing Character and String Literals - 649][Writing Character and String Literals - 649]]
  - [[International Language Support - 649][International Language Support - 649]]
  - [[Escaping Text - 650][Escaping Text - 650]]
    - [[Single-Character Escape Codes - 650][Single-Character Escape Codes - 650]]
    - [[Multiline String Literals - 651][Multiline String Literals - 651]]
    - [[ASCII Control Codes - 651][ASCII Control Codes - 651]]
    - [[Control-with-Character Escapes - 652][Control-with-Character Escapes - 652]]
    - [[Numeric Escapes - 652][Numeric Escapes - 652]]
    - [[The Zero-Width Escape Sequence - 653][The Zero-Width Escape Sequence - 653]]
- [[Tips][Tips]]

* TODO Preface - xxiii
* TODO 1 Getting Started - 1
** Your Haskell Environment - 1
** Getting Started with ghci, the Interpreter - 2
** Basic Interaction: Using ghci as a Calculator - 3
*** Simple Arithmetic - 3
*** An Arithmetic Quirk: Writing Negative Numbers - 4
*** Boolean Logic, Operators, and Value Comparisons - 5
*** Operator Precedence and Associativity - 7
*** Undefined Values, and Introducing Variables - 8
*** Dealing with Precedence and Associativity Variables - 8
** Command-Line Editing in ghci - 9
** Lists - 9
*** Operators on List - 11
** Strings and Characters - 11
** First Steps and Characters - 12
** A Simple Program - 15

* TODO 2 Types and Functions - 17
** Why Care About Types? - 17
** Haskell's Type System - 18
*** Strong Types - 18
*** Static Types - 19
*** Type Inference - 20

** What to Expect from the Type System - 20
** Some Common Basic Types - 21
** Function Application - 22
** Useful Composite Data Types: Lists and Tuples - 23
** Functions over Lists and Tuples - 25
*** Passing an Expression to a Function - 26

** Function Types and Purity - 27
** Haskell Source Files, and Writing Simple Functions - 27
*** Just What Is a Variable, Anyway? - 28
*** Conditional Evaluation - 29

** Understanding Evaluation by Example - 32
*** Lazy Evaluation - 32
*** A More Involved Example - 33
*** Recursion - 34
*** Ending the Recursion - 35
*** Returning from the Recursion - 35
*** What Have We Learned? - 36

** Polymorphism in Haskell - 36
*** Reasoning About Polymorphic Functions - 38
*** Further Reading - 38

** The Type of a Function of More Than One Argument - 38
** Why the Fuss over Purity? - 39
** Conclusion - 40

* TODO 3 Defining Types, Streamlining Functions - 41
** Defining a New Data Type - 41
*** Naming Types and Values - 43

** Type Synonyms - 43
** Algebraic Data Types - 44
*** Tuples, Algebraic Data Types, and When to Use Each - 45
*** Analogues to Algebraic Data Types in Other Languages - 47
**** The structure - 47
**** The enumeration - 48
**** The discriminated union - 49

** Pattern Matching - 50
*** Construction and Deconstruction - 51
*** Further Adventures - 52
*** Variable Naming in Patterns - 53
*** The Wild Card Pattern - 53
*** Exhaustive Patterns and Wild Cards - 54

** Record Syntax - 55
** Parameterized Types - 57
** Recursive Types - 58
** Reporting Errors - 60
*** A More Controlled Approach - 61

** Introducing Local Variables - 61
*** Shadowing - 62
*** The where Clause - 63
*** Local Functions, Global Variables - 63

** The Offside Rule and Whitespace in an Expression - 64
*** A Note About Tabs Versus Spaces - 66
*** The Offside Rule Is Not Mandatory - 66

** The ~case~ Expression - 66
** Common Beginner Mistakes with Patterns - 67
*** Incorrectly Matching Against a Variable - 67
*** Incorrectly Trying to Compare for Equality - 68

** Conditional Evaluation with Guards - 68

* TODO 4 Functional Programming - 71
** Thinking in Haskell - 71
** A Simple Command-Line Framework - 71
** Warming Up: Portably Splitting Lines of Text - 72
*** A Line-Ending Conversion Program - 75

** Infix Functions - 76
** Working with Lists - 77
*** Basic List Manipulation - 78
*** Safely and Sanely Working with Crashy Functions - 79
*** Partial and Total Functions - 79
*** More Simple List Manipulations - 80
*** Working with Sublists - 81
*** Searching Lists - 82
*** Working with Several Lists at Once - 83
*** Special String-Handling Functions - 84

** How to Think About Loops - 84
*** Explicit Recursion - 85
*** Transforming Every Piece of Input - 87
*** Mapping over a List - 88
*** Selecting Pieces of Input - 90
*** Computing One Answer over a Collection - 90
*** The Left Fold - 92
*** Why Use Folds, Maps, and Filters? - 93
*** Folding from the Right - 94
*** Left Folds, Laziness, and Space Leaks - 96
*** Further Reading - 99

** Anonymous (lambda) Functions - 99
** Partial Function Application and Currying - 100
*** Sections - 102

** As-patterns - 103
** Code Reuse Through Composition - 104
*** Use Your Head Wisely - 107

** Tips for Writing Readable Code - 107
** Space Leaks and Strict Evaluation - 108
*** Avoiding Space Leaks with ~seq~ - 108
*** Learning to Use ~seq~ - 109

* TODO 5 Writing a Library: Working with JSON Data - 111
** A Whirlwind Tour of JSON - 111
** Representing JSON Data in Haskell - 111
** The Anatomy of a Haskell Module - 113
** Compiling Haskell Source - 114
** Generating a Haskell Program and Importing Modules - 114
** Printing JSON Data - 115
** Type Inference Is a Double-Edged Sword - 117
** A More General Look at Rendering - 118
** Developing Haskell Code Without Going Nuts - 119
** Pretty Printing a String - 120
** Arrays and Objects, and the Module Header - 122
** Writing a Module Header - 123
** Fleshing Out the Pretty-Printing Library - 124
*** Compact Rendering - 127
*** True Pretty Printing - 128
*** Following the Pretty Printer - 129

** Creating a Package - 131
*** Writing a Package Description - 131
*** GHC’s Package Manager - 133
*** Setting Up, Building, and Installing - 133

** Practical Pointers and Further Reading - 134

* TODO 6 Using Typeclasses - 135
** The Need for Typeclasses - 135
** What Are Typeclasses? - 136
** Declaring Typeclass Instances - 139
** Important Built-in Typeclasses - 139
*** Show - 139
*** Read - 141
*** Serialization with read and show - 143
*** Numeric Types - 144
*** Equality, Ordering, and Comparisons - 148

** Automatic Derivation - 148
** Typeclasses at Work: Making JSON Easier to Use - 149
*** More Helpful Errors - 151
*** Making an Instance with a Type Synonym - 151

** Living in an Open World - 152
*** When Do Overlapping Instances Cause Problems? - 153
*** Relaxing Some Restrictions on Typeclasses - 154
*** How Does Show Work for Strings? - 155

** How to Give a Type a New Identity - 155
*** Differences Between Data and Newtype Declarations - 157
*** Summary: The Three Ways of Naming Types - 158

** JSON Typeclasses Without Overlapping Instances - 159
** The Dreaded Monomorphism Restriction - 162
** Conclusion - 163

* TODO 7 I/O
  _Page 165-192_
** Classic I/O in Haskell
*** Pure Versus I/O
*** Why Purity Matters
** Working with Files and Handles
*** More on openFile
*** Closing Handles
*** Seek and Tell
*** Standard Input, Output, and Error
*** Deleting and Renaming Files
*** Temporary Files
** Extended Example: Functional I/O and Temporary Files
** Lazy I/O
*** hGetContents
*** readFile and writeFile
*** A Word on Lazy Output
*** interact
** The IO Monad
*** Actions
*** Sequencing
*** The True Nature of Return
** Is Haskell Really Imperative?
** Side Effects with Lazy I/O
** Buffering
*** Buffering Modes
*** Flushing The Buffer
** Reading Command-Line Arguments
** Environment Variables
* TODO 8 Efficient File Processing, Regular Expressions, and Filename Matching
  _Page 193-212_
** Efficient File Processing
*** Binary I/O and Qualified Imports
*** Text I/O
** Filename Matching
** Regular Expressions in Haskell
*** The Many Types of Result
** More About Regular Expressions
*** Mixing and Matching String Types
*** Other Things You Should Know
** Translating a glob Pattern into a Regular Expression
** An important Aside: Writing Lazy Functions
** Making Use of Our Pattern Matcher
** Handling Errors Through API Design
** Putting Our Code to Work
* TODO 9 I/O Case Study: A Library for Searching the Filesystem
  _Page 298-343_
** The find Command
** Starting Simple: Recursively Listing a Directory
*** Revisiting Anonymous and Named Functions
*** Why Provide Both mapM and forM?
** A Naive Finding Function
** Predicates: From Poverty to Riches, While Remaining Pure
** Sizing a File Safely
*** The Acquire-Use-Release Cycle
** A Domain-Specific Language for Predicates
*** Avoiding Boilerplate with Lifting
*** Gluing Predicates Together
*** Defining and Using New Operators
** Controlling Traversal
** Density, Readability, and the Learning Process
** Another Way of Looking at Traversal
** Useful Coding Guidelines
*** Common Layout Styles
* TODO 10 Code Case Study: Parsing a Binary Data Format
  _Page 235-254_
** Grayscale Files
** Parsing a Raw PGM File
** Getting Rid of Boilerplate Code
** Implicit State
*** The Identity Parser
*** Record Syntax, Updates, and Pattern Matching
*** A More Interesting Parser
*** Obtaining and Modifying the Parse State
*** Reporting Parse Errors
*** Chaining Parsers Together
** Introducing Functors
*** Constraints on Type Definitions Are Bad
*** Infix Use of fmap
*** Flexible Instances
*** Thinking More About Functors
** Writing a Functor Instance for Parse
** Using Functors for Parsing
** Rewriting Our PGM Parser
** Future Directions
* TODO 11 Testing and Quality Assurance
** QuickCheck: Type-Based Testing
*** Testing for Properties
*** Testing Against a Model
** Testing Case Study: Specifying a Pretty Printer
*** Generating Test Data
*** Testing Document Construction
*** Using Lists as a Model
*** Putting It All Together
** Measuring Test Coverage with HPC
* TODO 12 Barcode Recognition
  _Page 269-298_
** A Little Bit About Barcodes
*** EAN-13 Encoding
** Introducing Arrays
*** Arrays and Laziness
*** Folding over Arrays
*** Modifying Array Elements
** Encoding an EAN-13 Barcode
** Constraints on Our Decoder
** Divide and Conquer
** Turning a Color Image into Something Tractable
*** Parsing a Color Image
*** Grayscale Conversion
*** Grayscale to Binary and Type Safety
** What Have We Done to Our Image?
** Finding Matching Digits
*** Run Length Encoding
*** Scaling Run Lengths, and Finding Approximate Matches
*** List Comprehensions
*** Remembering a Match’s Parity
*** Chunking a List
*** Generating a List of Candidate Digits
** Life Without Arrays or Hash Tables
*** A Forest of Solutions
*** A Brief Introduction to Maps
*** Further Reading
** Turning Digit Soup into an Answer
*** Solving for Check Digits in Parallel
*** Completing the Solution Map with the First Digit
*** Finding the Correct Sequence
** Working with Row Data
** Pulling It All Together
** A Few Comments on Development Style
* TODO 13 Data Structures
** Association Lists
** Maps
** Functions Are Data, Too
** Extended Example: /etc/passwd
** Extended Example: Numeric Types
*** First Steps
*** Completed Code
** Taking Advantage of Functions as Data
*** Turning Difference Lists into a Proper Library
*** Lists, Difference Lists, and Monoids
** General-Purpose Sequences
* TODO 14 Monads
** Revisiting Earlier Code Examples
*** Maybe Chaining
*** Implicit State
** Looking for Shared Patterns
** The Monad Typeclass
** And Now, a Jargon Moment
** Using a New Monad: Show Your Work!
*** Information Hiding
*** Controlled Escape
*** Leaving a Trace
*** Using the Logger Monad
** Mixing Pure and Monadic Code
** Putting a Few Misconceptions to Rest
** Building the Logger Monad
*** Sequential Logging, Not Sequential Evaluation
*** The Writer Monad
** The Maybe Monad
*** Executing the Maybe Monad
*** Maybe at Work, and Good API Design
** The List Monad
*** Understanding the List Monad
*** Putting the List Monad to Work
** Desugaring of do Blocks
*** Monads as a Programmable Semicolon
*** Why Go Sugar-Free?
** The State Monad
*** Almost a State Monad
*** Reading and Modifying the State
*** Will the Real State Monad Please Stand Up?
*** Using the State Monad: Generating Random Values
*** A First Attempt at Purity
*** Random Values in the State Monad
*** Running the State Monad
*** What About a Bit More State?
** Monads and Functors
*** Another Way of Looking at Monads
** The Monad Laws and Good Coding Style
* TODO 15 Programming with Monads
** Golfing Practice: Association Lists
** Generalized Lifting
** Looking for Alternatives
*** The Name mplus Does Not Imply Addition
*** Rules for Working with MonadPlus
*** Failing Safely with MonadPlus
** Adventures in Hiding the Plumbing
*** Supplying Random Numbers
*** Another Round of Golf
** Separating Interface from Implementation
*** Multiparameter Typeclasses
*** Functional Dependencies
*** Rounding Out Our Module
*** Programming to a Monad’s Interface
** The Reader Monad
** A Return to Automated Deriving
** Hiding the IO Monad
*** Using a newtype
*** Designing for Unexpected Uses
*** Using Typeclasses
*** Isolation and Testing
*** The Writer Monad and Lists
*** Arbitrary I/O Revisited
* TODO 16 Using Parsec
** First Steps with Parsec: Simple CSV Parsing
** The sepBy and endBy Combinators
** Choices and Errors
*** Lookahead
*** Error Handling
** Extended Example: Full CSV Parser
** Parsec and MonadPlus
** Parsing a URL-Encoded Query String
** Supplanting Regular Expressions for Casual Parsing
** Parsing Without Variables
** Applicative Functors for Parsing
** Applicative Parsing by Example
** Parsing JSON Data
** Parsing a HTTP Request
*** Backtracking and Its Discontents
*** Parsing Headers

* TODO 17 Interfacing with C: The FFI
** Foreign Language Bindings: The Basics
*** Be Careful of Side Effects
*** A High-Level Wrapper
** Regular Expressions for Haskell: A Binding for PCRE
*** Simple Tasks: Using the C Preprocessor
*** Binding Haskell to C with hsc2hs
*** Adding Type Safety to PCRE
*** Binding to Constants
*** Automating the Binding
** Passing String Data Between Haskell and C
*** Typed Pointers
*** Memory Management: Let the Garbage Collector Do the Work
*** A High-Level Interface: Marshaling Data
*** Marshaling ByteStrings
*** Allocating Local C Data: The Storable Class
*** Putting It All Together
** Matching on Strings
*** Extracting Information About the Pattern
*** Pattern Matching with Substrings
*** The Real Deal: Compiling and Matching Regular Expressions
* TODO 18 Monad Transformers
** Motivation: Boilerplate Avoidance
** A Simple Monad Transformer Example
** Common Patterns in Monads and Monad Transformers
** Stacking Multiple Monad Transformers
*** Hiding Our Work
** Moving Down the Stack
*** When Explicit Lifting Is Necessary
** Understanding Monad Transformers by Building One
*** Creating a Monad Transformer
*** More Typeclass Instances
*** Replacing the Parse Type with a Monad Stack
** Transformer Stacking Order Is Important
** Putting Monads and Monad Transformers into Perspective
*** Interference with Pure Code
*** Overdetermined Ordering
*** Runtime Overhead
*** Unwieldy Interfaces
*** Pulling It All Together

* TODO 19 Error Handling
** Error Handling with Data Types
*** Use of Maybe
*** Use of Either
** Exceptions
*** First Steps with Exceptions
*** Laziness and Exception Handling
*** Using handle
*** Selective Handling of Exceptions
*** I/O Exceptions
*** Throwing Exceptions
*** Dynamic Exceptions
** Error Handling in Monads
*** A Tiny Parsing Framework
* TODO 20 Systems Programming in Haskell
** Running External Programs
** Directory and File Information
** Program Termination
** Dates and Times
*** ClockTime and CalendarTime
*** File Modification Times
** Extended Example: Piping
*** Using Pipes for Redirection
*** Better Piping
*** Final Words on Pipes

* TODO 21 Using Databases
** Overview of HDBC
** Installing HDBC and Drivers
** Connecting to Databases
** Transactions
** Simple Queries
** SqlValue
** Query Parameters
** Prepared Statements
** Reading Results
*** Reading with Statements
*** Lazy Reading
** Database Metadata
** Error Handling
* TODO 22 Extended Example: Web Client Programming
** Basic Types
** The Database
** The Parser
** Downloading
** Main Program
* TODO 23 GUI Programming with gtk2hs
** Installing gtk2hs
** Overview of the GTK+ Stack
** User Interface Design with Glade
*** Glade Concepts
** Event-Driven Programming
** Initializing the GUI
** The Add Podcast Window
** Long-Running Tasks
** Using Cabal
* TODO 24 Concurrent and Multicore Programming
** Defining Concurrency and Parallelism
** Concurrent Programming with Threads
*** Threads Are Nondeterministic
*** Hiding Latency
** Simple Communication Between Threads
** The Main Thread and Waiting for Other Threads
*** Safely Modifying an MVar
*** Safe Resource Management: A Good Idea, and Easy Besides
*** Finding the Status of a Thread
*** Writing Tighter Code
** Communicating over Channels
** Useful Things to Know About
*** MVar and Chan Are Nonstrict
*** Chan Is Unbounded
** Shared-State Concurrency Is Still Hard
*** Deadlock
*** Starvation
*** Is There Any Hope?
** Using Multiple Cores with GHC
*** Runtime Options
*** Finding the Number of Available Cores from Haskell
*** Choosing the Right Runtime
** Parallel Programming in Haskell
*** Normal Form and Head Normal Form
*** Sequential Sorting
*** Transforming Our Code into Parallel Code
*** Knowing What to Evaluate in Parallel
*** What Promises Does par Make?
*** Running Our Code and Measuring Performance
*** Tuning for Performance
** Parallel Strategies and MapReduce
*** Separating Algorithm from Evaluation
*** Separating Algorithm from Strategy
*** Writing a Simple MapReduce Definition
*** MapReduce and Strategies
*** Sizing Work Appropriately
*** Efficiently Finding Line-Aligned Chunks
*** Counting Lines
*** Finding the Most Popular URLs
*** Conclusions
* TODO 25 Profiling and Optimization
** Profiling Haskell Programs
*** Collecting Runtime Statistics
*** Time Profiling
*** Space Profiling
** Controlling Evaluation
*** Strictness and Tail Recursion
*** Adding Strictness
** Understanding Core
** Advanced Techniques: Fusion
*** Tuning the Generated Assembly
** Conclusions
* TODO 26 Advanced Library Design: Building a Bloom Filter
** Introducing the Bloom Filter
** Use Cases and Package Layout
** Basic Design
*** Unboxing, Lifting, and Bottom
** The ST Monad
** Designing an API for Qualified Import
** Creating a Mutable Bloom Filter
** The Immutable API
** Creating a Friendly Interface
*** Re-Exporting Names for Convenience
*** Hashing Values
*** Turning Two Hashes into Many
*** Implementing the Easy Creation Function
** Creating a Cabal Package
*** Dealing with Different Build Setups
*** Compilation Options and Interfacing to C
** Testing with QuickCheck
*** Polymorphic Testing
*** Writing Arbitrary Instances for ByteStrings
*** Are Suggested Sizes Correct?
** Performance Analysis and Tuning
*** Profile-Driven Performance Tuning
* TODO 27 Sockets and Syslog
** Basic Networking
** Communicating with UDP
*** UDP Client Example: syslog
*** UDP Syslog Server
** Communicating with TCP
*** Handling Multiple TCP Streams
*** TCP Syslog Server
*** TCP Syslog Client

* TODO 28 Software Transactional Memory - 623
** The Basics - 623
** Some Simple Examples - 624
** STM and Safety - 626
** Retrying a Transaction - 626
*** What Happens When We Retry? - 628

** Choosing Between Alternatives - 628
*** Using Higher Order Code with Transactions - 628

** I/O and STM - 629
** Communication Between Threads - 630
** A Concurrent Web Link Checker - 631
*** Checking a Link - 633
*** Worker Threads - 634
*** Finding Links - 635
*** Command-Line Parsing - 636
*** Pattern Guards - 637

** Practical Aspects of STM - 638
*** Getting Comfortable with Giving Up Control - 638
*** Using Invariants - 639

* TODO A. Installing GHC and Haskell Libraries - 641
** DONE Installing GHC - 641
   CLOSED: [2018-04-08 Sun 11:47]
   =From Jian=  Don't follow this section! Always use /stack/!!!

*** Windows - 641
*** Mac OS X - 642
**** Alternatives - 643

*** Ubuntu and Debian Linux - 643
*** Fedora Linux - 645
*** FreeBSD - 645

** TODO Installing Haskell Software - 646
*** Automated Download and Installation with /cabal/ - 646
**** Installing cabal - 646
**** Updating cabal's package list - 646
**** Installing a library or program - 646
    
*** Building Packages by Hand - 647

* TODO B. Characters, Strings, and Escaping Rules - 649
** Writing Character and String Literals - 649
** International Language Support - 649
** Escaping Text - 650
*** Single-Character Escape Codes - 650
*** Multiline String Literals - 651
*** ASCII Control Codes - 651
*** Control-with-Character Escapes - 652
*** Numeric Escapes - 652
*** The Zero-Width Escape Sequence - 653

* Tips
