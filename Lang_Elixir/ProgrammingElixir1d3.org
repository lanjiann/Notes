#+TITLE: Programming Elixir \ge{} 1.6
#+SUBTITLE: Functional |> Concurrent |> Pragmatic |> Fun
#+AUTHOR: Dave Thomas
#+Foreword by: José Valim
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Foreword - ?][Foreword - ?]]
- [[A Vain Attempt at a Justification - ?][A Vain Attempt at a Justification - ?]]
  - [[Acknowledgments - ?][Acknowledgments - ?]]
- [[1. Take the Red Pill - 1][1. Take the Red Pill - 1]]
  - [[Programming Should Be About Transforming Data - 1][Programming Should Be About Transforming Data - 1]]
  - [[Installing Elixir - 4][Installing Elixir - 4]]
  - [[Running Elixir - 4][Running Elixir - 4]]
  - [[Suggestions for Reading the Book - 9][Suggestions for Reading the Book - 9]]
  - [[Exercises - 10][Exercises - 10]]
  - [[Think Different(ly) - 10][Think Different(ly) - 10]]
- [[Part I. Conventional Programming][Part I. Conventional Programming]]
- [[2. Pattern Matching - 13][2. Pattern Matching - 13]]
  - [[Assignment: I Do Not Think It Means What You Think It Means - 13][Assignment: I Do Not Think It Means What You Think It Means - 13]]
  - [[More Complex Matches - 14][More Complex Matches - 14]]
  - [[Ignoring a Value with _ (Underscore) - 16][Ignoring a Value with _ (Underscore) - 16]]
  - [[Variables Bind Once (per Match) - 16][Variables Bind Once (per Match) - 16]]
  - [[Another Way of Looking at the Equals Sign - 18][Another Way of Looking at the Equals Sign - 18]]
- [[3. Immutability - 19][3. Immutability - 19]]
  - [[You Already Have (Some) Immutable Data - 19][You Already Have (Some) Immutable Data - 19]]
  - [[Immutable Data Is Known Data - 20][Immutable Data Is Known Data - 20]]
  - [[Performance Implications of Immutability - 21][Performance Implications of Immutability - 21]]
  - [[Coding with Immutable Data - 22][Coding with Immutable Data - 22]]
- [[4. Elixir Basics - 23][4. Elixir Basics - 23]]
  - [[Built-in Types - 23][Built-in Types - 23]]
  - [[Value Types - 24][Value Types - 24]]
  - [[System Types - 26][System Types - 26]]
  - [[Collection Types - 26][Collection Types - 26]]
  - [[Maps - 29][Maps - 29]]
  - [[Binaries - 30][Binaries - 30]]
  - [[Dates and Times - 31][Dates and Times - 31]]
  - [[Names, Source Files, Conventions, Operators, and So On - 32][Names, Source Files, Conventions, Operators, and So On - 32]]
  - [[Variable Scope - 34][Variable Scope - 34]]
  - [[End of the Basics - 36][End of the Basics - 36]]
- [[5. Anonymous Functions - 37][5. Anonymous Functions - 37]]
  - [[Functions and Pattern Matching - 38][Functions and Pattern Matching - 38]]
  - [[One Function, Multiple Bodies - 39][One Function, Multiple Bodies - 39]]
  - [[Functions Can Return Functions - 41][Functions Can Return Functions - 41]]
  - [[Passing Functions As Arguments - 43][Passing Functions As Arguments - 43]]
  - [[Functions Are the Core - 46][Functions Are the Core - 46]]
- [[6. Modules and Named Functions - 47][6. Modules and Named Functions - 47]]
  - [[Compiling a Module - 47][Compiling a Module - 47]]
  - [[The Function’s Body Is a Block - 48][The Function’s Body Is a Block - 48]]
  - [[Function Calls and Pattern Matching - 49][Function Calls and Pattern Matching - 49]]
  - [[Guard Clauses - 52][Guard Clauses - 52]]
  - [[Default Parameters - 53][Default Parameters - 53]]
  - [[Private Functions - 57][Private Functions - 57]]
  - [[The Amazing Pipe Operator: ~|>~ - 58][The Amazing Pipe Operator: ~|>~ - 58]]
  - [[Modules - 59][Modules - 59]]
  - [[Module Attributes - 62][Module Attributes - 62]]
  - [[Module Names: Elixir, Erlang, and Atoms - 63][Module Names: Elixir, Erlang, and Atoms - 63]]
  - [[Calling a Function in an Erlang Library - 63][Calling a Function in an Erlang Library - 63]]
  - [[Finding Libraries - 64][Finding Libraries - 64]]
- [[7. Lists and Recursion - 65][7. Lists and Recursion - 65]]
  - [[Heads and Tails - 65][Heads and Tails - 65]]
  - [[Using Head and Tail to Process a List - 66][Using Head and Tail to Process a List - 66]]
  - [[Using Head and Tail to Build a List - 68][Using Head and Tail to Build a List - 68]]
  - [[Creating a Map Function - 69][Creating a Map Function - 69]]
  - [[Reducing a List to a Single Value - ??][Reducing a List to a Single Value - ??]]
  - [[More Complex List Patterns - 73][More Complex List Patterns - 73]]
  - [[The List Module in Action - 76][The List Module in Action - 76]]
  - [[Get Friendly with Lists - 77][Get Friendly with Lists - 77]]
- [[8. Maps, Keyword Lists, Sets, and Structs - 79][8. Maps, Keyword Lists, Sets, and Structs - 79]]
  - [[How to Choose Between Maps, Structs, and Keyword Lists - 79][How to Choose Between Maps, Structs, and Keyword Lists - 79]]
  - [[Keyword Lists - 79][Keyword Lists - 79]]
  - [[Maps - 80][Maps - 80]]
  - [[Pattern Matching and Updating Maps - 81][Pattern Matching and Updating Maps - 81]]
  - [[Updating a Map - 83][Updating a Map - 83]]
  - [[Structs - 83][Structs - 83]]
  - [[Nested Dictionary Structures - 85][Nested Dictionary Structures - 85]]
  - [[Sets - 90][Sets - 90]]
  - [[With Great Power Comes Great Temptation - 91][With Great Power Comes Great Temptation - 91]]
- [[9. An Aside -- What Are Types? - 93][9. An Aside -- What Are Types? - 93]]
- [[10. Processing Collections—Enum and Stream - 95][10. Processing Collections—Enum and Stream - 95]]
  - [[Enum -- Processing Collections - 95][Enum -- Processing Collections - 95]]
  - [[Streams -- Lazy Enumerables - 99][Streams -- Lazy Enumerables - 99]]
  - [[The Collectable Protocol - 106][The Collectable Protocol - 106]]
  - [[Comprehensions - 107][Comprehensions - 107]]
  - [[Moving Past Divinity - 111][Moving Past Divinity - 111]]
- [[11. Strings and Binaries - 113][11. Strings and Binaries - 113]]
  - [[String Literals - 113][String Literals - 113]]
  - [[The Name "strings" - 116][The Name "strings" - 116]]
  - [[Single-Quoted Strings -- Lists of Character Codes - 117][Single-Quoted Strings -- Lists of Character Codes - 117]]
  - [[Binaries - 119][Binaries - 119]]
  - [[Double-Quoted Strings Are Binaries - 120][Double-Quoted Strings Are Binaries - 120]]
  - [[Binaries and Pattern Matching - 126][Binaries and Pattern Matching - 126]]
  - [[Familiar Yet Strange - 127][Familiar Yet Strange - 127]]
- [[12. Control Flow - 129][12. Control Flow - 129]]
  - [[~if~ and ~unless~ - 129][~if~ and ~unless~ - 129]]
  - [[~cond~ - 130][~cond~ - 130]]
  - [[~case~ - 133][~case~ - 133]]
  - [[Raising Exceptions - 134][Raising Exceptions - 134]]
  - [[Designing with Exceptions - 134][Designing with Exceptions - 134]]
  - [[Doing More with Less - 135][Doing More with Less - 135]]
- [[13. Organizing a Project - 137][13. Organizing a Project - 137]]
  - [[The Project: Fetch Issues from GitHub - 137][The Project: Fetch Issues from GitHub - 137]]
  - [[Step 1: Use Mix to Create Our New Project - 138][Step 1: Use Mix to Create Our New Project - 138]]
  - [[Transformation: Parse the Command Line - 141][Transformation: Parse the Command Line - 141]]
  - [[Write Some Basic Tests - 142][Write Some Basic Tests - 142]]
  - [[Transformation: Fetch from GitHub - 144][Transformation: Fetch from GitHub - 144]]
  - [[Step 2: Use Libraries - 145][Step 2: Use Libraries - 145]]
  - [[Transformation: Convert Response - 150][Transformation: Convert Response - 150]]
  - [[Transformation: Sort Data - 152][Transformation: Sort Data - 152]]
  - [[Transformation: Take First n Items - 154][Transformation: Take First n Items - 154]]
  - [[Transformation: Format the Table - 154][Transformation: Format the Table - 154]]
  - [[Step 3: Make a Command-Line Executable - 157][Step 3: Make a Command-Line Executable - 157]]
  - [[Step 4: Add Some Logging - 158][Step 4: Add Some Logging - 158]]
  - [[Step 5: Create Project Documentation - 160][Step 5: Create Project Documentation - 160]]
  - [[Coding by Transforming Data - 161][Coding by Transforming Data - 161]]
- [[14. Tooling - 165][14. Tooling - 165]]
  - [[Debugging with IEx - ???][Debugging with IEx - ???]]
  - [[Testing - 165][Testing - 165]]
  - [[Code Dependencies - 178][Code Dependencies - 178]]
  - [[Server Monitoring - 179][Server Monitoring - 179]]
  - [[Source-Code Formatting - ???][Source-Code Formatting - ???]]
  - [[Inevitably, There's More - 182][Inevitably, There's More - 182]]
- [[Part II. Concurrent Programming][Part II. Concurrent Programming]]
- [[15. Working with Multiple Processes - 185][15. Working with Multiple Processes - 185]]
  - [[A Simple Process][A Simple Process]]
  - [[Process Overhead][Process Overhead]]
  - [[When Processes Die][When Processes Die]]
  - [[Parallel Map -- The "Hello, World" of Erlang][Parallel Map -- The "Hello, World" of Erlang]]
  - [[A Fibonacci Server][A Fibonacci Server]]
  - [[Agents -- A Teaser][Agents -- A Teaser]]
  - [[Thinking in Processes][Thinking in Processes]]
- [[16. Nodes -- The Key to Distributing Services - 207][16. Nodes -- The Key to Distributing Services - 207]]
  - [[Naming Nodes][Naming Nodes]]
  - [[Naming Your Processes][Naming Your Processes]]
  - [[Input, Output, PIDs, and Nodes][Input, Output, PIDs, and Nodes]]
  - [[Nodes Are the Basis of Distribution][Nodes Are the Basis of Distribution]]
- [[17. OTP: Servers - 217][17. OTP: Servers - 217]]
  - [[Some OTP Definitions][Some OTP Definitions]]
  - [[An OTP Server][An OTP Server]]
  - [[GenServer Callbacks][GenServer Callbacks]]
  - [[Naming a Process][Naming a Process]]
  - [[Tidying Up the Interface][Tidying Up the Interface]]
  - [[Making Our Server into a Component][Making Our Server into a Component]]
- [[18. OTP: Supervisors - 231][18. OTP: Supervisors - 231]]
  - [[Supervisors and Workers][Supervisors and Workers]]
  - [[Worker Restart Options][Worker Restart Options]]
  - [[Supervisors Are the Heart of Reliability][Supervisors Are the Heart of Reliability]]
- [[19. A More Complex Example - ???][19. A More Complex Example - ???]]
  - [[Introduction to Duper - ???][Introduction to Duper - ???]]
  - [[The Duper Application - ???][The Duper Application - ???]]
  - [[But Does It Work? - ???][But Does It Work? - ???]]
  - [[Planning Your Elixir Application - ???][Planning Your Elixir Application - ???]]
  - [[Next Up - ???][Next Up - ???]]
- [[20. OTP: Applications - 241][20. OTP: Applications - 241]]
  - [[This Is Not Your Father's Application][This Is Not Your Father's Application]]
  - [[The Application Specification File][The Application Specification File]]
  - [[Turning Our Sequence Program into an OTP Application][Turning Our Sequence Program into an OTP Application]]
  - [[Supervision Is the Basis of Reliability][Supervision Is the Basis of Reliability]]
  - [[Releasing Your Code][Releasing Your Code]]
  - [[Distillery -- The Elixir Release Manager][Distillery -- The Elixir Release Manager]]
  - [[OTP Is Big -- Unbelievably Big][OTP Is Big -- Unbelievably Big]]
- [[21. Tasks and Agents - 257][21. Tasks and Agents - 257]]
  - [[Tasks - 257][Tasks - 257]]
  - [[Agents - 258][Agents - 258]]
  - [[A Bigger Example - 261][A Bigger Example - 261]]
  - [[Agents and Tasks, or GenServer? - 263][Agents and Tasks, or GenServer? - 263]]
- [[Part III — More Advanced Elixir][Part III — More Advanced Elixir]]
- [[22. Macros and Code Evaluation - 267][22. Macros and Code Evaluation - 267]]
  - [[Implementing an if Statement - 267][Implementing an if Statement - 267]]
  - [[Macros Inject Code - 269][Macros Inject Code - 269]]
  - [[Using the Representation as Code - 271][Using the Representation as Code - 271]]
  - [[Using Bindings to Inject Values - 276][Using Bindings to Inject Values - 276]]
  - [[Macros Are Hygienic - 277][Macros Are Hygienic - 277]]
  - [[Other Ways to Run Code Fragments - 278][Other Ways to Run Code Fragments - 278]]
  - [[Macros and Operators - 279][Macros and Operators - 279]]
  - [[Digging Deeper - 280][Digging Deeper - 280]]
  - [[Digging Ridiculously Deep - 280][Digging Ridiculously Deep - 280]]
- [[23. Linking Modules: Behavio(u)rs and Use - 283][23. Linking Modules: Behavio(u)rs and Use - 283]]
  - [[Behaviours - 283][Behaviours - 283]]
  - [[use and __using__ - 285][use and __using__ - 285]]
  - [[Putting It Together -- Tracing Method Calls - 286][Putting It Together -- Tracing Method Calls - 286]]
  - [[Use use - 289][Use use - 289]]
- [[24. Protocols -- Polymorphic Functions - 291][24. Protocols -- Polymorphic Functions - 291]]
  - [[Defining a Protocol - 291][Defining a Protocol - 291]]
  - [[Implementing a Protocol - 292][Implementing a Protocol - 292]]
  - [[The Available Types - 293][The Available Types - 293]]
  - [[Protocols and Structs - 294][Protocols and Structs - 294]]
  - [[Built-In Protocols - 295][Built-In Protocols - 295]]
  - [[Protocols Are Polymorphism - 302][Protocols Are Polymorphism - 302]]
- [[25. More Cool Stuff - 305][25. More Cool Stuff - 305]]
  - [[Writing Your Own Sigils - 305][Writing Your Own Sigils - 305]]
  - [[Multi-app Umbrella Projects - 309][Multi-app Umbrella Projects - 309]]
  - [[But Wait! There's More! - 313][But Wait! There's More! - 313]]
- [[A1. Exceptions: raise and try, catch and throw - 315][A1. Exceptions: raise and try, catch and throw - 315]]
  - [[Raising an Exception - 315][Raising an Exception - 315]]
  - [[catch, exit, and throw - 317][catch, exit, and throw - 317]]
  - [[Defining Your Own Exceptions - 318][Defining Your Own Exceptions - 318]]
  - [[Now Ignore This Appendix - 319][Now Ignore This Appendix - 319]]
- [[A2. Type Specifications and Type Checking - 321][A2. Type Specifications and Type Checking - 321]]
  - [[When Specifications Are Used - 321][When Specifications Are Used - 321]]
  - [[Specifying a Type - 322][Specifying a Type - 322]]
  - [[Defining New Types - 324][Defining New Types - 324]]
  - [[Specs for Functions and Callbacks - 325][Specs for Functions and Callbacks - 325]]
  - [[Using Dialyzer - 326][Using Dialyzer - 326]]
- [[Bibliography - 333][Bibliography - 333]]
- [[Index - 335][Index - 335]]

* Foreword - ?
* A Vain Attempt at a Justification - ?
** Acknowledgments - ?

* TODO 1. Take the Red Pill - 1
** TODO Programming Should Be About Transforming Data - 1
** TODO Installing Elixir - 4 
** TODO Running Elixir - 4 
** TODO Suggestions for Reading the Book - 9 
** TODO Exercises - 10
** TODO Think Different(ly) - 10

* TODO Part I. Conventional Programming
* TODO 2. Pattern Matching - 13
** Assignment: I Do Not Think It Means What You Think It Means - 13
** More Complex Matches - 14
** Ignoring a Value with _ (Underscore) - 16
** Variables Bind Once (per Match) - 16
** Another Way of Looking at the Equals Sign - 18

* TODO 3. Immutability - 19
** You Already Have (Some) Immutable Data - 19
** Immutable Data Is Known Data - 20
** Performance Implications of Immutability - 21
** Coding with Immutable Data - 22

* TODO 4. Elixir Basics - 23
** Built-in Types - 23
** Value Types - 24
** System Types - 26
** Collection Types - 26
** Maps - 29
** Binaries - 30
** Dates and Times - 31
** Names, Source Files, Conventions, Operators, and So On - 32
** Variable Scope - 34
** End of the Basics - 36

* TODO 5. Anonymous Functions - 37
** Functions and Pattern Matching - 38
** One Function, Multiple Bodies - 39
** Functions Can Return Functions - 41
** Passing Functions As Arguments - 43
** Functions Are the Core - 46

* TODO 6. Modules and Named Functions - 47
** Compiling a Module - 47
** The Function’s Body Is a Block - 48
** Function Calls and Pattern Matching - 49
** Guard Clauses - 52
** Default Parameters - 53
** Private Functions - 57
** The Amazing Pipe Operator: ~|>~ - 58
** Modules - 59
** Module Attributes - 62
** Module Names: Elixir, Erlang, and Atoms - 63
** Calling a Function in an Erlang Library - 63
** Finding Libraries - 64

* TODO 7. Lists and Recursion - 65
** Heads and Tails - 65
** Using Head and Tail to Process a List - 66
** Using Head and Tail to Build a List - 68
** Creating a Map Function - 69
** Reducing a List to a Single Value - ??
** More Complex List Patterns - 73
** The List Module in Action - 76
** Get Friendly with Lists - 77

* TODO 8. Maps, Keyword Lists, Sets, and Structs - 79
** How to Choose Between Maps, Structs, and Keyword Lists - 79
** Keyword Lists - 79
** Maps - 80
** Pattern Matching and Updating Maps - 81
** Updating a Map - 83
** Structs - 83
** Nested Dictionary Structures - 85
** Sets - 90
** With Great Power Comes Great Temptation - 91

* TODO 9. An Aside -- What Are Types? - 93
* TODO 10. Processing Collections—Enum and Stream - 95
** Enum -- Processing Collections - 95
** Streams -- Lazy Enumerables - 99
** The Collectable Protocol - 106
** Comprehensions - 107
** Moving Past Divinity - 111

* TODO 11. Strings and Binaries - 113
** String Literals - 113
** The Name "strings" - 116
** Single-Quoted Strings -- Lists of Character Codes - 117
** Binaries - 119
** Double-Quoted Strings Are Binaries - 120
** Binaries and Pattern Matching - 126
** Familiar Yet Strange - 127

* TODO 12. Control Flow - 129
** ~if~ and ~unless~ - 129
** ~cond~ - 130
** ~case~ - 133
** Raising Exceptions - 134
** Designing with Exceptions - 134
** Doing More with Less - 135

* TODO 13. Organizing a Project - 137
** The Project: Fetch Issues from GitHub - 137
** Step 1: Use Mix to Create Our New Project - 138
** Transformation: Parse the Command Line - 141
** Write Some Basic Tests - 142
** Transformation: Fetch from GitHub - 144
** Step 2: Use Libraries - 145
** Transformation: Convert Response - 150
** Transformation: Sort Data - 152
** Transformation: Take First n Items - 154
** Transformation: Format the Table - 154
** Step 3: Make a Command-Line Executable - 157
** Step 4: Add Some Logging - 158
** Step 5: Create Project Documentation - 160
** Coding by Transforming Data - 161

* TODO 14. Tooling - 165
** Debugging with IEx - ???
** Testing - 165
** Code Dependencies - 178
** Server Monitoring - 179
** Source-Code Formatting - ???
** Inevitably, There's More - 182

* Part II. Concurrent Programming
* TODO 15. Working with Multiple Processes - 185
** A Simple Process
** Process Overhead
** When Processes Die
** Parallel Map -- The "Hello, World" of Erlang
** A Fibonacci Server
** Agents -- A Teaser
** Thinking in Processes

* TODO 16. Nodes -- The Key to Distributing Services - 207
** Naming Nodes
** Naming Your Processes
** Input, Output, PIDs, and Nodes
** Nodes Are the Basis of Distribution

* TODO 17. OTP: Servers - 217
** Some OTP Definitions
** An OTP Server
** GenServer Callbacks
** Naming a Process
** Tidying Up the Interface
** Making Our Server into a Component

* TODO 18. OTP: Supervisors - 231
** Supervisors and Workers
** Worker Restart Options
** Supervisors Are the Heart of Reliability

* TODO 19. A More Complex Example - ???
** Introduction to Duper - ???
** The Duper Application - ???
** But Does It Work? - ???
** Planning Your Elixir Application - ???
** Next Up - ???

* TODO 20. OTP: Applications - 241
** This Is Not Your Father's Application
** The Application Specification File
** Turning Our Sequence Program into an OTP Application
** Supervision Is the Basis of Reliability
** Releasing Your Code
** Distillery -- The Elixir Release Manager
** OTP Is Big -- Unbelievably Big

* TODO 21. Tasks and Agents - 257
** Tasks - 257
** Agents - 258
** A Bigger Example - 261
** Agents and Tasks, or GenServer? - 263

* TODO Part III — More Advanced Elixir
* TODO 22. Macros and Code Evaluation - 267
** Implementing an if Statement - 267
** Macros Inject Code - 269
** Using the Representation as Code - 271
** Using Bindings to Inject Values - 276
** Macros Are Hygienic - 277
** Other Ways to Run Code Fragments - 278
** Macros and Operators - 279
** Digging Deeper - 280
** Digging Ridiculously Deep - 280

* TODO 23. Linking Modules: Behavio(u)rs and Use - 283
** Behaviours - 283
** use and __using__ - 285
** Putting It Together -- Tracing Method Calls - 286
** Use use - 289

* TODO 24. Protocols -- Polymorphic Functions - 291
** Defining a Protocol - 291
** Implementing a Protocol - 292
** The Available Types - 293
** Protocols and Structs - 294
** Built-In Protocols - 295
** Protocols Are Polymorphism - 302

* TODO 25. More Cool Stuff - 305
** Writing Your Own Sigils - 305
** Multi-app Umbrella Projects - 309
** But Wait! There's More! - 313

* TODO A1. Exceptions: raise and try, catch and throw - 315
** Raising an Exception - 315
** catch, exit, and throw - 317
** Defining Your Own Exceptions - 318
** Now Ignore This Appendix - 319

* TODO A2. Type Specifications and Type Checking - 321
** When Specifications Are Used - 321
** Specifying a Type - 322
** Defining New Types - 324
** Specs for Functions and Callbacks - 325
** Using Dialyzer - 326

* Bibliography - 333
* Index - 335
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
