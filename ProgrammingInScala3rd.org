#+TITLE: Programming in Scala
#+SUBTITLE: A comprehensive step-by-step guide
#+VERSION: 3rd
#+AUTHOR: Martin Odersky, Lex Spoon, Bill Venners
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Contents][Contents]]
- [[List of Figures][List of Figures]]
- [[List of Tables][List of Tables]]
- [[List of Listings][List of Listings]]
- [[Foreword][Foreword]]
- [[Acknowledgments][Acknowledgments]]
- [[Introduction][Introduction]]
- [[1 A Scalable Language][1 A Scalable Language]]
  - [[1.1 A language that grows on you][1.1 A language that grows on you]]
  - [[1.2 What makes Scala scalable?][1.2 What makes Scala scalable?]]
  - [[1.3 Why Scala?][1.3 Why Scala?]]
  - [[1.4 Scala's roots][1.4 Scala's roots]]
  - [[1.5 Conclusion][1.5 Conclusion]]
- [[2 First Steps in Scala][2 First Steps in Scala]]
  - [[Step 1. Learn to use the Scala interpreter][Step 1. Learn to use the Scala interpreter]]
  - [[Step 2. Define some variables][Step 2. Define some variables]]
  - [[Step 3. Define some functions][Step 3. Define some functions]]
  - [[Step 4. Write some Scala scripts][Step 4. Write some Scala scripts]]
  - [[Step 5. Loop with while; decide with if][Step 5. Loop with while; decide with if]]
  - [[Step 6. Iterate with foreach and for][Step 6. Iterate with foreach and for]]
  - [[Conclusion][Conclusion]]
- [[3 Next Steps in Scala][3 Next Steps in Scala]]
  - [[Step 7. Parameterize arrays with types][Step 7. Parameterize arrays with types]]
  - [[Step 8. Use lists][Step 8. Use lists]]
  - [[Step 9. Use tuples][Step 9. Use tuples]]
  - [[Step 10. Use sets and maps][Step 10. Use sets and maps]]
  - [[Step 11. Learn to recognize the functional style][Step 11. Learn to recognize the functional style]]
  - [[Step 12. Read lines from a file][Step 12. Read lines from a file]]
  - [[Conclusion][Conclusion]]
- [[4 Classes and Objects][4 Classes and Objects]]
  - [[4.1 Classes, fields, and methods][4.1 Classes, fields, and methods]]
  - [[4.2 Semicolon inference][4.2 Semicolon inference]]
  - [[4.3 Singleton objects][4.3 Singleton objects]]
  - [[4.4 A Scala application][4.4 A Scala application]]
  - [[4.5 The App trait][4.5 The App trait]]
  - [[4.6 Conclusion][4.6 Conclusion]]
- [[5 Basic Types and Operations][5 Basic Types and Operations]]
  - [[5.1 Some basic types][5.1 Some basic types]]
  - [[5.2 Literals][5.2 Literals]]
  - [[5.3 String interpolation][5.3 String interpolation]]
  - [[5.4 Operators are methods][5.4 Operators are methods]]
  - [[5.5 Arithmetic operations][5.5 Arithmetic operations]]
  - [[5.6 Relational and logical operations][5.6 Relational and logical operations]]
  - [[5.7 Bitwise operations][5.7 Bitwise operations]]
  - [[5.8 Object equality][5.8 Object equality]]
  - [[5.9 Operator precedence and associativity][5.9 Operator precedence and associativity]]
  - [[5.10 Rich wrappers][5.10 Rich wrappers]]
  - [[5.11 Conclusion][5.11 Conclusion]]
- [[6 Functional Objects][6 Functional Objects]]
  - [[6.1 A specification for class Rational][6.1 A specification for class Rational]]
  - [[6.2 Constructing a Rational][6.2 Constructing a Rational]]
  - [[6.3 Reimplementing the toString method][6.3 Reimplementing the toString method]]
  - [[6.4 Checking preconditions][6.4 Checking preconditions]]
  - [[6.5 Adding fields][6.5 Adding fields]]
  - [[6.6 Self references][6.6 Self references]]
  - [[6.7 Auxiliary constructors][6.7 Auxiliary constructors]]
  - [[6.8 Private fields and methods][6.8 Private fields and methods]]
  - [[6.9 Defining operators][6.9 Defining operators]]
  - [[6.10 Identifiers in Scala][6.10 Identifiers in Scala]]
  - [[6.11 Method overloading][6.11 Method overloading]]
  - [[6.12 Implicit conversions][6.12 Implicit conversions]]
  - [[6.13 A word of caution][6.13 A word of caution]]
  - [[6.14 Conclusion][6.14 Conclusion]]
- [[7 Built-in Control Structures][7 Built-in Control Structures]]
  - [[7.1 If expressions][7.1 If expressions]]
  - [[7.2 While loops][7.2 While loops]]
  - [[7.3 For expressions][7.3 For expressions]]
  - [[7.4 Exception handling with try expressions][7.4 Exception handling with try expressions]]
  - [[7.5 Match expressions][7.5 Match expressions]]
  - [[7.6 Living without break and continue][7.6 Living without break and continue]]
  - [[7.7 Variable scope][7.7 Variable scope]]
  - [[7.8 Refactoring imperative-style code][7.8 Refactoring imperative-style code]]
  - [[7.9 Conclusion][7.9 Conclusion]]
- [[8 Functions and Closures][8 Functions and Closures]]
  - [[8.1 Methods][8.1 Methods]]
  - [[8.2 Local functions][8.2 Local functions]]
  - [[8.3 First-class functions][8.3 First-class functions]]
  - [[8.4 Short forms of function literals][8.4 Short forms of function literals]]
  - [[8.5 Placeholder syntax][8.5 Placeholder syntax]]
  - [[8.6 Partially applied functions][8.6 Partially applied functions]]
  - [[8.7 Closures][8.7 Closures]]
  - [[8.8 Special function call forms][8.8 Special function call forms]]
  - [[8.9 Tail recursion][8.9 Tail recursion]]
  - [[8.10 Conclusion][8.10 Conclusion]]
- [[9 Control Abstraction][9 Control Abstraction]]
  - [[9.1 Reducing code duplication][9.1 Reducing code duplication]]
  - [[9.2 Simplifying client code][9.2 Simplifying client code]]
  - [[9.3 Currying][9.3 Currying]]
  - [[9.4 Writing new control structures][9.4 Writing new control structures]]
  - [[9.5 By-name parameters][9.5 By-name parameters]]
  - [[9.6 Conclusion][9.6 Conclusion]]
- [[10 Composition and Inheritance][10 Composition and Inheritance]]
  - [[10.1 A two-dimensional layout library][10.1 A two-dimensional layout library]]
  - [[10.2 Abstract classes][10.2 Abstract classes]]
  - [[10.3 Defining parameterless methods][10.3 Defining parameterless methods]]
  - [[10.4 Extending classes][10.4 Extending classes]]
  - [[10.5 Overriding methods and fields][10.5 Overriding methods and fields]]
  - [[10.6 Defining parametric fields][10.6 Defining parametric fields]]
  - [[10.7 Invoking superclass constructors][10.7 Invoking superclass constructors]]
  - [[10.8 Using override modifiers][10.8 Using override modifiers]]
  - [[10.9 Polymorphism and dynamic binding][10.9 Polymorphism and dynamic binding]]
  - [[10.10 Declaring final members][10.10 Declaring final members]]
  - [[10.11 Using composition and inheritance][10.11 Using composition and inheritance]]
  - [[10.12 Implementing above, beside, and toString][10.12 Implementing above, beside, and toString]]
  - [[10.13 Defining a factory object][10.13 Defining a factory object]]
  - [[10.14 Heighten and widen][10.14 Heighten and widen]]
  - [[10.15 Putting it all together][10.15 Putting it all together]]
  - [[10.16 Conclusion][10.16 Conclusion]]
- [[11 Scala's Hierarchy][11 Scala's Hierarchy]]
  - [[11.1 Scala's class hierarchy][11.1 Scala's class hierarchy]]
  - [[11.2 How primitives are implemented][11.2 How primitives are implemented]]
  - [[11.3 Bottom types][11.3 Bottom types]]
  - [[11.4 Defining your own value classes][11.4 Defining your own value classes]]
  - [[11.5 Conclusion][11.5 Conclusion]]
- [[12 Traits][12 Traits]]
  - [[12.1 How traits work][12.1 How traits work]]
  - [[12.2 Thin versus rich interfaces][12.2 Thin versus rich interfaces]]
  - [[12.3 Example: Rectangular objects][12.3 Example: Rectangular objects]]
  - [[12.4 The Ordered trait][12.4 The Ordered trait]]
  - [[12.5 Traits as stackable modifications][12.5 Traits as stackable modifications]]
  - [[12.6 Why not multiple inheritance?][12.6 Why not multiple inheritance?]]
  - [[12.7 To trait or not to trait?][12.7 To trait or not to trait?]]
  - [[12.8 Conclusion][12.8 Conclusion]]
- [[13 Packages and Imports][13 Packages and Imports]]
  - [[13.1 Putting code in packages][13.1 Putting code in packages]]
  - [[13.2 Concise access to related code][13.2 Concise access to related code]]
  - [[13.3 Imports][13.3 Imports]]
  - [[13.4 Implicit imports][13.4 Implicit imports]]
  - [[13.5 Access modifiers][13.5 Access modifiers]]
  - [[13.6 Package objects][13.6 Package objects]]
  - [[13.7 Conclusion][13.7 Conclusion]]
- [[14 Assertions and Tests][14 Assertions and Tests]]
  - [[14.1 Assertions][14.1 Assertions]]
  - [[14.2 Testing in Scala][14.2 Testing in Scala]]
  - [[14.3 Informative failure reports][14.3 Informative failure reports]]
  - [[14.4 Tests as specifications][14.4 Tests as specifications]]
  - [[14.5 Property-based testing][14.5 Property-based testing]]
  - [[14.6 Organizing and running tests][14.6 Organizing and running tests]]
  - [[14.7 Conclusion][14.7 Conclusion]]
- [[15 Case Classes and Pattern Matching][15 Case Classes and Pattern Matching]]
  - [[15.1 A simple example][15.1 A simple example]]
  - [[15.2 Kinds of patterns][15.2 Kinds of patterns]]
  - [[15.3 Pattern guards][15.3 Pattern guards]]
  - [[15.4 Pattern overlaps][15.4 Pattern overlaps]]
  - [[15.5 Sealed classes][15.5 Sealed classes]]
  - [[15.6 The Option type][15.6 The Option type]]
  - [[15.7 Patterns everywhere][15.7 Patterns everywhere]]
  - [[15.8 A larger example][15.8 A larger example]]
  - [[15.9 Conclusion][15.9 Conclusion]]
- [[16 Working with Lists][16 Working with Lists]]
  - [[16.1 List literals][16.1 List literals]]
  - [[16.2 The List type][16.2 The List type]]
  - [[16.3 Constructing lists][16.3 Constructing lists]]
  - [[16.4 Basic operations on lists][16.4 Basic operations on lists]]
  - [[16.5 List patterns][16.5 List patterns]]
  - [[16.6 First-order methods on class List][16.6 First-order methods on class List]]
  - [[16.7 Higher-order methods on class List][16.7 Higher-order methods on class List]]
  - [[16.8 Methods of the List object][16.8 Methods of the List object]]
  - [[16.9 Processing multiple lists together][16.9 Processing multiple lists together]]
  - [[16.10 Understanding Scala’s type inference algorithm][16.10 Understanding Scala’s type inference algorithm]]
  - [[16.11 Conclusion][16.11 Conclusion]]
- [[17 Working with Other Collections][17 Working with Other Collections]]
  - [[17.1 Sequences][17.1 Sequences]]
  - [[17.2 Sets and maps][17.2 Sets and maps]]
  - [[17.3 Selecting mutable versus immutable collections][17.3 Selecting mutable versus immutable collections]]
  - [[17.4 Initializing collections][17.4 Initializing collections]]
  - [[17.5 Tuples][17.5 Tuples]]
  - [[17.6 Conclusion][17.6 Conclusion]]
- [[18 Mutable Objects][18 Mutable Objects]]
  - [[18.1 What makes an object mutable?][18.1 What makes an object mutable?]]
  - [[18.2 Reassignable variables and properties][18.2 Reassignable variables and properties]]
  - [[18.3 Case study: Discrete event simulation][18.3 Case study: Discrete event simulation]]
  - [[18.4 A language for digital circuits][18.4 A language for digital circuits]]
  - [[18.5 The Simulation API][18.5 The Simulation API]]
  - [[18.6 Circuit Simulation][18.6 Circuit Simulation]]
  - [[18.7 Conclusion][18.7 Conclusion]]
- [[19 Type Parameterization][19 Type Parameterization]]
  - [[19.1 Functional queues][19.1 Functional queues]]
  - [[19.2 Information hiding][19.2 Information hiding]]
  - [[19.3 Variance annotations][19.3 Variance annotations]]
  - [[19.4 Checking variance annotations][19.4 Checking variance annotations]]
  - [[19.5 Lower bounds][19.5 Lower bounds]]
  - [[19.6 Contravariance][19.6 Contravariance]]
  - [[19.7 Object private data][19.7 Object private data]]
  - [[19.8 Upper bounds][19.8 Upper bounds]]
  - [[19.9 Conclusion][19.9 Conclusion]]
- [[20 Abstract Members][20 Abstract Members]]
  - [[20.1 A quick tour of abstract members][20.1 A quick tour of abstract members]]
  - [[20.2 Type members][20.2 Type members]]
  - [[20.3 Abstract vals][20.3 Abstract vals]]
  - [[20.4 Abstract vars][20.4 Abstract vars]]
  - [[20.5 Initializing abstract vals][20.5 Initializing abstract vals]]
  - [[20.6 Abstract types][20.6 Abstract types]]
  - [[20.7 Path-dependent types][20.7 Path-dependent types]]
  - [[20.8 Refinement types][20.8 Refinement types]]
  - [[20.9 Enumerations][20.9 Enumerations]]
  - [[20.10 Case study: Currencies][20.10 Case study: Currencies]]
  - [[20.11 Conclusion][20.11 Conclusion]]
- [[21 Implicit Conversions and Parameters][21 Implicit Conversions and Parameters]]
  - [[21.1 Implicit conversions][21.1 Implicit conversions]]
  - [[21.2 Rules for implicits][21.2 Rules for implicits]]
  - [[21.3 Implicit conversion to an expected type][21.3 Implicit conversion to an expected type]]
  - [[21.4 Converting the receiver][21.4 Converting the receiver]]
  - [[21.5 Implicit parameters][21.5 Implicit parameters]]
  - [[21.6 Context bounds][21.6 Context bounds]]
  - [[21.7 When multiple conversions apply][21.7 When multiple conversions apply]]
  - [[21.8 Debugging implicits][21.8 Debugging implicits]]
  - [[21.9 Conclusion][21.9 Conclusion]]
- [[22 Implementing Lists][22 Implementing Lists]]
  - [[22.1 The List class in principle][22.1 The List class in principle]]
  - [[22.2 The ListBuffer class][22.2 The ListBuffer class]]
  - [[22.3 The List class in practice][22.3 The List class in practice]]
  - [[22.4 Functional on the outside][22.4 Functional on the outside]]
  - [[22.5 Conclusion][22.5 Conclusion]]
- [[23 For Expressions Revisited][23 For Expressions Revisited]]
  - [[23.1 For expressions][23.1 For expressions]]
  - [[23.2 The n-queens problem][23.2 The n-queens problem]]
  - [[23.3 Querying with for expressions][23.3 Querying with for expressions]]
  - [[23.4 Translation of for expressions][23.4 Translation of for expressions]]
  - [[23.5 Going the other way][23.5 Going the other way]]
  - [[23.6 Generalizing for][23.6 Generalizing for]]
  - [[23.7 Conclusion][23.7 Conclusion]]
- [[24 Collections in Depth][24 Collections in Depth]]
  - [[24.1 Mutable and immutable collections][24.1 Mutable and immutable collections]]
  - [[24.2 Collections consistency][24.2 Collections consistency]]
  - [[24.3 Trait Traversable][24.3 Trait Traversable]]
  - [[24.4 Trait Iterable][24.4 Trait Iterable]]
  - [[24.5 The sequence traits Seq, IndexedSeq, and LinearSeq][24.5 The sequence traits Seq, IndexedSeq, and LinearSeq]]
  - [[24.6 Sets][24.6 Sets]]
  - [[24.7 Maps][24.7 Maps]]
  - [[24.8 Concrete immutable collection classes][24.8 Concrete immutable collection classes]]
  - [[24.9 Concrete mutable collection classes][24.9 Concrete mutable collection classes]]
  - [[24.10 Arrays][24.10 Arrays]]
  - [[24.11 Strings][24.11 Strings]]
  - [[24.12 Performance characteristics][24.12 Performance characteristics]]
  - [[24.13 Equality][24.13 Equality]]
  - [[24.14 Views][24.14 Views]]
  - [[24.15 Iterators][24.15 Iterators]]
  - [[24.16 Creating collections from scratch][24.16 Creating collections from scratch]]
  - [[24.17 Conversions between Java and Scala collections][24.17 Conversions between Java and Scala collections]]
  - [[24.18 Conclusion][24.18 Conclusion]]
- [[25 The Architecture of Scala Collections][25 The Architecture of Scala Collections]]
  - [[25.1 Builders][25.1 Builders]]
  - [[25.2 Factoring out common operations][25.2 Factoring out common operations]]
  - [[25.3 Integrating new collections][25.3 Integrating new collections]]
  - [[25.4 Conclusion][25.4 Conclusion]]
- [[26 Extractors][26 Extractors]]
  - [[26.1 An example: extracting email addresses][26.1 An example: extracting email addresses]]
  - [[26.2 Extractors][26.2 Extractors]]
  - [[26.3 Patterns with zero or one variables][26.3 Patterns with zero or one variables]]
  - [[26.4 Variable argument extractors][26.4 Variable argument extractors]]
  - [[26.5 Extractors and sequence patterns][26.5 Extractors and sequence patterns]]
  - [[26.6 Extractors versus case classes][26.6 Extractors versus case classes]]
  - [[26.7 Regular expressions][26.7 Regular expressions]]
  - [[26.8 Conclusion][26.8 Conclusion]]
- [[27 Annotations][27 Annotations]]
  - [[27.1 Why have annotations?][27.1 Why have annotations?]]
  - [[27.2 Syntax of annotations][27.2 Syntax of annotations]]
  - [[27.3 Standard annotations][27.3 Standard annotations]]
  - [[27.4 Conclusion][27.4 Conclusion]]
- [[28 Working with XML][28 Working with XML]]
  - [[28.1 Semi-structured data][28.1 Semi-structured data]]
  - [[28.2 XML overview][28.2 XML overview]]
  - [[28.3 XML literals][28.3 XML literals]]
  - [[28.4 Serialization][28.4 Serialization]]
  - [[28.5 Taking XML apart][28.5 Taking XML apart]]
  - [[28.6 Deserialization][28.6 Deserialization]]
  - [[28.7 Loading and saving][28.7 Loading and saving]]
  - [[28.8 Pattern matching on XML][28.8 Pattern matching on XML]]
  - [[28.9 Conclusion][28.9 Conclusion]]
- [[29 Modular Programming Using Objects][29 Modular Programming Using Objects]]
  - [[29.1 The problem][29.1 The problem]]
  - [[29.2 A recipe application][29.2 A recipe application]]
  - [[29.3 Abstraction][29.3 Abstraction]]
  - [[29.4 Splitting modules into traits][29.4 Splitting modules into traits]]
  - [[29.5 Runtime linking][29.5 Runtime linking]]
  - [[29.6 Tracking module instances][29.6 Tracking module instances]]
  - [[29.7 Conclusion][29.7 Conclusion]]
- [[30 Object Equality][30 Object Equality]]
  - [[30.1 Equality in Scala][30.1 Equality in Scala]]
  - [[30.2 Writing an equality method][30.2 Writing an equality method]]
  - [[30.3 Defining equality for parameterized types][30.3 Defining equality for parameterized types]]
  - [[30.4 Recipes for equals and hashCode][30.4 Recipes for equals and hashCode]]
  - [[30.5 Conclusion][30.5 Conclusion]]
- [[31 Combining Scala and Java][31 Combining Scala and Java]]
  - [[31.1 Using Scala from Java][31.1 Using Scala from Java]]
  - [[31.2 Annotations][31.2 Annotations]]
  - [[31.3 Wildcard types][31.3 Wildcard types]]
  - [[31.4 Compiling Scala and Java together][31.4 Compiling Scala and Java together]]
  - [[31.5 Java 8 integration in Scala 2.12][31.5 Java 8 integration in Scala 2.12]]
  - [[31.6 Conclusion][31.6 Conclusion]]
- [[32 Futures and Concurrency][32 Futures and Concurrency]]
  - [[32.1 Trouble in paradise][32.1 Trouble in paradise]]
  - [[32.2 Asynchronous execution and Trys][32.2 Asynchronous execution and Trys]]
  - [[32.3 Working with Futures][32.3 Working with Futures]]
  - [[32.4 Testing with Futures][32.4 Testing with Futures]]
  - [[32.5 Conclusion][32.5 Conclusion]]
- [[33 Combinator Parsing][33 Combinator Parsing]]
  - [[33.1 Example: Arithmetic expressions][33.1 Example: Arithmetic expressions]]
  - [[33.2 Running your parser][33.2 Running your parser]]
  - [[33.3 Basic regular expression parsers][33.3 Basic regular expression parsers]]
  - [[33.4 Another example: JSON][33.4 Another example: JSON]]
  - [[33.5 Parser output][33.5 Parser output]]
  - [[33.6 Implementing combinator parsers][33.6 Implementing combinator parsers]]
  - [[33.7 String literals and regular expressions][33.7 String literals and regular expressions]]
  - [[33.8 Lexing and parsing][33.8 Lexing and parsing]]
  - [[33.9 Error reporting][33.9 Error reporting]]
  - [[33.10 Backtracking versus LL(1)][33.10 Backtracking versus LL(1)]]
  - [[33.11 Conclusion][33.11 Conclusion]]
- [[34 GUI Programming][34 GUI Programming]]
  - [[34.1 A first Swing application][34.1 A first Swing application]]
  - [[34.2 Panels and layouts][34.2 Panels and layouts]]
  - [[34.3 Handling events][34.3 Handling events]]
  - [[34.4 Example: Celsius/Fahrenheit converter][34.4 Example: Celsius/Fahrenheit converter]]
  - [[34.5 Conclusion][34.5 Conclusion]]
- [[35 The SCells Spreadsheet][35 The SCells Spreadsheet]]
  - [[35.1 The visual framework][35.1 The visual framework]]
  - [[35.2 Disconnecting data entry and display][35.2 Disconnecting data entry and display]]
  - [[35.3 Formulas][35.3 Formulas]]
  - [[35.4 Parsing formulas][35.4 Parsing formulas]]
  - [[35.5 Evaluation][35.5 Evaluation]]
  - [[35.6 Operation libraries][35.6 Operation libraries]]
  - [[35.7 Change propagation][35.7 Change propagation]]
  - [[35.8 Conclusion][35.8 Conclusion]]
- [[A Scala Scripts on Unix andWindows][A Scala Scripts on Unix andWindows]]
- [[Glossary][Glossary]]
- [[Bibliography][Bibliography]]
- [[About the Authors][About the Authors]]
- [[Index][Index]]
- [[][]]
- [[Tips (may not from this book)][Tips (may not from this book)]]
- [[TodoList][TodoList]]

* Contents
* List of Figures
* List of Tables
* List of Listings
* Foreword
* Acknowledgments
* Introduction
* 1 A Scalable Language
** 1.1 A language that grows on you
** 1.2 What makes Scala scalable?
** 1.3 Why Scala?
** 1.4 Scala's roots
** 1.5 Conclusion

* 2 First Steps in Scala
** Step 1. Learn to use the Scala interpreter
** Step 2. Define some variables
** Step 3. Define some functions
** Step 4. Write some Scala scripts
** Step 5. Loop with while; decide with if
** Step 6. Iterate with foreach and for
** Conclusion

* 3 Next Steps in Scala
** Step 7. Parameterize arrays with types
** Step 8. Use lists
** Step 9. Use tuples
** Step 10. Use sets and maps
** Step 11. Learn to recognize the functional style
** Step 12. Read lines from a file
** Conclusion

* 4 Classes and Objects
** 4.1 Classes, fields, and methods
** 4.2 Semicolon inference
** 4.3 Singleton objects
** 4.4 A Scala application
** 4.5 The App trait
** 4.6 Conclusion

* 5 Basic Types and Operations
** 5.1 Some basic types
** 5.2 Literals
** 5.3 String interpolation
** 5.4 Operators are methods
** 5.5 Arithmetic operations
** 5.6 Relational and logical operations
** 5.7 Bitwise operations
** 5.8 Object equality
** 5.9 Operator precedence and associativity
** 5.10 Rich wrappers
** 5.11 Conclusion

* 6 Functional Objects
** 6.1 A specification for class Rational
** 6.2 Constructing a Rational
** 6.3 Reimplementing the toString method
** 6.4 Checking preconditions
** 6.5 Adding fields
** 6.6 Self references
** 6.7 Auxiliary constructors
** 6.8 Private fields and methods
** 6.9 Defining operators
** 6.10 Identifiers in Scala
** 6.11 Method overloading
** 6.12 Implicit conversions
** 6.13 A word of caution
** 6.14 Conclusion

* 7 Built-in Control Structures
** 7.1 If expressions
** 7.2 While loops
** 7.3 For expressions
** 7.4 Exception handling with try expressions
** 7.5 Match expressions
** 7.6 Living without break and continue
** 7.7 Variable scope
** 7.8 Refactoring imperative-style code
** 7.9 Conclusion

* 8 Functions and Closures
** 8.1 Methods
** 8.2 Local functions
** 8.3 First-class functions
** 8.4 Short forms of function literals
** 8.5 Placeholder syntax
** 8.6 Partially applied functions
** 8.7 Closures
** 8.8 Special function call forms
** 8.9 Tail recursion
** 8.10 Conclusion

* 9 Control Abstraction
** 9.1 Reducing code duplication
** 9.2 Simplifying client code
** 9.3 Currying
** 9.4 Writing new control structures
** 9.5 By-name parameters
** 9.6 Conclusion

* 10 Composition and Inheritance
** 10.1 A two-dimensional layout library
** 10.2 Abstract classes
** 10.3 Defining parameterless methods
** 10.4 Extending classes
** 10.5 Overriding methods and fields
** 10.6 Defining parametric fields
** 10.7 Invoking superclass constructors
** 10.8 Using override modifiers
** 10.9 Polymorphism and dynamic binding
** 10.10 Declaring final members
** 10.11 Using composition and inheritance
** 10.12 Implementing above, beside, and toString
** 10.13 Defining a factory object
** 10.14 Heighten and widen
** 10.15 Putting it all together
** 10.16 Conclusion
* 11 Scala's Hierarchy
** 11.1 Scala's class hierarchy
** 11.2 How primitives are implemented
** 11.3 Bottom types
** 11.4 Defining your own value classes
** 11.5 Conclusion
* 12 Traits
** 12.1 How traits work
** 12.2 Thin versus rich interfaces
** 12.3 Example: Rectangular objects
** 12.4 The Ordered trait
** 12.5 Traits as stackable modifications
** 12.6 Why not multiple inheritance?
** 12.7 To trait or not to trait?
** 12.8 Conclusion
* 13 Packages and Imports
** 13.1 Putting code in packages
** 13.2 Concise access to related code
** 13.3 Imports
** 13.4 Implicit imports
** 13.5 Access modifiers
** 13.6 Package objects
** 13.7 Conclusion
* 14 Assertions and Tests
** 14.1 Assertions
** 14.2 Testing in Scala
** 14.3 Informative failure reports
** 14.4 Tests as specifications
** 14.5 Property-based testing
** 14.6 Organizing and running tests
** 14.7 Conclusion
* 15 Case Classes and Pattern Matching
** 15.1 A simple example
** 15.2 Kinds of patterns
** 15.3 Pattern guards
** 15.4 Pattern overlaps
** 15.5 Sealed classes
** 15.6 The Option type
** 15.7 Patterns everywhere
** 15.8 A larger example
** 15.9 Conclusion
* 16 Working with Lists
** 16.1 List literals
** 16.2 The List type
** 16.3 Constructing lists
** 16.4 Basic operations on lists
** 16.5 List patterns
** 16.6 First-order methods on class List
** 16.7 Higher-order methods on class List
** 16.8 Methods of the List object
** 16.9 Processing multiple lists together
** 16.10 Understanding Scala’s type inference algorithm
** 16.11 Conclusion
* 17 Working with Other Collections
** 17.1 Sequences
** 17.2 Sets and maps
** 17.3 Selecting mutable versus immutable collections
** 17.4 Initializing collections
** 17.5 Tuples
** 17.6 Conclusion
* 18 Mutable Objects
** 18.1 What makes an object mutable?
** 18.2 Reassignable variables and properties
** 18.3 Case study: Discrete event simulation
** 18.4 A language for digital circuits
** 18.5 The Simulation API
** 18.6 Circuit Simulation
** 18.7 Conclusion
* 19 Type Parameterization
** 19.1 Functional queues
** 19.2 Information hiding
** 19.3 Variance annotations
** 19.4 Checking variance annotations
** 19.5 Lower bounds
** 19.6 Contravariance
** 19.7 Object private data
** 19.8 Upper bounds
** 19.9 Conclusion
* 20 Abstract Members
** 20.1 A quick tour of abstract members
** 20.2 Type members
** 20.3 Abstract vals
** 20.4 Abstract vars
** 20.5 Initializing abstract vals
** 20.6 Abstract types
** 20.7 Path-dependent types
** 20.8 Refinement types
** 20.9 Enumerations
** 20.10 Case study: Currencies
** 20.11 Conclusion
* 21 Implicit Conversions and Parameters
** 21.1 Implicit conversions
** 21.2 Rules for implicits
** 21.3 Implicit conversion to an expected type
** 21.4 Converting the receiver
** 21.5 Implicit parameters
** 21.6 Context bounds
** 21.7 When multiple conversions apply
** 21.8 Debugging implicits
** 21.9 Conclusion
* 22 Implementing Lists
** 22.1 The List class in principle
** 22.2 The ListBuffer class
** 22.3 The List class in practice
** 22.4 Functional on the outside
** 22.5 Conclusion
* 23 For Expressions Revisited
** 23.1 For expressions
** 23.2 The n-queens problem
** 23.3 Querying with for expressions
** 23.4 Translation of for expressions
** 23.5 Going the other way
** 23.6 Generalizing for
** 23.7 Conclusion
* 24 Collections in Depth
** 24.1 Mutable and immutable collections
** 24.2 Collections consistency
** 24.3 Trait Traversable
** 24.4 Trait Iterable
** 24.5 The sequence traits Seq, IndexedSeq, and LinearSeq
** 24.6 Sets
** 24.7 Maps
** 24.8 Concrete immutable collection classes
** 24.9 Concrete mutable collection classes
** 24.10 Arrays
** 24.11 Strings
** 24.12 Performance characteristics
** 24.13 Equality
** 24.14 Views
** 24.15 Iterators
** 24.16 Creating collections from scratch
** 24.17 Conversions between Java and Scala collections
** 24.18 Conclusion
* 25 The Architecture of Scala Collections
** 25.1 Builders
** 25.2 Factoring out common operations
** 25.3 Integrating new collections
** 25.4 Conclusion
* 26 Extractors
** 26.1 An example: extracting email addresses
** 26.2 Extractors
** 26.3 Patterns with zero or one variables
** 26.4 Variable argument extractors
** 26.5 Extractors and sequence patterns
** 26.6 Extractors versus case classes
** 26.7 Regular expressions
** 26.8 Conclusion
* 27 Annotations
** 27.1 Why have annotations?
** 27.2 Syntax of annotations
** 27.3 Standard annotations
** 27.4 Conclusion
* 28 Working with XML
** 28.1 Semi-structured data
** 28.2 XML overview
** 28.3 XML literals
** 28.4 Serialization
** 28.5 Taking XML apart
** 28.6 Deserialization
** 28.7 Loading and saving
** 28.8 Pattern matching on XML
** 28.9 Conclusion
* 29 Modular Programming Using Objects
** 29.1 The problem
** 29.2 A recipe application
** 29.3 Abstraction
** 29.4 Splitting modules into traits
** 29.5 Runtime linking
** 29.6 Tracking module instances
** 29.7 Conclusion
* 30 Object Equality
** 30.1 Equality in Scala
** 30.2 Writing an equality method
** 30.3 Defining equality for parameterized types
** 30.4 Recipes for equals and hashCode
** 30.5 Conclusion
* 31 Combining Scala and Java
** 31.1 Using Scala from Java
** 31.2 Annotations
** 31.3 Wildcard types
** 31.4 Compiling Scala and Java together
** 31.5 Java 8 integration in Scala 2.12
** 31.6 Conclusion
* 32 Futures and Concurrency
** 32.1 Trouble in paradise
** 32.2 Asynchronous execution and Trys
** 32.3 Working with Futures
** 32.4 Testing with Futures
** 32.5 Conclusion
* 33 Combinator Parsing
** 33.1 Example: Arithmetic expressions
** 33.2 Running your parser
** 33.3 Basic regular expression parsers
** 33.4 Another example: JSON
** 33.5 Parser output
** 33.6 Implementing combinator parsers
** 33.7 String literals and regular expressions
** 33.8 Lexing and parsing
** 33.9 Error reporting
** 33.10 Backtracking versus LL(1)
** 33.11 Conclusion
* 34 GUI Programming
** 34.1 A first Swing application
** 34.2 Panels and layouts
** 34.3 Handling events
** 34.4 Example: Celsius/Fahrenheit converter
** 34.5 Conclusion
* 35 The SCells Spreadsheet
** 35.1 The visual framework
** 35.2 Disconnecting data entry and display
** 35.3 Formulas
** 35.4 Parsing formulas
** 35.5 Evaluation
** 35.6 Operation libraries
** 35.7 Change propagation
** 35.8 Conclusion
* A Scala Scripts on Unix andWindows
* Glossary
* Bibliography
* About the Authors
* Index
* 
* Tips (may not from this book)
* TodoList
