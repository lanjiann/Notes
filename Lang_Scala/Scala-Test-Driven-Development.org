#+TITLE: Scala Test-Driven Development
#+VERSION: 2016
#+AUTHOR: Gaurav Sood
#+STARTUP: entitiespretty


* Table of Contents                                      :TOC_4_org:noexport:
- [[Preface][Preface]]
  - [[What this book covers][What this book covers]]
  - [[What you need for this book][What you need for this book]]
  - [[Who this book is for][Who this book is for]]
  - [[Conventions][Conventions]]
  - [[Reader feedback][Reader feedback]]
  - [[Customer support][Customer support]]
  - [[Downloading the example code][Downloading the example code]]
  - [[Errata][Errata]]
  - [[Piracy][Piracy]]
  - [[Questions][Questions]]
- [[1. Hello, TDD!][1. Hello, TDD!]]
  - [[What is TDD?][What is TDD?]]
  - [[Why TDD?][Why TDD?]]
  - [[Changing our approach to problem solving][Changing our approach to problem solving]]
    - [[Iteratively writing failing tests][Iteratively writing failing tests]]
      - [[Baby steps][Baby steps]]
  - [[Brief introduction to Scala and SBT][Brief introduction to Scala and SBT]]
    - [[What is Scala?][What is Scala?]]
    - [[Why Scala?][Why Scala?]]
    - [[Scala Build Tool][Scala Build Tool]]
    - [[Why SBT?][Why SBT?]]
    - [[Resources for learning Scala][Resources for learning Scala]]
    - [[Resources for SBT][Resources for SBT]]
    - [[Setting up a build environment][Setting up a build environment]]
    - [[Steps for downloading and installing Scala][Steps for downloading and installing Scala]]
    - [[Steps for downloading and installing SBT][Steps for downloading and installing SBT]]
    - [[Creating a project directory structure][Creating a project directory structure]]
    - [[Build definition files][Build definition files]]
  - [[Hello World!][Hello World!]]
    - [[Creating a directory structure][Creating a directory structure]]
    - [[Creating a build definition][Creating a build definition]]
    - [[Test first!][Test first!]]
  - [[Summary][Summary]]
- [[2. First Test-Driven Application][2. First Test-Driven Application]]
  - [[Testing frameworks][Testing frameworks]]
  - [[ScalaTest][ScalaTest]]
    - [[A quick tutorial][A quick tutorial]]
      - [[Adding ScalaTest to the project][Adding ScalaTest to the project]]
      - [[Choose your testing style][Choose your testing style]]
      - [[Resources for ScalaTest][Resources for ScalaTest]]
  - [[Problem statements][Problem statements]]
  - [[IDE][IDE]]
  - [[Project structure][Project structure]]
  - [[Write a failing test – RED][Write a failing test – RED]]
  - [[Writing application code to fix the test – GREEN][Writing application code to fix the test – GREEN]]
  - [[More tests – REPEAT][More tests – REPEAT]]
  - [[Intercepting exceptions][Intercepting exceptions]]
  - [[Summary][Summary]]
- [[3. Clean Code Using ScalaTest][3. Clean Code Using ScalaTest]]
  - [[Assertions][Assertions]]
    - [[Deliberately failing tests][Deliberately failing tests]]
    - [[Assumptions][Assumptions]]
    - [[Canceling tests][Canceling tests]]
    - [[Failure messages and clues][Failure messages and clues]]
  - [[Matchers][Matchers]]
    - [[Matchers for equality][Matchers for equality]]
    - [[Matchers for instance and identity checks of objects][Matchers for instance and identity checks of objects]]
    - [[Matchers for size and length][Matchers for size and length]]
    - [[Matching strings][Matching strings]]
    - [[Matching greater and less than][Matching greater and less than]]
    - [[Matching Boolean properties][Matching Boolean properties]]
    - [[Matching number within ranges][Matching number within ranges]]
    - [[Matching emptiness][Matching emptiness]]
    - [[Writing your own BeMatchers][Writing your own BeMatchers]]
  - [[Some more Matchers][Some more Matchers]]
    - [[Matchers for containers][Matchers for containers]]
    - [[Combining Matchers with logical expressions][Combining Matchers with logical expressions]]
    - [[Matching options][Matching options]]
    - [[Matching properties][Matching properties]]
    - [[Checking that a snippet of code does not compileBase test classes][Checking that a snippet of code does not compileBase test classes]]
  - [[Base test classes][Base test classes]]
  - [[Test fixtures][Test fixtures]]
    - [[Calling get-fixture methods][Calling get-fixture methods]]
    - [[Instantiating fixture-context objects][Instantiating fixture-context objects]]
    - [[Overriding ~withFixture(NoArgTest)~][Overriding ~withFixture(NoArgTest)~]]
    - [[Calling loan-fixture methods][Calling loan-fixture methods]]
    - [[Overriding ~withFixture(OneArgTest)~][Overriding ~withFixture(OneArgTest)~]]
    - [[Mixing in ~BeforeAndAfter~][Mixing in ~BeforeAndAfter~]]
    - [[Composing fixtures by stacking traits][Composing fixtures by stacking traits]]
  - [[Problem statement][Problem statement]]
    - [[Feature – decimal to hexadecimal conversion][Feature – decimal to hexadecimal conversion]]
      - [[BinaryToDecimalSpec.scala][BinaryToDecimalSpec.scala]]
      - [[HexadecimalToDecimalSpec.scala][HexadecimalToDecimalSpec.scala]]
      - [[DecimalHexadecimalSpec.scala][DecimalHexadecimalSpec.scala]]
      - [[BeanSpec.scala][BeanSpec.scala]]
      - [[package.scala.packt][package.scala.packt]]
      - [[BaseConversion.scala][BaseConversion.scala]]
  - [[Summary][Summary]]
- [[4. Refactor Mercilessly][4. Refactor Mercilessly]]
  - [[Clean code][Clean code]]
  - [[Red-Green-Refactor][Red-Green-Refactor]]
  - [[Code smell][Code smell]]
    - [[Expendable][Expendable]]
    - [[Couplers][Couplers]]
    - [[Modification thwarters][Modification thwarters]]
    - [[Bloaters][Bloaters]]
    - [[Object-oriented abusers][Object-oriented abusers]]
    - [[Obsolete libraries][Obsolete libraries]]
  - [[To refactor or not to refactor][To refactor or not to refactor]]
    - [[Doing it thrice (rule of three)][Doing it thrice (rule of three)]]
    - [[Adding new feature][Adding new feature]]
    - [[Bug fixing][Bug fixing]]
    - [[Code reviews][Code reviews]]
  - [[Refactoring techniques][Refactoring techniques]]
    - [[Composing methods][Composing methods]]
    - [[Moving features between objects][Moving features between objects]]
    - [[Organizing data][Organizing data]]
  - [[Summary][Summary]]
- [[5. Another Level of Testing][5. Another Level of Testing]]
  - [[Integration testing][Integration testing]]
    - [[Functional testing][Functional testing]]
    - [[Acceptance testing][Acceptance testing]]
    - [[Need for user acceptance testing][Need for user acceptance testing]]
  - [[Behavior-driven development][Behavior-driven development]]
    - [[IntroductionThree amigos][IntroductionThree amigos]]
    - [[Bird's-eye view of BDD][Bird's-eye view of BDD]]
    - [[Gherkin][Gherkin]]
    - [[Executable specification][Executable specification]]
    - [[Don't repeat yourself][Don't repeat yourself]]
  - [[Talk is cheap][Talk is cheap]]
    - [[Adding Cucumber dependency][Adding Cucumber dependency]]
    - [[Directory structure][Directory structure]]
    - [[The feature file][The feature file]]
    - [[Running the feature][Running the feature]]
    - [[Step definition][Step definition]]
  - [[Summary][Summary]]
- [[6. Mock Objects and Stubs][6. Mock Objects and Stubs]]
  - [[History][History]]
  - [[Coupling][Coupling]]
  - [[Stubs][Stubs]]
  - [[Mock objects][Mock objects]]
    - [[Expectations][Expectations]]
    - [[Verifications][Verifications]]
  - [[Fakes][Fakes]]
  - [[Spy][Spy]]
  - [[Mocking frameworks][Mocking frameworks]]
    - [[JMock][JMock]]
      - [[Advantages of JMock][Advantages of JMock]]
    - [[EasyMock][EasyMock]]
  - [[Mockito][Mockito]]
  - [[ScalaMock][ScalaMock]]
    - [[Advantages of ScalaMock][Advantages of ScalaMock]]
    - [[mockFunction][mockFunction]]
    - [[Proxy mocks][Proxy mocks]]
    - [[Generated mocks][Generated mocks]]
    - [[Let's dig a little deeper][Let's dig a little deeper]]
      - [[Specifying expectations][Specifying expectations]]
  - [[Summary][Summary]]
- [[7. Property-Based Testing][7. Property-Based Testing]]
  - [[Introduction to property-based testing][Introduction to property-based testing]]
    - [[Table-driven properties][Table-driven properties]]
  - [[Generator-driven properties][Generator-driven properties]]
  - [[ScalaCheck][ScalaCheck]]
    - [[Generators][Generators]]
      - [[Generating case classes][Generating case classes]]
      - [[Conditional Generators][Conditional Generators]]
      - [[Generating containers][Generating containers]]
      - [[Arbitrary Generator][Arbitrary Generator]]
      - [[Generation statistics][Generation statistics]]
      - [[Executing property checks][Executing property checks]]
    - [[Our own Generator-driven property checks][Our own Generator-driven property checks]]
  - [[Summary][Summary]]
- [[8. Scala TDD with Specs2][8. Scala TDD with Specs2]]
  - [[Introduction to Specs2][Introduction to Specs2]]
  - [[Differences between Specs2 and ScalaTest][Differences between Specs2 and ScalaTest]]
  - [[Setting up Specs2][Setting up Specs2]]
  - [[Styles][Styles]]
    - [[Unit specifications][Unit specifications]]
  - [[Acceptance specification][Acceptance specification]]
  - [[Matchers][Matchers]]
    - [[Simple Matchers][Simple Matchers]]
    - [[Matchers for strings][Matchers for strings]]
    - [[Matchers for relational operators][Matchers for relational operators]]
    - [[Matchers for floating point][Matchers for floating point]]
    - [[Matchers for references][Matchers for references]]
    - [[Matchers for Option/Either][Matchers for Option/Either]]
    - [[Matchers for the try monad][Matchers for the try monad]]
    - [[Matching exception][Matching exception]]
    - [[Iterable Matchers][Iterable Matchers]]
    - [[Matchers for sequences and traversables][Matchers for sequences and traversables]]
    - [[Matchers for maps][Matchers for maps]]
    - [[Matchers for XML][Matchers for XML]]
    - [[Matchers for files][Matchers for files]]
    - [[Matchers for partial functions][Matchers for partial functions]]
    - [[Other Matchers][Other Matchers]]
  - [[Specs2 data tables][Specs2 data tables]]
  - [[Running Specs2 tests][Running Specs2 tests]]
  - [[Summary][Summary]]
- [[9. Miscellaneous and Emerging Trends in Scala TDD][9. Miscellaneous and Emerging Trends in Scala TDD]]
  - [[Scala ~Future~'s and ~Promise~'s][Scala ~Future~'s and ~Promise~'s]]
    - [[~ExecutionContext~][~ExecutionContext~]]
    - [[~Future~'s][~Future~'s]]
  - [[The ~Inside~ trait][The ~Inside~ trait]]
  - [[The ~OptionValue~ trait][The ~OptionValue~ trait]]
  - [[The ~EitherValue~ trait][The ~EitherValue~ trait]]
  - [[Eventually][Eventually]]
    - [[How to configure eventually][How to configure eventually]]
    - [[Simple backoff algorithm][Simple backoff algorithm]]
    - [[Integration patience][Integration patience]]
  - [[Consumer-Driven Contracts][Consumer-Driven Contracts]]
    - [[How services interface with each other][How services interface with each other]]
      - [[The gigantic way][The gigantic way]]
      - [[Microservices][Microservices]]
    - [[Using CDC to integrate microservices][Using CDC to integrate microservices]]
      - [[Traditional way][Traditional way]]
      - [[Using CDC][Using CDC]]
    - [[Benefits of CDC][Benefits of CDC]]
  - [[Summary][Summary]]

* Preface
** What this book covers
** What you need for this book
** Who this book is for
** Conventions
** Reader feedback
** Customer support
** Downloading the example code
** Errata
** Piracy
** Questions

* TODO 1. Hello, TDD!
  - This chapter will explore:
    + What is TDD?
    + What is the need for TDD?
    + Changing approach to problem solving
    + Iteratively writing failing tests and fixing them
    + Significance of baby steps
    + Scala
    + Brief introduction to Scala and SBT
    + Setting up the build environment
    + TDD with Scala
    + "Hello World" application

** What is TDD?
** Why TDD?
** Changing our approach to problem solving
*** Iteratively writing failing tests
**** Baby steps

** Brief introduction to Scala and SBT
*** What is Scala?
*** Why Scala?
*** Scala Build Tool
*** Why SBT?
*** Resources for learning Scala
*** Resources for SBT
*** Setting up a build environment
*** Steps for downloading and installing Scala
*** Steps for downloading and installing SBT
*** Creating a project directory structure
*** Build definition files

** Hello World!
*** Creating a directory structure
*** Creating a build definition
*** Test first!

** Summary

* DONE 2. First Test-Driven Application
  CLOSED: [2018-12-04 Tue 04:37]
  - The topics we will explore in this chapter are:
    + Testing frameworks
    + ScalaTest
    + Problem statement
    + IDE
    + Implementation

** DONE Testing frameworks
   CLOSED: [2018-12-04 Tue 04:34]
   - testing framework :: a framework used for the *automated testing* of software.

   - A /testing framework/ is primarily a collection of
     + /postulations/
     + /perceptions/
     + /observations/

     which support automated testing of application code.

   - /Testing frameworks/ includes functionalities for unit tests, as well as
     /integration, smoke, and acceptance testing/. =???= =TODO=

   - There are *TWO main frameworks* for testing application code written in Scala:
     + ScalaTest
     + Specs2.

   - The choice of one over the other will depend on your testing approach.

     For example,
     + ScalaTest uses the JUnit like testing structure,

       whereas the

     + Specs2 test by itself is  =???= =TODO= =???=
       NOT prosaic
       BUT cleaves more closely to an _immutability ideal_.

     *ScalaTest is arguably more popular as it makes a transition from JUnit
     easier.*

** DONE ScalaTest
   CLOSED: [2018-12-04 Tue 04:37]
   - ScalaTest includes multiple styles.
     It is a comprehensive framework for both BDD and TDD.

   - ScalaTest also *integrates* VERY WELL WITH various third party frameworks
     such as =TODO= =???= =TODO=
     + JUnit
     + TestNG =???=
     + Ant
     + Maven
     + SBT
     + ScalaCheck
     + JMock =???=
     + EasyMock =???=
     + Mockito =???=
     + ScalaMock =???=
     + Selenium, =???= and so on. =???=

   - ScalaTest also integrates with IDEs like Eclipse, NetBeans, and IntelliJ.

*** TODO A quick tutorial
**** DONE Adding ScalaTest to the project
     CLOSED: [2018-12-04 Tue 04:27]
     - In practice,
       it is advisable to use the _SAME testing style throughout the project_, so
       there is uniformity in testing and code that can be reused or refactored
       later.

     - From the author:
       I sometimes use *two* DIFFERENT styles in my project:
       + one for unit testing
       + another for functional testing.

       This makes it easier to look at the test and know if it can be run in
       isolation, as is the case with most unit tests.

     - It is recommended to use
       + ~FlatSpec~ for /unit testing/, for example
         #+BEGIN_SRC scala
           class AddSuite extends FunSuite {
             test("3 plus 3 is 6") {
               assert((3 + 3) == 6)
             }
           }
         #+END_SRC
         and

       + ~FeatureSpec~ for /functional or acceptance testing/, for example
         #+BEGIN_SRC scala
           import org.scalatest._

           class Calculator {
             def add(a: Int, b: Int): Int = a + b
           }

           class CalcSpec extends FeatureSpec with GivenWhenThen {
             info("As a calculator owner")
             info("I want to be able add two numbers")
             info("so I can get a correct result")

             feature("Addition") {
               scenario("User adds two numbers") {
                 Given("a calculator")
                 val calc = new Calculator

                 When("two numbers are added")
                 val result = calc.add(3, 3)

                 Then("we get correct result")
                 assert(result == 6)
               }
             }
           }
         #+END_SRC

**** TODO Choose your testing style
     - *Note*
       MOST of the book's examples will be built using ~FlatSpec~ and ~FeatureSpec~.

***** FunSuite
***** FlatSpec
***** FunSpec
***** WordSpec
***** FreeSpec
***** Spec
***** PropSpec
***** FeatureSpec

**** Resources for ScalaTest

** DONE Problem statements
   CLOSED: [2018-12-04 Tue 01:08]
   Use /Gherkin language/, which is a DSL for describing BDD WITHOUT
   implementation details.

   - Example:
     *Feature: decimal to binary conversion*:
     As a user, I want to convert a decimal number to a binary number:
     + _Scenario 1_:
       * *Given* I have a number A
       * *When* I convert this number to a binary number
       * *Then*, I get a binary equivalent B of the original decimal number

     + _Scenario 2_:
       * *Given* I have binary number X
       * *When* I convert this number to a decimal number
       * *Then*, I get a decimal equivalent Y of the original binary number

     + _Scenario 3_:
       * *Given* I have decimal number A
       * *When*
         I convert A to binary to get binary number B,
         and again convert B to decimal number C
       * *Then* A is equal to C

   - *TIP* =TODO= =TODO=
     More about /gherkin language/: https://docs.cucumber.io/gherkin/

** DONE IDE
   CLOSED: [2018-12-04 Tue 02:46]
   - This book use IntelliJ IDEA with the Scala plugin.

** DONE Project structure
   CLOSED: [2018-12-04 Tue 03:03]
   Create a Scala project with SBT in IntelliJ IDEA.
   =from Jian= Here ~./~ represents the _project root_.

   - =./build.sbt=
     #+BEGIN_SRC scala
       name := "tdd"

       version := "0.1"

       scalaVersion := "2.12.7"

       libraryDependencies ++= {
         Seq(
           "org.scalactic" %% "scalactic" % "3.0.5",
           "org.scalatest" %% "scalatest" % "3.0.5" % Test
         )
       }
     #+END_SRC

   - =./project/build.properties=
     ~sbt.version = 1.2.7~

   - =./project/plugins.sbt=
     ~addSbtPlugin("com.artima.supersafe" % "sbtplugin" % "1.1.7")~
     This version _1.1.7_ is for the Scala 2.12.7

     + For using this plugin, you need to add the /resolver/ to the
       =$HOME/.sbt/1.0/global.sbt=.

** DONE Write a failing test – RED
   CLOSED: [2018-12-04 Tue 03:01]
   - In =test=
     #+BEGIN_SRC scala
       package com.packt

       import org.scalatest.FlatSpec

       class DecimalBinarySpec extends FlatSpec{
         "base conversion utility" should "convert a number 99 into a
         binary number 1100011" in {
           var binary: Binary = BaseConversion.decimalToBinary(Decimal("99"))
           assert(binary.number == "1100011")
         }
       }
     #+END_SRC

   - In =main=
     #+BEGIN_SRC scala
       package com.packt

       object BaseConversion {
         def decimalToBinary(x: Decimal) = ???
       }
     #+END_SRC

     + Also add /package object/:
       #+BEGIN_SRC scala
         package com

         package object packt {
           trait Number {
             def number: String
           }
           case class Decimal(number: String) extends Number
           case class Binary(number: String) extends Number
         }
       #+END_SRC

   - *Note*
     The definition of ~???~ in ~Predef~:
     ~def ???: Nothing = throw new NotImplementedError~

** DONE Writing application code to fix the test – GREEN
   CLOSED: [2018-12-04 Tue 03:20]
   - *NOTE*

   - *TIP*
     Add a body ~Binary("1100011")~ to the definition of ~decimalToBinary~. this
     is used for us to learn what will happen when we can pass the test we
     wrote, THOUGH this is NOT the right implementation.

     When pass, we see GREEN output.

   - Add two lines to the ~DecimalBinarySpec~, then we have
     #+BEGIN_SRC scala
       package com.packt

       import org.scalatest.FlatSpec

       class DecimalBinarySpec extends FlatSpec{
         "base conversion utility" should "convert a number 99
         into a binary number 1100011" in {
           val binary:Binary = BaseConversion.decimalToBinary(Decimal("99"))
           assert(binary.number == "1100011")
         }

         it should "convert a number 245 into a binary number 11110101" in pending

         it should "convert a number 3141 into a binary number 110001000101" in pending
       }
     #+END_SRC
     + ~it~ is a shorthand to repeat the initial string ~"binary conversion utility"~.

     + ~pending~ means this test has _NOT_ been implemented!
       When you run tests you will see =Test Pending= output for each ~pending~ test.

** DONE More tests – REPEAT
   CLOSED: [2018-12-04 Tue 04:24]
   - TDD testing cycle ::
        RED -> GREEN -> REFACTOR -> REPEAT

   - For our till now simple examples, /refactor/ is NOT required.
     Just ignore it now, and MOVE TO _REPEAT_.

   - Let's fill in our pending tests:

     #+BEGIN_SRC scala
       it should "convert a number 245 into a binary number 11110101" in {
         val binary: Binary = BaseConversion.decimalToBinary(Decimal("245"))
         assert(binary.number == "11110101")
       }

       it should "convert a number 3141 into a binary number 110001000101" in {
         val binary: Binary = BaseConversion.decimalToBinary(Decimal("3141"))
         assert(binary.number == "110001000101")
       }
     #+END_SRC

     + Now implement the body of ~decimalToBinary~ for general inputs:
       #+BEGIN_SRC scala
         package com.packt

         object BaseConversion {
           def decimalToBinary(decimal: Decimal) =
             Binary(toBinary(BigInt(decimal.number)))

           @annotation.tailrec
           private def toBinary(num: BigInt, acc: List[BigInt] = Nil): String =
             num match {
               case 0 => acc.mkString
               case _ => toBinary(num / 2, (num % 2) :: acc)
             }
         }
       #+END_SRC

   - Also write ~BinaryToDecimalSpec~:
     #+BEGIN_SRC scala
       package com.packt

       import org.scalatest.FlatSpec

       class BinaryToDecimalSpec extends FlatSpec {
         "base conversion utility" should "convert binary number 100100111101 to decimal equivalent 2365" in {
           val decimal: Decimal = BaseConversion.binaryToDecimal(Binary("100100111101"))
           assert(decimal.number == "2365")
         }

         it should "convert binary number 11110001111110111 to decimal equivalent 123895" in {
           val decimal: Decimal = BaseConversion.binaryToDecimal(Binary("11110001111110111"))
           assert(decimal.number == "123895")
         }

         it should "convert binary number 100000000000001110000001 to decimal equivalent 8389505" in {
           val decimal: Decimal = BaseConversion.binaryToDecimal(Binary("100000000000001110000001"))
           assert(decimal.number == "8389505")
         }
       }
     #+END_SRC

   - Add ~BeanSpec~ to make sure that
     if the strings passed to ~Decimal~ and ~Binary~ are not all digits, /excpetions/
     should be thrown.

** DONE Intercepting exceptions
   CLOSED: [2018-12-04 Tue 04:24]
   Two styles:
   - The JUnit style: Use ~try~ and ~catch~
     #+BEGIN_SRC scala
       try {
         Decimal("XYZ")
       } catch {
         case e: IllegalArgumentException =>
           assert(e.getMessage == "requirement failed: Unable to convert string to number")

         case _: Throwable => fail
       }
     #+END_SRC
     + The type annotation ~Throwable~ should always be there for the catch-all
       pattern in the ~catch~ block, or else a warning will should up -- ~_~
       should be a catch all but ONLY all ~Throwable~, NOT all else!!!

   - Use the ~intercept~
     #+BEGIN_SRC scala
       intercept[IllegalArgumentException] {
         Binary("XYZ")
       }
     #+END_SRC

** DONE Summary
   CLOSED: [2018-12-04 Tue 04:27]
   This chapter was intended to be _MORE hands on_.

   - Looked at ScalaTest and _HOW_ it fits in with other /unit testing/ frameworks
     for Scala.

   - looked at _different styles and specs_, which ScalaTest provides.

   - We also laid the foundation for the problem that we will be looking at
     *THROUGHOUT* the book.

     + We will be _adding more complexities_ to the same problem.

     + We will be looking to *create a robust test* harness by refactoring our
       tests at every stage.

* TODO 3. Clean Code Using ScalaTest
  Look at some examples of writing *clean* test code.

  - We will explore the following: =TODO=
    + Assertions
    + Matchers
    + Base test classes
    + Test fixtures

  - Some of the examples in this chapter comes from the ScalaTest official docs.

** DONE Assertions
   CLOSED: [2018-12-05 Wed 00:26]
   - Three default /assertions/ that come out of the box with ScalaTest:
     + ~assert~
       =???= =from Jian= Any differences from the ~assert~ of Scala built-in?
       =TODO= =???=

     + ~assertResult~
       This is designed to differentiate between the _expected value_ and the
       _actual_:
       #+BEGIN_SRC scala
         test("one plus one with result") {
           val two = 2
           assertResult(two) { 1 + 1 }
         }
       #+END_SRC

     + ~intercept~
       #+BEGIN_SRC scala
         intercept[IllegalArgumentException] {
           someMethod()
         }
       #+END_SRC

*** DONE Deliberately failing tests
    CLOSED: [2018-12-05 Wed 00:06]
    Use ~fail()~ or ~fail("Failure message")~
    Thsi will throw ~TestFailException~ with the message, if any.

*** DONE Assumptions
    CLOSED: [2018-12-05 Wed 00:11]
    Apart from the default assertions, the ~Assertion~ /trait/ also includes
    functionalities that can check preconditions to decide if the test should be
    canclled. *Cancel does NOT mean Fail!!*

    #+BEGIN_SRC scala
      assume(database.isAvailable(), "Duh!!")
      assume(database.isAvailable())
    #+END_SRC

*** DONE Canceling tests
    CLOSED: [2018-12-05 Wed 00:13]
    - ~cancel~ is similar to ~fail~, same number of overloaded variations.

    - ~cancel~ will throw ~TestCancelledException~.

    - Example:
      #+BEGIN_SRC scala
        cancle()
        cancle("I cancelled it deliberately")
      #+END_SRC

*** DONE Failure messages and clues
    CLOSED: [2018-12-05 Wed 00:26]
    #+BEGIN_SRC scala
      assert("Hello".length == 5, "Message")

      assertResult(5, "Message") {"Hello".length}

      withClue("Message") {
        intercept[IllegalArgumentException] {
          someMethod()
        }
      }
    #+END_SRC

    - The ~intercept~ does NOT have an overload for a _message_.
      You have to use ~wihtClue~ to provide the _message_.

    - The ~withClue~ /method/ will
      *ONLY modify* the detailed message of an /exception/ that is _mixin the
      ~ModifiableMessage~ /trait/._

** TODO Matchers
   - Along with /assequality assertionsertions/,
     ScalaTest also supports a DSL for *expressing assertions in the test*.
     This is achieved using the word ~should~.

   - This is done by *mixing in* ~Matchers~:
     #+BEGIN_SRC scala
       import org.scalatest._

       class PacktSpec extends FlatSpec with Matchers
     #+END_SRC

   - The members of the /trait/ can be imported EXPLICITLY:
     ~import Matchers._~

   - You can mixin the ~Matcher~ /trait/ with your /test suite class/ to write
     /equality assertions/ like:
     ~message should equal ("Hello World")~

   - Alternatively,
     you can mixin ~MustMatcher~'s as an alternative to ~Matcher~'s,
     which proves same syntax and meaning as the ~Matcher~'s /trait/, but uses
     the verb ~must~ instead of ~should~.

*** DONE Matchers for equality
    CLOSED: [2018-12-05 Wed 00:44]
    Five ways:
    #+BEGIN_SRC scala
      message should be    ("Hello World")
      message shouldBe      "Hello World"
      message should equal ("Hello World")
      message should ===   ("Hello to World")
      message shouldEqual   "Hello World"
    #+END_SRC

    =from Jian= I don't like this kind of "flexibility"!!

*** DONE Matchers for instance and identity checks of objects
    CLOSED: [2018-12-05 Wed 00:46]
    #+BEGIN_SRC scala
      message shouldBe a [String]
      person should not be an [Animal]
    #+END_SRC

    - Any type parameters will be erased on JVM, therefore, it's recommended to
      use _underscore_ for type:
      ~names should be a [Seq[_]]~

    - References equality check:
      ~obj1 should be theSameInstanceAs obj2~

*** TODO Matchers for size and length
*** TODO Matching strings
*** TODO Matching greater and less than
*** TODO Matching Boolean properties
*** TODO Matching number within ranges
*** TODO Matching emptiness
*** DONE Writing your own BeMatchers
    CLOSED: [2018-12-05 Wed 00:47]

** TODO Some more Matchers
   We have some more ~Matcher~'s that are _NOT as generic as_ the BASIC ~Matcher~'s
   from last section.

*** TODO Matchers for containers
*** DONE Combining Matchers with logical expressions
    CLOSED: [2018-12-05 Wed 00:51]
    #+BEGIN_SRC scala
      map should (contain key ("two") and not contain value (7))

      traversable should (contain (7) or (contain (8) and have size (9)))

      map should (not be (null) and contain key ("ouch"))
    #+END_SRC

*** DONE Matching options
    CLOSED: [2018-12-05 Wed 00:54]
    You can work with /options/ using *ScalaTest's equality, empty, defined,
    and contain syntax.*

    - Example: 
      #+BEGIN_SRC scala
        optionVal shouldEqual None
        optionVal shouldBe    None
        optionVal should === (None)
        optionVal shouldBe    empty
      #+END_SRC

    - Example (specific values):
      #+BEGIN_SRC scala
        option shoudlEqual Some("hi")
        option shouldBe defined
      #+END_SRC

*** TODO Matching properties
*** DONE Checking that a snippet of code does not compileBase test classes
    CLOSED: [2018-12-05 Wed 01:15]
    #+BEGIN_SRC scala
      "val a: String = 1" shouldNot compile

      "val a: String = 1" shouldNot typeCheck

      "val a: Int = 1" should compile
    #+END_SRC

    They are implemented with /macros/, and the results are determined at
    /compile time/, but reported as tests failure at /runtime/.


** DONE Base test classes
   CLOSED: [2018-12-05 Wed 01:32]
   - Try to create a base test class for your specific requirements like:
     #+BEGIN_SRC scala
       package com.packt

       import org.scalatest._

       abstract class UnitSpec extends FlatSpec
                                  with Matchers
                                  with OptionValues
                                  with Inside
                                  with Inspectors
     #+END_SRC

     + This is actually what the author of this book want to use.

   - You usually create multiple this kind of base classes, each focused on a
     different kind of test.

     - For example, possbile senarios:
       You might have
       + a /base class/ for /integration tests/ that require a _database_
         (perhaps named ~DbSpec~),

       + another for /integration tests/ that require an /actor system/ (perhaps
         named ~ActorSysSpec~),

       + another for /integration test/ that require BOTH a _database_ and an /actor
         system/ (perhaps named ~DbActorSysSpec~), and so on.

** TODO Test fixtures
*** TODO Calling get-fixture methods
*** TODO Instantiating fixture-context objects
*** TODO Overriding ~withFixture(NoArgTest)~
*** TODO Calling loan-fixture methods
*** TODO Overriding ~withFixture(OneArgTest)~
*** TODO Mixing in ~BeforeAndAfter~
*** TODO Composing fixtures by stacking traits

** TODO Problem statement
   Extend our example from the previous chapter about base conversion
   so that we can convert from decimal to hexadecimal and vice versa.

   =from Jian= Then, we can test more, and learn more about tests.

*** TODO Feature – decimal to hexadecimal conversion
    - Similar to before we, add three scenarios:
      + _Scenario 1_:
        * *Given* a decimal number A
        * *When* I convert this number to a hexadecimal number
        * *Then*, I get a hexadecimal equivalent B of the original decimal number

      + _Scenario 2_:
        * *Given* a hexadecimal number X
        * *When* I convert this number to a decimal number
        * *Then*, I get decimal equivalent Y of the original hexadecimal number

      + _Scenario 3_:
        * *Given* a decimal number A
        * *When* I convert A to hexadecimal to get hexadecimal number B
          _And_ I again convert B to decimal number C
        * *Then*, A is equal to C

**** BinaryToDecimalSpec.scala
**** HexadecimalToDecimalSpec.scala
**** DecimalHexadecimalSpec.scala
**** BeanSpec.scala
**** package.scala.packt
**** BaseConversion.scala

** TODO Summary

* TODO 4. Refactor Mercilessly
** TODO Clean code
** TODO Red-Green-Refactor
** TODO Code smell
*** Expendable
*** Couplers
*** Modification thwarters
*** Bloaters
*** Object-oriented abusers
*** Obsolete libraries

** TODO To refactor or not to refactor
*** Doing it thrice (rule of three)
*** Adding new feature
*** Bug fixing
*** Code reviews

** TODO Refactoring techniques
*** Composing methods
*** Moving features between objects
*** Organizing data

** TODO Summary

* TODO 5. Another Level of Testing
** TODO Integration testing
*** TODO Functional testing
*** TODO Acceptance testing
*** TODO Need for user acceptance testing

** TODO Behavior-driven development
*** TODO IntroductionThree amigos
*** TODO Bird's-eye view of BDD
*** TODO Gherkin
*** TODO Executable specification
*** TODO Don't repeat yourself

** TODO Talk is cheap
*** TODO Adding Cucumber dependency
*** TODO Directory structure
*** TODO The feature file
*** TODO Running the feature
*** TODO Step definition

** TODO Summary

* TODO 6. Mock Objects and Stubs
** TODO History
** TODO Coupling
** TODO Stubs
** TODO Mock objects
*** TODO Expectations
*** TODO Verifications

** TODO Fakes
** TODO Spy
** TODO Mocking frameworks
*** TODO JMock
**** Advantages of JMock

*** EasyMock

** TODO Mockito
** TODO ScalaMock
*** Advantages of ScalaMock
*** mockFunction
*** Proxy mocks
*** Generated mocks
*** Let's dig a little deeper
**** Specifying expectations

** TODO Summary

* TODO 7. Property-Based Testing
** TODO Introduction to property-based testing
*** TODO Table-driven properties

** TODO Generator-driven properties
** TODO ScalaCheck
*** TODO Generators
**** Generating case classes
**** Conditional Generators
**** Generating containers
**** Arbitrary Generator
**** Generation statistics
**** Executing property checks

*** Our own Generator-driven property checks

** Summary

* TODO 8. Scala TDD with Specs2
** TODO Introduction to Specs2
** TODO Differences between Specs2 and ScalaTest
** TODO Setting up Specs2
** TODO Styles
*** Unit specifications

** TODO Acceptance specification
** TODO Matchers
*** Simple Matchers
*** Matchers for strings
*** Matchers for relational operators
*** Matchers for floating point
*** Matchers for references
*** Matchers for Option/Either
*** Matchers for the try monad
*** Matching exception
*** Iterable Matchers
*** Matchers for sequences and traversables
*** Matchers for maps
*** Matchers for XML
*** Matchers for files
*** Matchers for partial functions
*** Other Matchers

** TODO Specs2 data tables
** TODO Running Specs2 tests
** TODO Summary

* TODO 9. Miscellaneous and Emerging Trends in Scala TDD
** TODO Scala ~Future~'s and ~Promise~'s
*** ~ExecutionContext~
*** ~Future~'s

** TODO The ~Inside~ trait
** TODO The ~OptionValue~ trait
** TODO The ~EitherValue~ trait
** TODO Eventually
*** How to configure eventually
*** Simple backoff algorithm
*** Integration patience

** TODO Consumer-Driven Contracts
*** TODO How services interface with each other
**** The gigantic way
**** Microservices

*** TODO Using CDC to integrate microservices
**** Traditional way
**** Using CDC

*** TODO Benefits of CDC

** TODO Summary
