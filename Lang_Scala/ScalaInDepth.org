#+TITLE: Scala in Depth
#+SUBTITLE: A comprehensive step-by-step guide
#+YEAR: 2012
#+AUTHOR: Joshua D. Suereth
#+Foreword by: Martin Odersky
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[foreword - xi][foreword - xi]]
- [[preface - xiii][preface - xiii]]
- [[acknowledgments - xiv][acknowledgments - xiv]]
- [[about this book - xvi][about this book - xvi]]
  - [[Who should read this book? - xvi][Who should read this book? - xvi]]
  - [[Roadmap - xvi][Roadmap - xvi]]
  - [[Code downloads and conventions - xvii][Code downloads and conventions - xvii]]
  - [[Author online - xviii][Author online - xviii]]
  - [[About the author - xviii][About the author - xviii]]
- [[about the cover illustration - xix][about the cover illustration - xix]]
- [[1 Scala -- a blended language - 1][1 Scala -- a blended language - 1]]
  - [[1.1 Functional programming meets object orientation - 2][1.1 Functional programming meets object orientation - 2]]
    - [[Discovering existing functional concepts - 4][Discovering existing functional concepts - 4]]
    - [[Examining functional concepts in Google Collections - 6][Examining functional concepts in Google Collections - 6]]
  - [[1.2 Static typing and expressiveness - 8][1.2 Static typing and expressiveness - 8]]
    - [[Changing sides - 8][Changing sides - 8]]
    - [[Type inference - 9][Type inference - 9]]
    - [[Dropping verbose syntax - 9][Dropping verbose syntax - 9]]
    - [[Implicits are an old concept - 10][Implicits are an old concept - 10]]
    - [[Using Scala's implicit keyword - 11][Using Scala's implicit keyword - 11]]
  - [[1.3 Transparently working with the JVM - 12][1.3 Transparently working with the JVM - 12]]
    - [[Java in Scala - 12][Java in Scala - 12]]
    - [[Scala in Java - 13][Scala in Java - 13]]
    - [[The benefits of a JVM - 14][The benefits of a JVM - 14]]
  - [[1.4 Summary - 15][1.4 Summary - 15]]
- [[2 The core rules - 16][2 The core rules - 16]]
  - [[2.1 Learn to use the Read Eval Print Loop (REPL) - 16][2.1 Learn to use the Read Eval Print Loop (REPL) - 16]]
    - [[Experiment-driven development - 18][Experiment-driven development - 18]]
    - [[Working around eager parsing - 19][Working around eager parsing - 19]]
    - [[Inexpressible language features - 20][Inexpressible language features - 20]]
  - [[2.2 Think in expressions - 21][2.2 Think in expressions - 21]]
    - [[Don't use return - 22][Don't use return - 22]]
    - [[Mutability - 24][Mutability - 24]]
  - [[2.3 Prefer immutability - 26][2.3 Prefer immutability - 26]]
    - [[Object equality - 27][Object equality - 27]]
    - [[Concurrency - 31][Concurrency - 31]]
  - [[2.4 Use None instead of null - 34][2.4 Use None instead of null - 34]]
    - [[Advanced Option techniques - 35][Advanced Option techniques - 35]]
  - [[2.5 Polymorphic equality - 38][2.5 Polymorphic equality - 38]]
    - [[Example: A timeline library - 38][Example: A timeline library - 38]]
    - [[Polymorphic equals implementation - 40][Polymorphic equals implementation - 40]]
  - [[2.6 Summary - 42][2.6 Summary - 42]]
- [[3 Modicum of style -- coding conventions - 43][3 Modicum of style -- coding conventions - 43]]
  - [[3.1 Avoid coding conventions from other languages - 44][3.1 Avoid coding conventions from other languages - 44]]
    - [[The block debacle - 45][The block debacle - 45]]
  - [[3.2 Dangling operators and parenthetical expressions - 48][3.2 Dangling operators and parenthetical expressions - 48]]
  - [[3.3 Use meaningful variable names - 49][3.3 Use meaningful variable names - 49]]
    - [[Avoid $ in names - 50][Avoid $ in names - 50]]
    - [[Working with named and default parameters - 53][Working with named and default parameters - 53]]
  - [[3.4 Always mark overridden methods - 55][3.4 Always mark overridden methods - 55]]
  - [[3.5 Annotate for expected optimizations - 60][3.5 Annotate for expected optimizations - 60]]
    - [[Using the tableswitch optimization - 61][Using the tableswitch optimization - 61]]
    - [[Using the tail recursion optimization - 64][Using the tail recursion optimization - 64]]
  - [[3.6 Summary - 66][3.6 Summary - 66]]
- [[4 Utilizing object orientation - 68][4 Utilizing object orientation - 68]]
  - [[4.1 Limit code inside an object or trait's body to initialization logic - 69][4.1 Limit code inside an object or trait's body to initialization logic - 69]]
    - [[Delayed construction - 69][Delayed construction - 69]]
    - [[And then there's multiple inheritance - 70][And then there's multiple inheritance - 70]]
  - [[4.2 Provide empty implementations for abstract methods on traits - 72][4.2 Provide empty implementations for abstract methods on traits - 72]]
  - [[4.3 Composition can include inheritance - 76][4.3 Composition can include inheritance - 76]]
    - [[Member composition by inheritance - 78][Member composition by inheritance - 78]]
    - [[Classic constructors with a twist - 80][Classic constructors with a twist - 80]]
  - [[4.4 Promote abstract interface into its own trait - 82][4.4 Promote abstract interface into its own trait - 82]]
    - [[Interfaces you can talk to - 84][Interfaces you can talk to - 84]]
    - [[Learning from the past - 85][Learning from the past - 85]]
  - [[4.5 Provide return types in your public APIs - 86][4.5 Provide return types in your public APIs - 86]]
  - [[4.6 Summary - 88][4.6 Summary - 88]]
- [[5 Using implicits to write expressive code - 89][5 Using implicits to write expressive code - 89]]
  - [[5.1 Introduction to implicits - 90][5.1 Introduction to implicits - 90]]
    - [[Identifiers: A digression 91][Identifiers: A digression 91]]
    - [[Scope and bindings 92][Scope and bindings 92]]
    - [[Implicit resolution - 96][Implicit resolution - 96]]
  - [[5.2 Enhancing existing classes with implicit views - 101][5.2 Enhancing existing classes with implicit views - 101]]
  - [[5.3 Utilize implicit parameters with defaults - 106][5.3 Utilize implicit parameters with defaults - 106]]
  - [[5.4 Limiting the scope of implicits - 112][5.4 Limiting the scope of implicits - 112]]
    - [[Creating implicits for import 113][Creating implicits for import 113]]
    - [[Implicits without the import tax - 115][Implicits without the import tax - 115]]
  - [[5.5 Summary - 119][5.5 Summary - 119]]
- [[6 The type system - 120][6 The type system - 120]]
  - [[6.1 Types - 121][6.1 Types - 121]]
    - [[Types and paths - 122][Types and paths - 122]]
    - [[The type keyword - 124][The type keyword - 124]]
    - [[Structural types - 125][Structural types - 125]]
  - [[6.2 Type constraints - 131][6.2 Type constraints - 131]]
  - [[6.3 Type parameters and higher-kinded types - 134][6.3 Type parameters and higher-kinded types - 134]]
    - [[Type parameter constraints - 134][Type parameter constraints - 134]]
    - [[Higher-kinded types - 135][Higher-kinded types - 135]]
  - [[6.4 Variance - 137][6.4 Variance - 137]]
    - [[Advanced variance annotations - 141][Advanced variance annotations - 141]]
  - [[6.5 Existential types - 144][6.5 Existential types - 144]]
    - [[The formal syntax of existential types - 146][The formal syntax of existential types - 146]]
  - [[6.6 Summary - 149][6.6 Summary - 149]]
- [[7 Using implicits and types together - 150][7 Using implicits and types together - 150]]
  - [[7.1 Context bounds and view bounds - 151][7.1 Context bounds and view bounds - 151]]
    - [[When to use implicit type constraints - 152][When to use implicit type constraints - 152]]
  - [[7.2 Capturing types with implicits - 153][7.2 Capturing types with implicits - 153]]
    - [[Manifests - 153][Manifests - 153]]
    - [[Using Manifests - 154][Using Manifests - 154]]
    - [[Capturing type constraints - 156][Capturing type constraints - 156]]
    - [[Specialized methods - 158][Specialized methods - 158]]
  - [[7.3 Use type classes - 159][7.3 Use type classes - 159]]
    - [[FileLike as a type class - 163][FileLike as a type class - 163]]
    - [[The benefits of type classes - 166][The benefits of type classes - 166]]
  - [[7.4 Conditional execution using the type system - 167][7.4 Conditional execution using the type system - 167]]
    - [[Heterogeneous typed list - 169][Heterogeneous typed list - 169]]
    - [[IndexedView - 172][IndexedView - 172]]
  - [[7.5 Summary - 178][7.5 Summary - 178]]
- [[8 Using the right collection - 179][8 Using the right collection - 179]]
  - [[8.1 Use the right collection - 180][8.1 Use the right collection - 180]]
    - [[The collection hierarchy - 180][The collection hierarchy - 180]]
    - [[Traversable - 182][Traversable - 182]]
    - [[Iterable - 185][Iterable - 185]]
    - [[Seq - 187][Seq - 187]]
    - [[LinearSeq - 187][LinearSeq - 187]]
    - [[IndexedSeq - 189][IndexedSeq - 189]]
    - [[Set - 190][Set - 190]]
    - [[Map - 191][Map - 191]]
  - [[8.2 Immutable collections - 192][8.2 Immutable collections - 192]]
    - [[Vector - 192][Vector - 192]]
    - [[List - 194][List - 194]]
    - [[Stream - 195][Stream - 195]]
  - [[8.3 Mutable collections - 198][8.3 Mutable collections - 198]]
    - [[ArrayBuffer - 198][ArrayBuffer - 198]]
    - [[Mixin mutation event][Mixin mutation event]]
    - [[publishing - 199][publishing - 199]]
    - [[Mixin synchronization - 200][Mixin synchronization - 200]]
  - [[8.4 Changing evaluation with views and parallel collections - 200][8.4 Changing evaluation with views and parallel collections - 200]]
    - [[Views - 201][Views - 201]]
    - [[Parallel collections - 203][Parallel collections - 203]]
  - [[8.5 Writing methods to use with all collection types - 205][8.5 Writing methods to use with all collection types - 205]]
    - [[Optimizing algorithms for each collections type - 209][Optimizing algorithms for each collections type - 209]]
  - [[8.6 Summary - 211][8.6 Summary - 211]]
- [[9 Actors - 212][9 Actors - 212]]
  - [[9.1 Know when to use actors - 213][9.1 Know when to use actors - 213]]
    - [[Using actors to search - 213][Using actors to search - 213]]
  - [[9.2 Use typed, transparent references - 216][9.2 Use typed, transparent references - 216]]
    - [[Scatter-Gather with OutputChannel - 217][Scatter-Gather with OutputChannel - 217]]
  - [[9.3 Limit failures to zones - 221][9.3 Limit failures to zones - 221]]
    - [[Scatter-Gather failure zones - 221][Scatter-Gather failure zones - 221]]
    - [[General failure handling practices - 224][General failure handling practices - 224]]
  - [[9.4 Limit overload using scheduler zones - 225][9.4 Limit overload using scheduler zones - 225]]
    - [[Scheduling zones - 227][Scheduling zones - 227]]
  - [[9.5 Dynamic actor topology - 228][9.5 Dynamic actor topology - 228]]
  - [[9.6 Summary - 233][9.6 Summary - 233]]
- [[10 Integrating Scala with Java - 234][10 Integrating Scala with Java - 234]]
  - [[10.1 The language mismatch between Scala and Java - 235][10.1 The language mismatch between Scala and Java - 235]]
    - [[10.1.1 Differences in primitive boxing - 236][10.1.1 Differences in primitive boxing - 236]]
    - [[10.1.2 Differences in visibility - 240][10.1.2 Differences in visibility - 240]]
    - [[10.1.3 Inexpressible language features - 241][10.1.3 Inexpressible language features - 241]]
  - [[10.2 Be wary of implicit conversions - 244][10.2 Be wary of implicit conversions - 244]]
    - [[10.2.1 Object identity and equality - 245][10.2.1 Object identity and equality - 245]]
    - [[10.2.2 Chaining implicits - 246][10.2.2 Chaining implicits - 246]]
  - [[10.3 Be wary of Java serialization - 248][10.3 Be wary of Java serialization - 248]]
    - [[10.3.1 Serializing anonymous classes - 250][10.3.1 Serializing anonymous classes - 250]]
  - [[10.4 Annotate your annotations - 252][10.4 Annotate your annotations - 252]]
    - [[Annotation targets 254 ■ Scala and static fields - 255][Annotation targets 254 ■ Scala and static fields - 255]]
  - [[10.5 Summary - 256][10.5 Summary - 256]]
- [[11 Patterns in functional programming - 257][11 Patterns in functional programming - 257]]
  - [[11.1 Category theory for computer science - 258][11.1 Category theory for computer science - 258]]
  - [[11.2 Functors and monads, and how they relate to categories - 262][11.2 Functors and monads, and how they relate to categories - 262]]
    - [[Monads - 264][Monads - 264]]
  - [[11.3 Currying and applicative style - 266][11.3 Currying and applicative style - 266]]
    - [[Currying - 266][Currying - 266]]
    - [[Applicative style - 268][Applicative style - 268]]
  - [[11.4 Monads as workflows - 272][11.4 Monads as workflows - 272]]
  - [[11.5 Summary - 276][11.5 Summary - 276]]
- [[index - 277][index - 277]]

* DONE foreword - xi
  CLOSED: [2018-02-07 Wed 15:44]
  - The author Joshua D. Suereth is an expert in /high-performance systems/,
    /build tools/, /type theory/, and _many other areas_.

  - This book talks about more intricate areas of Scala:
    * advanced aspects of Scala's type system

    * implicts

    * composition techniques with traits

    * collections

    * actors (=TODO= If this is the theory, it is OK. If this is the library, it should be replaced with Akka)

    * functional categories

  - =IMPORTANT= This book talks about and explains /the Scala specification/!!!

* preface - xiii
* acknowledgments - xiv
* DONE about this book - xvi
  CLOSED: [2018-02-07 Wed 15:55]
  - This book, _picking up where introductory books drop off_, enables readers to
    write idiomatic Scala code and understand trade-offs when making use of
    advanced language features.

** DONE Who should read this book? - xvi
   CLOSED: [2018-02-07 Wed 16:04]
   - This book is for *intermediate Scala developers*.
     =From Jian= the author mentioned *new* Scala developer, but I think it is
                 more _intermediate Scala developers oriented_.

   - This readers should know Java or another OO language.
     It covers Scala 2.7.x through Scala 2.9.x (=From Jian= They don't fully
     support Java 8's features, and they don't mandatorily require Java 8).

** DONE Roadmap - xvi
   CLOSED: [2018-02-07 Wed 16:20]
   - _THREE_ dichotomies are discussed:
     + static typing versus expressiveness
     + functional programming versus object-oriented programming
     + powerful language features versus dead simple Java integration

   - =TODO= Each chapter =NOTE='s

** DONE Code downloads and conventions - xvii
   CLOSED: [2018-02-07 Wed 16:12]
   - https://github.com/jsuereth/scala-in-depth-source

** TODO Author online - xviii
** DONE About the author - xviii
   CLOSED: [2018-02-07 Wed 16:00]
   Josh Suereth is a Senior Software Engineer at Typesafe Inc (=From Jian= now
   it's Lightbend Inc).

   He started his professional career as a software developer in 2004, cutting
   his teeth with C++, STL, and Boost. His path:
   1. C++, STL, and Boost
   2. Web-hosted distributed Java-delivered solutions
   3. (from 2007) Scala

* TODO about the cover illustration - xix
* 1 Scala -- a blended language - 1
  - In this chapter
    + Short introduction to Scala

    + Insights into Scala's design

  - 

** TODO 1.1 Functional programming meets object orientation - 2
*** TODO Discovering existing functional concepts - 4
*** DONE Examining functional concepts in Google Collections - 6
    CLOSED: [2018-02-07 Wed 19:00]
    - Q: Why is NOT there something like ~? super T~ in Scala?

      A: Scala defines /type variances/ at declaration time, *rather than*
         requiring it on _every_ /method/ that used the /class/.


    - The essence of functional programming:
      *delaying* /side effects/ as long as possible.

** 1.2 Static typing and expressiveness - 8
*** Changing sides - 8
*** Type inference - 9
*** Dropping verbose syntax - 9
*** Implicits are an old concept - 10
*** Using Scala's implicit keyword - 11

** 1.3 Transparently working with the JVM - 12
*** Java in Scala - 12
*** Scala in Java - 13
*** The benefits of a JVM - 14

** 1.4 Summary - 15

* 2 The core rules - 16
** 2.1 Learn to use the Read Eval Print Loop (REPL) - 16
*** Experiment-driven development - 18
*** Working around eager parsing - 19
*** Inexpressible language features - 20

** 2.2 Think in expressions - 21
*** Don't use return - 22
*** Mutability - 24

** 2.3 Prefer immutability - 26
*** Object equality - 27
*** Concurrency - 31

** 2.4 Use None instead of null - 34
*** Advanced Option techniques - 35

** 2.5 Polymorphic equality - 38
*** Example: A timeline library - 38
*** Polymorphic equals implementation - 40

** 2.6 Summary - 42

* 3 Modicum of style -- coding conventions - 43
** 3.1 Avoid coding conventions from other languages - 44
*** The block debacle - 45

** 3.2 Dangling operators and parenthetical expressions - 48
** 3.3 Use meaningful variable names - 49
*** Avoid $ in names - 50
*** Working with named and default parameters - 53

** 3.4 Always mark overridden methods - 55
** 3.5 Annotate for expected optimizations - 60
*** Using the tableswitch optimization - 61
*** Using the tail recursion optimization - 64

** 3.6 Summary - 66

* 4 Utilizing object orientation - 68
** 4.1 Limit code inside an object or trait's body to initialization logic - 69
*** Delayed construction - 69
*** And then there's multiple inheritance - 70

** 4.2 Provide empty implementations for abstract methods on traits - 72
** 4.3 Composition can include inheritance - 76
*** Member composition by inheritance - 78
*** Classic constructors with a twist - 80

** 4.4 Promote abstract interface into its own trait - 82
*** Interfaces you can talk to - 84
*** Learning from the past - 85

** 4.5 Provide return types in your public APIs - 86
** 4.6 Summary - 88

* 5 Using implicits to write expressive code - 89
** 5.1 Introduction to implicits - 90
*** Identifiers: A digression 91 
*** Scope and bindings 92 
*** Implicit resolution - 96

** 5.2 Enhancing existing classes with implicit views - 101
** 5.3 Utilize implicit parameters with defaults - 106
** 5.4 Limiting the scope of implicits - 112
*** Creating implicits for import 113 
*** Implicits without the import tax - 115

** 5.5 Summary - 119

* 6 The type system - 120
** 6.1 Types - 121
*** Types and paths - 122
*** The type keyword - 124
*** Structural types - 125

** 6.2 Type constraints - 131
** 6.3 Type parameters and higher-kinded types - 134
*** Type parameter constraints - 134
*** Higher-kinded types - 135

** 6.4 Variance - 137
*** Advanced variance annotations - 141

** 6.5 Existential types - 144
*** The formal syntax of existential types - 146

** 6.6 Summary - 149

* 7 Using implicits and types together - 150
** 7.1 Context bounds and view bounds - 151
*** When to use implicit type constraints - 152

** 7.2 Capturing types with implicits - 153
*** Manifests - 153
*** Using Manifests - 154
*** Capturing type constraints - 156
*** Specialized methods - 158

** 7.3 Use type classes - 159
*** FileLike as a type class - 163
*** The benefits of type classes - 166

** 7.4 Conditional execution using the type system - 167
*** Heterogeneous typed list - 169
*** IndexedView - 172

** 7.5 Summary - 178

* 8 Using the right collection - 179
** 8.1 Use the right collection - 180
*** The collection hierarchy - 180
*** Traversable - 182
*** Iterable - 185
*** Seq - 187
*** LinearSeq - 187
*** IndexedSeq - 189
*** Set - 190
*** Map - 191

** 8.2 Immutable collections - 192
*** Vector - 192
*** List - 194
*** Stream - 195

** 8.3 Mutable collections - 198
*** ArrayBuffer - 198
*** Mixin mutation event
*** publishing - 199
*** Mixin synchronization - 200

** 8.4 Changing evaluation with views and parallel collections - 200
*** Views - 201
*** Parallel collections - 203

** 8.5 Writing methods to use with all collection types - 205
*** Optimizing algorithms for each collections type - 209

** 8.6 Summary - 211

* 9 Actors - 212
** 9.1 Know when to use actors - 213
*** Using actors to search - 213

** 9.2 Use typed, transparent references - 216
*** Scatter-Gather with OutputChannel - 217

** 9.3 Limit failures to zones - 221
*** Scatter-Gather failure zones - 221
*** General failure handling practices - 224

** 9.4 Limit overload using scheduler zones - 225
*** Scheduling zones - 227

** 9.5 Dynamic actor topology - 228
** 9.6 Summary - 233

* TODO 10 Integrating Scala with Java - 234
  - In this chapter
    + The *benefits* of _using /interfaces/ for Scala-Java interaction._

    + The *dangers* _of /automatic implicit conversions/ of /Java types/._

    + The *complications* _of /Java serialization/ in Scala._

    + How to *effectively use* /annotations/ _in Scala for Java libraries._

  - Two apsects add complicate things to the integration of Scala and Java:
    + _From Scala_:
      But complicated Scala features are implemented with some compiler tricks,

      and these tricks are usually the cause of issues when integrating with
      Java.

    + _From Java_:
      For the most part, the Java language translates simply into JVM bytecode;
      however, it too has language features that use compiler tricks.

      These will also cause rough spots in Scala/ Java interaction.

  - *Another benefit* of understanding how to interface Scala with Java is that
    *it helps to _integrate Scala with every other JVM language_.*

    *Rationale*:
    Because Java is king on the JVM, all alternative JVM languages provide means
    of using existing Java code.
    *This means that communications from Scala to another JVM language can be
    accomplished through Java _even in the worst case_.*

    + Scala is working on language features to integrate directly with (JVM)
      dynamic languages, but even with the 2.9.0 release, these features are
      considered experimental.

** TODO 10.1 The language mismatch between Scala and Java - 235
*** 10.1.1 Differences in primitive boxing - 236
*** 10.1.2 Differences in visibility - 240
*** 10.1.3 Inexpressible language features - 241

** TODO 10.2 Be wary of implicit conversions - 244
*** 10.2.1 Object identity and equality - 245
*** 10.2.2 Chaining implicits - 246

** TODO 10.3 Be wary of Java serialization - 248
*** TODO 10.3.1 Serializing anonymous classes - 250

** TODO 10.4 Annotate your annotations - 252
*** TODO Annotation targets 254 ■ Scala and static fields - 255

** TODO 10.5 Summary - 256

* 11 Patterns in functional programming - 257
** 11.1 Category theory for computer science - 258
** 11.2 Functors and monads, and how they relate to categories - 262
*** Monads - 264

** 11.3 Currying and applicative style - 266
*** Currying - 266
*** Applicative style - 268

** 11.4 Monads as workflows - 272
** 11.5 Summary - 276

* index - 277
