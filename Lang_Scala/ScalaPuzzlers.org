#+TITLE: Scala Puzzlers
#+SUBTITLE: The fun path to deeper understanding
#+VERSION: 2014
#+AUTHOR: Andrew Phillips, Nermin Šerifović
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Contents vii][Contents vii]]
- [[Foreword xii][Foreword xii]]
- [[Preface xiii][Preface xiii]]
- [[Acknowledgments xiv][Acknowledgments xiv]]
- [[Introduction xv][Introduction xv]]
  - [[How to read this book][How to read this book]]
  - [[EBook features][EBook features]]
  - [[Typographic conventions][Typographic conventions]]
- [[1. Hi There! 18][1. Hi There! 18]]
- [[2. UPSTAIRS downstairs 23][2. UPSTAIRS downstairs 23]]
  - [[Explanation][Explanation]]
  - [[Discussion][Discussion]]
- [[3. Location, Location, Location 27][3. Location, Location, Location 27]]
- [[4. Now You See Me, Now You Don’t 33][4. Now You See Me, Now You Don’t 33]]
- [[5. The Missing List 41][5. The Missing List 41]]
    - [[Explanation][Explanation]]
    - [[Discussion][Discussion]]
- [[6. Arg Arrgh! 45][6. Arg Arrgh! 45]]
- [[7. Caught Up in Closures 50][7. Caught Up in Closures 50]]
- [[8. Map Comprehension 55][8. Map Comprehension 55]]
- [[9. Init You, Init Me 59][9. Init You, Init Me 59]]
- [[10. A Case of Equality 67][10. A Case of Equality 67]]
- [[11. If at First You Don’t Succeed... 74][11. If at First You Don’t Succeed... 74]]
- [[12. To Map, or Not to Map 78][12. To Map, or Not to Map 78]]
- [[13. Self: See Self 83][13. Self: See Self 83]]
- [[14. Return to Me! 87][14. Return to Me! 87]]
- [[15. Count Me Now, Count Me Later 93][15. Count Me Now, Count Me Later 93]]
- [[16. One Bound, Two to Go 100][16. One Bound, Two to Go 100]]
- [[17. Implicitly Surprising 106][17. Implicitly Surprising 106]]
- [[18. Information Overload 112][18. Information Overload 112]]
- [[19. What’s in a Name? 118][19. What’s in a Name? 118]]
- [[20. Irregular Expressions 123][20. Irregular Expressions 123]]
- [[21. I Can Has Padding? 127][21. I Can Has Padding? 127]]
- [[22. Cast Away 132][22. Cast Away 132]]
- [[23. Adaptive Reasoning 138][23. Adaptive Reasoning 138]]
- [[24. Double Trouble 143][24. Double Trouble 143]]
- [[25. Type Extortion 148][25. Type Extortion 148]]
- [[26. Accepts Any Args 152][26. Accepts Any Args 152]]
- [[27. A Case of Strings 157][27. A Case of Strings 157]]
- [[28. Pick a Value, AnyValue! 163][28. Pick a Value, AnyValue! 163]]
- [[29. Implicit Kryptonite 169][29. Implicit Kryptonite 169]]
- [[30. Quite the Outspoken Type 176][30. Quite the Outspoken Type 176]]
- [[31. A View to a Shill 181][31. A View to a Shill 181]]
- [[32. Set the Record Straight 185][32. Set the Record Straight 185]]
- [[33. The Devil Is in the Defaults 192][33. The Devil Is in the Defaults 192]]
- [[34. The Main Thing 198][34. The Main Thing 198]]
- [[35. A Listful of Dollars 205][35. A Listful of Dollars 205]]
- [[36. Size It Up 210][36. Size It Up 210]]
- [[Bibliography 216][Bibliography 216]]
- [[About the Authors 219][About the Authors 219]]
- [[Subject Index 220][Subject Index 220]]

* Contents vii
* Foreword xii
* Preface xiii
* Acknowledgments xiv
* DONE Introduction xv
  CLOSED: [2017-09-28 Thu 22:46]
  - This book will help you recognize many counter-intuitive traps and
    pitfalls and prevent them from biting you in production.

** DONE How to read this book
   CLOSED: [2017-09-28 Thu 22:45]

   - The puzzlers in this book are _NOT_ listed in any specific order.

   - If you find a specific area of the Scala language interesting and are looking
     for related puzzlers, the Subject Index at the end of this book is for you.

   - This book use Scala 2.11

   - http://booksites.artima.com/scala_puzzlers/errata.

** DONE EBook features
   CLOSED: [2017-09-28 Thu 22:46]
** DONE Typographic conventions
   CLOSED: [2017-09-28 Thu 22:46]

   - 

* DONE 1. Hi There! 18
  CLOSED: [2018-02-08 Thu 23:18]
  - block expression :: one or multiple statements inside ~{}~, _with the LAST
       determining the RESULT of the block_.

  - /block expressions/ are *NOT* /anonymous function/.

  - Assume ~val lst = List(1, 2)~,
    + ~lst.map(i => println("Hi"); i + 1)~ CANNOT compiled.

      The body of an /anonymous function/ can ONLY be ONE experssion. For
      example, ONLY ~i + 1~ is OK; a /block expression/ that contains multiple
      expressions is OK. However, not the code above.

    + ~lst.map(i \equal{}> { println("Hi"); i + 1 })~ will print *TWO* =Hi='s, and
      return ~List(2, 3)~.

      The /block expression/ is the body of this /anonymous function/.
      The body will be evaluated everytime its /anonymous function/ is called.
      For this example, it is evaluated two times.

    + Both ~lst.map { println("Hi"); _ + 1 }~ and ~lst.map({ println("Hi"); _ + 1 })~
      will print *ONE* =Hi=, and return ~List(2, 3)~.
  
      The /block expression/ is evaluated first, and then its *LAST* expression is
      returned as an /anonymous function/ passed to ~map~. Therefore, ONLY *one*
      =Hi= -- the ~println("Hi");~ as a part of this /block expression/ is
      evaluated once.

  - The scope of the /placeholder/ ~_~ is the exact expression that includes the
    /placeholder/. All the other parts are NOT considered as the body of an
    /anonymous function/ related to the ~_~.

* DONE 2. UPSTAIRS downstairs 23
  CLOSED: [2017-09-28 Thu 23:37]
  - Q :: What is the result of executing the following code in the REPL?
    #+BEGIN_SRC scala
      var MONTH = 12; var DAY = 24
      var (HOUR, MINUTE, SECOND) = (12, 0, 0)
    #+END_SRC

  - A :: The first line compiles, and the second fails to compile.

** DONE Explanation
   CLOSED: [2017-09-28 Thu 23:05]
   #+BEGIN_SRC scala
     var MONTH = 12; var DAY = 24
     // MONTH: Int = 12
     // DAY: Int = 24

     var (HOUR, MINUTE, SECOND) = (12, 0, 0)
     // <console>:11: error: not found: value HOUR
     //        var (HOUR, MINUTE, SECOND) = (12, 0, 0)
     //             ˆ
     // <console>:11: error: not found: value MINUTE
     //        var (HOUR, MINUTE, SECOND) = (12, 0, 0)
     //                   ˆ
     // <console>:11: error: not found: value SECOND
     //        var (HOUR, MINUTE, SECOND) = (12, 0, 0)
     //                           ˆ
   #+END_SRC

   - /Uppercase variable names/ can be used for plain, single-value assignments
     of ~val~'s and ~var~'s, as in the case of ~MONTH~ and ~DAY~.

   - Some *trickiness* arises in /pattern matching/ -- multiple-variable assignments,
     NOT LIKE single-variable assignment, are /paatern matching/.

     In /pattern matching/,

     + Variables _STARTING WITH an UPPERCASE letter_ are /stable identifiers/.
       They are intended for matching against _constants_.
       #+BEGIN_SRC scala
         final val TheAnswer = 42

         def checkGuess(guess: Int) = guess match {
           case TheAnswer => "Your guess is correct"
           case _ => "Try again"
         }

         checkGuess(21)
         // res0: String = Try again

         checkGuess(42)
         // res1: String = Your guess is correct
       #+END_SRC

     + Variables _STARTING WITH an LOWERCASE letter_, by contrast, define
       /variable patterns/, which cause values to be *assigned*:
       ~var (hour, minute, second) = (12, 0, 0)~

** DONE Discussion
   CLOSED: [2017-09-28 Thu 23:37]
   - If, by extreme *coincidence*, the required /stable identifiers/ are
     *in scope* the pattern matching part will compile successfully.

     At runtime, ~MatchError~ may happen is the given value of the /stable
     identifiers/ can't match the RHS value of pattern matching.
     
     #+BEGIN_SRC scala
       val HOUR = 12; val MINUTE, SECOND = 0;
       var (HOUR, MINUTE, SECOND) = (12, 0, 0)
       // Even if it compiles successfully, NO assignment happen.


       val HOUR = 13; val MINUTE, SECOND = 0;
       var (HOUR, MINUTE, SECOND) = (12, 0, 0)
       // scala.MatchError: (12,0,0) (of class scala.Tuple3)
       //  ...
     #+END_SRC

   - *Enclosing lowercase variables in backticks*, and then you get /stable
     identifiers/

     #+BEGIN_SRC scala
       final val theAnswer = 42

       def checkGuess(guess: Int) = guess match {
         case `theAnswer` => "Your guess is correct"
         case _ => "Try again"
       }

       checkGuess(42)
       // res0: String = Your guess is correct
     #+END_SRC

     #+BEGIN_SRC scala
       // not a `val` (should be), and not `final` either
       var theAnswer: Int = 42

       def checkGuess(guess: Int) = guess match {
         case `theAnswer` => "Your guess is correct"
         case _ => "Try again"
       }

       // <console>:9: error: stable identifier required, but
       //   theAnswer found.
       //          case `theAnswer` => "Your guess is correct"
     #+END_SRC

   - You can also use the *enclosing with backticks* way to convert keywords to
     variable names. For example, you can use ~`val`~ as a variable name.


   - We should keep the convention in other languages -- use /lowercase name/
     for ~var~'s (better still, avoid ~var~'s completely!), and /uppercase names/
     for /constants/.

     + constants (in Scala) :: variables declared as ~final val~

     =Comment from Jian=
     A example to distinguish /constant/ and /immutable quantity/:
       Suppose there are two universe follow the same physics rules (same form
     formula), and the ONLY difference is some /physics constants/. These
     /physics constants/ are actully /immutable quantities/ in each universe, not
     /constant/ in our context of discussion. A /constant/, rather than
     /immutable quantity/, should be a fixed value defined the template of these
     two universes -- the universe class. Therefore, for this example, a good
     choice is the ~static final val~.

     Declared as ~final~ _PREVENTS subclasses from overriding them_, and has an
     additional performance benefit in that the compiler can /inline/ them.

   - _SUMMARY_
     Use *uppercase* variable names ONLY for /constants/.

* TODO 3. Location, Location, Location 27
* TODO 4. Now You See Me, Now You Don’t 33
  Q: What does the following program print?
  #+BEGIN_SRC scala
    trait A {
      val foo: Int
      val bar = 10
      println("In A: foo: " + foo + ", bar: " + bar)
    }

    class B extends A {
      val foo: Int = 25
      println("In B: foo: " + foo + ", bar: " + bar)
    }

    class C extends B {
      override val bar = 99
      println("In C: foo: " + foo + ", bar: " + bar)
    }

    new C()
  #+END_SRC

  A: Prints:
     In A: foo: 0, bar: 0
     In B: foo: 25, bar: 0
     In B: foo: 25, bar: 99

  - ~-Xcheckinit~ Wrap field accersors to throw an exception on uninitialized
    accesses.

* DONE 5. The Missing List 41
  CLOSED: [2017-09-28 Thu 22:38]
  Q: What does the following program print?
  #+BEGIN_SRC scala
    def sumSizes(collections: Iterable[Iterable[_]]): Int =
      collections.map(_.size).sum

    sumSizes(List(Set(1, 2), List(3, 4)))
    sumSizes(Set(List(1, 2), Set(3, 4)))
  #+END_SRC

  A: Prints:
     Int = 4
     Int = 2

*** Explanation 
    - If we create a ~sumSizes~ (with the same type signature as above) function
      in Java
      + both the result will be two 4's.

      + the intermediate result of ~collections.map(_.size)~ (in the body of
        ~sumSizes~ definition) should be ~Iterable[Int]~.

    - In Scala, the intermediate result of ~collections.map(_.size)~ (in the body
      of ~sumSizes~ definition) should be a more specific result which satisfies
      ~Iterable[Int]~.
      + For ~sumSizes(List(Set(1, 2), List(3, 4)))~, it should be ~List[Int]~.
        ~List(2, 2).sum~  is 4.

      + For ~sumSizes(Set(List(1, 2), Set(3, 4)))~, it should be ~Set[Int]~.
        ~Set(2, 2).sum~ is actually ~Set(2).sum~, which is 2.

      There is NO warning about the second, which is BAD.
      This time Java does the right thing.
      Why Scala make decision to do the calculation in this way?????? =TODO=

*** Discussion
    Solutions:
    - Convert the outer collection to a known type, e.g., using ~toSeq~:
      #+BEGIN_SRC scala
        def sumSizes(collections: Iterable[Iterable[_]]): Int =
          collections.toSeq.map(_.size).sum
      #+END_SRC

    - Even better, implement ~sumSizes~ with ~fold~ rather than ~map~, then you
      can avoid the problem and eliminate one of the iterations through the outer
      collection (use ~map~, we need ~sum~ that follows it; with ~fold~, we get
      the result directly):
      #+BEGIN_SRC scala
        def sumSizes(collections: Iterable[Iterable[_]]): Int =
          collections.foldLeft(0) {
            (sumOfSizes, collection) => sumOfSizes + collection.size
        }
      #+END_SRC

    - SUMMARY:
      Pay close attention to the possible input types to your methods that
      operate on collections.
        If you do not need to preserve the input type, consider constructing
      your own intermediate types with known characteristics.

* TODO 6. Arg Arrgh! 45
* TODO 7. Caught Up in Closures 50
* TODO 8. Map Comprehension 55
* TODO 9. Init You, Init Me 59
* TODO 10. A Case of Equality 67
* 11. If at First You Don’t Succeed... 74
* 12. To Map, or Not to Map 78
* 13. Self: See Self 83
* 14. Return to Me! 87
* 15. Count Me Now, Count Me Later 93
* 16. One Bound, Two to Go 100
* 17. Implicitly Surprising 106
* 18. Information Overload 112
* 19. What’s in a Name? 118
* 20. Irregular Expressions 123
* 21. I Can Has Padding? 127
* 22. Cast Away 132
* 23. Adaptive Reasoning 138
* 24. Double Trouble 143
* 25. Type Extortion 148
* 26. Accepts Any Args 152
* 27. A Case of Strings 157
* 28. Pick a Value, AnyValue! 163
* 29. Implicit Kryptonite 169
* 30. Quite the Outspoken Type 176
* 31. A View to a Shill 181
* 32. Set the Record Straight 185
* 33. The Devil Is in the Defaults 192
* 34. The Main Thing 198
* 35. A Listful of Dollars 205
* 36. Size It Up 210
* Bibliography 216
* About the Authors 219
* Subject Index 220
