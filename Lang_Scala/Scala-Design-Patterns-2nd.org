#+TITLE: Scala Design Patterns
#+VERSION: 2018, 2nd
#+AUTHOR: Ivan Nikolov
#+STARTUP: entitiespretty


* Table of Contents                                      :TOC_4_org:noexport:
- [[Preface][Preface]]
  - [[Who this book is for][Who this book is for]]
  - [[What this book covers][What this book covers]]
  - [[To get the most out of this book][To get the most out of this book]]
    - [[Download the example code files][Download the example code files]]
    - [[Conventions used][Conventions used]]
  - [[Get in touch][Get in touch]]
    - [[Reviews][Reviews]]
- [[1. The Design Patterns Out There and Setting Up Your Environment][1. The Design Patterns Out There and Setting Up Your Environment]]
  - [[Design patterns][Design patterns]]
    - [[Scala and design patterns][Scala and design patterns]]
    - [[The need for design patterns and their benefits][The need for design patterns and their benefits]]
  - [[Design pattern categories - =RE-READ= =IMPORTANT=][Design pattern categories - =RE-READ= =IMPORTANT=]]
    - [[Creational design patterns][Creational design patterns]]
      - [[The abstract factory design pattern][The abstract factory design pattern]]
      - [[The factory method design pattern][The factory method design pattern]]
      - [[The lazy initialization design pattern][The lazy initialization design pattern]]
      - [[The singleton design pattern][The singleton design pattern]]
      - [[The object pool design pattern][The object pool design pattern]]
      - [[The builder design pattern][The builder design pattern]]
      - [[The prototype design pattern][The prototype design pattern]]
    - [[Structural design patterns][Structural design patterns]]
      - [[The adapter design pattern][The adapter design pattern]]
      - [[The decorator design pattern][The decorator design pattern]]
      - [[The bridge design pattern][The bridge design pattern]]
      - [[The composite design pattern][The composite design pattern]]
      - [[The facade design pattern][The facade design pattern]]
      - [[The flyweight design pattern][The flyweight design pattern]]
      - [[The proxy design pattern][The proxy design pattern]]
    - [[Behavioral design patterns][Behavioral design patterns]]
      - [[The value object design pattern][The value object design pattern]]
      - [[The null object design pattern][The null object design pattern]]
      - [[The strategy design pattern][The strategy design pattern]]
      - [[The command design pattern][The command design pattern]]
      - [[The chain of responsibility design pattern][The chain of responsibility design pattern]]
      - [[The interpreter design pattern][The interpreter design pattern]]
      - [[The iterator design pattern][The iterator design pattern]]
      - [[The mediator design pattern][The mediator design pattern]]
      - [[The memento design pattern][The memento design pattern]]
      - [[The observer design pattern][The observer design pattern]]
      - [[The state design pattern][The state design pattern]]
      - [[The template method design pattern][The template method design pattern]]
      - [[The visitor design pattern][The visitor design pattern]]
    - [[Functional design patterns][Functional design patterns]]
      - [[Monoids][Monoids]]
      - [[Monads][Monads]]
      - [[Functors][Functors]]
    - [[Scala-specific design patterns][Scala-specific design patterns]]
      - [[The lens design pattern][The lens design pattern]]
      - [[The cake design pattern][The cake design pattern]]
      - [[Pimp my library][Pimp my library]]
      - [[Stackable traits][Stackable traits]]
      - [[The type class design pattern][The type class design pattern]]
      - [[Lazy evaluation][Lazy evaluation]]
      - [[Partial functions][Partial functions]]
      - [[Implicit injection][Implicit injection]]
      - [[Duck typing][Duck typing]]
      - [[Memoization][Memoization]]
  - [[Choosing a design pattern - =Re-REAd= =IMPORTANT=][Choosing a design pattern - =Re-REAd= =IMPORTANT=]]
  - [[Setting up the development environment][Setting up the development environment]]
    - [[Installing Scala][Installing Scala]]
      - [[Tips for installing Scala manually][Tips for installing Scala manually]]
      - [[Tips for installing Scala using SBT][Tips for installing Scala using SBT]]
    - [[Scala IDEs][Scala IDEs]]
    - [[Dependency management][Dependency management]]
      - [[SBT][SBT]]
      - [[Maven][Maven]]
      - [[SBT versus Maven][SBT versus Maven]]
  - [[Summary][Summary]]
- [[2. Traits and Mixin Compositions][2. Traits and Mixin Compositions]]
  - [[Traits][Traits]]
    - [[Traits as interfaces][Traits as interfaces]]
      - [[Mixing in traits with variables][Mixing in traits with variables]]
    - [[Traits as classes][Traits as classes]]
    - [[Extending classes][Extending classes]]
    - [[Extending traits][Extending traits]]
  - [[Mixin compositions][Mixin compositions]]
    - [[Mixing traits in][Mixing traits in]]
    - [[Composing][Composing]]
      - [[Composing simple traits][Composing simple traits]]
      - [[Composing complex traits][Composing complex traits]]
      - [[Composing with self-types][Composing with self-types]]
    - [[Clashing traits - =TODO= NOTES][Clashing traits - =TODO= NOTES]]
      - [[Same signatures and return types][Same signatures and return types]]
      - [[Same signatures and different return types traits][Same signatures and different return types traits]]
      - [[Same signatures and return types mixins][Same signatures and return types mixins]]
      - [[Same signatures and different return types mixins][Same signatures and different return types mixins]]
  - [[Multiple inheritance][Multiple inheritance]]
    - [[The diamond problem][The diamond problem]]
    - [[The limitations][The limitations]]
  - [[Linearization][Linearization]]
    - [[Rules of inheritance hierarchies][Rules of inheritance hierarchies]]
    - [[Linearization rules][Linearization rules]]
    - [[How linearization works][How linearization works]]
    - [[Initialization][Initialization]]
    - [[Method overriding][Method overriding]]
  - [[Testing traits][Testing traits]]
    - [[Using a class][Using a class]]
    - [[Mixing the trait in][Mixing the trait in]]
      - [[Mixing into the test class][Mixing into the test class]]
      - [[Mixing into the test cases][Mixing into the test cases]]
    - [[Running the tests][Running the tests]]
  - [[Traits versus classes][Traits versus classes]]
    - [[Summary][Summary]]
- [[3. Unification][3. Unification]]
  - [[Functions and classes][Functions and classes]]
    - [[Functions as classes][Functions as classes]]
      - [[Function literals][Function literals]]
      - [[Functions without syntactic sugar][Functions without syntactic sugar]]
    - [[Increased expressivity][Increased expressivity]]
  - [[Algebraic data types and class hierarchies][Algebraic data types and class hierarchies]]
    - [[ADTs][ADTs]]
      - [[Sum ADTs][Sum ADTs]]
      - [[Product ADTs][Product ADTs]]
      - [[Hybrid ADTs][Hybrid ADTs]]
      - [[The unification][The unification]]
    - [[Pattern matching][Pattern matching]]
      - [[Pattern matching with values][Pattern matching with values]]
      - [[Pattern matching for product ADTs][Pattern matching for product ADTs]]
  - [[Modules and objects][Modules and objects]]
      - [[Using modules][Using modules]]
  - [[Summary][Summary]]
- [[4. Abstract and Self Types][4. Abstract and Self Types]]
  - [[Abstract types][Abstract types]]
    - [[Generics][Generics]]
    - [[Abstract types][Abstract types]]
    - [[Generics versus abstract types][Generics versus abstract types]]
      - [[Usage advice][Usage advice]]
  - [[Polymorphism][Polymorphism]]
    - [[Subtype polymorphism][Subtype polymorphism]]
    - [[Parametric polymorphism][Parametric polymorphism]]
    - [[Ad hoc polymorphism][Ad hoc polymorphism]]
      - [[Adding functions for multiple types][Adding functions for multiple types]]
  - [[Self types][Self types]]
    - [[Using self types][Using self types]]
      - [[Requiring multiple components][Requiring multiple components]]
      - [[Conflicting components][Conflicting components]]
      - [[Self types and the cake design pattern][Self types and the cake design pattern]]
    - [[Self types versus inheritance][Self types versus inheritance]]
      - [[Inheritance leaking functionality][Inheritance leaking functionality]]
  - [[Summary][Summary]]
- [[5. Aspect-Oriented Programming and Components][5. Aspect-Oriented Programming and Components]]
  - [[Aspect-oriented programming][Aspect-oriented programming]]
    - [[Understanding application efficiency][Understanding application efficiency]]
      - [[Timing our application without AOP][Timing our application without AOP]]
      - [[Timing our application with AOP][Timing our application with AOP]]
  - [[Components in Scala][Components in Scala]]
    - [[Using Scala's expressive power to build components][Using Scala's expressive power to build components]]
      - [[Implementing components][Implementing components]]
      - [[Self types for components][Self types for components]]
  - [[Summary][Summary]]
- [[6. Creational Design Patterns][6. Creational Design Patterns]]
  - [[What are creational design patterns?][What are creational design patterns?]]
  - [[The factory method design pattern][The factory method design pattern]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
      - [[Scala alternatives][Scala alternatives]]
    - [[What it is good for?][What it is good for?]]
    - [[What it is not so good for?][What it is not so good for?]]
  - [[The abstract factory][The abstract factory]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
      - [[Scala alternatives][Scala alternatives]]
    - [[What it is good for?][What it is good for?]]
    - [[What it is not so good for?][What it is not so good for?]]
  - [[Other factory design patterns][Other factory design patterns]]
    - [[The static factory][The static factory]]
    - [[The simple factory][The simple factory]]
    - [[Factory combinations][Factory combinations]]
  - [[Lazy initialization][Lazy initialization]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
    - [[What it is good for?][What it is good for?]]
    - [[What it is not so good for?][What it is not so good for?]]
  - [[The singleton design pattern][The singleton design pattern]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
    - [[What it is good for?][What it is good for?]]
    - [[What it is not so good for?][What it is not so good for?]]
  - [[The builder design pattern][The builder design pattern]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
      - [[A Java-like implementation][A Java-like implementation]]
      - [[Implementation with a case class][Implementation with a case class]]
      - [[Using generalized type constraints][Using generalized type constraints]]
    - [[What it is good for?][What it is good for?]]
    - [[What it is not so good for?][What it is not so good for?]]
  - [[The prototype design pattern][The prototype design pattern]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
    - [[What it is good for?][What it is good for?]]
    - [[What it is not so good for?][What it is not so good for?]]
  - [[Summary][Summary]]
- [[7. Structural Design Patterns][7. Structural Design Patterns]]
  - [[Defining structural design patterns][Defining structural design patterns]]
  - [[The adapter design pattern][The adapter design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
      - [[The adapter design pattern with final classes][The adapter design pattern with final classes]]
      - [[The adapter design pattern the Scala way][The adapter design pattern the Scala way]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The decorator design pattern][The decorator design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
      - [[The decorator design pattern the Scala way][The decorator design pattern the Scala way]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The bridge design pattern][The bridge design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
      - [[The bridge design pattern the Scala way][The bridge design pattern the Scala way]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The composite design pattern][The composite design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The facade design pattern][The facade design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The flyweight design pattern][The flyweight design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The proxy design pattern][The proxy design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[Summary][Summary]]
- [[8. Behavioral Design Patterns - Part One][8. Behavioral Design Patterns - Part One]]
  - [[Defining behavioral design patterns][Defining behavioral design patterns]]
  - [[The value object design pattern][The value object design pattern]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
    - [[Alternative implementation][Alternative implementation]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The null object design pattern][The null object design pattern]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The strategy design pattern][The strategy design pattern]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
      - [[The strategy design pattern the Scala way][The strategy design pattern the Scala way]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The command design pattern][The command design pattern]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
      - [[The command design pattern the Scala way][The command design pattern the Scala way]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The chain of responsibility design pattern][The chain of responsibility design pattern]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
      - [[The chain of responsibility design pattern the][The chain of responsibility design pattern the]]
      - [[Scala way][Scala way]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The interpreter design pattern][The interpreter design pattern]]
    - [[An example class diagram][An example class diagram]]
    - [[A code example][A code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[Summary][Summary]]
- [[9. Behavioral Design Patterns - Part Two][9. Behavioral Design Patterns - Part Two]]
  - [[The iterator design pattern][The iterator design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The mediator design pattern][The mediator design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The memento design pattern][The memento design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The observer design pattern][The observer design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The state design pattern][The state design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The template method design pattern][The template method design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code exampleWhat it is good for][Code exampleWhat it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[The visitor design pattern][The visitor design pattern]]
    - [[Example class diagram][Example class diagram]]
    - [[Code example][Code example]]
      - [[The visitor design pattern the Scala way][The visitor design pattern the Scala way]]
    - [[What it is good for][What it is good for]]
    - [[What it is not so good for][What it is not so good for]]
  - [[Summary][Summary]]
- [[10. Functional Design Patterns - the Deep Theory][10. Functional Design Patterns - the Deep Theory]]
  - [[Abstraction and vocabulary][Abstraction and vocabulary]]
  - [[Monoids][Monoids]]
    - [[What are monoids?][What are monoids?]]
    - [[Monoids in real life][Monoids in real life]]
    - [[Using monoids][Using monoids]]
      - [[Monoids and foldable collections][Monoids and foldable collections]]
      - [[Monoids and parallel computations][Monoids and parallel computations]]
      - [[Monoids and composition][Monoids and composition]]
    - [[When to use monoids][When to use monoids]]
  - [[Functors][Functors]]
    - [[Functors in real life][Functors in real life]]
      - [[Using our functors][Using our functors]]
  - [[Monads][Monads]]
    - [[What is a monad?][What is a monad?]]
      - [[The flatMap method][The flatMap method]]
      - [[The unit method][The unit method]]
      - [[The connection between map, flatMap, and unit][The connection between map, flatMap, and unit]]
      - [[The monad laws][The monad laws]]
    - [[Monads in real life][Monads in real life]]
    - [[Using monads][Using monads]]
      - [[The Option monad][The Option monad]]
      - [[A more advanced monad example][A more advanced monad example]]
    - [[Monad intuition][Monad intuition]]
  - [[Summary][Summary]]
- [[11. Applying What We Have Learned][11. Applying What We Have Learned]]
  - [[The lens design pattern][The lens design pattern]]
    - [[Lens example][Lens example]]
      - [[Without the lens design pattern][Without the lens design pattern]]
      - [[With the lens design pattern][With the lens design pattern]]
    - [[Minimizing the boilerplate][Minimizing the boilerplate]]
  - [[The cake design pattern][The cake design pattern]]
    - [[Dependency injection][Dependency injection]]
      - [[Dependency injection libraries and Scala][Dependency injection libraries and Scala]]
    - [[Dependency injection in Scala][Dependency injection in Scala]]
      - [[Writing our code][Writing our code]]
      - [[Wiring it all up][Wiring it all up]]
      - [[Unit testing our application][Unit testing our application]]
    - [[Other dependency injection alternatives][Other dependency injection alternatives]]
      - [[Implicits for dependency injection][Implicits for dependency injection]]
      - [[Reader monad for dependency injection][Reader monad for dependency injection]]
  - [[The pimp my library design pattern][The pimp my library design pattern]]
    - [[Using pimp my library][Using pimp my library]]
    - [[Pimp my library in real life][Pimp my library in real life]]
  - [[The stackable traits design pattern][The stackable traits design pattern]]
    - [[Using stackable traits][Using stackable traits]]
  - [[The type class design pattern][The type class design pattern]]
    - [[Type class example][Type class example]]
    - [[Type class design pattern alternatives][Type class design pattern alternatives]]
  - [[Lazy evaluation][Lazy evaluation]]
    - [[Evaluating by-name parameters only once][Evaluating by-name parameters only once]]
    - [[Alternative lazy evaluation][Alternative lazy evaluation]]
  - [[Partial functions][Partial functions]]
    - [[Partial functions are not partially applied functions][Partial functions are not partially applied functions]]
    - [[Partially defined functions][Partially defined functions]]
  - [[Implicit injection][Implicit injection]]
    - [[Implicit conversions][Implicit conversions]]
    - [[Dependency injection using implicits][Dependency injection using implicits]]
      - [[Testing with implicit dependency injection][Testing with implicit dependency injection]]
  - [[Duck typing][Duck typing]]
    - [[Duck typing example][Duck typing example]]
    - [[Duck typing alternatives][Duck typing alternatives]]
    - [[When to use duck typing][When to use duck typing]]
  - [[Memoization][Memoization]]
    - [[Memoization example][Memoization example]]
    - [[Memoization alternatives][Memoization alternatives]]
  - [[Summary][Summary]]
- [[12. Real-Life Applications][12. Real-Life Applications]]
  - [[Reasons to use libraries][Reasons to use libraries]]
  - [[The Scalaz library][The Scalaz library]]
    - [[Monoids in Scalaz][Monoids in Scalaz]]
      - [[Using monoids][Using monoids]]
      - [[Testing monoids][Testing monoids]]
    - [[Monads in Scalaz][Monads in Scalaz]]
      - [[Using monads][Using monads]]
      - [[Testing monads][Testing monads]]
    - [[The possibilities of Scalaz][The possibilities of Scalaz]]
  - [[Writing a complete application][Writing a complete application]]
    - [[Application specifications][Application specifications]]
    - [[Implementation][Implementation]]
      - [[The libraries to use][The libraries to use]]
    - [[Writing some code][Writing some code]]
    - [[Wiring it all up][Wiring it all up]]
    - [[The end result][The end result]]
  - [[Testing our application][Testing our application]]
    - [[Unit testing][Unit testing]]
    - [[Application testing][Application testing]]
  - [[The future of our application][The future of our application]]
  - [[Summary][Summary]]

* Preface
** Who this book is for
** What this book covers
** To get the most out of this book
*** Download the example code files
*** Conventions used

** Get in touch
*** Reviews

* DONE 1. The Design Patterns Out There and Setting Up Your Environment
  CLOSED: [2018-08-14 Tue 01:27]
** DONE Design patterns
   CLOSED: [2018-05-29 Tue 11:54]
   - Design Patterns (The formal definition) ::
        A design pattern is a reusable solution to a recurring problem in
        software design. It is not a finished piece of code but a template that
        helps to solve a particular problem or family of problems.

   - Feature-rich languages might not even need a /design pattern/, while others
     still do.

   - The lack or existence of a certain functionality within aprogramming language
     also makes it able to implement additional /design patterns/ that others
     cannot. The opposite is also valid -- it might not be able to implement
     things that others can.

*** DONE Scala and design patterns
    CLOSED: [2018-05-29 Tue 11:54]
    - The hybrid nature of the Scala makes some of the /traditional object-oriented
      design patterns/ _obsolete_, or possible, using _other cleaner techniques_.

*** DONE The need for design patterns and their benefits
    CLOSED: [2018-05-29 Tue 11:54]

** DONE Design pattern categories - =RE-READ= =IMPORTANT=
   CLOSED: [2018-05-29 Tue 12:45]
   - Even if there are many different /design patterns/, they can all be grouped
     in the following:
     + Creational

     + Structural

     + Behavioral

     + Functional

     + Scala-specific design patterns
       * Some of these /design patterns/ can be assigned to the previous groups.
         - They can either be _additions_ or _replacements_ of the already
           existing ones.

         - They are typical to Scala and take advantage of some advanced language
           features or simply features not available in other languages.)

   - The _first three groups_ contain the famous /Gang of Four design patterns/.

     The rest, even if they can be assigned to one of the first three groups, will
     be specific to Scala and functional programming languages.

     =TODO=
     In the next few subsections, we will explain the main characteristics of
     the listed groups and briefly present the actual design patterns that fall
     under them.

*** TODO Creational design patterns
    - The /creational design patterns/ deal with /object creation mechanisms/.

      + *PURPOSE*: create objects in a way that is suitable to the current situation,
        which could lead to unnecessary complexity and the need for extra
        knowledge if they were not there.

      + The main ideas behind the /creational design patterns/ are as follows:
        * *Knowledge encapsulation* about the concrete classes

        * *Hiding details* about the actual creation and how objects are combined

**** TODO The abstract factory design pattern
**** TODO The factory method design pattern
**** TODO The lazy initialization design pattern
**** TODO The singleton design pattern
**** TODO The object pool design pattern
**** TODO The builder design pattern
**** TODO The prototype design pattern

*** TODO Structural design patterns
    - /Structural design patterns/ exist in order to help establish the
      relationships between different entities in order to _form larger
      structures_.

        They define how each component should be structured so that it has very
      flexible interconnecting modules that can work together in a larger
      system.

    - The main features of /structural design patterns/ include the following:
      + The use of composition to combine the implementations of multiple objects

      + Help build a large system made of various components by maintaining a high
        level of flexibility

**** TODO The adapter design pattern
**** TODO The decorator design pattern
**** TODO The bridge design pattern
**** TODO The composite design pattern
**** TODO The facade design pattern
**** TODO The flyweight design pattern
**** TODO The proxy design pattern

*** TODO Behavioral design patterns
    - /Behavioral design patterns/ increase *communication flexibility* between
      objects based on the specific ways they interact with each other.

      Here,
      + /creational patterns/ mostly describe a moment in time during creation,
      + /structural patterns/ describe a more or less static structure,
      + /behavioral patterns/ describe a process or flow.

      They simplify this flow and make it more understandable.

    - The main features of /behavioral design patterns/ are as follows:
      + What is being described is a process or flow

      + The flows are simplified and made understandable

      + They accomplish tasks that would be difficult or impossible to achieve
        with objects

**** The value object design pattern
**** The null object design pattern
**** The strategy design pattern
**** The command design pattern
**** The chain of responsibility design pattern
**** The interpreter design pattern
**** The iterator design pattern
**** The mediator design pattern
**** The memento design pattern
**** The observer design pattern
**** The state design pattern
**** The template method design pattern
**** The visitor design pattern

*** DONE Functional design patterns
    CLOSED: [2018-05-29 Tue 12:37]
**** DONE Monoids
     CLOSED: [2018-05-29 Tue 12:29]
     - Concept

     - What is important about /monoids/ is that
       + they give us the possibility to work with many different types of values
         in a common way.

       + They allow us to convert pairwise operations to *work with sequences*;
       + the /associativity/ gives us the possibility for *parallelization*
       + the /identity element/ allows us to know what to do with empty lists.

       /Monoids/ are *GREAT to EASILY* _describe and implement *aggregations*._

**** DONE Monads
     CLOSED: [2018-05-29 Tue 12:37]
     - /Monads/ are algebraic structures that REPRESENT _computations as sequences
       of steps_.

     - /Monads/ are useful for
       + building pipelines

       + adding operations with side effects cleanly to a language where everything
         is immutable

       + implementing compositions.
         =From Jian= Especially for data structures with embedded sub-structures

**** DONE Functors
     CLOSED: [2018-05-29 Tue 12:34]
     - This concept comes from /category theory/.

     - For now, you could remember that /functors/ are things that can allow us
       to *lift* a function of the /type/ ~A => B~ to a function of the /type/
       ~F[A] => F[B]~.

*** DONE Scala-specific design patterns
    CLOSED: [2018-05-29 Tue 12:45]
**** The lens design pattern
**** The cake design pattern
**** Pimp my library
**** Stackable traits
**** The type class design pattern
**** Lazy evaluation
**** Partial functions
**** Implicit injection
**** Duck typing
**** Memoization

** DONE Choosing a design pattern - =Re-REAd= =IMPORTANT=
   CLOSED: [2018-08-14 Tue 01:19]
   - About how to *use* /a design pattern/ or *combine* /design patterns/, you
     should consider (this is BY NO MEANS an exhaustive list of questions):
     + Is this piece of code
       going to be _fairly static_ OR will it _change in the future_?

     + Do we have to _dynamically decide_ what /algorithms/ to use?

     + Is our code going to be _used by others_?

     + Do we have an agreed /interface/?

     + _What libraries_ are we planning to use, if any?

     + Are there any _special performance requirements or limitations_?

   - In the rest of the chapters, we will try to give specific recommendations
     about _when a /design pattern/ should and should NOT be used._ =TODO=

     =IMPORTANT=
     They should help you ask the right questions and take the right decision
     before going on and writing code.

** DONE Setting up the development environment
   CLOSED: [2018-08-14 Tue 01:26]
*** DONE Installing Scala
    CLOSED: [2018-05-29 Tue 13:12]
**** DONE Tips for installing Scala manually
     CLOSED: [2018-05-29 Tue 13:12]
**** DONE Tips for installing Scala using SBT
     CLOSED: [2018-05-29 Tue 13:12]

*** DONE Scala IDEs
    CLOSED: [2018-05-29 Tue 13:13]
*** DONE Dependency management
    CLOSED: [2018-08-14 Tue 01:22]
**** SBT
**** Maven
**** SBT versus Maven

** DONE Summary
   CLOSED: [2018-08-14 Tue 01:26]
   - In MANY CASES, we could _use Scala's features_
     in order to
     _make a pattern OBSOLETE, SIMPLER, or DIFFERENT to implement compared to
     the classical case like in old Java (Before Java 8)_.

* TODO 2. Traits and Mixin Compositions
  - =TODO= NOTE

  - We will go through the following main topics in this chapter:
    + /Traits/

    + /Mixin compositions/

    + /Multiple inheritance/

    + /Linearization/

    + Testing /traits/

    + /Traits/ vs. /classes/

** DONE Traits
   CLOSED: [2018-10-04 Thu 02:07]
   - People have different perspectives of /traits/ in Scala:
     + They can be viewed not only as /interfaces/ in other languages
       but also
     + as /classes/ with *only parameter-less constructors*.
       =comment= This point will be change in Dotty!

   - In the following few sections,
     =TODO=
     we will see the /traits/
     + from different points of view
       and
     + try to give you some ideas about how they can be used.
   
*** DONE Traits as interfaces
    CLOSED: [2018-10-04 Thu 02:07]
    - Whenever there is some code in a /trait/ -- not pure abstract as Java /interface/
      before Java 8 (without /default method/) -- the /trait/ is called a /mixin/.

    - =from Jian=
      It seems we can category /traits/ as (*in my words*):
      + interface traits

      + mixin traits (similar to /abstract class/ in other languages)

    - Example (these /traits/ are used in the next section -- Mixin compositions):
      #+BEGIN_SRC scala
        trait Alarm {  // from Jian: interface trait
          def trigger(): String
        }

        trait Notifier {  // from Jian: mixin trait
          val notificationMessage: String

          def printNotification(): Unit = {
            System.out.println(notificationMessage)
          }

          def clear()
        }
      #+END_SRC

**** DONE Mixing in traits with variables
     CLOSED: [2018-10-04 Thu 22:43]
     #+BEGIN_SRC scala
       class NotifierImpl(val notificationMessage: String) extends Notifier {
         override def clear(): Unit = System.out.println("cleared")
       }
     #+END_SRC

     - Here you apply ~val~ on ~notificationMessage~, then it is a part of the
       /class/ as a /field/, and a /getter/ will be generated for it.
       (*required*: 1. ~val~; 2. same name ~notificationMessage~)

     - If there is NO ~val~, we need implement ~notificationMessage~ in the body
       with ~override val notificationMessage~ (for implementing /trait field/,
       ~override~ is *optional* -- =from Jian= I think keep using ~override~ is
       a good practice -- a hint to its origin. However, I don't think ~override~
       meaning is fit for this, I prefer a NOT ACTUALLY EXIST in Scala keyword
       like ~impl~).

*** DONE Traits as classes
    CLOSED: [2018-10-04 Thu 02:07]
    - /Traits/ can also be seen _from the perspective of_ /classes/. In this case,
      + they have to *implement ALL their methods*
      + they have ONLY ONE /constructor that does *NOT* accept any parameters/.

    - Example:
      #+BEGIN_SRC scala
        trait Beeper {
          def beep(times: Int): Unit =
            (1 to times).
              view.
              map(i => s"Beep number: $i").
              foreach(println)
        }

        object BeeperRunner {
          val TIMES = 10

          def main(args: Array[String]): Unit = {
            // Because you can't instantiate a `trait`,
            // you CANNOT write `new Beeper` without the following `{}`
            val beeper = new Beeper {}
            beeper beep TIMES
          }
        }
      #+END_SRC

*** DONE Extending classes
    CLOSED: [2018-10-04 Thu 02:07]
    /Traits/ can *extend* /classes/.

    - Example:
      #+BEGIN_SRC scala
        abstract class Connector {
          def connect()
          def close()
        }

        trait ConnectorWithHelper extends Connector {
          def findDriver(): Unit = {
            System.out.println("Find driver called.")
          }
        }

        class PgSqlConnector extends ConnectorWithHelper {
          override def connect(): Unit = {
            System.out.println("Connected...")
          }
          override def close(): Unit = {
            System.out.println("Closed...")
          }
        }
      #+END_SRC

      =TODO= =TODO= =TODO=
      However, Scala will put a *limit* to some cases, and we will =TODO= see how
      it will affect us later in this chapter when we look at compositions.

*** DONE Extending traits
    CLOSED: [2018-10-04 Thu 02:06]
    /Traits/ can *extend* /traits/.

    - Example:
      #+BEGIN_SRC scala
        trait Ping {
          def ping(): Unit = {
            System.out.println("ping")
          }
        }

        trait Pong {
          def pong(): Unit = {
            System.out.println("pong")
          }
        }

        trait PingPong extends Ping with Pong {
          def pingPong(): Unit = {
            ping()
            pong()
          }
        }

        object Runner extends PingPong {
          def main(args: Array[String]): Unit = {
            pingPong()
          }
        }
      #+END_SRC
      + This is just a example. Of course, your ~Runner~ can extends the /super
        traits/ of ~PingPong~ (~Ping~ and ~Pong~) DIRECTLY, rather than
        ~PingPong~ itself.

    - =from Jian= didn't metion the *forbided* /circular extension/!!!

    - =TODO= /Stackable Traits/

** DONE Mixin compositions
   CLOSED: [2018-10-06 Sat 01:37]
   Show how /traits/ can be *mixed in* a SPECIFIC /class/

   OR

   used to *create* /anonymous classes/ with some specific functionality while
   writing our code.

*** DONE Mixing traits in
    CLOSED: [2018-10-04 Thu 22:20]
*** DONE Composing
    CLOSED: [2018-10-06 Sat 01:27]
    Composing at _creation time_ gives us an opportunity to CREATE /anonymous
    classes/ *without* the need to explicitly define them.
    
**** DONE Composing simple traits
     CLOSED: [2018-10-06 Sat 00:50]
     Compose simple /traits/, which do NOT extend other /traits/ or /classes/:
     #+BEGIN_SRC scala
       class Watch(val brand: String, initialTime: Long) {
         def getTime(): Long = System.currentTimeMillis() - initialTime
       }

       object WatchUser {
         def main(args: Array[String]): Unit = {
           val expensiveWatch = new Watch("expensive brand", 1000L) with Alarm with
               Notifier {
             override def trigger(): String = "The alarm was triggered."
             override def clear(): Unit = {
               System.out.println("Alarm cleared.")
             }
             override val notificationMessage: String = "Alarm is running!"
           }
           val cheapWatch = new Watch("cheap brand", 1000L) with Alarm {
             override def trigger(): String = "The alarm was triggered."
           }
             // show some watch usage.
           System.out.println(expensiveWatch.trigger())
           expensiveWatch.printNotification()
           System.out.println(s"The time is ${expensiveWatch.getTime()}.")
           expensiveWatch.clear()
           System.out.println(cheapWatch.trigger())
           System.out.println(s"${cheapWatch.brand} watches cannot manually stop the alarm...")
         }
       }
     #+END_SRC
     =from Jian= The original code does neither use ~brand~, nor create a /field/
     for it. This is not reasonable -- I modified the code and convert ~brand~ to
     a ~val~ field.

**** DONE Composing complex traits
     CLOSED: [2018-10-06 Sat 01:02]
     We defined ~ConnectorWithHelper~ /trait/ before, and it extends the
     /abstract class/ ~Connector~. Now let's use ~ConnectorWithHelper~:
     #+BEGIN_SRC scala
       object ReallyExpensiveWatchUser {
         def main(args: Array[String]): Unit = {
           val reallyExpensiveWatch =
             new Watch("really expensive brand", 1000L)
                 with ConnectorWithHelper {
               override def connect(): Unit = {
                 System.out.println("Connected with another connector.")
               }

               override def close(): Unit = {
                 System.out.println("Closed with another connector.")
               }
             }

           System.out.println("Using the really expensive watch.")
           reallyExpensiveWatch.findDriver()
           reallyExpensiveWatch.connect()
           reallyExpensiveWatch.close()
         }
       }
     #+END_SRC

     You compile the code above and will see a /compilation error/ like:
     #+BEGIN_SRC text
       Error:(36, 80) illegal inheritance; superclass Watch
        is not a subclass of the superclass Connector
        of the mixin trait ConnectorWithHelper
           val reallyExpensiveWatch = new Watch("really expensive brand", 1000L)
       with ConnectorWithHelper {
       ^
     #+END_SRC

     ~Watch~ is a /class/ and it is NOT the /subclass/ of ~Connector~, thus it
     *CANNOT* extends a /trait/ that extends ~Connector~ -- for here,
     ~ConnectorWithHelper~ is the one.

     This is a case that how Scala *limit* multiple inheritance in order to prevent
     dangerous errors from happening. (=from Jian= "limit" not "forbid" --
     /trait/ based /mutiple inheritance/ is still a /mutiple inheritance/).
     
**** DONE Composing with self-types
     CLOSED: [2018-10-06 Sat 01:27]
     We can *enforce* a /trait/ to be /mixed into/ a /class/ that also has another
     /trait/ or /multiple traits/ mixed into it.

     - Example:
       #+BEGIN_SRC scala
         trait AlarmNotifier {
           this: Notifier =>

           def trigger(): String
         }
       #+END_SRC
       + Of course, ~this~ here must be ~AlarmNotifier~ itself, but it is also a
         ~Notifier~.

       + In the preceding code, we've shown a /self-type/.
         * The highlighted piece of code brings all the /methods/ of ~Notifier~
           to the scope of our new ~trait~
           and
         * it also requires that ANY /class/ that /mixes in/ ~AlarmNotifier~ should
           *also* /mix in/ ~Notifier~. Otherwise, a compilation error will occur.

       + Instead of this, we can use ~self~ and then refer to the ~Notifier~ /methods/
         inside ~AlarmNotifier~ by typing, for example, ~self.printNotification()~.

         =Urgent= =TODO= =IMPORTANT= =???= =Experiment=
         =from Jian= Does this mean if we write ~self: Notifier =>~, we can, in
         the body of this /trait/, use ~self~ to refer ~Notifier~ and use ~this~
         to refer ~AlarmNotifier~???

     - Code use the ~AlarmNotifier~ in the right way:
       #+BEGIN_SRC scala
         object SelfTypeWatchUser {
           def main(args: Array[String]): Unit = {
             //// uncomment to see the self-type error.
             // val watch = new Watch("alarm with notification", 1000L) with AlarmNotifier
             val watch = new Watch("alarm with notification", 1000L) with
                 AlarmNotifier with Notifier {
               override def trigger(): String = "Alarm triggered."
               override def clear(): Unit = System.out.println("Alarm cleared.")
               override val notificationMessage: String = "The notification."
             }
             System.out.println(watch.trigger())
             watch.printNotification()
             System.out.println(s"The time is ${watch.getTime()}.")
             watch.clear()
           }
         }
       #+END_SRC

     - Multiple /traits/ /self-types/ are also allowed, just use ~with~.

     - /Self-types/ are a key part of the /cake design pattern/, which is used for
       /dependency injection/.
       =TODO= More interesting cases later in this book!

*** DONE Clashing traits - =TODO= NOTES
    CLOSED: [2018-10-06 Sat 01:36]
    Resolve the question of _mix in_ /traits/ that have /methods/ with
    *IDENTICAL* /signatures/.

**** TODO Same signatures and return types
**** TODO Same signatures and different return types traits
**** TODO Same signatures and return types mixins
**** TODO Same signatures and different return types mixins

** TODO Multiple inheritance
*** TODO The diamond problem
*** TODO The limitations

** TODO Linearization
*** TODO Rules of inheritance hierarchies
*** TODO Linearization rules
*** TODO How linearization works
*** TODO Initialization
*** TODO Method overriding

** TODO Testing traits
*** TODO Using a class
*** TODO Mixing the trait in
**** Mixing into the test class
**** Mixing into the test cases

*** TODO Running the tests

** TODO Traits versus classes
*** TODO Summary

* TODO 3. Unification
** TODO Functions and classes
*** DONE Functions as classes
    CLOSED: [2018-08-14 Tue 01:38]
**** Function literals
**** Functions without syntactic sugar

*** Increased expressivity
    From the example, you see:
    - *Unifying classes and functions* leads to _increased expressivity_
      and
      + we can easily achieve various things such as /callbacks/, /lazy parameter
        evaluation/, /centralized exception handling/, and others,
        AND
        without writing extra code and logic.

    - Moreover, /functions/ as /classes/ mean that we can extend them to _provide
      EXTRA functionality_.

** Algebraic data types and class hierarchies
   - Scala's ADT -- Use /case classes/.

*** TODO ADTs
    - =TODO=
      The following few subsections will give
      + a bit more insight on what ADTs are
        and
      + what types are out there.
   
**** DONE Sum ADTs
     CLOSED: [2018-08-14 Tue 01:51]
     - /Sum ADTs/ is good for enumerable variants cases.

     - Example:
       #+BEGIN_SRC scala
         sealed abstract trait Month
         case object January extends Month
         case object February extends Month
         case object March extends Month
         case object April extends Month
         case object May extends Month
         case object June extends Month
         case object July extends Month
         case object August extends Month
         case object September extends Month
         case object October extends Month
         case object November extends Month
         case object December extends Month
       #+END_SRC

**** DONE Product ADTs
     CLOSED: [2018-08-14 Tue 01:51]
     - /Product ADTs/ for NOT-be-enumerable variants cases.

     - Example:
       ~sealed case class RGB(red: Int, greet: Int, blue: Int}~

**** Hybrid ADTs
**** The unification

*** Pattern matching
**** Pattern matching with values
**** Pattern matching for product ADTs

** Modules and objects
**** Using modules

** Summary

* TODO 4. Abstract and Self Types
  - Designing and writing high-quality code in software engineering is important
    in order to have applications that are easy to extend and maintain.

    This activity requires the
    + domain to be well-known, correctly understood by a developer
    + the requirements for the application to be well-defined.

    If any of these are absent, then writing good programs becomes quite
    challenging.

  - We will look into the following topics in this chapter:
    + Abstract types
    + Polymorphism
    + Self types

  - This chapter can by itself help you writing good code.

  - This chapter is useful when we start looking into some of the concrete
    design patterns.

** TODO Abstract types
   We can _parameterize classes by using values_ -- instantiate a class with
   different values to get different instances -- just the construction
   parameters.

   For example, pass different names (string values) to ~case class Person(name:
   String)~.

*** DONE Generics
    CLOSED: [2018-09-21 Fri 17:04]
    - /Generics/ are another way of _parameterizing classes_.

    - The most signatures example of using /generics/ to _parameterizing
      classes_ is the collection types.

    - Example:
      #+BEGIN_SRC scala
        trait Adder {
          def sum[T](a: T, b: T)(implicit numeric: Numeric[T]): T =
            numeric.plus(a, b)
        }
      #+END_SRC

    - *ad hoc polymorphism*
      =TODO=
      =???=

*** TODO Abstract types
    - Another way to _parameterize classes is by using /abstract types/._

      /Generics/ have their counterparts in other languages such as Java.
      _UNLIKE them_, however, /abstract types/ do *not* exist in Java.

    - xxx

*** TODO Generics versus abstract types
**** Usage advice

** TODO Polymorphism
*** TODO Subtype polymorphism
*** TODO Parametric polymorphism
*** TODO Ad hoc polymorphism
**** TODO Adding functions for multiple types

** TODO Self types
*** TODO Using self types
**** TODO Requiring multiple components
**** TODO Conflicting components
**** TODO Self types and the cake design pattern

*** TODO Self types versus inheritance
**** TODO Inheritance leaking functionality

** TODO Summary

* 5. Aspect-Oriented Programming and Components
** Aspect-oriented programming
*** Understanding application efficiency
**** Timing our application without AOP
**** Timing our application with AOP

** Components in Scala
*** Using Scala's expressive power to build components
**** Implementing components
**** Self types for components

** Summary

* 6. Creational Design Patterns
** What are creational design patterns?
** The factory method design pattern
*** An example class diagram
*** A code example
**** Scala alternatives

*** What it is good for?
*** What it is not so good for?

** The abstract factory
*** An example class diagram
*** A code example
**** Scala alternatives

*** What it is good for?
*** What it is not so good for?

** Other factory design patterns
*** The static factory
*** The simple factory
*** Factory combinations

** Lazy initialization
*** An example class diagram
*** A code example
*** What it is good for?
*** What it is not so good for?

** The singleton design pattern
*** An example class diagram
*** A code example
*** What it is good for?
*** What it is not so good for?

** The builder design pattern
*** An example class diagram
*** A code example
**** A Java-like implementation
**** Implementation with a case class
**** Using generalized type constraints
***** Changing the Person class
***** Adding generalized type constraints to the required methods
***** Using the type-safe builder

*** What it is good for?
*** What it is not so good for?

** The prototype design pattern
*** An example class diagram
*** A code example
*** What it is good for?
*** What it is not so good for?

** Summary

* 7. Structural Design Patterns
** Defining structural design patterns
** The adapter design pattern
*** Example class diagram
*** Code example
**** The adapter design pattern with final classes
**** The adapter design pattern the Scala way

*** What it is good for
*** What it is not so good for

** The decorator design pattern
*** Example class diagram
*** Code example
**** The decorator design pattern the Scala way

*** What it is good for
*** What it is not so good for

** The bridge design pattern
*** Example class diagram
*** Code example
**** The bridge design pattern the Scala way

*** What it is good for
*** What it is not so good for

** The composite design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The facade design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The flyweight design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The proxy design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** Summary

* 8. Behavioral Design Patterns - Part One
** Defining behavioral design patterns
** The value object design pattern
*** An example class diagram
*** A code example
*** Alternative implementation
*** What it is good for
*** What it is not so good for

** The null object design pattern
*** An example class diagram
*** A code example
*** What it is good for
*** What it is not so good for

** The strategy design pattern
*** An example class diagram
*** A code example
**** The strategy design pattern the Scala way

*** What it is good for
*** What it is not so good for

** The command design pattern
*** An example class diagram
*** A code example
**** The command design pattern the Scala way

*** What it is good for
*** What it is not so good for

** The chain of responsibility design pattern
*** An example class diagram
*** A code example
**** The chain of responsibility design pattern the
**** Scala way
*** What it is good for
*** What it is not so good for

** The interpreter design pattern
*** An example class diagram
*** A code example
*** What it is good for
*** What it is not so good for

** Summary

* 9. Behavioral Design Patterns - Part Two
** The iterator design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The mediator design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The memento design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The observer design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The state design pattern
*** Example class diagram
*** Code example
*** What it is good for
*** What it is not so good for

** The template method design pattern
*** Example class diagram
*** Code exampleWhat it is good for
*** What it is not so good for

** The visitor design pattern
*** Example class diagram
*** Code example
**** The visitor design pattern the Scala way

*** What it is good for
*** What it is not so good for

** Summary

* 10. Functional Design Patterns - the Deep Theory
** Abstraction and vocabulary
** Monoids
*** What are monoids?
*** Monoids in real life
*** Using monoids
**** Monoids and foldable collections
**** Monoids and parallel computations
**** Monoids and composition

*** When to use monoids

** Functors
*** Functors in real life
**** Using our functors

** Monads
*** What is a monad?
**** The flatMap method
**** The unit method
**** The connection between map, flatMap, and unit
***** The names of the methods
**** The monad laws

*** Monads in real life
*** Using monads
**** The Option monad
**** A more advanced monad example

*** Monad intuition

** Summary

* 11. Applying What We Have Learned
** The lens design pattern
*** Lens example
**** Without the lens design pattern
***** Immutable and verbose
***** Using mutable properties

**** With the lens design pattern

*** Minimizing the boilerplate

** The cake design pattern
*** Dependency injection
**** Dependency injection libraries and Scala

*** Dependency injection in Scala
**** Writing our code
**** Wiring it all up
**** Unit testing our application

*** Other dependency injection alternatives
**** Implicits for dependency injection
**** Reader monad for dependency injection

** The pimp my library design pattern
*** Using pimp my library
*** Pimp my library in real life

** The stackable traits design pattern
*** Using stackable traits

** The type class design pattern
*** Type class example
*** Type class design pattern alternatives

** Lazy evaluation
*** Evaluating by-name parameters only once
*** Alternative lazy evaluation

** Partial functions
*** Partial functions are not partially applied functions
*** Partially defined functions

** Implicit injection
*** Implicit conversions
*** Dependency injection using implicits
**** Testing with implicit dependency injection

** Duck typing
*** Duck typing example
*** Duck typing alternatives
*** When to use duck typing

** Memoization
*** Memoization example
*** Memoization alternatives

** Summary

* 12. Real-Life Applications
** Reasons to use libraries
** The Scalaz library
*** Monoids in Scalaz
**** Using monoids
**** Testing monoids

*** Monads in Scalaz
**** Using monads
**** Testing monads

*** The possibilities of Scalaz

** Writing a complete application
*** Application specifications
*** Implementation
**** The libraries to use
***** Reading the application configuration
***** Reading the scheduler configuration
***** Scheduling tasks
***** Accessing a database
***** Executing console commands

*** Writing some code
*** Wiring it all up
*** The end result

** Testing our application
*** Unit testing
*** Application testing

** The future of our application
** Summary
