#+TITLE: Scala Cookbook
#+VERSION: 1st
#+AUTHOR: Alvin Alexander
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Preface - 15][Preface - 15]]
  - [[The Scala Language - xiii][The Scala Language - xiii]]
    - [[Solution - xiv][Solution - xiv]]
  - [[Audience - xvi][Audience - xvi]]
  - [[Contents of This Book - xvii][Contents of This Book - xvii]]
  - [[Online Bonus Chapters - xx][Online Bonus Chapters - xx]]
  - [[Installing the Software - xx][Installing the Software - xx]]
  - [[How the Code Listings Work - xxi][How the Code Listings Work - xxi]]
  - [[Conventions Used in This Book - xxi][Conventions Used in This Book - xxi]]
  - [[Using Code Examples - xxii][Using Code Examples - xxii]]
  - [[How to Contact Us - xxiii][How to Contact Us - xxiii]]
  - [[Acknowledgements - xxiii][Acknowledgements - xxiii]]
- [[1. Strings - 1][1. Strings - 1]]
  - [[Introduction - 1][Introduction - 1]]
    - [[Add Methods to Closed Classes - 3][Add Methods to Closed Classes - 3]]
  - [[1.1. Testing String Equality - 4][1.1. Testing String Equality - 4]]
    - [[Problem - 4][Problem - 4]]
    - [[Solution - 4][Solution - 4]]
    - [[Discussion - 6][Discussion - 6]]
  - [[1.2. Creating Multiline Strings - 6][1.2. Creating Multiline Strings - 6]]
    - [[Problem - 6][Problem - 6]]
    - [[Solution - 6][Solution - 6]]
    - [[Discussion - 7][Discussion - 7]]
  - [[1.3. Splitting Strings - 8][1.3. Splitting Strings - 8]]
    - [[Problem - 8][Problem - 8]]
    - [[Solution - 8][Solution - 8]]
    - [[Discussion - 8][Discussion - 8]]
      - [[About that ~split~ method... - 9][About that ~split~ method... - 9]]
  - [[1.4. Substituting Variables into Strings - 9][1.4. Substituting Variables into Strings - 9]]
    - [[Problem - 9][Problem - 9]]
    - [[Solution - 9][Solution - 9]]
      - [[Using expressions in string literals - 10][Using expressions in string literals - 10]]
      - [[~s~ is a method - 10][~s~ is a method - 10]]
      - [[The ~f~ string interpolator (~printf~ style formatting) - 11][The ~f~ string interpolator (~printf~ style formatting) - 11]]
      - [[The ~raw~ interpolator - 11][The ~raw~ interpolator - 11]]
      - [[Create your own interpolator - 12][Create your own interpolator - 12]]
    - [[Discussion - 12][Discussion - 12]]
    - [[See Also - 13][See Also - 13]]
  - [[1.5. Processing a String One Character at a Time - 13][1.5. Processing a String One Character at a Time - 13]]
    - [[Problem - 13][Problem - 13]]
    - [[Solution - 13][Solution - 13]]
    - [[Discussion - 14][Discussion - 14]]
      - [[Understanding how map works - 15][Understanding how map works - 15]]
      - [[A complete example - 16][A complete example - 16]]
    - [[See Also - 17][See Also - 17]]
  - [[1.6. Finding Patterns in Strings - 18][1.6. Finding Patterns in Strings - 18]]
    - [[Problem - 18][Problem - 18]]
    - [[Solution - 18][Solution - 18]]
    - [[Discussion - 19][Discussion - 19]]
      - [[Handling the ~Option~ returned by ~findFirstIn~ - 19][Handling the ~Option~ returned by ~findFirstIn~ - 19]]
    - [[See Also- 20][See Also- 20]]
  - [[1.7. Replacing Patterns in Strings - 21][1.7. Replacing Patterns in Strings - 21]]
    - [[Problem - 21][Problem - 21]]
    - [[Solution - 21][Solution - 21]]
    - [[See Also - 21][See Also - 21]]
  - [[1.8. Extracting Parts of a String That Match Patterns - 22][1.8. Extracting Parts of a String That Match Patterns - 22]]
    - [[Problem - 22][Problem - 22]]
    - [[Solution - 22][Solution - 22]]
    - [[Discussion - 22][Discussion - 22]]
    - [[See Also - 24][See Also - 24]]
  - [[1.9. Accessing a Character in a String - 24][1.9. Accessing a Character in a String - 24]]
    - [[Problem - 24][Problem - 24]]
    - [[Solution - 24][Solution - 24]]
    - [[Discussion - 24][Discussion - 24]]
  - [[1.10. Add Your Own Methods to the String Class - 25][1.10. Add Your Own Methods to the String Class - 25]]
    - [[Problem - 25][Problem - 25]]
    - [[Solution - 25][Solution - 25]]
      - [[Put the ~implicit class~ in an object - 25][Put the ~implicit class~ in an object - 25]]
      - [[Put the ~implicit class~ in a package object - 26][Put the ~implicit class~ in a package object - 26]]
      - [[Using versions of Scala prior to version 2.10 - 27][Using versions of Scala prior to version 2.10 - 27]]
    - [[Discussion - 27][Discussion - 27]]
      - [[Annotate your method return type - 28][Annotate your method return type - 28]]
      - [[Returning other types - 29][Returning other types - 29]]
- [[2. Numbers - 31][2. Numbers - 31]]
  - [[Introduction - 31][Introduction - 31]]
    - [[Complex Numbers and Dates - 32][Complex Numbers and Dates - 32]]
  - [[2.1. Parsing a Number from a String - 32][2.1. Parsing a Number from a String - 32]]
    - [[Problem - 32][Problem - 32]]
    - [[Solution - 32][Solution - 32]]
      - [[Handling a base and radix - 33][Handling a base and radix - 33]]
    - [[Discussion - 34][Discussion - 34]]
      - [[Alternatives to ~Option~ - 35][Alternatives to ~Option~ - 35]]
    - [[See Also - 36][See Also - 36]]
  - [[2.2. Converting Between Numeric Types (Casting) - 36][2.2. Converting Between Numeric Types (Casting) - 36]]
    - [[Problem - 36][Problem - 36]]
    - [[Solution - 36][Solution - 36]]
    - [[Discussion - 36][Discussion - 36]]
    - [[See Also - 36][See Also - 36]]
  - [[2.3. Overriding the Default Numeric Type - 37][2.3. Overriding the Default Numeric Type - 37]]
    - [[Problem - 37][Problem - 37]]
    - [[Solution - 37][Solution - 37]]
    - [[Discussion - 39][Discussion - 39]]
    - [[See Also - 39][See Also - 39]]
  - [[2.4. Replacements for ~++~ and ~−−~ - 39][2.4. Replacements for ~++~ and ~−−~ - 39]]
    - [[Problem - 40][Problem - 40]]
    - [[Solution - 41][Solution - 41]]
    - [[Discussion - 41][Discussion - 41]]
    - [[See Also - 41][See Also - 41]]
  - [[2.5. Comparing Floating-Point Numbers - 41][2.5. Comparing Floating-Point Numbers - 41]]
    - [[Problem - 41][Problem - 41]]
    - [[Solution - 41][Solution - 41]]
    - [[Discussion - 42][Discussion - 42]]
    - [[See Also - 43][See Also - 43]]
  - [[2.6. Handling Very Large Numbers - 43][2.6. Handling Very Large Numbers - 43]]
    - [[Problem - 43][Problem - 43]]
    - [[Solution - 43][Solution - 43]]
    - [[Discussion - 44][Discussion - 44]]
    - [[See Also - 45][See Also - 45]]
  - [[2.7. Generating Random Numbers - 45][2.7. Generating Random Numbers - 45]]
    - [[Problem - 45][Problem - 45]]
    - [[Solution - 45][Solution - 45]]
    - [[Discussion - 46][Discussion - 46]]
    - [[See Also - 47][See Also - 47]]
  - [[2.8. Creating a ~Range~, ~List~, or ~Array~ of Numbers - 47][2.8. Creating a ~Range~, ~List~, or ~Array~ of Numbers - 47]]
    - [[Problem - 47][Problem - 47]]
    - [[Solution - 47][Solution - 47]]
    - [[Discussion - 48][Discussion - 48]]
    - [[See Also - 49][See Also - 49]]
  - [[2.9. Formatting Numbers and Currency - 49][2.9. Formatting Numbers and Currency - 49]]
    - [[Problem - 49][Problem - 49]]
    - [[Solution - 49][Solution - 49]]
    - [[Discussion - 51][Discussion - 51]]
    - [[See Also - 51][See Also - 51]]
- [[3. Control Structures - 53][3. Control Structures - 53]]
  - [[Introduction - 53][Introduction - 53]]
  - [[3.1. Looping with ~for~ and ~foreach~ - 54][3.1. Looping with ~for~ and ~foreach~ - 54]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
      - [[Returning values from a for loop][Returning values from a for loop]]
      - [[~for~ loop counters][~for~ loop counters]]
      - [[Generators and guards][Generators and guards]]
      - [[Looping over a Map][Looping over a Map]]
    - [[Discussioin][Discussioin]]
      - [[How ~for~ loops are translated][How ~for~ loops are translated]]
  - [[3.2. Using for Loops with Multiple Counters - 60][3.2. Using for Loops with Multiple Counters - 60]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.3. Using a for Loop with Embedded if Statements (Guards) - 62][3.3. Using a for Loop with Embedded if Statements (Guards) - 62]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.4. Creating a for Comprehension (for/yield Combination) - 63][3.4. Creating a for Comprehension (for/yield Combination) - 63]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.5. Implementing break and continue - 65][3.5. Implementing break and continue - 65]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
      - [[The *break* example][The *break* example]]
      - [[The *continue* example][The *continue* example]]
      - [[General syntax][General syntax]]
      - [[About that *continue* example..][About that *continue* example..]]
      - [[Nested loops and /labeled breaks/][Nested loops and /labeled breaks/]]
    - [[Discussion][Discussion]]
  - [[3.6. Using the ~if~ Construct Like a Ternary Operator - 71][3.6. Using the ~if~ Construct Like a Ternary Operator - 71]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.7. Using a Match Expression Like a switch Statement - 72][3.7. Using a Match Expression Like a switch Statement - 72]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
      - [[The ~@switch~ annotation][The ~@switch~ annotation]]
    - [[Discussion][Discussion]]
      - [[Handling the default case][Handling the default case]]
      - [[Do you really need a switch statement?][Do you really need a switch statement?]]
  - [[3.8. Matching Multiple Conditions with One Case Statement - 76][3.8. Matching Multiple Conditions with One Case Statement - 76]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.9. Assigning the Result of a Match Expression to a Variable - 77][3.9. Assigning the Result of a Match Expression to a Variable - 77]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.10. Accessing the Value of the Default Case in a Match Expression - 78][3.10. Accessing the Value of the Default Case in a Match Expression - 78]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.11. Using Pattern Matching in Match Expressions - 79][3.11. Using Pattern Matching in Match Expressions - 79]]
    - [[Problem - 79][Problem - 79]]
    - [[Solution - 79][Solution - 79]]
    - [[Discussion - 82][Discussion - 82]]
      - [[Patterns - 82][Patterns - 82]]
      - [[Adding variables to patterns - 84][Adding variables to patterns - 84]]
      - [[Using ~Some~ and ~None~ in match expressions - 85][Using ~Some~ and ~None~ in match expressions - 85]]
    - [[See Also - 86][See Also - 86]]
  - [[3.12. Using Case Classes in Match Expressions - 86][3.12. Using Case Classes in Match Expressions - 86]]
    - [[Problem - 86][Problem - 86]]
    - [[Solution - 86][Solution - 86]]
  - [[3.13. Adding if Expressions (Guards) to Case Statements - 87][3.13. Adding if Expressions (Guards) to Case Statements - 87]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.14. Using a Match Expression Instead of isInstanceOf - 88][3.14. Using a Match Expression Instead of isInstanceOf - 88]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.15. Working with a List in a Match Expression - 89][3.15. Working with a List in a Match Expression - 89]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.16. Matching One or More Exceptions with try/catch - 91][3.16. Matching One or More Exceptions with try/catch - 91]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.17. Declaring a Variable Before Using It in a try/catch/finally Block - 92][3.17. Declaring a Variable Before Using It in a try/catch/finally Block - 92]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
    - [[Discussion][Discussion]]
  - [[3.18. Creating Your Own Control Structures - 95][3.18. Creating Your Own Control Structures - 95]]
    - [[Problem - 95][Problem - 95]]
    - [[Solution - 95][Solution - 95]]
    - [[Discussion - 96][Discussion - 96]]
- [[4. Classes and Properties - 99][4. Classes and Properties - 99]]
  - [[Introduction - 99][Introduction - 99]]
  - [[4.1. Creating a Primary Constructor - 100][4.1. Creating a Primary Constructor - 100]]
    - [[Problem - 100][Problem - 100]]
    - [[Solution - 100][Solution - 100]]
    - [[Discussion - 101][Discussion - 101]]
      - [[A comparison with Java - 102][A comparison with Java - 102]]
      - [[Those ~_$eq~ methods - 103][Those ~_$eq~ methods - 103]]
      - [[Summary - 104][Summary - 104]]
  - [[4.2. Controlling the Visibility of Constructor Fields - 104][4.2. Controlling the Visibility of Constructor Fields - 104]]
    - [[Problem - 104][Problem - 104]]
    - [[Solution - 105][Solution - 105]]
      - [[~var~ fields - 105][~var~ fields - 105]]
      - [[~val~ fields - 106][~val~ fields - 106]]
      - [[Fields without ~val~ or ~var~ - 106][Fields without ~val~ or ~var~ - 106]]
      - [[Adding ~private~ to ~val~ or ~var~ - 106][Adding ~private~ to ~val~ or ~var~ - 106]]
    - [[Discussion - 107][Discussion - 107]]
      - [[Case classes - 107][Case classes - 107]]
  - [[4.3. Defining Auxiliary Constructors - 108][4.3. Defining Auxiliary Constructors - 108]]
    - [[Problem - 108][Problem - 108]]
    - [[Solution - 108][Solution - 108]]
    - [[Discussion - 109][Discussion - 109]]
      - [[Generating auxiliary constructors for case classes - 110][Generating auxiliary constructors for case classes - 110]]
    - [[See Also - 112][See Also - 112]]
  - [[4.4. Defining a Private Primary Constructor - 112][4.4. Defining a Private Primary Constructor - 112]]
    - [[Problem - 112][Problem - 112]]
    - [[Solution - 112][Solution - 112]]
    - [[Discussion - 112][Discussion - 112]]
      - [[Utility classes - 113][Utility classes - 113]]
  - [[4.5. Providing Default Values for Constructor Parameters - 114][4.5. Providing Default Values for Constructor Parameters - 114]]
    - [[Problem - 114][Problem - 114]]
    - [[Solution - 114][Solution - 114]]
    - [[Discussion - 114][Discussion - 114]]
      - [[Multiple parameters - 115][Multiple parameters - 115]]
      - [[Using named parameters - 115][Using named parameters - 115]]
    - [[See Also - 115][See Also - 115]]
  - [[4.6. Overriding Default Accessor - 116][4.6. Overriding Default Accessor - 116]]
    - [[Problem - 116][Problem - 116]]
    - [[Solution - 116][Solution - 116]]
    - [[Discussion - 117][Discussion - 117]]
      - [[Summary - 118][Summary - 118]]
  - [[4.7. Preventing Getter and Setter Methods from Being Generated - 119][4.7. Preventing Getter and Setter Methods from Being Generated - 119]]
    - [[Problem - 119][Problem - 119]]
    - [[Solution - 119][Solution - 119]]
    - [[Discussion - 119][Discussion - 119]]
      - [[Object-private fields - 120][Object-private fields - 120]]
    - [[See Also - 115][See Also - 115]]
  - [[4.8. Assigning a Field to a Block or Function - 121][4.8. Assigning a Field to a Block or Function - 121]]
    - [[Problem - 121][Problem - 121]]
    - [[Solution - 121][Solution - 121]]
    - [[Discussion - 121][Discussion - 121]]
  - [[4.9. Setting Uninitialized var Field Types - 122][4.9. Setting Uninitialized var Field Types - 122]]
    - [[Problem - 122][Problem - 122]]
    - [[Solution - 123][Solution - 123]]
    - [[Discussion - 124][Discussion - 124]]
    - [[See Also - 124][See Also - 124]]
  - [[4.10. Handling Constructor Parameters When Extending a Class - 124][4.10. Handling Constructor Parameters When Extending a Class - 124]]
    - [[Problem - 124][Problem - 124]]
    - [[Solution - 124][Solution - 124]]
    - [[Discussion - 125][Discussion - 125]]
  - [[4.11. Calling a Superclass Constructor - 127][4.11. Calling a Superclass Constructor - 127]]
    - [[Problem - 127][Problem - 127]]
    - [[Solution - 127][Solution - 127]]
      - [[Auxiliary constructors - 128][Auxiliary constructors - 128]]
  - [[4.12. When to Use an Abstract Class - 129][4.12. When to Use an Abstract Class - 129]]
    - [[Problem - 129][Problem - 129]]
    - [[Solution - 129][Solution - 129]]
    - [[Discussion - 129][Discussion - 129]]
  - [[4.13. Defining Properties in an Abstract Base Class (or Trait) - 131][4.13. Defining Properties in an Abstract Base Class (or Trait) - 131]]
    - [[Problem - 131][Problem - 131]]
    - [[Solution - 131][Solution - 131]]
      - [[Abstract ~val~ and ~var~ fields - 131][Abstract ~val~ and ~var~ fields - 131]]
    - [[Discussion - 132][Discussion - 132]]
      - [[Concrete val fields in abstract classes - 133][Concrete val fields in abstract classes - 133]]
      - [[Concrete var fields in abstract classes - 134][Concrete var fields in abstract classes - 134]]
      - [[Don't use ~null~ - 135][Don't use ~null~ - 135]]
    - [[See Also - 136][See Also - 136]]
  - [[4.14. Generating Boilerplate Code with Case Classes - 136][4.14. Generating Boilerplate Code with Case Classes - 136]]
    - [[Problem - 136][Problem - 136]]
    - [[Solution - 136][Solution - 136]]
    - [[Discussion - 138][Discussion - 138]]
      - [[Generated code - 138][Generated code - 138]]
    - [[See Also - 140][See Also - 140]]
  - [[4.15. Defining an equals Method (Object Equality) - 140][4.15. Defining an equals Method (Object Equality) - 140]]
    - [[Problem - 140][Problem - 140]]
    - [[Solution - 140][Solution - 140]]
    - [[Discussion - 141][Discussion - 141]]
      - [[Theory - 142][Theory - 142]]
    - [[See Also - 143][See Also - 143]]
  - [[4.16. Creating Inner Classes - 143][4.16. Creating Inner Classes - 143]]
    - [[Problem - 143][Problem - 143]]
    - [[Solution - 143][Solution - 143]]
    - [[Discussion - 144][Discussion - 144]]
    - [[See Also - 145][See Also - 145]]
- [[5. Methods - 147][5. Methods - 147]]
  - [[Introduction - 147][Introduction - 147]]
  - [[5.1. Controlling Method Scope - 148][5.1. Controlling Method Scope - 148]]
    - [[Problem - 148][Problem - 148]]
    - [[Solution - 148][Solution - 148]]
      - [[Object-private scope - 148][Object-private scope - 148]]
      - [[Private scope - 149][Private scope - 149]]
      - [[Protected scope - 149][Protected scope - 149]]
      - [[Package scope - 150][Package scope - 150]]
      - [[More package-level control - 150][More package-level control - 150]]
      - [[Public scope - 151][Public scope - 151]]
    - [[Discussion - 152][Discussion - 152]]
  - [[5.2. Calling a Method on a Superclass - 152][5.2. Calling a Method on a Superclass - 152]]
    - [[Problem - 152][Problem - 152]]
    - [[Solution - 153][Solution - 153]]
      - [[Controlling which trait you call a method from - 153][Controlling which trait you call a method from - 153]]
  - [[5.3. Setting Default Values for Method Parameters - 154][5.3. Setting Default Values for Method Parameters - 154]]
    - [[Problem - 154][Problem - 154]]
    - [[Solution - 155][Solution - 155]]
    - [[Discussion - 156][Discussion - 156]]
  - [[5.4. Using Parameter Names When Calling a Method - 157][5.4. Using Parameter Names When Calling a Method - 157]]
    - [[Problem - 157][Problem - 157]]
    - [[Solution - 157][Solution - 157]]
    - [[Discussion - 158][Discussion - 158]]
  - [[5.5. Defining a Method That Returns Multiple Items (Tuples) - 159][5.5. Defining a Method That Returns Multiple Items (Tuples) - 159]]
    - [[Problem - 159][Problem - 159]]
    - [[Solution - 159][Solution - 159]]
    - [[Discussion - 159][Discussion - 159]]
      - [[Working with tuples - 160][Working with tuples - 160]]
    - [[See Also - 160][See Also - 160]]
  - [[5.6. Forcing Callers to Leave Parentheses off Accessor Methods - 161][5.6. Forcing Callers to Leave Parentheses off Accessor Methods - 161]]
    - [[Problem - 161][Problem - 161]]
    - [[Solution - 161][Solution - 161]]
    - [[Discussion - 161][Discussion - 161]]
    - [[See Also - 162][See Also - 162]]
  - [[5.7. Creating Methods That Take Variable-Argument Fields - 163][5.7. Creating Methods That Take Variable-Argument Fields - 163]]
    - [[Problem - 163][Problem - 163]]
    - [[Solution - 163][Solution - 163]]
    - [[Discussion - 163][Discussion - 163]]
  - [[5.8. Declaring That a Method Can Throw an Exception - 165][5.8. Declaring That a Method Can Throw an Exception - 165]]
    - [[Problem - 165][Problem - 165]]
    - [[Solution - 165][Solution - 165]]
    - [[Discussion - 165][Discussion - 165]]
    - [[See Also - 166][See Also - 166]]
  - [[5.9. Supporting a Fluent Style of Programming - 167][5.9. Supporting a Fluent Style of Programming - 167]]
    - [[Problem - 167][Problem - 167]]
    - [[Solution - 167][Solution - 167]]
    - [[Discussion - 168][Discussion - 168]]
    - [[See Also - 170][See Also - 170]]
- [[6. Objects - 171][6. Objects - 171]]
  - [[6.1. Object Casting - 172][6.1. Object Casting - 172]]
    - [[Problem - 172][Problem - 172]]
    - [[Solution - 172][Solution - 172]]
    - [[Discussion - 172][Discussion - 172]]
    - [[See Also - 173][See Also - 173]]
  - [[6.2. The Scala Equivalent of Java's .class - 174][6.2. The Scala Equivalent of Java's .class - 174]]
    - [[Problem - 174][Problem - 174]]
    - [[Solution - 174][Solution - 174]]
    - [[Discussion - 174][Discussion - 174]]
    - [[See Also - 174][See Also - 174]]
  - [[6.3. Determining the Class of an Object - 174][6.3. Determining the Class of an Object - 174]]
    - [[Problem - 174][Problem - 174]]
    - [[Solution - 175][Solution - 175]]
    - [[Discussion - 176][Discussion - 176]]
  - [[6.4. Launching an Application with an Object - 176][6.4. Launching an Application with an Object - 176]]
    - [[Problem - 176][Problem - 176]]
    - [[Solution - 176][Solution - 176]]
    - [[Discussion - 177][Discussion - 177]]
    - [[See Also - 178][See Also - 178]]
  - [[6.5. Creating Singletons with object - 178][6.5. Creating Singletons with object - 178]]
    - [[Problem - 178][Problem - 178]]
    - [[Solution - 178][Solution - 178]]
    - [[Discussion - 180][Discussion - 180]]
  - [[6.6. Creating Static Members with Companion Objects - 180][6.6. Creating Static Members with Companion Objects - 180]]
    - [[Problem - 180][Problem - 180]]
    - [[Solution - 180][Solution - 180]]
    - [[Discussion - 181][Discussion - 181]]
      - [[Accessing private members - 181][Accessing private members - 181]]
  - [[6.7. Putting Common Code in Package Objects - 182][6.7. Putting Common Code in Package Objects - 182]]
    - [[Problem - 182][Problem - 182]]
    - [[Solution - 182][Solution - 182]]
    - [[Discussion - 183][Discussion - 183]]
    - [[See Also - 184][See Also - 184]]
  - [[6.8. Creating Object Instances Without Using the new Keyword - 185][6.8. Creating Object Instances Without Using the new Keyword - 185]]
    - [[Problem - 185][Problem - 185]]
    - [[Solution - 185][Solution - 185]]
      - [[Creating a companion object with an apply method - 185][Creating a companion object with an apply method - 185]]
      - [[Declare your class as a case class - 186][Declare your class as a case class - 186]]
    - [[Discussion - 186][Discussion - 186]]
      - [[Providing multiple constructors with additional apply methods - 186][Providing multiple constructors with additional apply methods - 186]]
      - [[Providing multiple constructors for case classes - 187][Providing multiple constructors for case classes - 187]]
  - [[6.9. Implement the Factory Method in Scala with apply - 189][6.9. Implement the Factory Method in Scala with apply - 189]]
    - [[Problem - 189][Problem - 189]]
    - [[Solution - 189][Solution - 189]]
    - [[Discussion - 190][Discussion - 190]]
    - [[See Also - 190][See Also - 190]]
- [[7. Packaging and Imports - 191][7. Packaging and Imports - 191]]
  - [[Introduction - 191][Introduction - 191]]
  - [[7.1. Packaging with the Curly Braces Style Notation - 192][7.1. Packaging with the Curly Braces Style Notation - 192]]
    - [[Problem - 192][Problem - 192]]
    - [[Solution - 192][Solution - 192]]
    - [[Discussion - 193][Discussion - 193]]
  - [[7.2. Importing One or More Members - 193][7.2. Importing One or More Members - 193]]
    - [[Problem - 193][Problem - 193]]
    - [[Solution - 193][Solution - 193]]
    - [[Discussion - 194][Discussion - 194]]
      - [[Placing import statements anywhere - 194][Placing import statements anywhere - 194]]
  - [[7.3. Renaming Members on Import - 195][7.3. Renaming Members on Import - 195]]
    - [[Problem - 195][Problem - 195]]
    - [[Solution - 195][Solution - 195]]
    - [[Discussion - 195][Discussion - 195]]
  - [[7.4. Hiding a Class During the Import Process - 196][7.4. Hiding a Class During the Import Process - 196]]
    - [[Problem - 196][Problem - 196]]
    - [[Solution - 196][Solution - 196]]
  - [[7.5. Using Static Imports - 197][7.5. Using Static Imports - 197]]
    - [[Problem - 197][Problem - 197]]
    - [[Solution - 197][Solution - 197]]
    - [[Discussion - 198][Discussion - 198]]
  - [[7.6. Using Import Statements Anywhere - 199][7.6. Using Import Statements Anywhere - 199]]
    - [[Problem - 199][Problem - 199]]
    - [[Solution - 199][Solution - 199]]
    - [[Discussion - 200][Discussion - 200]]
- [[8. Traits - 203][8. Traits - 203]]
  - [[8.1. Using a Trait as an Interface - 203][8.1. Using a Trait as an Interface - 203]]
    - [[Problem - 203][Problem - 203]]
    - [[Solution - 203][Solution - 203]]
    - [[Discussion - 205][Discussion - 205]]
  - [[8.2. Using Abstract and Concrete Fields in Traits - 206][8.2. Using Abstract and Concrete Fields in Traits - 206]]
    - [[Problem - 206][Problem - 206]]
    - [[Solution - 206][Solution - 206]]
    - [[Discussion - 206][Discussion - 206]]
  - [[8.3. Using a Trait Like an Abstract Class - 207][8.3. Using a Trait Like an Abstract Class - 207]]
    - [[Problem - 207][Problem - 207]]
    - [[Solution - 207][Solution - 207]]
    - [[Discussion - 207][Discussion - 207]]
    - [[See Also - 208][See Also - 208]]
  - [[8.4. Using Traits as Simple Mixins - 208][8.4. Using Traits as Simple Mixins - 208]]
    - [[Problem - 208][Problem - 208]]
    - [[Solution - 208][Solution - 208]]
    - [[See Also - 209][See Also - 209]]
  - [[8.5. Limiting Which Classes Can Use a Trait by Inheritance - 209][8.5. Limiting Which Classes Can Use a Trait by Inheritance - 209]]
    - [[Problem - 209][Problem - 209]]
    - [[Solution - 209][Solution - 209]]
    - [[Discussion - 210][Discussion - 210]]
    - [[Discussion - 211 ???][Discussion - 211 ???]]
    - [[See Also - 211][See Also - 211]]
  - [[8.6. Marking Traits So They Can Only Be Used by Subclasses of a Certain Type - 211][8.6. Marking Traits So They Can Only Be Used by Subclasses of a Certain Type - 211]]
    - [[Problem - 211][Problem - 211]]
    - [[Solution - 211][Solution - 211]]
    - [[Discussion - 212][Discussion - 212]]
    - [[See Also - 213][See Also - 213]]
  - [[8.7. Ensuring a Trait Can Only Be Added to a Type That Has a Specific Method - 213][8.7. Ensuring a Trait Can Only Be Added to a Type That Has a Specific Method - 213]]
    - [[Problem - 213][Problem - 213]]
    - [[Solution - 213][Solution - 213]]
    - [[Discussion - 214][Discussion - 214]]
    - [[See Also - 214][See Also - 214]]
  - [[8.8. Adding a Trait to an Object Instance - 215][8.8. Adding a Trait to an Object Instance - 215]]
    - [[Problem - 215][Problem - 215]]
    - [[Solution - 215][Solution - 215]]
    - [[Discussion - 215][Discussion - 215]]
  - [[8.9. Extending a Java Interface Like a Trait - 216][8.9. Extending a Java Interface Like a Trait - 216]]
    - [[Problem - 216][Problem - 216]]
    - [[Solution - 216][Solution - 216]]
- [[9. Functional Programming - 217][9. Functional Programming - 217]]
  - [[Introduction - 217][Introduction - 217]]
  - [[9.1. Using Function Literals (Anonymous Functions) - 218][9.1. Using Function Literals (Anonymous Functions) - 218]]
    - [[Problem - 218][Problem - 218]]
    - [[Solution - 218][Solution - 218]]
    - [[Discussion - 218][Discussion - 218]]
  - [[9.2. Using Functions as Variables - 219][9.2. Using Functions as Variables - 219]]
    - [[Problem - 219][Problem - 219]]
    - [[Solution - 219][Solution - 219]]
    - [[Discussion - 220][Discussion - 220]]
      - [[Using a method like an anonymous function - 221][Using a method like an anonymous function - 221]]
      - [[Assigning an existing function/method to a function variable - 222][Assigning an existing function/method to a function variable - 222]]
    - [[See Also - 223][See Also - 223]]
  - [[9.3. Defining a Method That Accepts a Simple Function Parameter - 223][9.3. Defining a Method That Accepts a Simple Function Parameter - 223]]
    - [[Problem - 223][Problem - 223]]
    - [[Solution - 223][Solution - 223]]
    - [[Discussion - 224][Discussion - 224]]
    - [[See Also - 225][See Also - 225]]
  - [[9.4. More Complex Functions - 226][9.4. More Complex Functions - 226]]
    - [[Problem - 226][Problem - 226]]
    - [[Solution - 226][Solution - 226]]
    - [[Discussion - 226][Discussion - 226]]
      - [[Passing in a function with other parameters - 227][Passing in a function with other parameters - 227]]
  - [[9.5. Using Closures - 229][9.5. Using Closures - 229]]
    - [[Problem - 229][Problem - 229]]
    - [[Solution - 229][Solution - 229]]
    - [[Discussion - 230][Discussion - 230]]
      - [[A second example - 231][A second example - 231]]
      - [[Using closures with other data types - 232][Using closures with other data types - 232]]
      - [[A comparison to Java - 232][A comparison to Java - 232]]
    - [[See Also - 234][See Also - 234]]
  - [[9.6. Using Partially Applied Functions - 234][9.6. Using Partially Applied Functions - 234]]
    - [[Problem - 234][Problem - 234]]
    - [[Solution - 234][Solution - 234]]
    - [[Discussion - 235][Discussion - 235]]
  - [[9.7. Creating a Function That Returns a Function - 236][9.7. Creating a Function That Returns a Function - 236]]
    - [[Problem - 236][Problem - 236]]
    - [[Solution - 236][Solution - 236]]
    - [[Discussion - 237][Discussion - 237]]
      - [[Another example - 237][Another example - 237]]
    - [[See Also - 238][See Also - 238]]
  - [[9.9. A Real-World Example - 242][9.9. A Real-World Example - 242]]
    - [[Problem - 238][Problem - 238]]
    - [[Solution - 238][Solution - 238]]
      - [[The ~PartialFunction~ explained - 239][The ~PartialFunction~ explained - 239]]
      - [[~orElse~ and ~andThen~ - 240][~orElse~ and ~andThen~ - 240]]
    - [[Discussion - 241][Discussion - 241]]
    - [[See Also - 242][See Also - 242]]
- [[10. Collections - 245][10. Collections - 245]]
  - [[Introduction - 245][Introduction - 245]]
    - [[A Few Important Concepts - 245][A Few Important Concepts - 245]]
  - [[10.1. Understanding the Collections Hierarchy - 246][10.1. Understanding the Collections Hierarchy - 246]]
    - [[Problem - 246][Problem - 246]]
    - [[Solution - 247][Solution - 247]]
  - [[10.2. Choosing a Collection Class - 250][10.2. Choosing a Collection Class - 250]]
  - [[10.3. Choosing a Collection Method to Solve a Problem - 255][10.3. Choosing a Collection Method to Solve a Problem - 255]]
  - [[10.4. Understanding the Performance of Collections - 261][10.4. Understanding the Performance of Collections - 261]]
  - [[10.5. Declaring a Type When Creating a Collection - 264][10.5. Declaring a Type When Creating a Collection - 264]]
  - [[10.6. Understanding Mutable Variables with Immutable Collections - 265][10.6. Understanding Mutable Variables with Immutable Collections - 265]]
  - [[10.7. Make Vector Your “Go To” Immutable Sequence - 266][10.7. Make Vector Your “Go To” Immutable Sequence - 266]]
  - [[10.8. Make ArrayBuffer Your “Go To” Mutable Sequence - 268][10.8. Make ArrayBuffer Your “Go To” Mutable Sequence - 268]]
  - [[10.9. Looping over a Collection with foreach - 270][10.9. Looping over a Collection with foreach - 270]]
  - [[10.10. Looping over a Collection with a for Loop - 272][10.10. Looping over a Collection with a for Loop - 272]]
  - [[10.11. Using zipWithIndex or zip to Create Loop Counters - 276][10.11. Using zipWithIndex or zip to Create Loop Counters - 276]]
  - [[10.12. Using Iterators - 278][10.12. Using Iterators - 278]]
  - [[10.13. Transforming One Collection to Another with for/yield - 279][10.13. Transforming One Collection to Another with for/yield - 279]]
  - [[10.14. Transforming One Collection to Another with map - 282][10.14. Transforming One Collection to Another with map - 282]]
  - [[10.15. Flattening a List of Lists with flatten - 285][10.15. Flattening a List of Lists with flatten - 285]]
  - [[10.16. Combining map and flatten with flatMap - 286][10.16. Combining map and flatten with flatMap - 286]]
  - [[10.17. Using filter to Filter a Collection - 289][10.17. Using filter to Filter a Collection - 289]]
  - [[10.18. Extracting a Sequence of Elements from a Collection - 291][10.18. Extracting a Sequence of Elements from a Collection - 291]]
  - [[10.19. Splitting Sequences into Subsets (groupBy, partition, etc.) - 293][10.19. Splitting Sequences into Subsets (groupBy, partition, etc.) - 293]]
  - [[10.20. Walking Through a Collection with the reduce and fold Methods - 295][10.20. Walking Through a Collection with the reduce and fold Methods - 295]]
  - [[10.21. Extracting Unique Elements from a Sequence - 300][10.21. Extracting Unique Elements from a Sequence - 300]]
  - [[10.22. Merging Sequential Collections - 302][10.22. Merging Sequential Collections - 302]]
  - [[10.23. Merging Two Sequential Collections into Pairs with zip - 304][10.23. Merging Two Sequential Collections into Pairs with zip - 304]]
  - [[10.24. Creating a Lazy View on a Collection - 306][10.24. Creating a Lazy View on a Collection - 306]]
  - [[10.25. Populating a Collection with a Range - 309][10.25. Populating a Collection with a Range - 309]]
  - [[10.26. Creating and Using Enumerations - 311][10.26. Creating and Using Enumerations - 311]]
  - [[10.27. Tuples, for When You Just Need a Bag of Things - 312][10.27. Tuples, for When You Just Need a Bag of Things - 312]]
  - [[10.28. Sorting a Collection - 315][10.28. Sorting a Collection - 315]]
  - [[10.29. Converting a Collection to a String with mkString - 318][10.29. Converting a Collection to a String with mkString - 318]]
- [[11. List, Array, Map, Set (and More) 321][11. List, Array, Map, Set (and More) 321]]
  - [[11.1. Different Ways to Create and Populate a ~List~ - 322][11.1. Different Ways to Create and Populate a ~List~ - 322]]
  - [[11.2. Creating a Mutable ~List~ - 324][11.2. Creating a Mutable ~List~ - 324]]
  - [[11.3. Adding Elements to a ~List~ - 325][11.3. Adding Elements to a ~List~ - 325]]
  - [[11.4. Deleting Elements from a ~List~ (or ~ListBuffer~) - 328][11.4. Deleting Elements from a ~List~ (or ~ListBuffer~) - 328]]
  - [[11.5. Merging (Concatenating) ~List~'s - 330][11.5. Merging (Concatenating) ~List~'s - 330]]
  - [[11.6. Using ~Stream~, a Lazy Version of a ~List~ - 331][11.6. Using ~Stream~, a Lazy Version of a ~List~ - 331]]
  - [[11.7. Different Ways to Create and Update an ~Array~ - 333][11.7. Different Ways to Create and Update an ~Array~ - 333]]
  - [[11.8. Creating an Array Whose Size Can Change (~ArrayBuffer~) - 335][11.8. Creating an Array Whose Size Can Change (~ArrayBuffer~) - 335]]
  - [[11.9. Deleting ~Array~ and ~ArrayBuffer~ Elements - 335][11.9. Deleting ~Array~ and ~ArrayBuffer~ Elements - 335]]
  - [[11.10. Sorting ~Array~'s - 337][11.10. Sorting ~Array~'s - 337]]
  - [[11.11. Creating Multidimensional ~Array~'s - 338][11.11. Creating Multidimensional ~Array~'s - 338]]
  - [[11.12. Creating Maps - 341][11.12. Creating Maps - 341]]
  - [[11.13. Choosing a Map Implementation - 343][11.13. Choosing a Map Implementation - 343]]
  - [[11.14. Adding, Updating, and Removing Elements with a Mutable Map - 345][11.14. Adding, Updating, and Removing Elements with a Mutable Map - 345]]
  - [[11.15. Adding, Updating, and Removing Elements with Immutable Maps - 347][11.15. Adding, Updating, and Removing Elements with Immutable Maps - 347]]
  - [[11.16. Accessing Map Values - 349][11.16. Accessing Map Values - 349]]
  - [[11.17. Traversing a Map - 350][11.17. Traversing a Map - 350]]
  - [[11.18. Getting the Keys or Values from a Map - 352][11.18. Getting the Keys or Values from a Map - 352]]
  - [[11.19. Reversing Keys and Values - 352][11.19. Reversing Keys and Values - 352]]
  - [[11.20. Testing for the Existence of a Key or Value in a Map - 353][11.20. Testing for the Existence of a Key or Value in a Map - 353]]
  - [[11.21. Filtering a Map - 354][11.21. Filtering a Map - 354]]
  - [[11.22. Sorting an Existing Map by Key or Value - 357][11.22. Sorting an Existing Map by Key or Value - 357]]
  - [[11.23. Finding the Largest Key or Value in a Map - 360][11.23. Finding the Largest Key or Value in a Map - 360]]
  - [[11.24. Adding Elements to a Set - 361][11.24. Adding Elements to a Set - 361]]
  - [[11.25. Deleting Elements from Sets - 363][11.25. Deleting Elements from Sets - 363]]
  - [[11.26. Using Sortable Sets - 365][11.26. Using Sortable Sets - 365]]
  - [[11.27. Using a Queue - 367][11.27. Using a Queue - 367]]
  - [[11.28. Using a Stack - 369][11.28. Using a Stack - 369]]
  - [[11.29. Using a Range - 371][11.29. Using a Range - 371]]
- [[12. Files and Processes - 375][12. Files and Processes - 375]]
  - [[12.0. Introduction - 375][12.0. Introduction - 375]]
  - [[12.1. How to Open and Read a Text File - 375][12.1. How to Open and Read a Text File - 375]]
    - [[Problem][Problem]]
    - [[Solution][Solution]]
      - [[Using the concise syntax][Using the concise syntax]]
      - [[Properly closing the file][Properly closing the file]]
    - [[Discussion - 377][Discussion - 377]]
      - [[Leaving files open - 377][Leaving files open - 377]]
      - [[Automatically closing the resource - 377][Automatically closing the resource - 377]]
      - [[Handling exceptions - 379][Handling exceptions - 379]]
      - [[Multiple fromFile methods - 380][Multiple fromFile methods - 380]]
    - [[See Also - 380][See Also - 380]]
  - [[12.2. Writing Text Files - 381][12.2. Writing Text Files - 381]]
    - [[Problem - 381][Problem - 381]]
    - [[Solution - 381][Solution - 381]]
    - [[Discussion - 381][Discussion - 381]]
    - [[See Also - 381][See Also - 381]]
  - [[12.3. Reading and Writing Binary Files - 382][12.3. Reading and Writing Binary Files - 382]]
    - [[Problem - 382][Problem - 382]]
    - [[Solution - 382][Solution - 382]]
    - [[See Also - 383][See Also - 383]]
  - [[12.4. How to Process Every Character in a Text File - 383][12.4. How to Process Every Character in a Text File - 383]]
    - [[Problem - 650][Problem - 650]]
    - [[Solution - 651][Solution - 651]]
  - [[12.5. How to Process a CSV File - 384][12.5. How to Process a CSV File - 384]]
    - [[Problem - x][Problem - x]]
    - [[Solution - y][Solution - y]]
    - [[Discussion - z][Discussion - z]]
    - [[See Also - l][See Also - l]]
  - [[12.6. Pretending that a String Is a File - 387][12.6. Pretending that a String Is a File - 387]]
    - [[Problem - 387][Problem - 387]]
    - [[Solution - 387][Solution - 387]]
    - [[Discussion - 388][Discussion - 388]]
    - [[See Also - 389][See Also - 389]]
  - [[12.7. Using Serialization - 389][12.7. Using Serialization - 389]]
    - [[Problem - x][Problem - x]]
    - [[Solution - y][Solution - y]]
    - [[Discussion - z][Discussion - z]]
    - [[See Also - l][See Also - l]]
  - [[12.8. Listing Files in a Directory - 391][12.8. Listing Files in a Directory - 391]]
    - [[Problem - x][Problem - x]]
    - [[Solution - y][Solution - y]]
    - [[Discussion - z][Discussion - z]]
    - [[See Also - l][See Also - l]]
  - [[12.9. Listing Subdirectories Beneath a Directory - 392][12.9. Listing Subdirectories Beneath a Directory - 392]]
    - [[Problem - x][Problem - x]]
    - [[Solution - y][Solution - y]]
    - [[Discussion - z][Discussion - z]]
  - [[12.10. Executing External Commands - 394][12.10. Executing External Commands - 394]]
    - [[Problem - 394][Problem - 394]]
    - [[Solution - 394][Solution - 394]]
    - [[Discussion - 395][Discussion - 395]]
      - [[Using the lines method - 396][Using the lines method - 396]]
      - [[External commands versus built-in commands - 396][External commands versus built-in commands - 396]]
  - [[12.11. Executing External Commands and Using STDOUT - 397][12.11. Executing External Commands and Using STDOUT - 397]]
    - [[Problem - x][Problem - x]]
    - [[Solution - y][Solution - y]]
    - [[Discussion - z][Discussion - z]]
  - [[12.12. Handling STDOUT and STDERR for External Commands - 399][12.12. Handling STDOUT and STDERR for External Commands - 399]]
    - [[Problem - x][Problem - x]]
    - [[Solution - y][Solution - y]]
    - [[See Also - z][See Also - z]]
  - [[12.13. Building a Pipeline of Commands - 401][12.13. Building a Pipeline of Commands - 401]]
    - [[Problem - x][Problem - x]]
    - [[Solution - y][Solution - y]]
    - [[Discussion - z][Discussion - z]]
    - [[See Also - l][See Also - l]]
  - [[12.14. Redirecting the STDOUT and STDIN of External Commands - 402][12.14. Redirecting the STDOUT and STDIN of External Commands - 402]]
    - [[Problem - x][Problem - x]]
    - [[Solution - y][Solution - y]]
    - [[Discussion - z][Discussion - z]]
    - [[See Also - l][See Also - l]]
  - [[12.15. Using AND (~&&~) and OR (~||~) with Processes - 404][12.15. Using AND (~&&~) and OR (~||~) with Processes - 404]]
    - [[Problem - x][Problem - x]]
    - [[Solution - y][Solution - y]]
  - [[12.16. Handling Wildcard Characters in External Commands - 405][12.16. Handling Wildcard Characters in External Commands - 405]]
    - [[Problem - 405][Problem - 405]]
    - [[Solution - x][Solution - x]]
    - [[Discussion - x][Discussion - x]]
    - [[See Also - x][See Also - x]]
  - [[12.17. How to Run a Process in a Different Directory - 406][12.17. How to Run a Process in a Different Directory - 406]]
    - [[Problem - 406][Problem - 406]]
    - [[Solution - x][Solution - x]]
  - [[12.18. Setting Environment Variables When Running Commands - 407][12.18. Setting Environment Variables When Running Commands - 407]]
    - [[Problem - 407][Problem - 407]]
    - [[Solution - x][Solution - x]]
    - [[See Also - x][See Also - x]]
  - [[12.19. An Index of Methods to Execute External Commands - 408][12.19. An Index of Methods to Execute External Commands - 408]]
- [[13. Actors and Concurrency - 411][13. Actors and Concurrency - 411]]
  - [[13.1. Getting Started with a Simple Actor - 414][13.1. Getting Started with a Simple Actor - 414]]
  - [[13.2. Creating an Actor Whose Class Constructor Requires Arguments - 418][13.2. Creating an Actor Whose Class Constructor Requires Arguments - 418]]
  - [[13.3. How to Communicate Between Actors - 419][13.3. How to Communicate Between Actors - 419]]
  - [[13.4. Understanding the Methods in the Akka Actor Lifecycle - 422][13.4. Understanding the Methods in the Akka Actor Lifecycle - 422]]
  - [[13.5. Starting an Actor - 425][13.5. Starting an Actor - 425]]
  - [[13.6. Stopping Actors - 427][13.6. Stopping Actors - 427]]
  - [[13.7. Shutting Down the Akka Actor System - 432][13.7. Shutting Down the Akka Actor System - 432]]
  - [[13.8. Monitoring the Death of an Actor with watch - 433][13.8. Monitoring the Death of an Actor with watch - 433]]
  - [[13.9. Simple Concurrency with Futures - 436][13.9. Simple Concurrency with Futures - 436]]
  - [[13.10. Sending a Message to an Actor and Waiting for a Reply - 445][13.10. Sending a Message to an Actor and Waiting for a Reply - 445]]
  - [[13.11. Switching Between Different States with become - 446][13.11. Switching Between Different States with become - 446]]
  - [[13.12. Using Parallel Collections - 448][13.12. Using Parallel Collections - 448]]
- [[14. Command-Line Tasks - 453][14. Command-Line Tasks - 453]]
  - [[14.0. Introduction - 453][14.0. Introduction - 453]]
  - [[14.1. Getting Started with the Scala REPL - 454][14.1. Getting Started with the Scala REPL - 454]]
    - [[Problem - 454][Problem - 454]]
    - [[Solution - 454][Solution - 454]]
    - [[Discussion - 456][Discussion - 456]]
      - [[REPL command-line options - 457][REPL command-line options - 457]]
      - [[Deprecation and feature warnings - 457][Deprecation and feature warnings - 457]]
      - [[The Scala Worksheet - 458][The Scala Worksheet - 458]]
    - [[See Also - 459][See Also - 459]]
  - [[14.2. Pasting and Loading Blocks of Code into the REPL - 459][14.2. Pasting and Loading Blocks of Code into the REPL - 459]]
    - [[Problem - 459][Problem - 459]]
    - [[Solution - 459][Solution - 459]]
      - [[The ~:paste~ command - 459][The ~:paste~ command - 459]]
      - [[The ~:load~ command - 460][The ~:load~ command - 460]]
    - [[Discussion - 461][Discussion - 461]]
      - [[Scala's ~-i~ option][Scala's ~-i~ option]]
    - [[See Also - 461][See Also - 461]]
  - [[14.3. Adding JAR Files and Classes to the REPL Classpath - 461][14.3. Adding JAR Files and Classes to the REPL Classpath - 461]]
    - [[Problem - 461][Problem - 461]]
    - [[Solution - 461][Solution - 461]]
  - [[14.4. Running a Shell Command from the REPL - 462][14.4. Running a Shell Command from the REPL - 462]]
    - [[Problem - 462][Problem - 462]]
    - [[Solution - 463][Solution - 463]]
      - [[Scala's ~-i~ option - 463][Scala's ~-i~ option - 463]]
    - [[See Also - 464][See Also - 464]]
  - [[14.5. Compiling with scalac and Running with scala - 465][14.5. Compiling with scalac and Running with scala - 465]]
    - [[Problem - 465][Problem - 465]]
    - [[Solution - 465][Solution - 465]]
    - [[Discussion - 465][Discussion - 465]]
  - [[14.6. Disassembling and Decompiling Scala Code - 466][14.6. Disassembling and Decompiling Scala Code - 466]]
    - [[Problem - 466][Problem - 466]]
    - [[Solution - 466][Solution - 466]]
      - [[Using ~javap~ - 467][Using ~javap~ - 467]]
      - [[Using ~scalac~ print options - 467][Using ~scalac~ print options - 467]]
      - [[Use a decompiler - 468][Use a decompiler - 468]]
    - [[Discussion - 469][Discussion - 469]]
    - [[See Also - 471][See Also - 471]]
  - [[14.7. Finding Scala Libraries - 471][14.7. Finding Scala Libraries - 471]]
    - [[Problem - 471][Problem - 471]]
    - [[Solution - 471][Solution - 471]]
  - [[14.8. Generating Documentation with scaladoc - 472][14.8. Generating Documentation with scaladoc - 472]]
    - [[Problem - 472][Problem - 472]]
    - [[Solution - 472][Solution - 472]]
    - [[Discussion - 476][Discussion - 476]]
    - [[See Also - 478][See Also - 478]]
  - [[14.9. Faster Command-Line Compiling with fsc - 479][14.9. Faster Command-Line Compiling with fsc - 479]]
    - [[Problem - 479][Problem - 479]]
    - [[Solution - 479][Solution - 479]]
    - [[Discussion - 479][Discussion - 479]]
    - [[See Also - 480][See Also - 480]]
  - [[14.10. Using Scala as a Scripting Language - 480][14.10. Using Scala as a Scripting Language - 480]]
    - [[Problem - 480][Problem - 480]]
    - [[Solution - 480][Solution - 480]]
    - [[Discussion - 480][Discussion - 480]]
      - [[Using the App trait or main method - 481][Using the App trait or main method - 481]]
      - [[Building the classpath - 482][Building the classpath - 482]]
    - [[See Also - 483][See Also - 483]]
  - [[14.11. Accessing Command-Line Arguments from a Script - 483][14.11. Accessing Command-Line Arguments from a Script - 483]]
    - [[Problem - 483][Problem - 483]]
    - [[Solution - 483][Solution - 483]]
    - [[Discussion - 484][Discussion - 484]]
  - [[14.12. Prompting for Input from a Scala Shell Script - 485][14.12. Prompting for Input from a Scala Shell Script - 485]]
    - [[Problem - 485][Problem - 485]]
    - [[Solution - 485][Solution - 485]]
    - [[Discussion - 485][Discussion - 485]]
      - [[Reading multiple values from one line - 486][Reading multiple values from one line - 486]]
      - [[Fun with output - 488][Fun with output - 488]]
    - [[See Also - 488][See Also - 488]]
  - [[14.13. Make Your Scala Scripts Run Faster - 489][14.13. Make Your Scala Scripts Run Faster - 489]]
    - [[Problem - 489][Problem - 489]]
    - [[Solution - 489][Solution - 489]]
    - [[Discussion - 490][Discussion - 490]]
- [[15. Web Services - 491][15. Web Services - 491]]
  - [[15.1. Creating a JSON String from a Scala Object - 491][15.1. Creating a JSON String from a Scala Object - 491]]
  - [[15.2. Creating a JSON String from Classes That Have Collections - 495][15.2. Creating a JSON String from Classes That Have Collections - 495]]
  - [[15.3. Creating a Simple Scala Object from a JSON String - 500][15.3. Creating a Simple Scala Object from a JSON String - 500]]
  - [[15.4. Parsing JSON Data into an Array of Objects - 501][15.4. Parsing JSON Data into an Array of Objects - 501]]
  - [[15.5. Creating Web Services with Scalatra - 503][15.5. Creating Web Services with Scalatra - 503]]
  - [[15.6. Replacing XML Servlet Mappings with Scalatra Mounts - 507][15.6. Replacing XML Servlet Mappings with Scalatra Mounts - 507]]
  - [[15.7. Accessing Scalatra Web Service GET Parameters - 509][15.7. Accessing Scalatra Web Service GET Parameters - 509]]
  - [[15.8. Accessing POST Request Data with Scalatra - 510][15.8. Accessing POST Request Data with Scalatra - 510]]
  - [[15.9. Creating a Simple GET Request Client - 514][15.9. Creating a Simple GET Request Client - 514]]
  - [[15.10. Sending JSON Data to a POST URL - 518][15.10. Sending JSON Data to a POST URL - 518]]
  - [[15.11. Getting URL Headers - 519][15.11. Getting URL Headers - 519]]
  - [[15.12. Setting URL Headers When Sending a Request - 520][15.12. Setting URL Headers When Sending a Request - 520]]
  - [[15.13. Creating a GET Request Web Service with the Play Framework - 521][15.13. Creating a GET Request Web Service with the Play Framework - 521]]
  - [[15.14. POSTing JSON Data to a Play Framework Web Service - 524][15.14. POSTing JSON Data to a Play Framework Web Service - 524]]
- [[16. Databases and Persistence 527][16. Databases and Persistence 527]]
  - [[16.1. Connecting to MySQL with JDBC - 528][16.1. Connecting to MySQL with JDBC - 528]]
  - [[16.2. Connecting to a Database with the Spring Framework - 530][16.2. Connecting to a Database with the Spring Framework - 530]]
  - [[16.3. Connecting to MongoDB and Inserting Data - 533][16.3. Connecting to MongoDB and Inserting Data - 533]]
  - [[16.4. Inserting Documents into MongoDB with insert, save, or += - 537][16.4. Inserting Documents into MongoDB with insert, save, or += - 537]]
  - [[16.5. Searching a MongoDB Collection - 539][16.5. Searching a MongoDB Collection - 539]]
  - [[16.6. Updating Documents in a MongoDB Collection - 542][16.6. Updating Documents in a MongoDB Collection - 542]]
  - [[16.7. Accessing the MongoDB Document ID Field - 544][16.7. Accessing the MongoDB Document ID Field - 544]]
  - [[16.8. Deleting Documents in a MongoDB Collection - 545][16.8. Deleting Documents in a MongoDB Collection - 545]]
  - [[16.9. A Quick Look at Slick - 547][16.9. A Quick Look at Slick - 547]]
- [[17. Interacting with Java - 549][17. Interacting with Java - 549]]
  - [[Introduction - 549][Introduction - 549]]
  - [[17.1. Going to and from Java Collections - 549][17.1. Going to and from Java Collections - 549]]
    - [[Problem - 549][Problem - 549]]
    - [[Solution - 550][Solution - 550]]
    - [[Discussion - 550][Discussion - 550]]
      - [[Conversion tables - 552][Conversion tables - 552]]
      - [[Going from Scala collections to Java collections - 553][Going from Scala collections to Java collections - 553]]
      - [[The JavaConverters object - 554][The JavaConverters object - 554]]
    - [[See Also - 554][See Also - 554]]
  - [[17.2. Add Exception Annotations to Scala Methods to Work with Java - 554][17.2. Add Exception Annotations to Scala Methods to Work with Java - 554]]
    - [[Problem - 554][Problem - 554]]
    - [[Solution - 554][Solution - 554]]
    - [[Discussion - 555][Discussion - 555]]
  - [[17.3. Using ~@SerialVersionUID~ and Other Annotations - 556][17.3. Using ~@SerialVersionUID~ and Other Annotations - 556]]
    - [[Problem - 556][Problem - 556]]
    - [[Solution - 556][Solution - 556]]
    - [[Discussion - 556][Discussion - 556]]
    - [[See Also - 557][See Also - 557]]
  - [[17.4. Using the Spring Framework - 557][17.4. Using the Spring Framework - 557]]
    - [[Problem - 557][Problem - 557]]
    - [[Solution - 557][Solution - 557]]
    - [[Discussion - 560][Discussion - 560]]
    - [[See Also - 560][See Also - 560]]
  - [[17.5. Annotating varargs Methods - 560][17.5. Annotating varargs Methods - 560]]
    - [[Problem - 560][Problem - 560]]
    - [[Solution - 560][Solution - 560]]
    - [[Discussion - 561][Discussion - 561]]
  - [[17.6. When Java Code Requires JavaBeans - 562][17.6. When Java Code Requires JavaBeans - 562]]
    - [[Problem - 562][Problem - 562]]
    - [[Solution - 562][Solution - 562]]
    - [[Discussion - 563][Discussion - 563]]
    - [[See Also - 565][See Also - 565]]
  - [[17.7. Wrapping Traits with Implementations - 565][17.7. Wrapping Traits with Implementations - 565]]
    - [[Problem - 565][Problem - 565]]
    - [[Solution - 565][Solution - 565]]
    - [[Discussion - 566][Discussion - 566]]
      - [[Other attempts - 566][Other attempts - 566]]
- [[18. The Simple Build Tool (SBT) - 569][18. The Simple Build Tool (SBT) - 569]]
  - [[18.1. Creating a Project Directory Structure for SBT - 570][18.1. Creating a Project Directory Structure for SBT - 570]]
  - [[18.2. Compiling, Running, and Packaging a Scala Project with SBT - 574][18.2. Compiling, Running, and Packaging a Scala Project with SBT - 574]]
  - [[18.3. Running Tests with SBT and ScalaTest - 579][18.3. Running Tests with SBT and ScalaTest - 579]]
  - [[18.4. Managing Dependencies with SBT - 581][18.4. Managing Dependencies with SBT - 581]]
  - [[18.5. Controlling Which Version of a Managed Dependency Is Used - 584][18.5. Controlling Which Version of a Managed Dependency Is Used - 584]]
  - [[18.6. Creating a Project with Subprojects - 586][18.6. Creating a Project with Subprojects - 586]]
  - [[18.7. Using SBT with Eclipse - 588][18.7. Using SBT with Eclipse - 588]]
  - [[18.8. Generating Project API Documentation - 590][18.8. Generating Project API Documentation - 590]]
  - [[18.9. Specifying a Main Class to Run - 591][18.9. Specifying a Main Class to Run - 591]]
  - [[18.10. Using GitHub Projects as Project Dependencies - 593][18.10. Using GitHub Projects as Project Dependencies - 593]]
  - [[18.11. Telling SBT How to Find a Repository (Working with Resolvers) - 595][18.11. Telling SBT How to Find a Repository (Working with Resolvers) - 595]]
  - [[18.12. Resolving Problems by Getting an SBT Stack Trace - 596][18.12. Resolving Problems by Getting an SBT Stack Trace - 596]]
  - [[18.13. Setting the SBT Log Level - 597][18.13. Setting the SBT Log Level - 597]]
  - [[18.14. Deploying a Single, Executable JAR File - 597][18.14. Deploying a Single, Executable JAR File - 597]]
  - [[18.15. Publishing Your Library - 601][18.15. Publishing Your Library - 601]]
  - [[18.16. Using Build.scala Instead of build.sbt - 602][18.16. Using Build.scala Instead of build.sbt - 602]]
  - [[18.17. Using a Maven Repository Library with SBT - 604][18.17. Using a Maven Repository Library with SBT - 604]]
  - [[18.18. Building a Scala Project with Ant - 606][18.18. Building a Scala Project with Ant - 606]]
- [[19. Types - 611][19. Types - 611]]
  - [[Introduction - 611][Introduction - 611]]
    - [[Variance - 611][Variance - 611]]
    - [[Bounds - 612][Bounds - 612]]
    - [[Type Constraints - 613][Type Constraints - 613]]
    - [[Type Examples in Other Chapters - 613][Type Examples in Other Chapters - 613]]
  - [[19.1. Creating Classes That Use Generic Types - 614][19.1. Creating Classes That Use Generic Types - 614]]
    - [[Problem - 614][Problem - 614]]
    - [[Solution - 614][Solution - 614]]
    - [[Discussion - 615][Discussion - 615]]
      - [[Type parameter symbols - 616][Type parameter symbols - 616]]
    - [[See Also - 617][See Also - 617]]
  - [[19.2. Creating a Method That Takes a Simple Generic Type - 617][19.2. Creating a Method That Takes a Simple Generic Type - 617]]
    - [[Problem -][Problem -]]
    - [[Solution -][Solution -]]
    - [[Discussion -][Discussion -]]
  - [[19.3. Using Duck Typing (Structural Types) - 618][19.3. Using Duck Typing (Structural Types) - 618]]
    - [[Problem -][Problem -]]
    - [[Solution -][Solution -]]
    - [[Discussion -][Discussion -]]
  - [[19.4. Make Mutable Collections Invariant - 620][19.4. Make Mutable Collections Invariant - 620]]
    - [[Problem -][Problem -]]
    - [[Solution -][Solution -]]
    - [[Discussion -][Discussion -]]
    - [[See Also -][See Also -]]
  - [[19.5. Make Immutable Collections Covariant - 622][19.5. Make Immutable Collections Covariant - 622]]
    - [[Problem -][Problem -]]
    - [[Solution -][Solution -]]
    - [[Discussion -][Discussion -]]
  - [[19.6. Create a Collection Whose Elements Are All of Some Base Type - 624][19.6. Create a Collection Whose Elements Are All of Some Base Type - 624]]
    - [[Problem -][Problem -]]
    - [[Solution -][Solution -]]
    - [[Discussion -][Discussion -]]
    - [[See Also -][See Also -]]
  - [[19.7. Selectively Adding New Behavior to a Closed Model - 627][19.7. Selectively Adding New Behavior to a Closed Model - 627]]
    - [[Problem -][Problem -]]
    - [[Solution -][Solution -]]
    - [[Discussion -][Discussion -]]
    - [[See Also -][See Also -]]
  - [[19.8. Building Functionality with Types - 630][19.8. Building Functionality with Types - 630]]
    - [[Example 1: Creating a Timer - 630][Example 1: Creating a Timer - 630]]
    - [[Example 2: Writing Your Own "Try" Classes - 631][Example 2: Writing Your Own "Try" Classes - 631]]
      - [[The Scala 2.10 Try classes - 633][The Scala 2.10 Try classes - 633]]
- [[20. Idioms - 635][20. Idioms - 635]]
  - [[Introduction - 635][Introduction - 635]]
    - [[Other Resources][Other Resources]]
  - [[20.1. Create Methods with No Side Effects (Pure Functions) - 636][20.1. Create Methods with No Side Effects (Pure Functions) - 636]]
    - [[Problem - 636][Problem - 636]]
    - [[Solution - 636][Solution - 636]]
      - [[Referential transparency - 637][Referential transparency - 637]]
      - [[Pure functions - 637][Pure functions - 637]]
      - [[The Java approach - 639][The Java approach - 639]]
      - [[Fixing the problems - 640][Fixing the problems - 640]]
    - [[Discussion - 642][Discussion - 642]]
      - [[StockUtils or Stock object?][StockUtils or Stock object?]]
    - [[See Also][See Also]]
  - [[20.2. Prefer Immutable Objects - 644][20.2. Prefer Immutable Objects - 644]]
  - [[20.3. Think “Expression-Oriented Programming” - 647][20.3. Think “Expression-Oriented Programming” - 647]]
  - [[20.4. Use Match Expressions and Pattern Matching - 650][20.4. Use Match Expressions and Pattern Matching - 650]]
    - [[Problem - 650][Problem - 650]]
    - [[Solution - 651][Solution - 651]]
      - [[Replacement for the Java switch statement and unwieldy if/then statements - 651][Replacement for the Java switch statement and unwieldy if/then statements - 651]]
      - [[In ~try/catch~ expressions - 651][In ~try/catch~ expressions - 651]]
      - [[As the body of a function or method - 652][As the body of a function or method - 652]]
      - [[Use with ~Option/Some/None~ - 653][Use with ~Option/Some/None~ - 653]]
      - [[In actors - 653][In actors - 653]]
      - [[Summary - 654][Summary - 654]]
    - [[See Also - 653][See Also - 653]]
  - [[20.5. Eliminate ~null~ Values from Your Code - 654][20.5. Eliminate ~null~ Values from Your Code - 654]]
    - [[Problem - 654][Problem - 654]]
    - [[Solution - 654][Solution - 654]]
      - [[Initialize ~var~ fields with ~Option~, not ~null~ - 655][Initialize ~var~ fields with ~Option~, not ~null~ - 655]]
      - [[Don't return ~null~ from methods - 656][Don't return ~null~ from methods - 656]]
      - [[Converting a ~null~ into an ~Option~, or something else - 657][Converting a ~null~ into an ~Option~, or something else - 657]]
      - [[Benefits - 658][Benefits - 658]]
    - [[See Also - 658][See Also - 658]]
  - [[20.6. Using the ~Option~, ~Some~, ~None~ Pattern - 658][20.6. Using the ~Option~, ~Some~, ~None~ Pattern - 658]]
    - [[Problem - 658][Problem - 658]]
    - [[Solution - 658][Solution - 658]]
      - [[Returning an ~Option~ from a method - 659][Returning an ~Option~ from a method - 659]]
      - [[Getting the value from an ~Option~ - 659][Getting the value from an ~Option~ - 659]]
      - [[Using ~Option~ with Scala collections - 660][Using ~Option~ with Scala collections - 660]]
      - [[Using ~Option~ with other frameworks - 661][Using ~Option~ with other frameworks - 661]]
      - [[Using ~Try~ (~Success~ and ~Failure~) - 662][Using ~Try~ (~Success~ and ~Failure~) - 662]]
      - [[Using ~Either~ (~Left~ and ~Right~) - 664][Using ~Either~ (~Left~ and ~Right~) - 664]]
    - [[Discussion - 665][Discussion - 665]]
      - [[Don't use the ~get~ method with ~Option~ - 665][Don't use the ~get~ method with ~Option~ - 665]]
    - [[See Also - 666][See Also - 666]]
- [[Index - 667][Index - 667]]
- [[TodoList][TodoList]]

* TODO Preface - 15
** The Scala Language - xiii
*** Solution - xiv

** Audience - xvi
** Contents of This Book - xvii
** Online Bonus Chapters - xx
** Installing the Software - xx
** How the Code Listings Work - xxi
** Conventions Used in This Book - xxi
** Using Code Examples - xxii
** How to Contact Us - xxiii
** Acknowledgements - xxiii

* TODO 1. Strings - 1
** DONE Introduction - 1
   CLOSED: [2018-03-01 Thu 19:36]
   - Scala ~String~ is Java ~String~

   - It seems Scala ~String~ has more methods than Java ~String~.
       When you think you call a /method/ on an ~String~ object, the reality
     might be you call a /method/ from the ~StringOps~, from the ~StringLike~ (a
     /trait/ that ~StringOps~ extends), or from the ~WrappedString~, and so on.
       Everything begins with the /implicit conversion/ from ~String~ to
     ~StringOps~ in the ~Predef~ object.

*** DONE Add Methods to Closed Classes - 3
    CLOSED: [2018-03-01 Thu 19:36]
    - =TODO= Recipe 1.9, "Accessing a Character in a String"

    - *How Did the Preceding Example Work?*

** DONE 1.1. Testing String Equality - 4
   CLOSED: [2018-03-01 Thu 19:12]
*** DONE Problem - 4
    CLOSED: [2018-03-01 Thu 19:08]
*** DONE Solution - 4
    CLOSED: [2018-03-01 Thu 19:08]
    - Use ~==~, NOT like Java.

    - Since use ~==~, also NOT like Java, there is no longer
      ~java.lang.NullPointerException~

    - To compare two strings while ignoring their case, you can
      + ~str1.toUpperCase == str2.toUpperCase~

        *CAUTION*: Since you call method on ~str1~ and ~str2~, the
        ~java.lang.NullPointerException~ may show up again.

      + fall back to Java
        ~str1.equalsIgnoreCase(str2)~

*** DONE Discussion - 6
    CLOSED: [2018-03-01 Thu 19:12]
    - In Scala, the ~==~ /method/ defined in the ~AnyRef~ class
      1. It first checks for ~null~ values,
      2. then it calls the ~equals~ /method/ on the first object (i.e., this) to
         see if the two objects are equal.

      As a result, you don't have to check for ~null~ values when comparing
      strings.

    - In *idiomatic Scala*, you _NEVER_ use ~null~.

    - =REDO= See Recipe 4.15 "Defining an equals Method (Object Equality)".

** DONE 1.2. Creating Multiline Strings - 6
   CLOSED: [2018-03-01 Thu 19:44]
*** DONE Problem - 6
    CLOSED: [2018-03-01 Thu 19:40]
*** DONE Solution - 6
    CLOSED: [2018-03-01 Thu 19:40]
    Use _three double quotes_:
    #+BEGIN_SRC scala
      val foo = """This is
      a multiline
      String"""
    #+END_SRC

*** DONE Discussion - 7
    CLOSED: [2018-03-01 Thu 19:44]
    You cannot expect left end alignment when you do something like
    #+BEGIN_SRC scala
      val foo = """This is
                   a multiline
                   String"""
    #+END_SRC
    The second and third lines will have _prefixed spaces_.

    - *SOLUTION*
      #+BEGIN_SRC scala
        val speech = """Four score and
                       |seven years ago
                       |our fathers""".stripMargin


        val speech1 = """Four score and
                        #seven years ago
                        #our fathers""".stripMargin('#')
      #+END_SRC

** DONE 1.3. Splitting Strings - 8
   CLOSED: [2018-03-01 Thu 19:02]
*** DONE Problem - 8
    CLOSED: [2018-03-01 Thu 07:15]
*** DONE Solution - 8
    CLOSED: [2018-03-01 Thu 07:15]
    The ~split~ method of ~String~ (acutally, ~String~ or ~StringLike~).

*** DONE Discussion - 8
    CLOSED: [2018-03-01 Thu 19:02]
**** About that ~split~ method... - 9
     - The ~split~ method is _overloaded_, with some versions of the method
       coming from the _Java ~String~ class_ and some coming from the _Scala
       ~StringLike~ class_.

** DONE 1.4. Substituting Variables into Strings - 9
   CLOSED: [2018-03-01 Thu 22:12]
*** DONE Problem - 9
    CLOSED: [2018-03-01 Thu 19:45]
*** DONE Solution - 9
    CLOSED: [2018-03-01 Thu 21:21]
    Since Scala 2.10, you can use /string interpolation/

    - Basic /string interpolation/
      + use ~s~ method
      + use ~$~ to insert variable
      + use ~${variableName}~ to eliminate ambiguity.

      #+BEGIN_SRC scala
        val name = "Fred"
        val age = 33
        val weight = 200.0

        println(s"$name is $age years old, and weighs $weight pounds.")
        // Fred is 33 years old, and weighs 200.0 pounds.
      #+END_SRC

**** DONE Using expressions in string literals - 10
     CLOSED: [2018-03-01 Thu 20:56]
     - the official string interpolation documentation:
       #+BEGIN_QUOTE
       Any arbitrary expression can be embedded in ~${}~.
       #+END_QUOTE

     - Wrap /object fields/ in curly braces, or there will be a wrong
       interpretation.
       #+BEGIN_SRC scala
         // error: this is intentionally wrong

         println(s"$hannah.name has a score of $hannah.score")
         // Student(Hannah,95).name has a score of Student(Hannah,95).score
       #+END_SRC

**** DONE ~s~ is a method - 10
     CLOSED: [2018-03-01 Thu 21:00]
     - The ~s~ that's placed before each string literal is actually a /method/.

     - This seems not as convenient as the other languages that use interploation
       as default, but it has at least _two benefits_:
       + Scala provides other off-shelf interpolation funcitons to give you more
         power.

       + You can define your own string interpolation functions.

**** DONE The ~f~ string interpolator (~printf~ style formatting) - 11
     CLOSED: [2018-03-01 Thu 21:07]
     #+BEGIN_SRC scala
       println(f"$name is $age years old, and weighs $weight%.2f pounds.")
       // Fred is 33 years old, and weighs 200.00 pounds.

       ////  and then with no decimal places:
       println(f"$name is $age years old, and weighs $weight%.0f pounds.")
       // Fred is 33 years old, and weighs 200 pounds.

       // For fields
       case class S(i: Int, d: Double)
       val s = S(1, 200.03)
       println(f"${s.i}, ${s.d}%.0f")
       // Only variable names can be inside the ${}
       // You can't use `${s.d%.0f}`
     #+END_SRC

**** DONE The ~raw~ interpolator - 11
     CLOSED: [2018-03-01 Thu 21:21]
     /The official string interpolation documentation/ for ~raw~:
     #+BEGIN_QUOTE
     performs no escaping of literals within the string.
     #+END_QUOTE

     - Example:
       #+BEGIN_SRC scala
         s"foo\nbar"
         // foo
         // bar
  
         raw"foo\nbar"
         // foo\nbar
       #+END_SRC

     - _Triple double quote_ also performs no escaping of literals within the
       string, and you can instert newline literally without escaping.

     - Both ~raw~ and _triple double quote_ are especially useful when you work
       with Regex.

     - =TODO= =???=
       =Now is 2.12, how about this feature now?=
       String interpolation does not work with pattern-matching statements
       in Scala 2.10. This feature is planned for inclusion in Scala 2.11.

**** DONE Create your own interpolator - 12
     CLOSED: [2018-03-01 Thu 21:21]
     =TODO= See /the official Scala String Interpolation documentation/.

*** DONE Discussion - 12
    CLOSED: [2018-03-01 Thu 22:10]
    - Prior to version 2.10, Scala didn't include the /string interpolation/
      functionality just described. Use ~format~ /method/.

    - =From Jian=
      I think there is an error in the
      Table 1-1. Common printf style format sepcifiers

      There should be no ~%u~ format specifier !?!?
      NOT 100% sure.

*** TODO See Also - 13

** DONE 1.5. Processing a String One Character at a Time - 13
   CLOSED: [2018-03-01 Thu 01:08]
*** DONE Problem - 13
    CLOSED: [2018-02-28 Wed 22:22]
*** DONE Solution - 13
    CLOSED: [2018-02-28 Wed 22:21]
    ~map~, ~foreach~, for-loop, for-iteration

*** DONE Discussion - 14
    CLOSED: [2018-03-01 Thu 01:08]
    Corresponding Java code (if not use ~Stream~):
    #+BEGIN_SRC java
      String s = "Hello";
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < s.length(); i++) {
          char c = s.charAt(i);
          // do something with the character ...
          // sb.append ...
      }
      String result = sb.toString();
    #+END_SRC

**** Understanding how map works - 15
**** A complete example - 16

*** TODO See Also - 17

** DONE 1.6. Finding Patterns in Strings - 18
   CLOSED: [2018-03-01 Thu 22:20]
*** DONE Problem - 18
    CLOSED: [2018-03-01 Thu 22:16]
*** DONE Solution - 18
    CLOSED: [2018-03-01 Thu 22:19]
    Use the ~r~ method of string to create ~Regex~, and then use the
    ~findFirstIn~ or the ~findAllIn~ methods to get the result.

    - ~findFirstIn~ returns an ~Option[String]~ result.

    - ~findAllIn~ returns an /iterator/ result.

*** DONE Discussion - 19
    CLOSED: [2018-03-01 Thu 22:20]
    You can also use the ~scala.util.matching.Regex~ more explicity.
    For example, ~new Regex(raw"[0-9]+")~

**** DONE Handling the ~Option~ returned by ~findFirstIn~ - 19
     CLOSED: [2018-03-01 Thu 22:20]

*** TODO See Also- 20

** DONE 1.7. Replacing Patterns in Strings - 21
   CLOSED: [2018-03-01 Thu 22:27]
*** DONE Problem - 21
    CLOSED: [2018-03-01 Thu 22:22]
*** DONE Solution - 21
    CLOSED: [2018-03-01 Thu 22:27]
    Two kinds of solutions:
    - ~String~ /method/:
      #+BEGIN_SRC scala
        val address = "123 Main Street"

        address.replaceAll(raw"[0-9]", "x")
        // xxx Main Street

        address.replaceFirst(raw"[0-9]", "x")
        // x23 Main Street
      #+END_SRC

    - ~Regex~ /method/
      #+BEGIN_SRC scala
        val address = "123 Main Street"
        val regex = raw"[0-9]".r

        regex.replaceAllIn(address, "x")
        // xxx Main Street

        regex.replaceFirstIn(address, "x")
        // x23 Main Street
      #+END_SRC

*** TODO See Also - 21

** DONE 1.8. Extracting Parts of a String That Match Patterns - 22
   CLOSED: [2018-03-01 Thu 22:39]
*** DONE Problem - 22
    CLOSED: [2018-03-01 Thu 22:32]
*** DONE Solution - 22
    CLOSED: [2018-03-01 Thu 22:32]
    #+BEGIN_SRC scala
      val pattern = "([0-9]+) ([A-Za-z]+)".r
      val pattern(count, fruit) = "100 Bananas"
      // count: String = 100
      // fruit: String = Bananas
    #+END_SRC

*** DONE Discussion - 22
    CLOSED: [2018-03-01 Thu 22:39]
*** TODO See Also - 24

** DONE 1.9. Accessing a Character in a String - 24
   CLOSED: [2018-03-01 Thu 22:41]
*** DONE Problem - 24
    CLOSED: [2018-03-01 Thu 22:39]
*** DONE Solution - 24
    CLOSED: [2018-03-01 Thu 22:41]
    - Java use the way of ~"hello".charAt(0)~, and Scala do it like ~"hello"(0)~.
*** DONE Discussion - 24
    CLOSED: [2018-03-01 Thu 22:41]
    Scala actully call the ~apply~ method.
    ~"hello"(0)~ is converted to ~"hello".apply(0)~ in the background.

** TODO 1.10. Add Your Own Methods to the String Class - 25
*** TODO Problem - 25
*** TODO Solution - 25
**** TODO Put the ~implicit class~ in an object - 25
**** TODO Put the ~implicit class~ in a package object - 26
**** TODO Using versions of Scala prior to version 2.10 - 27

*** TODO Discussion - 27
**** TODO Annotate your method return type - 28
**** TODO Returning other types - 29

* DONE 2. Numbers - 31
  CLOSED: [2018-02-28 Wed 18:05]
** DONE Introduction - 31
   CLOSED: [2018-02-28 Wed 17:31]
   - In Scala, all the /numeric types/ are /objects/, including ~Byte~, ~Char~,
     ~Double~, ~Float~, ~Int~, ~Long~, and ~Short~.

     These seven /numeric types/ extend the ~AnyVal~ /trait/.

   - There are some other /objects/, /nonnumeric value types/, that extend the
     ~AnyVal~ /trait/: ~Unit~ and ~Boolean~.

   - Table 2-1. Data ranges of Scala’s built-in numeric types
     (Save ranges as in Java)
     | Data type | Range                                  |
     |-----------+----------------------------------------|
     | Char      | 16-bit unsigned Unicode character      |
     | Byte      | 8-bit signed value                     |
     | Short     | 16-bit signed value                    |
     | Int       | 32-bit signed value                    |
     | Long      | 64-bit signed value                    |
     | Float     | 32-bit IEEE 754 single precision float |
     | Double    | 64-bit IEEE 754 single precision float |

*** DONE Complex Numbers and Dates - 32
    CLOSED: [2018-02-28 Wed 17:38]
    - =TODO= (This book is not very new. I should also check these libraries
      condition) =TODO=

      If you need more powerful math classes than those that are included with
      the standard Scala distribution,
      + check out the *Spire project*, which includes classes like ~Rational~,
        ~Complex~, ~Real~, and _more_; and

      + ~ScalaLab~, which offers Matlab-like scientific computing in Scala.

    - ~nscala-time~ is a wrapper for Java's Joda Time library, which help users
      to use Joda Time in a more Scala-like way.

      + =From Jian=
        However, since Java 8, a Joda Time like library is a part of the standard
        JDK. Use ~nscala-time~ and Joda Time is NO Longer a good choice.

      + =TODO=
        check if this exist? Or will be created? Or Java API is considered OK.
        =TODO=

        I think Scala has or will have a wrapper for the new Joda-Time-like
        standard library.

** DONE 2.1. Parsing a Number from a String - 32
   CLOSED: [2018-02-28 Wed 17:16]
*** DONE Problem - 32
    CLOSED: [2018-02-28 Wed 17:05]
*** DONE Solution - 32
    CLOSED: [2018-02-28 Wed 17:05]
    - Use ~toXXX~ pattern /methods/ for ~Short~, ~Int~, ~Long~, ~Float~, and
      ~Double~.

    - Use the ~apply~ /method/ of ~BigInt~ and ~BigDecimal~.
      #+BEGIN_SRC scala
        BigInt("1")

        BigInt("3.14159")
      #+END_SRC

**** Handling a base and radix - 33
     - You need to use Java's method to solve this problem.
       #+BEGIN_SRC scala
         Integer.parserInt("1", 2)
       #+END_SRC

     - You can also create /implict class/ with a ~toInt~ method with ~radix~
       parameter.
       #+BEGIN_SRC scala
         implicit class StringToInt(s: String) {
           def toInt(radix: Int) = Integer.parseInt(s, radix)
         }
       #+END_SRC

*** DONE Discussion - 34
    CLOSED: [2018-02-28 Wed 17:16]
    - If your scala code, which includes ~String~ to numbers conversion, will be
      used by Java, you'd better take care of the ~NumberFormatException~ with
      the ~@throws~ annotation.

    - For scala itself, you can use ~Option~ or ~Try~ (since Scala 2.10). 
      =From Jian= For dealing with exceptions, I think ~Try~ is better.
      #+BEGIN_SRC scala
        def toIntOpt(s: String): Option[Int] =
          try {
            Some(s.toInt)
          } catch {
            case e: NumberFormatException => None
          }

      #+END_SRC

**** Alternatives to ~Option~ - 35
     ~Try~ (since Scala 2.10) or ~Either~

*** TODO See Also - 36

** DONE 2.2. Converting Between Numeric Types (Casting) - 36
   CLOSED: [2018-02-28 Wed 15:55]
*** DONE Problem - 36
    CLOSED: [2018-02-28 Wed 15:52]
*** DONE Solution - 36
    CLOSED: [2018-02-28 Wed 15:53]
    - ~toByte~
    - ~toChar~
    - ~toDouble~
    - ~toFloat~
    - ~toInt~
    - ~toLong~
    - ~toShort~
    - ~toString~

*** DONE Discussion - 36
    CLOSED: [2018-02-28 Wed 15:54]
    If you want to _avoid potential conversion errors_ when casting from one
    numeric type to another, you can use the related ~isValidXXXX~.
      For example, ~a.isValidByte~

*** TODO See Also - 36

** DONE 2.3. Overriding the Default Numeric Type - 37
   CLOSED: [2018-02-28 Wed 16:06]
*** DONE Problem - 37
    CLOSED: [2018-02-28 Wed 16:02]
*** DONE Solution - 37
    CLOSED: [2018-02-28 Wed 16:02]
    #+BEGIN_SRC scala
      // Method 1
      val a = 1D
      val b = 1F

      // Method 2 (type ascription)
      val c = 1 : Double
      val d = 1 : Long

      // Method 3 (For simple variable initialization, Method 3 is prefered)
      val c: Double = 1
      val d: Long = 1
    #+END_SRC

*** DONE Discussion - 39
    CLOSED: [2018-02-28 Wed 16:06]
    - You can use the *underscore* character as a placeholder when assigning an
      initial value.
      #+BEGIN_SRC scala
        class Foo {
          var a: Short = 0
          var b: Short = _  // defaults to 0
        }
      #+END_SRC

      This works when creating /class variables/, but *does NOT work in other
      places*, such as inside a method.

    - For numeric types this isn't an issue -- you can just assign the type the
      value zero -- but with most other types, you can use this approach inside a
      method: ~var name = null.asInstanceOf[String]~

*** TODO See Also - 39

** DONE 2.4. Replacements for ~++~ and ~−−~ - 39
   CLOSED: [2018-02-28 Wed 15:16]
*** DONE Problem - 40
    CLOSED: [2018-02-28 Wed 15:16]
    Find the replacement of ~++~ and ~--~, which are NOT supported by Scala.

*** DONE Solution - 41
    CLOSED: [2018-02-28 Wed 15:14]
    Use the /methods/ like ~+=~ and ~-=~.

    =From Jian=
    Like Java, Scala doesn't support operator overloading.

    However, operators in Java like ~+~ and ~-~ are /methods/ in Scala, and you
    can overload them.

*** DONE Discussion - 41
    CLOSED: [2018-02-28 Wed 15:16]
    /Methods/ like ~+=~ and ~-=~ are more general then ~++~ and ~--~.
    You can use them with non-integer types.

*** TODO See Also - 41

** DONE 2.5. Comparing Floating-Point Numbers - 41
   CLOSED: [2018-02-28 Wed 15:31]
*** DONE Problem - 41
    CLOSED: [2018-02-28 Wed 15:24]
    Like most other languages that use IEEE standard to save floating numbers,
    Scala also cannot compare floating numbers directly. Then how to do it in
    Scala

*** DONE Solution - 41
    CLOSED: [2018-02-28 Wed 15:23]
    Use a funcition like
    #+BEGIN_SRC scala
      def ~=(x: Double, y: Double, tolerance: Double) =
        (x - y).abs < tolerance
    #+END_SRC

*** DONE Discussion - 42
    CLOSED: [2018-02-28 Wed 15:30]
    How to use the ~~=~ function in the Solution section?

    + Write it in an utility object.
      As a function with three parameters, alphabetical names, like
      ~approximatelyEqual~ or ~equalWithinTolerance~, might be better.


    + Use a default ~tolerance~ setting, create an implicit conversion to
      floating numbers, and use ~+=~ as an infix-operator-like /method/.

*** TODO See Also - 43
   
** DONE 2.6. Handling Very Large Numbers - 43
   CLOSED: [2018-02-28 Wed 17:25]
*** DONE Problem - 43
    CLOSED: [2018-02-28 Wed 17:19]
*** DONE Solution - 43
    CLOSED: [2018-02-28 Wed 17:19]
    ~BigInt~ and ~BigDecimal~
    Unlike their Java equivalents, these classes support all the operators
    (actually operator-like methods) you're used to using with numeric types:
    #+BEGIN_SRC scala
      var b = BigInt(1234567890)
      val bb = b + b
      b += 1
    #+END_SRC

*** DONE Discussion - 44
    CLOSED: [2018-02-28 Wed 17:25]
    - Although the Scala ~BigInt~ and ~BigDecimal~ classes are backed by the Java
      ~BigInteger~ and ~BigDecimal~ classes, they are simpler to use than their
      Java counterparts.

    - Before using ~BigInt~ or ~BigDecimal~, you may want to check the range of
      the non-Big numeric types like:
      #+BEGIN_SRC scala
        Byte.MaxValue    // 127
        Short.MaxValue   // 32767
        Int.MaxValue     // 2147483647
        Long.MaxValue    // 9223372036854775807
        Double.MaxValue  // 1.7976931348623157E308

        Double.PositiveInfinity  // Infinity
        Double.NegativeInfinity  // -Infinity

        // CAUTION: compare floating numbers simply with `>`, `<`, and `==` is NOT a good
        //          idea!
        1.7976931348623157E308 > Double.PositiveInfinity  // false
      #+END_SRC

*** TODO See Also - 45

** DONE 2.7. Generating Random Numbers - 45
   CLOSED: [2018-02-28 Wed 17:02]
*** DONE Problem - 45
    CLOSED: [2018-02-28 Wed 16:33]
*** DONE Solution - 45
    CLOSED: [2018-02-28 Wed 16:38]
    Use ~scala.util.Random~ class
    #+BEGIN_SRC scala
      val r = scala.util.Random

      r.nextInt

      r.nextInt(100)  // with limit 0 (inclusive) and 100 (exclusive)

      r.nextFloat

      r.nextDouble

      // Set the seed value using an `Int` or `Long`
      // 1. When new an instance
      val rr = new scala.util.Random(100)

      // 2. After the creation of an `Random` instance
      val rrr = new scala.util.Random
      rrr.setSeed(1000L)
    #+END_SRC

*** DONE Discussion - 46
    CLOSED: [2018-02-28 Wed 17:01]
    - The ~Random~ class handles all the usual use cases.
      For example, generate random characters ~r.nextPrintableChar~

    - Random-length ranges:
      ~0 to r.nextInt(10)~

    - Random number collections (with bound):
      ~(1 to 5).map(_ => r.nextInt(100))~

*** TODO See Also - 47

** DONE 2.8. Creating a ~Range~, ~List~, or ~Array~ of Numbers - 47
   CLOSED: [2018-02-28 Wed 15:46]
*** DONE Problem - 47
    CLOSED: [2018-02-28 Wed 15:43]
*** DONE Solution - 47
    CLOSED: [2018-02-28 Wed 15:43]
    - ~1 to 10~

    - ~1 to 10 by 2~

    - ~1 until 10~

    - ~1 until 10 by 2~

*** DONE Discussion - 48
    CLOSED: [2018-02-28 Wed 15:46]
    - ~Range~ can be converted to ~List~ and ~Array~ easily.
      Just use the ~toListl~ and ~toArray~ method.

    - You are actually invoking the ~to~ or ~until~ method of ~RichInt~.
      Scala help you to implictly do the converstion from ~Int~ to ~RichInt~.

*** TODO See Also - 49

** DONE 2.9. Formatting Numbers and Currency - 49
   CLOSED: [2018-02-28 Wed 18:05]
*** DONE Problem - 49
    CLOSED: [2018-02-28 Wed 18:00]
*** DONE Solution - 49
    CLOSED: [2018-02-28 Wed 17:43]
    :LOGBOOK:
    CLOCK: [2018-02-28 Wed 17:57]--[2018-02-28 Wed 18:22] =>  0:25
    :END:
    - For basic number formatting, use ~f~ string interpolator. For example,
      #+BEGIN_SRC scala
        val pi = scala.math.Pi

        println(f"$pi%1.5f")   // 3.14159
        println(f"$pi%1.2f")   // 3.14
        println(f"$pi%06.2f")  // 003.14
      #+END_SRC

      + Prior to Scala 2.10, you don't have the ~f~ string interpolator.
        You need to use the ~format~ method like ~"%06.2f".format(pi)~.

      + Use ~java.text.NumberFormat.getIntegerInstance~ to add commas to numbers
        for clarity.
        #+BEGIN_SRC scala
          val formatter = java.text.NumberFormat.getIntegerInstance

          formatter.format(10000)
          // res0: String = 10,000
          formatter.format(1000000)  // 1,000,000
          // res1: String = 1,000,000
        #+END_SRC

        * You can also set a locale with the ~getIntegerInstance~ /method/
          #+BEGIN_SRC scala
            val locale = new java.util.Locale("de", "DE")
            val formatter = java.text.NumberFormat.getIntegerInstance(locale)
            formatter.format(1000000)
            //res2: String = 1.000.000
          #+END_SRC

        * You can also handle floating numbers:
          #+BEGIN_SRC scala
            val formatter = java.text.NumberFormat.getInstance
            formatter.format(10000.33)
            // res0: String = 10,000.33
          #+END_SRC

    - For /currency/ output, use the ~getCurrencyInstance~ formatter:
      #+BEGIN_SRC scala
        val formatter = java.text.NumberFormat.getCurrencyInstance

        println(formatter.format(123.456789))
        // $123.46

        println(formatter.format(1234.56789))
        // $1,234.57

        println(formatter.format(12345.6789))
        // $12,345.68

        println(formatter.format(123456.789))
        // $123,456.79
      #+END_SRC

      + For international currency:
        #+BEGIN_SRC scala
          import java.util.{Currency, Locale}

          val de = Currency.getInstance(new Locale("de", "DE"))
          // de: java.util.Currency = EUR

          formatter.setCurrency(de)
          println(formatter.format(123456.789))
          // EUR123,456.79
        #+END_SRC

*** DONE Discussion - 51
    CLOSED: [2018-02-28 Wed 18:04]
    This recipe falls back to the Java approach for dealing with /currency/.

    In the experience of the author of this book, as a consultant, most companies
    he know use Java ~BigDecimal~ to process currency, and others create their
    own custom currency classes, which are typically wrappers around ~BigDecimal~.

*** TODO See Also - 51
    - JSR 354

* DONE 3. Control Structures - 53
  CLOSED: [2018-03-01 Thu 23:53]
** DONE Introduction - 53
   CLOSED: [2018-03-01 Thu 23:36]
** DONE 3.1. Looping with ~for~ and ~foreach~ - 54
   CLOSED: [2017-07-18 Tue 13:40]
   =54=
*** DONE Problem
    CLOSED: [2017-07-18 Tue 12:03]
*** DONE Solution
    CLOSED: [2017-07-18 Tue 12:09]
   - Loops in Scala:
     + ~for~ loop
     + ~while~ loop
     + collection methods:
       * ~foreach~
       * ~map~
       * ~flatMap~, and more

   - This section concentrate on ~for~ loop and ~foreach~ method.
     
**** DONE Returning values from a for loop
     CLOSED: [2017-07-18 Tue 12:04]
     ~yield~

**** DONE ~for~ loop counters
     CLOSED: [2017-07-18 Tue 12:07]
     #+BEGIN_SRC scala
       for (i <- 0 until a.length) {
         println(s"$i is ${a(i)}")
       }

       for ((e, count) <- a.zipWithIndex) {
         println(s"$count is $e")
       }
     #+END_SRC

     =TODO= Recipe 10.11 ~zipWithIndex~
**** DONE Generators and guards
     CLOSED: [2017-07-18 Tue 12:07]
     ~Range~
     #+BEGIN_SRC scala
       for (i <- 1 to 3) println(i)

       // With guard
       for (i <- 1 to 10 if i < 4) println(i)
     #+END_SRC
**** DONE Looping over a Map
     CLOSED: [2017-07-18 Tue 12:09]
     #+BEGIN_SRC scala
       for ((k,v) <- names) println(s"key: $k, value: $v")
     #+END_SRC

     =TODO= Recipe 11.17, "Traversing a Map"
*** DONE Discussioin
    CLOSED: [2017-07-18 Tue 13:40]
**** DONE How ~for~ loops are translated
     CLOSED: [2017-07-18 Tue 13:40]
     - A _simplification_ of the rules in /Scala Language Specification/:
       1. a ~for~ loop on a collection -> ~foreach~ method;

       2. a ~for~ loop with a guard -> a ~withFilter~ methods call on the
          collection followed by a ~foreach~ call;

       3. a ~for~ comprehension -> ~map~ method;

       4. a ~for~ comprehension with a guard -> a ~withFilter~ methods call on
          the collection followed by a ~map~ call;

     - Example:
       #+BEGIN_SRC scala
         class Main {
           for (i <- 1 to 10) println(i)
         }

         // In CLI:
         // scalac -Xprint:parse Main.scala

         // [[syntax trees at end of parser]] // Main.scala
         // package <empty> {
         //   class Main extends scala.AnyRef {
         //     def <init>() = {
         //       super.<init>();
         //       ()
         //     };
         //     1.to(10).foreach(((i) => println(i)))
         //   }
         // }
       #+END_SRC

     - ~-Xprint:parse~ shows the result after the first step.

     - ~-Xprint:all~ shows the result after all steps in the compilation process.

** DONE 3.2. Using for Loops with Multiple Counters - 60
   CLOSED: [2017-07-18 Tue 13:45]
*** DONE Problem
    CLOSED: [2017-07-18 Tue 13:45]

*** DONE Solution
    CLOSED: [2017-07-18 Tue 13:44]
    #+BEGIN_SRC scala
      val array = Array.ofDim[Int](2, 2)
      array(0)(0) = 0
      array(0)(1) = 1
      array(1)(0) = 2
      array(1)(1) = 3

      for {
        i <- 0 to 1
        j <- 0 to 1
      } println(s"($i)($j) = ${array(i)(j)}")
    #+END_SRC

*** DONE Discussion
    CLOSED: [2017-07-18 Tue 13:45]

** DONE 3.3. Using a for Loop with Embedded if Statements (Guards) - 62
   CLOSED: [2017-07-18 Tue 13:47]
*** Problem
*** Solution
*** Discussion
** DONE 3.4. Creating a for Comprehension (for/yield Combination) - 63
   CLOSED: [2017-07-18 Tue 13:50]
*** Problem
*** Solution
*** Discussion
** DONE 3.5. Implementing break and continue - 65
   CLOSED: [2017-07-19 Wed 01:08]
*** DONE Problem
    CLOSED: [2017-07-18 Tue 13:52]
    Scala doesn't have ~break~ or ~continue~ keywords.

*** DONE Solution
    CLOSED: [2017-07-18 Tue 23:37]
    ~break~-like and ~continue~-like functionalities are provided through
    ~scala.util.control.Breaks~

    #+BEGIN_SRC scala
      package com.alvinalexander.breakandcontinue

      import util.control.Breaks._

      object BreakAndContinueDemo extends App {
        println("\n=== BREAK EXAMPLE ===")
        breakable {
          for (i <- 1 to 10) {
            println(i)
            if (i > 4) break  // break out of the for loop
          }
        }

        println("\n===CONTINUE EXAMPLE ===")

        val searchMe = "peter piper picked a peck of pickled peppers"
        var numPs = 0

        for (i <- 0 until searchMe.length) {
          breakable {
            if (searchMe.charAt(i) ! = 'p') {
              break  // break out of the 'breakable', continue the outside loop
            } else {
              numPs += 1
            }
          }
        }
        println("Found " + numPs + " p's in the string.")
      }

      // === BREAK EXAMPLE ===
      // 1
      // 2
      // 3
      // 4
      // 5
      //
      // === CONTINUE EXAMPLE ===
      // Found 9 p's in the string.
    #+END_SRC

**** DONE The *break* example
     CLOSED: [2017-07-18 Tue 23:37]
     - ~break~ will throw a ~BreakControl~ exception when it's called. 
       #+BEGIN_SRC scala
         private val breakException = new BreakControl
         def break(): Nothing = { throw breakException }
       #+END_SRC

     - ~breakable~ will catch a ~BreakControl~ exception.
       #+BEGIN_SRC scala
         def breakable(op: => Unit) {
           try {
             op
           } catch {
             case ex: BreakControl =>
               // TODO: ???
               if (ex ne breakException) throw ex
           }
         }
       #+END_SRC

     - =TODO= rECIPE 3.18

**** DONE The *continue* example
     CLOSED: [2017-07-19 Wed 00:16]
     Use ~break~ and ~breakable~ to implement ~continue~-like functionality.
     #+BEGIN_SRC scala
       package com.alvinalexander.breakandcontinue

       // import util.control.Breaks._
       val searchMe = "peter piper picked a peck of pickled peppers"
       var numPs = 0

       for (i <- 0 until searchMe.length) {
         breakable {
           if (searchMe.charAt(i) ! = 'p') {
             break  // break out of the 'breakable', continue the outside loop
           } else {
             numPs += 1
           }
         }
       }
       println("Found " + numPs + " p's in the string.")
     #+END_SRC

**** DONE General syntax
     CLOSED: [2017-07-19 Wed 00:20]
     - _break_ functionality
       #+BEGIN_SRC scala
         breakable {
           for (x <- xs) {
             if (cond)
               break
           }
         }
       #+END_SRC

       Corresponds to this Java:

       #+BEGIN_SRC java
         for (X x : xs) {
             if (cond) break;
         }
       #+END_SRC

     - _continue_ functionality
       #+BEGIN_SRC scala
         for (x <- xs) {
           breakable {
             if (cond)
               break
           }
         }
       #+END_SRC

       Corresponds to this Java:

       #+BEGIN_SRC java
         for (X x : xs) {
             if (cond) continue;
         }
       #+END_SRC

**** DONE About that *continue* example..
     CLOSED: [2017-07-19 Wed 00:23]
     ~val count = searchMe.count(_=='p')~

**** DONE Nested loops and /labeled breaks/
     CLOSED: [2017-07-19 Wed 00:55]
     - Example
       #+BEGIN_SRC scala
         package com.alvinalexander.labeledbreaks

         object LabeldBreakDemo extends App {
           import scala.util.control._

           // TODO: Why capital
           val Inner = new Breaks
           // TODO: Why capital
           val Outer = new Breaks

           Outer.breakable {
             for (i <- 1 to 5) {
               Inner.breakable {
                 for (j <- 'a' to 'e') {
                   if (i == 1 && j == 'c') Inner.break else println(s"i: $i, j: $j")
                   if (i == 2 && j == 'b') Outer.break
                 }
               }
             }
           }
         }
       #+END_SRC

     - Use one labeled break, the pattern below is like the _continue_ pattern.
       However, since we used the labeled break, we actually implement a _break_
       pattern.
       #+BEGIN_SRC scala
         import scala.util.control._

         val Exit = new Breaks
         Exit.breakable {
           for (j <- 'a' to 'e') {
             if (j == 'c') Exit.break else println(s"j: $j")
           }
         }
       #+END_SRC

*** DONE Discussion
    CLOSED: [2017-07-19 Wed 01:08]
    If you don't like the _break_ pattern and the _continue_ pattern, try
    + guard

    + write a function, use ~return~ to break

    + Use recursive algorithm -- calculation stops when the base case/cases
      is/are reached.

** DONE 3.6. Using the ~if~ Construct Like a Ternary Operator - 71
   CLOSED: [2017-07-19 Wed 01:09]
*** Problem
*** Solution
*** Discussion
** DONE 3.7. Using a Match Expression Like a switch Statement - 72
   CLOSED: [2017-07-19 Wed 02:07]
*** DONE Problem
    CLOSED: [2017-07-19 Wed 02:03]
*** DONE Solution
    CLOSED: [2017-07-19 Wed 02:03]
**** DONE The ~@switch~ annotation
     CLOSED: [2017-07-19 Wed 02:03]
     Issue a warning if the pattern matching can't be compiled to ~tableswitch~
     or ~lookupswitch~.

     ~tableswitch~ and ~lookupswitch~ have good performance, because they are
     /branch tables/ rather than /decision trees/. They use _jump_ rather than
     walk through the decision tree.

     - Example: =SwitchDemo.scala= Version _1_, which has no warning.
       #+BEGIN_SRC scala
         // Version 1 - compiles to a tableswitch
         import scala.annotation.switch

         class SwitchDemo {
           val i = 1
           val x = (i: @switch) match {
             case 1 => "One"
             case 2 => "Two"
             case _ => "Other"
           }
         }
       #+END_SRC
       =SwitchDemo.scala= can be compiled without warnings

       The output of ~javap -c SwitchDemo~
       #+BEGIN_SRC text
         16:  tableswitch{ //1 to 2
                     1: 50;
                     2: 45;
                     defalut: 40 }
       #+END_SRC

     - Example: =SwitchDemo.scala= Version _2_, which has a warning.
       #+BEGIN_SRC scala
         // Version 2 - leads to a compiler warning
         import scala.annotation.switch

         class SwitchDemo {
           val i = 1
           val Two = 2  // added compared to Ver 1
           val x = (i: @switch) match {
             case 1 => "One"
             case Two => "Two"   // replaced the '2'
             case _ => "Other"
           }
         }
       #+END_SRC

       ~scalac SwitchDemo.scala~ will issue a warning:
       #+BEGIN_SRC text
         SwitchDemo.scala:7: warning: could not emit switch for @switch annotated match
         val x = (i: @switch) match {
         ^
         one warning found
       #+END_SRC

     - Rules (from the book *Scala In Depth* by Joshua Suereth) for Scala to
       apply the ~tableswitch~ optimization:
       1. The matched value must be a known integer

       2. The matched expression must be "simple". It can't contain any type
          checks, if statements, or extractors.

       3. The expression must also have its value available at compile time.

       4. There should be more than two ~case~ statements.

     - =From Jian= Where are the rules for ~lookupswitch~???

*** DONE Discussion
    CLOSED: [2017-07-19 Wed 02:07]
**** DONE Handling the default case
     CLOSED: [2017-07-19 Wed 02:05]
     =TODO= Recipe 9.8, "Creating Partial Functions".
**** DONE Do you really need a switch statement?
     CLOSED: [2017-07-19 Wed 02:07]
     Use ~Map~.

     #+BEGIN_SRC scala
       val monthNumberToName = Map(
         1 -> "January",
         2 -> "February",
         3 -> "March",
         4 -> "April",
         5 -> "May",
         6 -> "June",
         7 -> "July",
         8 -> "August",
         9 -> "September",
         10 -> "October",
         11 -> "November",
         12 -> "December"
       )

       val monthName = monthNumberToName(4)
       println(monthName) // prints "April"
     #+END_SRC

** DONE 3.8. Matching Multiple Conditions with One Case Statement - 76
   CLOSED: [2017-07-19 Wed 02:08]
*** DONE Problem
    CLOSED: [2017-07-19 Wed 02:09]
*** DONE Solution
    CLOSED: [2017-07-19 Wed 02:09]
    Use ~|~ to separate patterns
*** DONE Discussion
    CLOSED: [2017-07-19 Wed 02:09]

** DONE 3.9. Assigning the Result of a Match Expression to a Variable - 77
   CLOSED: [2017-07-19 Wed 02:11]
*** Problem
*** Solution
*** Discussion

** DONE 3.10. Accessing the Value of the Default Case in a Match Expression - 78
   CLOSED: [2017-07-19 Wed 02:12]
*** DONE Problem
    CLOSED: [2017-07-19 Wed 02:11]

*** DONE Solution
    CLOSED: [2017-07-19 Wed 02:11]
    In the last case use a name, rather than ~_~.

*** DONE Discussion
    CLOSED: [2017-07-19 Wed 02:12]

** DONE 3.11. Using Pattern Matching in Match Expressions - 79
   CLOSED: [2018-03-01 Thu 23:35]
*** DONE Problem - 79
    CLOSED: [2018-03-01 Thu 22:44]
    You need to match one or more patterns in a match expression, and the
    pattern may be a
    - constant pattern
    - variable pattern
    - constructor pattern
    - sequence pattern
    - tuple pattern
    - type pattern

*** DONE Solution - 79
    CLOSED: [2018-03-01 Thu 23:02]
    - Use ~_*~ to match the tail of a sequence:
      #+BEGIN_SRC scala
        case List(1, _*) => "a list beginning with 1, having any number of elements"
        case Vector(1, _*) => "a vector starting with 1, having any number of elements"
      #+END_SRC

    - Use /type wildcard/ to match arbitrary type:
      #+BEGIN_SRC scala
        case list: List[_] => s"thanks for the List: $list"
        case m: Map[_, _] => m.toString
      #+END_SRC

      =IMPORTANT=
      This is not mandatory! You can use type like ~List[x]~ to annotate your
      pattern. However, due to /type erasure/ in the JVM, nothing you can do with
      the ~x~. Therefore, before JVM solves this problem, there is NO reason to
      a named variable to match the actually erased type.

    - *Tips*: =IMPORTANT=
      About /type erasure/, if you write something like
      ~case l: List[Int] => "List"~, the Scala compiler will give you a warning
      #+BEGIN_QUOTE
      Test1.scala:7: warning: non-variable type argument Int in type pattern
      List[Int] is unchecked since it is eliminated by erasure
          case l: List[Int] => "List[Int]"
      #+END_QUOTE

      =From Jian=
      Before JVM solves the /type erasure/ problem, /generics type annotation/ in
      pattern matching is useless!

*** DONE Discussion - 82
    CLOSED: [2018-03-01 Thu 23:27]
**** DONE Patterns - 82
     CLOSED: [2018-03-01 Thu 23:21]
**** DONE Adding variables to patterns - 84
     CLOSED: [2018-03-01 Thu 23:21]
     - ~case list @ List(1, _*) => s"$list"~

     - ~case List(1, tl @ _*) => s"$list"~

**** DONE Using ~Some~ and ~None~ in match expressions - 85
     CLOSED: [2018-03-01 Thu 23:27]
     - =From Jian=
       Mostly you work with ~Option~ type and ~Try~ type with ~map~, ~flatMap~,
       and ~foreach~. Only when you try to get the inside value out, you may use
       /pattern matching/.

     - =From Jian=
       The /wave-particle duality/ of ~Option~'s and ~Try~'s:
       + particle: When you want to interact with them, use /pattern matching/.

       + wave: when you want them to propagate, use ~map~, ~flatMap~, and
         ~foreach~.

*** TODO See Also - 86
    =IMPORTANT=

** DONE 3.12. Using Case Classes in Match Expressions - 86
   CLOSED: [2017-07-19 Wed 02:13]
*** DONE Problem - 86
    CLOSED: [2018-03-01 Thu 22:49]
*** DONE Solution - 86
    CLOSED: [2018-03-01 Thu 22:49]

** DONE 3.13. Adding if Expressions (Guards) to Case Statements - 87
   CLOSED: [2017-07-19 Wed 02:13]
*** Problem
*** Solution
*** Discussion

** DONE 3.14. Using a Match Expression Instead of isInstanceOf - 88
   CLOSED: [2017-07-19 Wed 02:31]
*** DONE Problem
    CLOSED: [2017-07-19 Wed 02:28]

*** DONE Solution
    CLOSED: [2017-07-19 Wed 02:28]
    ~if (x.isInstanceOf[Foo]) { do something ... }~
    NOT ALWAYS BAD! This is good ONLY for some simple cases.

    For most situations use the TWO solutions listed below:
    #+BEGIN_SRC scala
      // 1
      def isPerson(x: Any): Boolean = x match {
        case p: Person => true
        case _ => false
      }



      // 2: case classes extended from some base class
      trait SentientBeing
      trait Animal extends SentientBeing
      case class Dog(name: String) extends Animal
      case class Person(name: String, age: Int) extends SentientBeing

      def printInfo(x: SentientBeing) = x match {
        case Person(name, age) => // handle the Person
        case Dog(name) => // handle the Dog
      }
    #+END_SRC

*** DONE Discussion
    CLOSED: [2017-07-19 Wed 02:30]

** DONE 3.15. Working with a List in a Match Expression - 89
   CLOSED: [2017-07-19 Wed 02:31]
*** Problem
*** Solution
*** Discussion

** DONE 3.16. Matching One or More Exceptions with try/catch - 91
   CLOSED: [2017-07-19 Wed 02:43]
*** DONE Problem
    CLOSED: [2017-07-19 Wed 02:32]

*** DONE Solution
    CLOSED: [2017-07-19 Wed 02:34]
    The Scala ~try/catch/finally~ syntax is _similar_ to Java,
    BUT it uses the _match expression approach_ in the ~catch~ block:
    #+BEGIN_SRC scala
      val s = "Foo"

      try {
        val i = s.toInt
      } catch {
        case e: Exception => e.printStackTrace
        // case ...
      }
    #+END_SRC
*** DONE Discussion
    CLOSED: [2017-07-19 Wed 02:43]
    A catch-all ~try ... catch~ should use a type ~Throwable~ case variable,
    rather than just ~_~ with no type specified.

    (NOTE form Jian: ~Throwable~ is a super class of ~Exception~,
     as well as ~Error~)

    #+BEGIN_SRC scala
      try {
        openAndReadAFile("foo")
      } catch {
        case t: Throwable => t.printStackTrace()
      }
    #+END_SRC

    If you prefer to declare the exceptions that your method throws,
    or you need to interact with Java,
    add the ~@throws~ annotation to your method definition:
    #+BEGIN_SRC scala
      @throws(classOf[NumberFormatException])
      def toInt(s: String): Option[Int] =
        try {
          Some(s.toInt)
        } catch {
          case e: NumberFormatException => throw e
        }
    #+END_SRC

** DONE 3.17. Declaring a Variable Before Using It in a try/catch/finally Block - 92
   CLOSED: [2017-07-19 Wed 02:53]
*** Problem
*** Solution
    #+BEGIN_SRC scala
      import java.io._

      object CopyBytes extends App {
        var in = None: Option[FileInputStream]
        var out = None: Option[FileOutputStream]
        try {
          in = Some(new FileInputStream("/tmp/Test.class"))
          out = Some(new FileOutputStream("/tmp/Test.class.copy"))
          var c = 0
          while ({c = in.get.read; c != −1}) {
            out.get.write(c)
          }
        } catch {
          case e: IOException => e.printStackTrace
        } finally {
          println("entered finally ...")
          if (in.isDefined) in.get.close
          if (out.isDefined) out.get.close
        }
      }
    #+END_SRC
*** Discussion

** DONE 3.18. Creating Your Own Control Structures - 95
   CLOSED: [2018-03-01 Thu 23:53]
*** DONE Problem - 95
    CLOSED: [2018-03-01 Thu 23:38]
*** DONE Solution - 95
    CLOSED: [2018-03-01 Thu 23:42]
    - =From Jian= Summary
      When _defining_ it, combine the features of
      + /funciton definition/

      + /currying/
        Since it is a control structure, you don't want to evaluate all parts of
        it when you see its header. Or else, this is NOT a control structure --
        a real control structure is used to decide what to do and what not to do,
        rather than do them all.

      + /lazy parameter(s)/
        The body of the control structure shouldn't be evaluated when the
        condition in the header isn't fulfilled.

    - For example,
      #+BEGIN_SRC scala
        package com.alvinalexander.controls

        import scala.annotation.tailrec


        object Whilst {
          // 2nd attempt
          @tailrec
          def whilst(testCondition: => Boolean)(codeBlock: => Unit) {
            if (testCondition) {
              codeBlock
              whilst(testCondition)(codeBlock)
            }
          }
        }
      #+END_SRC

    - When _using_ it, use the feature that function can accept /code blocks/ as
      parameters

    - For example
      #+BEGIN_SRC scala
        package foo

        import com.alvinalexander.controls.Whilst._


        object WhilstDemo extends App {

          var i = 0

          whilst (i < 5) {
            println(i)
            i += 1
          }

        }
      #+END_SRC

*** DONE Discussion - 96
    CLOSED: [2018-03-01 Thu 23:53]
    #+BEGIN_SRC scala
      def doubleif(test1: => Boolean)(test2: => Boolean)(codeBlock: => Unit) {
        if (test1 && test2) {
          codeBlock
        }
      }


      doubleif(age > 18)(numAccidents == 0) {
        println("Discount!")
      }
    #+END_SRC

* TODO 4. Classes and Properties - 99
** TODO Introduction - 99
   - Some of the biggest differences between Scala and Java:
     + the declaration of classes
     + class constructors
     + the control of field visibility

** TODO 4.1. Creating a Primary Constructor - 100
*** Problem - 100
*** Solution - 100
*** Discussion - 101
**** A comparison with Java - 102
**** Those ~_$eq~ methods - 103
**** Summary - 104

** TODO 4.2. Controlling the Visibility of Constructor Fields - 104
*** Problem - 104
*** Solution - 105
**** ~var~ fields - 105
**** ~val~ fields - 106
**** Fields without ~val~ or ~var~ - 106
**** Adding ~private~ to ~val~ or ~var~ - 106

*** Discussion - 107
**** Case classes - 107

** TODO 4.3. Defining Auxiliary Constructors - 108
*** Problem - 108
*** Solution - 108
*** Discussion - 109
**** Generating auxiliary constructors for case classes - 110

*** See Also - 112

** TODO 4.4. Defining a Private Primary Constructor - 112
*** Problem - 112
*** Solution - 112
*** Discussion - 112
**** Utility classes - 113

** TODO 4.5. Providing Default Values for Constructor Parameters - 114
*** Problem - 114
*** Solution - 114
*** Discussion - 114
**** Multiple parameters - 115
**** Using named parameters - 115

*** See Also - 115

** TODO 4.6. Overriding Default Accessor - 116
*** Problem - 116
*** Solution - 116
*** Discussion - 117
**** Summary - 118

** TODO 4.7. Preventing Getter and Setter Methods from Being Generated - 119
*** Problem - 119
*** Solution - 119
*** Discussion - 119
**** Object-private fields - 120

*** See Also - 115
** TODO 4.8. Assigning a Field to a Block or Function - 121
*** Problem - 121
*** Solution - 121
*** Discussion - 121

** TODO 4.9. Setting Uninitialized var Field Types - 122
*** Problem - 122
*** Solution - 123
*** Discussion - 124
*** See Also - 124

** TODO 4.10. Handling Constructor Parameters When Extending a Class - 124
*** Problem - 124
*** Solution - 124
*** Discussion - 125

** TODO 4.11. Calling a Superclass Constructor - 127
*** Problem - 127
*** Solution - 127
**** Auxiliary constructors - 128

** TODO 4.12. When to Use an Abstract Class - 129
*** Problem - 129
*** Solution - 129
*** Discussion - 129

** TODO 4.13. Defining Properties in an Abstract Base Class (or Trait) - 131
*** Problem - 131
*** Solution - 131
**** Abstract ~val~ and ~var~ fields - 131

*** Discussion - 132
**** Concrete val fields in abstract classes - 133

**** Concrete var fields in abstract classes - 134
**** Don't use ~null~ - 135

*** See Also - 136

** TODO 4.14. Generating Boilerplate Code with Case Classes - 136
*** Problem - 136
*** Solution - 136
*** Discussion - 138
**** Generated code - 138

*** See Also - 140

** TODO 4.15. Defining an equals Method (Object Equality) - 140
*** Problem - 140
*** Solution - 140
*** Discussion - 141
**** Theory - 142

*** See Also - 143

** TODO 4.16. Creating Inner Classes - 143
*** Problem - 143
*** Solution - 143
*** Discussion - 144
*** See Also - 145

* TODO 5. Methods - 147
** DONE Introduction - 147
   CLOSED: [2018-02-28 Wed 00:27]
   - Difference syntax between Scala and Java in declaring /methods/.

   - In addition to the differences in syntax, there are other differences
     between Scala and Java /methods/, including:
     + Specifying /method/ /access control (visibility)/

     + The ability to set /default values/ for /method parameters/

     + The ability to /specify the names/ of /method parameters/ when calling a
       /method/

     + How you declare the /exceptions/ a /method/ can throw

     + Using /varargs/ fields in /methods/

     This chapter demonstrates all of these method-related features.

** DONE 5.1. Controlling Method Scope - 148
   CLOSED: [2018-02-28 Wed 00:57]
*** DONE Problem - 148
    CLOSED: [2018-02-28 Wed 00:55]
    Scala /methos/ are *public* _by default_. NO keyword for this.
    How about to set upt other visibility?

*** DONE Solution - 148
    CLOSED: [2018-02-28 Wed 00:55]
    - Scala provides *more* control to the /visibility/ than that of Java:

    - Scala provides these scope options:
      + Object-private scope
      + Private
      + Package
      + Package-specific
      + Public

**** DONE Object-private scope - 148
     CLOSED: [2018-02-28 Wed 00:46]
     - ~private[this]~ -- the most restrictive one.
       A /method/ marked with this is only visible to a /instance/ itself.

     - Non-compilable code
       #+BEGIN_SRC scala
         class Foo {
           private[this] def isFoo = true

           def doFoo(other: Foo) {
             is (other.isFoo) {  // This line WON'T compile
               // code
             }
           }
         }
       #+END_SRC

**** DONE Private scope - 149
     CLOSED: [2018-02-28 Wed 00:46]
     - ~private~ makes the /method/ available to
       + the /current class/
       + other /instances/ of the /current class/

     - There is only one meaning for ~private~ in both Scala and Java.

     - Compilable (which is non-compilable in the last section with
       ~private[this]~)
       #+BEGIN_SRC scala
         class Foo {
           private def isFoo = true

           def doFoo(other: Foo) {
             is (other.isFoo) {  // This line WON'T compile
               // code
             }
           }
         }
       #+END_SRC

     - By making a method private, it is not available to subclasses -- you can't
       call it.
       + Non-compilable example
       #+BEGIN_SRC scala
         class Animal {
           private def heartBeat {}
         }

         class Dog extends Animal {
           heartBeat  // WON'T compile
         }
       #+END_SRC

       However, you can create one with the same name with any visibility you
       like.
       + Compilable - the superclass ~hearBeat~ is NOT available, and the
         subclass create a same name but complete different one. This is NOT
         shadowing, no ~override~ required, and, actually, you *MUST'T* add
         ~override~
         #+BEGIN_SRC scala
           class Animal {
             private def heartBeat {}
           }

           class Dog extends Animal {
             def heartBeat {}  
           }
         #+END_SRC

**** DONE Protected scope - 149
     CLOSED: [2018-02-28 Wed 00:49]
     - ~protected~ -- available to /subclasses/.
       + Compilable code (Non-compilable in the last section with ~private~):
         #+BEGIN_SRC scala
           class Animal {
             protected def heartBeat {}
           }

           class Dog extends Animal {
             heartBeat  // compilable
           }
         #+END_SRC

     - ~protected~ in Scala is different from that in Java.

**** DONE Package scope - 150
     CLOSED: [2018-02-28 Wed 00:48]
     - ~private[packageName]~ -- available to all members of the current package.
       This is called "package scope" in Java, and Java use its ~protected~ to
       mark this.

**** DONE More package-level control - 150
     CLOSED: [2018-02-28 Wed 00:55]
     - Use the ~private[packageName]~ pattern, but specify a package name of
       *different hierarchy* to make more control.

     - Example:
       #+BEGIN_SRC scala
         package com.acme.coolapp.model {
           class Foo {
             private[model] def doX {}
             private[coolapp] def doY {}
             private[acme] def doZ {}
           }
         }
         import com.acme.coolapp.model._
         package com.acme.coolapp.view {
           class Bar {
             val f = new Foo
             f.doX // won't compile
             f.doY
             f.doZ
           }
         }
         package com.acme.common {
           class Bar {
             val f = new Foo
             f.doX // won't compile
             f.doY // won't compile
             f.doZ
           }
         }
       #+END_SRC

**** DONE Public scope - 151
     No modifier means *public*.

*** DONE Discussion - 152
    CLOSED: [2018-02-28 Wed 00:57]
    *Summary* ...
    Table 5-1. Descriptions of Scala's access control modifiers

** DONE 5.2. Calling a Method on a Superclass - 152
   CLOSED: [2018-02-28 Wed 01:13]
*** DONE Problem - 152
    CLOSED: [2018-02-28 Wed 01:05]
*** DONE Solution - 153
    CLOSED: [2018-02-28 Wed 01:13]
    Use the ~super.methodName~ pattern.

**** DONE Controlling which trait you call a method from - 153
     CLOSED: [2018-02-28 Wed 01:13]
     - Use the ~super[traitName].methodName~ pattern to resolve confliction when
       a /class/ extends multiple /traits/ which have *same name* /methods/.
       #+BEGIN_SRC scala
         trait Human {
           def hello = "the Human trait"
         }

         trait Mother extends Human {
           override def hello = "Mother"
         }

         trait Father extends Human {
           override def hello = "Father"
         }

         class Child extends Human with Mother with Father {
           def printSuper = super.hello  // same as `super[Father].hello`
           // TODO: ?? By default, the last one (this is a guess for all triats, how about
           //       when one of them is a class????)

           def printMother = super[Mother].hello
           def printFather = super[Father].hello
           def printHuman = super[Human].hello
         }
       #+END_SRC

     - Note that when using this technique, _you *CANNOT* continue to REACH UP
       THROUGH the parent class hierarchy_ unless you directly /extend/ the
       target class or trait using the ~extends~ or ~with~ keywords.
       + Non-compilable
         #+BEGIN_SRC scala
           trait Animal {
             def walk { println("Animal is walking") }
           }

           class FourLeggedAnimal extends Animal {
             override def walk { println("I'm walking on all fours") }
           }

           class Dog extends FourLeggedAnimal {
             def walkThenRun {
               super.walk // works
               super[FourLeggedAnimal].walk // works
               super[Animal].walk // error: won't compile
             }
           }
         #+END_SRC

       + Make the code above compilable:
         Change the signature of ~Dog~ to
         ~class Dog extends FourLeggedAnimal with Animal~

** TODO 5.3. Setting Default Values for Method Parameters - 154
*** TODO Problem - 154
*** TODO Solution - 155
*** TODO Discussion - 156

** TODO 5.4. Using Parameter Names When Calling a Method - 157
*** TODO Problem - 157
*** TODO Solution - 157
*** TODO Discussion - 158

** TODO 5.5. Defining a Method That Returns Multiple Items (Tuples) - 159
*** TODO Problem - 159
*** TODO Solution - 159
*** TODO Discussion - 159
**** Working with tuples - 160

*** TODO See Also - 160

** TODO 5.6. Forcing Callers to Leave Parentheses off Accessor Methods - 161
*** TODO Problem - 161
*** TODO Solution - 161
*** TODO Discussion - 161
*** TODO See Also - 162

** TODO 5.7. Creating Methods That Take Variable-Argument Fields - 163
*** TODO Problem - 163
*** TODO Solution - 163
*** TODO Discussion - 163

** DONE 5.8. Declaring That a Method Can Throw an Exception - 165
   CLOSED: [2018-02-28 Wed 14:12]
*** DONE Problem - 165
    CLOSED: [2018-02-28 Wed 14:05]
*** DONE Solution - 165
    CLOSED: [2018-02-28 Wed 14:11]
    Use ~@throws(classOf[className])~

    - Example
      #+BEGIN_SRC scala
        @throws(classOf[Exception])
        override def play {
          // exception throwing code here ...
        }

        @throws(classOf[IOException])
        @throws(classOf[LineUnavailableException])
        @throws(classOf[UnsupportedAudioFileException])
        def playSoundFileWithJavaAudio {
          // exception throwing code here ...
        }
      #+END_SRC

*** TODO Discussion - 165
    - *Java Exception Types* =TODO=

*** TODO See Also - 166

** DONE 5.9. Supporting a Fluent Style of Programming - 167
   CLOSED: [2018-02-28 Wed 14:03]
*** DONE Problem - 167
    CLOSED: [2018-02-28 Wed 14:03]
*** DONE Solution - 167
    CLOSED: [2018-02-28 Wed 13:27]
    To support fluent (method chanining) style of programming:
    - If your class can be extended, specify ~this.type~ as the return type of
      fluent style methods.

      + =From Jian=
        Suppose you have ~A~ (trait or class) and ~B~ (traits or class), and B is
        a subclass/subtrait of A (B extends A). Then, with the help of
        ~this.type~, when ~A.method_1~ returns ~A.type~, ~B.method_1~ returns
        ~B.type~.

      + =From Jian=
        I think this is different from Java. In Java, if a superclass/supertrait
        ~A~ method returns an object of type ~A~, its subclass/subtrait will
        still returns an object of type ~A~, and you need to use cast which
        convert the returned ~A~ type object to a ~B~ type object at runtime.

      + =From Jian=
        Look the code below (*caution* this is Java code):
        #+BEGIN_SRC java
          // Person.java
          public class Person {
              public Person method_1() {
                  // some code
              }
          }

          // Employee.java
          public class Employee extends Person {
              @Override
              public Exployee method_1() {   // Wrong type! This is NOT an override!!!
                  // some code
              }
          }
        #+END_SRC
        * Java dosen't have ~this.type~. You have to use runtime cast when you
          use ~Employee~

      + Example:
        #+BEGIN_SRC scala
          class Person {
            protected var fname = ""
            protected var lname = ""

            def setFirstName(firstName: String): this.type = {
              fname = firstName
              this
            }

            def setLastName(lastName: String): this.type = {
              lname = lastName
              this
            }
          }

          class Employee extends Person {
            protected var role = ""

            def setRole(role: String): this.type = {
              this.role = role
              this
            }

            override def toString = {
              "%s, %s, %s".format(fname, lname, role)
            }
          }

          object Main extends App {
            val employee = new Employee

            // use the fluent methods
            employee.setFirstName("Al")
              .setLastName("Alexander")
              .setRole("Developer")
            println(employee)
          }
        #+END_SRC

        * If there is no ~this.type~ in Scala (like Java, even ~Employee~ methods
          return ~Person~), the last part will be
          #+BEGIN_SRC scala
            object Main extends App {
              val employee = new Employee

              // use the fluent methods
              employee.setFirstName("Al")
                .setLastName("Alexander")
                .asInstanceOf[Employee]
                .setRole("Developer")
              println(employee)
            }
          #+END_SRC

          Luckily, we don't need to do this.

    - If you're sure that your class won't be extended (use ~final~ in the
      declaration), you can optionally return ~this~ from your fluent style
      methods.

*** DONE Discussion - 168
    CLOSED: [2018-02-28 Wed 14:03]
    =TODO= More experiemnts!!!
    Explicitly use ~this.type~ as the return type can guarantee you won't get
    wrong type (superclass type or the type inference you don't want).

    - Interesting Example:
      Kamil Banaszczyk's answer for the question
      https://stackoverflow.com/questions/42062109/can-java-return-type-write-like-scala-this-type

*** TODO See Also - 170

* TODO 6. Objects - 171
** DONE 6.1. Object Casting - 172
   CLOSED: [2018-02-21 Wed 21:07]
*** DONE Problem - 172
    CLOSED: [2018-02-21 Wed 21:07]
*** DONE Solution - 172
    CLOSED: [2018-02-21 Wed 21:07]
    ~asInstanceOf[aType]~

*** TODO Discussion - 172
*** TODO See Also - 173

** TODO 6.2. The Scala Equivalent of Java's .class - 174
*** Problem - 174
*** Solution - 174
*** Discussion - 174
*** See Also - 174

** TODO 6.3. Determining the Class of an Object - 174
*** Problem - 174
*** Solution - 175
*** Discussion - 176

** TODO 6.4. Launching an Application with an Object - 176
*** Problem - 176
*** Solution - 176
*** Discussion - 177
*** See Also - 178

** TODO 6.5. Creating Singletons with object - 178
*** Problem - 178
*** Solution - 178
*** Discussion - 180

** DONE 6.6. Creating Static Members with Companion Objects - 180
   CLOSED: [2018-02-21 Wed 21:04]
*** DONE Problem - 180
    CLOSED: [2018-02-21 Wed 21:04]
    Scala does NOT have the ~static~ keyword.
    Create /static members/ in a /class's/ /companion object/.

*** DONE Solution - 180
    CLOSED: [2018-02-21 Wed 21:03]
    - companion object :: an object fulfill the requirements:
      + it must have the *same name* as its /companion class/
      + it must reside in the *same file* as its /companion class/

*** DONE Discussion - 181
    CLOSED: [2018-02-21 Wed 21:03]
**** Accessing private members - 181
     - =From Jian=
       A /class/ and its /companion object/ can access each other's
       /private members/. More concretely,
       + The /companion object/ accesses the /private memebers/ of the passed in
         its /companion class/'s instance(s).
         #+BEGIN_SRC scala
           class Foo {
             private val secret = 2
           }

           object Foo {
             // access the private class field 'secret'
             def double(foo: Foo) = foo.secret * 2
           }

           object Driver extends App {
             val f = new Foo
             println(Foo.double(f)) // prints 4
           }
         #+END_SRC

       + The /companion class/ accesses the /private memebers/ of its /companion
         object/ through the prefix of /companion object/'s name.

         =From Jian= I forget about this prefix for a long time. If you don't
         want this prefix, use ~import companionObjectName._~ inside the
         /compation class/.
         #+BEGIN_SRC scala
           class Foo {
             // access the private object field 'obj'
             def printObj { println(s"I can see ${Foo.obj}") }
           }

           object Foo {
             private val obj = "Foo's object"
           }

           object Driver extends App {
             val f = new Foo
             f.printObj
           }
         #+END_SRC

** TODO 6.7. Putting Common Code in Package Objects - 182
*** Problem - 182
*** Solution - 182
*** Discussion - 183
*** See Also - 184

** TODO 6.8. Creating Object Instances Without Using the new Keyword - 185
*** Problem - 185
*** Solution - 185
**** Creating a companion object with an apply method - 185
**** Declare your class as a case class - 186

*** Discussion - 186
**** Providing multiple constructors with additional apply methods - 186
**** Providing multiple constructors for case classes - 187

** TODO 6.9. Implement the Factory Method in Scala with apply - 189
*** Problem - 189
*** Solution - 189
*** Discussion - 190
*** See Also - 190

* TODO 7. Packaging and Imports - 191
** TODO Introduction - 191
** TODO 7.1. Packaging with the Curly Braces Style Notation - 192
*** Problem - 192
*** Solution - 192
*** Discussion - 193

** TODO 7.2. Importing One or More Members - 193
*** Problem - 193
*** Solution - 193
*** Discussion - 194
**** Placing import statements anywhere - 194

** TODO 7.3. Renaming Members on Import - 195
*** Problem - 195
*** Solution - 195
*** Discussion - 195

** TODO 7.4. Hiding a Class During the Import Process - 196
*** Problem - 196
*** Solution - 196

** TODO 7.5. Using Static Imports - 197
*** Problem - 197
*** Solution - 197
*** Discussion - 198

** TODO 7.6. Using Import Statements Anywhere - 199
*** Problem - 199
*** Solution - 199
*** Discussion - 200

* TODO 8. Traits - 203
** TODO 8.1. Using a Trait as an Interface - 203
*** Problem - 203
*** Solution - 203
*** Discussion - 205

** TODO 8.2. Using Abstract and Concrete Fields in Traits - 206
*** Problem - 206
*** Solution - 206
*** Discussion - 206

** TODO 8.3. Using a Trait Like an Abstract Class - 207
*** Problem - 207
*** Solution - 207
*** Discussion - 207
*** See Also - 208

** TODO 8.4. Using Traits as Simple Mixins - 208
*** Problem - 208
*** Solution - 208
*** See Also - 209

** TODO 8.5. Limiting Which Classes Can Use a Trait by Inheritance - 209
*** Problem - 209
*** Solution - 209
*** Discussion - 210
*** Discussion - 211 ???
*** See Also - 211

** TODO 8.6. Marking Traits So They Can Only Be Used by Subclasses of a Certain Type - 211
*** Problem - 211
*** Solution - 211
*** Discussion - 212
*** See Also - 213

** TODO 8.7. Ensuring a Trait Can Only Be Added to a Type That Has a Specific Method - 213
*** Problem - 213
*** Solution - 213
*** Discussion - 214
*** See Also - 214

** TODO 8.8. Adding a Trait to an Object Instance - 215
*** Problem - 215
*** Solution - 215
*** Discussion - 215

** TODO 8.9. Extending a Java Interface Like a Trait - 216
*** Problem - 216
*** Solution - 216

* TODO 9. Functional Programming - 217
** TODO Introduction - 217
** TODO 9.1. Using Function Literals (Anonymous Functions) - 218
*** Problem - 218
*** Solution - 218
*** Discussion - 218

** TODO 9.2. Using Functions as Variables - 219
*** Problem - 219
*** Solution - 219
*** Discussion - 220
**** Using a method like an anonymous function - 221
**** Assigning an existing function/method to a function variable - 222

*** See Also - 223

** TODO 9.3. Defining a Method That Accepts a Simple Function Parameter - 223
*** Problem - 223
*** Solution - 223
*** Discussion - 224
    - *Scala's Unit*

*** See Also - 225
** TODO 9.4. More Complex Functions - 226
*** Problem - 226
*** Solution - 226
*** Discussion - 226
**** Passing in a function with other parameters - 227

** TODO 9.5. Using Closures - 229
*** Problem - 229
*** Solution - 229
*** Discussion - 230
**** A second example - 231
**** Using closures with other data types - 232
**** A comparison to Java - 232

*** See Also - 234

** TODO 9.6. Using Partially Applied Functions - 234
*** Problem - 234
*** Solution - 234
*** Discussion - 235

** TODO 9.7. Creating a Function That Returns a Function - 236
*** Problem - 236
*** Solution - 236
*** Discussion - 237
**** Another example - 237

*** See Also - 238

** TODO 9.9. A Real-World Example - 242
*** Problem - 238
*** Solution - 238
**** The ~PartialFunction~ explained - 239
**** ~orElse~ and ~andThen~ - 240

*** Discussion - 241
*** See Also - 242

* 10. Collections - 245
** Introduction - 245
*** A Few Important Concepts - 245

** 10.1. Understanding the Collections Hierarchy - 246
*** DONE Problem - 246
    CLOSED: [2018-02-19 Mon 11:40]
    The /Scala collections hierarchy/ is very rich (deep and wide), and
    _understanding how it's organized can be helpful when choosing a
    collection to solve a problem_.

*** DONE Solution - 247

** 10.2. Choosing a Collection Class - 250
** 10.3. Choosing a Collection Method to Solve a Problem - 255
** 10.4. Understanding the Performance of Collections - 261
** 10.5. Declaring a Type When Creating a Collection - 264
** 10.6. Understanding Mutable Variables with Immutable Collections - 265
** 10.7. Make Vector Your “Go To” Immutable Sequence - 266
** 10.8. Make ArrayBuffer Your “Go To” Mutable Sequence - 268
** 10.9. Looping over a Collection with foreach - 270
** 10.10. Looping over a Collection with a for Loop - 272
** 10.11. Using zipWithIndex or zip to Create Loop Counters - 276
** 10.12. Using Iterators - 278
** 10.13. Transforming One Collection to Another with for/yield - 279
** 10.14. Transforming One Collection to Another with map - 282
** 10.15. Flattening a List of Lists with flatten - 285
** 10.16. Combining map and flatten with flatMap - 286
** 10.17. Using filter to Filter a Collection - 289
** 10.18. Extracting a Sequence of Elements from a Collection - 291
** 10.19. Splitting Sequences into Subsets (groupBy, partition, etc.) - 293
** 10.20. Walking Through a Collection with the reduce and fold Methods - 295
** 10.21. Extracting Unique Elements from a Sequence - 300
** 10.22. Merging Sequential Collections - 302
** 10.23. Merging Two Sequential Collections into Pairs with zip - 304
** 10.24. Creating a Lazy View on a Collection - 306
** 10.25. Populating a Collection with a Range - 309
** 10.26. Creating and Using Enumerations - 311
** 10.27. Tuples, for When You Just Need a Bag of Things - 312
** 10.28. Sorting a Collection - 315
** 10.29. Converting a Collection to a String with mkString - 318

* TODO 11. List, Array, Map, Set (and More) 321
** 11.1. Different Ways to Create and Populate a ~List~ - 322
** 11.2. Creating a Mutable ~List~ - 324
** 11.3. Adding Elements to a ~List~ - 325
** 11.4. Deleting Elements from a ~List~ (or ~ListBuffer~) - 328
** 11.5. Merging (Concatenating) ~List~'s - 330
** 11.6. Using ~Stream~, a Lazy Version of a ~List~ - 331
** 11.7. Different Ways to Create and Update an ~Array~ - 333
** 11.8. Creating an Array Whose Size Can Change (~ArrayBuffer~) - 335
** 11.9. Deleting ~Array~ and ~ArrayBuffer~ Elements - 335
** 11.10. Sorting ~Array~'s - 337
** 11.11. Creating Multidimensional ~Array~'s - 338
** 11.12. Creating Maps - 341
** 11.13. Choosing a Map Implementation - 343
** 11.14. Adding, Updating, and Removing Elements with a Mutable Map - 345
** 11.15. Adding, Updating, and Removing Elements with Immutable Maps - 347
** 11.16. Accessing Map Values - 349
** 11.17. Traversing a Map - 350
** 11.18. Getting the Keys or Values from a Map - 352
** 11.19. Reversing Keys and Values - 352
** 11.20. Testing for the Existence of a Key or Value in a Map - 353
** 11.21. Filtering a Map - 354
** 11.22. Sorting an Existing Map by Key or Value - 357
** 11.23. Finding the Largest Key or Value in a Map - 360
** 11.24. Adding Elements to a Set - 361
** 11.25. Deleting Elements from Sets - 363
** 11.26. Using Sortable Sets - 365
** 11.27. Using a Queue - 367
** 11.28. Using a Stack - 369
** 11.29. Using a Range - 371
* TODO 12. Files and Processes - 375
** DONE 12.0. Introduction - 375
   CLOSED: [2018-02-20 Tue 18:30]
   - ~scala.io.Source~ offers some nice simplifications comapred to Java:
     - Open and read text files.
     - Download content from URLs.
     - Substitute a ~String~ for a ~File~, which is useful for testing.

   - The Scala ~Console~ /class/ also SIMPLIFIES _console interaction_.

   - In other cases, such as when
     + reading a YAML file
       or
     + working with directories,
     you simply _fall back to use existing Java libraries_.

   - Execute system commands:
     Scala makes it *much* easier.
     Scala has a clean API to let you run external commands.

** DONE 12.1. How to Open and Read a Text File - 375
   CLOSED: [2018-02-20 Tue 18:24]
*** DONE Problem
    CLOSED: [2018-02-20 Tue 17:49]
    1. open a plain-text file

    2. process the lines in that file

*** DONE Solution
    CLOSED: [2018-02-20 Tue 17:49]
    - _TWO_ primary ways:
      + A concise one-line syntax.
        * With side-effect of leaving the file open
        * Be useful in short-lived programs, like shell scripts.

      + A slightly longer approach that properly closes the file.

**** Using the concise syntax
     #+BEGIN_SRC scala
       import scala.io.Source

       val filename = "fileopen.scala"
       for (line <- Source.fromFile(filename).getLines) {
         println(line)
       }
     #+END_SRC

     - Some variation:
       #+BEGIN_SRC scala
         val lines = Source.fromFile("/Users/Al/.bash_profile").getLines.toList
         val lines = Source.fromFile("/Users/Al/.bash_profile").getLines.toArray
       #+END_SRC

     - ~fromFile~ method returns a ~BufferedSource~, and its ~getLines~ method
       treats any =\r\n=, =\r=, or =\n= as a line separator.

**** Properly closing the file
     #+BEGIN_SRC scala
       val bufferedSource = Source.fromFile("example.txt")

       for (line <- bufferedSource.getLines) {
         println(line.toUpperCase)
       }

       bufferedSource.close
     #+END_SRC

     - =TODO=
       For automated methods of closing the file, see the "Loan Pattern" examples
       in the *Discussion*.

*** DONE Discussion - 377
    CLOSED: [2018-02-20 Tue 18:23]
**** DONE Leaving files open - 377
     CLOSED: [2018-02-20 Tue 17:51]
     You can use ~lsof~ ("list open files") to see the list of open files.
     ~lsof -u <userName> | grep '<filename(s)Pattern>'~

**** DONE Automatically closing the resource - 377
     CLOSED: [2018-02-20 Tue 18:12]
     Use the /load pattern/ - properly close resources once they goes out of
     scope.

     =From Jian= Until Scala 2.12.4, there is no Java /try-with-resources/ syntax

     - The core part of a /load pattern/ implementation:
       #+BEGIN_SRC scala
         def using[A](r: Resource)(f: Resource => A): A =
           try {
             f(r)
           } finally {
             r.dispose()
           }
       #+END_SRC

     - One way to IMPLEMENT the /Loan Pattern/ when working with files is to use
       *Joshua Suereth’s ARM library*.
       =From Jian= Check if this is outdated or NOT.

       #+BEGIN_SRC scala
         // in build.sbt
         libraryDependencies += "com.jsuereth" %% "scala-arm" % "1.3"

         // in TestARM
         import resource._
         import scala.io.Source

         object TestARM extends App {

           for (source <- managed(Source.fromFile("example.txt"))) {
             for (line <- source.getLines) {
               println(line)
             }
           }

         }
       #+END_SRC

     - Another way (from the book Beginning Scala by David Pollak - modified)
       #+BEGIN_SRC scala
         object Control {

           def using[A <: { def close(): Unit }, B](resource: A)(f: A => B): B =
             try {
               f(resource)
             } finally {
               resource.close()
             }
         }
       #+END_SRC

       + Usage:
         #+BEGIN_SRC scala
           import Control._
           import scala.io.Source

           object TestUsing extends App {

             using(Source.fromFile("example.txt")) { source => {
                 for (line <- source.getLines) {
                   println(line)
                 }
               }
             }

           }
         #+END_SRC

     - =From Jian= =TODO= =RE-READ=
       When you use the /Load Pattern/, take care about the /laziness/ --
       make sure you really use the resource before its closing:

       Read the answer of Rex Kerr from
       https://stackoverflow.com/questions/20762240/loaner-pattern-in-scala

**** DONE Handling exceptions - 379
     CLOSED: [2018-02-20 Tue 18:19]
     - Use ~try...catch~

     - Also use ~Option~ type to mark the availability of the result, and ~Try~
       can be better.

**** DONE Multiple fromFile methods - 380
     CLOSED: [2018-02-20 Tue 18:23]
     - *8* ~fromFile~ methods exist that let you specify
       + character encoding
       + buffer size
       + codec
       + URI

     - TIPS:
       You can also use
       + Java's ~FileReader~ and ~BufferedReader~
         =TODO=

       + Apache Commons ~FileUtils~ library.
         =TODO=

*** TODO See Also - 380

** DONE 12.2. Writing Text Files - 381
   CLOSED: [2018-02-21 Wed 14:29]
*** DONE Problem - 381
    CLOSED: [2018-02-21 Wed 14:16]
*** DONE Solution - 381
    CLOSED: [2018-02-21 Wed 14:29]
    Fall back and use Java's ~PrintWriter~ or ~FileWriter~.
    For example,
    #+BEGIN_SRC scala
      // PrintWriter
      import java.io._

      val pw = new PrintWriter(new File("hello.txt"))
      pw.write("Hello, world")
      pw.close()


      // FileWriter
      val file = new File(cannonicalFilename)
      val bw = new BufferedWriter(new FileWriter(file))
      bw.write(text)
      bw.close()
    #+END_SRC

*** DONE Discussion - 381
    CLOSED: [2018-02-21 Wed 14:29]
    From https://coderanch.com/t/418148/certification/Information-PrintWriter-FileWriter

    - ~FileWriter~ is the /character representation of IO/.
      That means it can be used to write characters.

    - *Internally* ~FileWriter~ would use
      1. the _default character set of the underlying OS_
      2. _convert the characters to bytes_
      3. _write it to the disk_.

    - ~PrintWriter~ & ~FileWriter~.
      + SIMILARITIES 
        * Both extend from ~Writer~.

        * Both are /character representation/ classes, that means they work with
          *characters* and _convert them to bytes using default charset_.

      + DIFFERENCES
        * ~FileWriter~ throws ~IOException~ in case of any IO failure, this is a
          /checked exception/.

        * *None* of the ~PrintWriter~ methods throws ~IOException~,
          instead they _set a boolean flag_ which can be obtained using
          ~checkError()~.

        * ~PrintWriter~ invokes /flush/ *after every byte of data is written*,
          automatically.

          In case of ~FileWriter~,
          invoker as to take care of invoking /flush/.

    - Difference between ~PrintStream~ and ~OutputStream~: Similar to above
      explanation, just replace /character/ with /byte/. 

*** TODO See Also - 381

** DONE 12.3. Reading and Writing Binary Files - 382
   CLOSED: [2018-02-21 Wed 14:56]
*** DONE Problem - 382
    CLOSED: [2018-02-21 Wed 14:56]
*** DONE Solution - 382
    CLOSED: [2018-02-21 Wed 14:56]
    - Use the Java ~FileInputStream~ and ~FileOutputStream~ classes.

    - To demonstrate this, the following code is a close Scala *translation* of
      the ~CopyBytes~ class on the _Oracle Byte Streams tutorial_:
      #+BEGIN_SRC scala
        import java.io._

        object CopyBytes extends App {
          var in = None: Option[FileInputStream]
          var out = None: Option[FileOutputStream]
          try {
            in = Some(new FileInputStream("/tmp/Test.class"))
            out = Some(new FileOutputStream("/tmp/Test.class.copy"))
            var c = 0
            while ({c = in.get.read; c != −1}) {
              out.get.write(c)
            }
          } catch {
            case e: IOException => e.printStackTrace
          } finally {
            println("entered finally ...")
            if (in.isDefined) in.get.close
            if (out.isDefined) out.get.close
          }
        }
      #+END_SRC
      + In the original Java version, the condition of ~while~ is like
        ~c = in.read() != -1~, which doesn't work in Scala:
        *assignment in Scala returns an ~Unit~ value, rather then the /assigned
        value/ in Java.*


*** TODO See Also - 383

** DONE 12.4. How to Process Every Character in a Text File - 383
   CLOSED: [2018-02-21 Wed 14:15]
*** DONE Problem - 650
    CLOSED: [2018-02-21 Wed 14:11]
*** DONE Solution - 651
    CLOSED: [2018-02-21 Wed 14:15]
    - *Slow* Method:
      With ~Source~ and do NOT use ~getLines~
      #+BEGIN_SRC scala
        // Process an Apache access logfile that is 10,000,000 lines
        // run time: took 100 secs
        def countLines1(source: io.Source): Long = {
          val NEWLINE = 10
          var newlineCount = 0L
          for {
            char <- source
            if char.toByte == NEWLINE
          } newlineCount += 1
          newlineCount
        }
      #+END_SRC

    - *Faster* Method:
      #+BEGIN_SRC scala
        // Process an Apache access logfile that is 10,000,000 lines
        // run time: 23 seconds
        // use getLines, then count the newline characters
        // (redundant for this purpose, i know)
        def countLines2(source: io.Source): Long = {
          val NEWLINE = 10  // TODO: in library, there should be a constant
          var newlineCount = 0L
          for {
            line <- source.getLines
            c <- line
            if c.toByte == NEWLINE
          } newlineCount += 1
          newlineCount
        }
      #+END_SRC

** TODO 12.5. How to Process a CSV File - 384
*** Problem - x
*** Solution - y
*** Discussion - z
*** See Also - l

** DONE 12.6. Pretending that a String Is a File - 387
   CLOSED: [2018-02-21 Wed 13:48]
*** DONE Problem - 387
    CLOSED: [2018-02-21 Wed 13:45]
    For the purposes of testing, you may want to pretend that a ~String~ is a /file/.

*** DONE Solution - 387
    CLOSED: [2018-02-21 Wed 13:45]
    - Since both ~Source.fromFile~ and ~Source.fromString~ return a ~Source~
      (actually ~BufferedSource~) object, they are easily *interchangeable*.

    - Example:
      #+BEGIN_SRC scala
        import io.Source

        def printLines(source: Source) {
          for (line <- source.getLines) {
            println(line)
          }
        }

        val s = Source.fromString("foo\nbar\n")
        printLines(s)
      #+END_SRC

*** DONE Discussion - 388
    CLOSED: [2018-02-21 Wed 13:48]
*** TODO See Also - 389

** TODO 12.7. Using Serialization - 389
*** Problem - x
*** Solution - y
*** Discussion - z
*** See Also - l

** TODO 12.8. Listing Files in a Directory - 391
*** Problem - x
*** Solution - y
*** Discussion - z
*** See Also - l

** TODO 12.9. Listing Subdirectories Beneath a Directory - 392
*** Problem - x
*** Solution - y
*** Discussion - z

** DONE 12.10. Executing External Commands - 394
   CLOSED: [2018-02-20 Tue 18:58]
*** DONE Problem - 394
    CLOSED: [2018-02-20 Tue 18:39]
    - You want to
      + execute an external (system) command from within a Scala application.

    - You're NOT concerned about the output from the command,
      but you are interested in its /exit code/.

*** DONE Solution - 394
    CLOSED: [2018-02-20 Tue 18:39]
    - There are *3* primary ways to execute external commands:
      + Use the ~!~ method to execute the command and _get its exit status_.
        (This recipie)

      + Use the ~!!~ method to execute the command and _get its output_.
        (NEXT recipie)

      + Use the ~lines~ method to execute the command in the background and get
        its result as a ~Stream~.
        (This recipie Discussion section)

    - Example:
      #+BEGIN_SRC scala
        // scala>
        import sys.process._

        // scala>
        "ls -al".!
        // total 64
        // drwxr-xr-x 10 Al staff 340 May 18 18:00 .
        // drwxr-xr-x 3 Al staff 102 Apr 4 17:58 ..
        // -rw-r--r-- 1 Al staff 118 May 17 08:34 Foo.sh
        // -rw-r--r-- 1 Al staff 2727 May 17 08:34 Foo.sh.jar
        // res0: Int = 0


        // scala>
        val exitcode = "ls -al".!
        // total 64
        // drwxr-xr-x 10 Al staff 340 May 18 18:00 .
        // drwxr-xr-x 3 Al staff 102 Apr 4 17:58 ..
        // -rw-r--r-- 1 Al staff 118 May 17 08:34 Foo.sh
        // -rw-r--r-- 1 Al staff 2727 May 17 08:34 Foo.sh.jar
        // result: Int = 0
      #+END_SRC

      + It is obvious that there must an /implicit conversion/ (from
        ~sys.process._~) to add the ~!~ /method/ to a ~String~.

*** DONE Discussion - 395
    CLOSED: [2018-02-20 Tue 18:58]
    - You can also use ~Seq~, where the first element is considered as a command,
      and the elements after the first one is considered arguments. For example,
      ~val exitCode = Seq("ls", "-al").!~

    - Use ~Process~ directly. For example,
      ~val exitCode = Process("ls").!~

    - =IMPORTANT=
      Remember to delete whitespaces around your command and arguments, or some
      /exceptions/ will be thrown out.
      #+BEGIN_SRC scala
        // beware leading whitespace

        // scala>
        " ls".!
        // java.io.IOException: Cannot run program "": error=2,
        //   No such file or directory
        //   at java.lang.ProcessBuilder.start(ProcessBuilder.java:460)

        // scala>
        val exitCode = Seq(" ls ", "-al").!
        //   java.io.IOException: Cannot run program " ls ": error=2,
        //     No such file or directory


        // beware trailing whitespace

        // scala>
        val exitCode = Seq("ls", " -al ").!
        // ls: -al : No such file or directory
        // exitCode: Int = 1
      #+END_SRC

    - =From Jian=
      Why NOT the library automatically clean the input strings to make them
      runnable commands???????

**** Using the lines method - 396
     - Since ~lines~ return a ~Stream~, you can use it, do something else, and
       read the /stream/ later.

     - The ~lines~ /method/ throws an /exception/ if the exit status of the
       command is nonzero.

     - If you want to retrieve the standard error from the command, use the
       ~lines_!~ /method/ instead.
       =TODO= Read Recipe 12.11 and discussed in Table 12-1 in Recipe 12.19.

**** External commands versus built-in commands - 396
     - This recipe can only help to run /external commands (excutable in the
       ~PATH~)/. You CANNOT use this recipe to run /shell built-in command/.

     - =TODO=
       See Recipe 12.13, “Building a Pipeline of Commands” for an example of how
       to execute a shell built-in command.

** TODO 12.11. Executing External Commands and Using STDOUT - 397
*** Problem - x
*** Solution - y
*** Discussion - z

** TODO 12.12. Handling STDOUT and STDERR for External Commands - 399
*** Problem - x
*** Solution - y
*** See Also - z

** TODO 12.13. Building a Pipeline of Commands - 401
*** Problem - x
*** Solution - y
*** Discussion - z
*** See Also - l

** TODO 12.14. Redirecting the STDOUT and STDIN of External Commands - 402
*** Problem - x
*** Solution - y
*** Discussion - z
*** See Also - l

** TODO 12.15. Using AND (~&&~) and OR (~||~) with Processes - 404
*** Problem - x
*** Solution - y

** TODO 12.16. Handling Wildcard Characters in External Commands - 405
*** Problem - 405
*** Solution - x
*** Discussion - x
*** See Also - x

** TODO 12.17. How to Run a Process in a Different Directory - 406
*** TODO Problem - 406
*** TODO Solution - x

** TODO 12.18. Setting Environment Variables When Running Commands - 407
*** TODO Problem - 407
*** TODO Solution - x
*** TODO See Also - x

** TODO 12.19. An Index of Methods to Execute External Commands - 408
* 13. Actors and Concurrency - 411
** 13.1. Getting Started with a Simple Actor - 414
** 13.2. Creating an Actor Whose Class Constructor Requires Arguments - 418
** 13.3. How to Communicate Between Actors - 419
** 13.4. Understanding the Methods in the Akka Actor Lifecycle - 422
** 13.5. Starting an Actor - 425
** 13.6. Stopping Actors - 427
** 13.7. Shutting Down the Akka Actor System - 432
** 13.8. Monitoring the Death of an Actor with watch - 433
** 13.9. Simple Concurrency with Futures - 436
** 13.10. Sending a Message to an Actor and Waiting for a Reply - 445
** 13.11. Switching Between Different States with become - 446
** 13.12. Using Parallel Collections - 448

* TODO 14. Command-Line Tasks - 453
** TODO 14.0. Introduction - 453
** TODO 14.1. Getting Started with the Scala REPL - 454
*** Problem - 454
*** Solution - 454
*** Discussion - 456
**** REPL command-line options - 457
**** Deprecation and feature warnings - 457
**** The Scala Worksheet - 458

*** See Also - 459

** TODO 14.2. Pasting and Loading Blocks of Code into the REPL - 459

*** Problem - 459
*** Solution - 459
**** The ~:paste~ command - 459
**** The ~:load~ command - 460

*** Discussion - 461
**** Scala's ~-i~ option

*** See Also - 461

** TODO 14.3. Adding JAR Files and Classes to the REPL Classpath - 461
*** Problem - 461
*** Solution - 461

** TODO 14.4. Running a Shell Command from the REPL - 462
*** Problem - 462
*** Solution - 463
**** Scala's ~-i~ option - 463

*** See Also - 464

** TODO 14.5. Compiling with scalac and Running with scala - 465
*** Problem - 465
*** Solution - 465
*** Discussion - 465

** TODO 14.6. Disassembling and Decompiling Scala Code - 466
*** Problem - 466
*** Solution - 466
**** Using ~javap~ - 467
**** Using ~scalac~ print options - 467
**** Use a decompiler - 468

*** Discussion - 469
*** See Also - 471

** TODO 14.7. Finding Scala Libraries - 471
*** Problem - 471
*** Solution - 471

** TODO 14.8. Generating Documentation with scaladoc - 472
*** Problem - 472
*** Solution - 472
*** Discussion - 476
*** See Also - 478

** TODO 14.9. Faster Command-Line Compiling with fsc - 479
*** Problem - 479
*** Solution - 479
*** Discussion - 479
*** See Also - 480

** TODO 14.10. Using Scala as a Scripting Language - 480
*** Problem - 480
*** Solution - 480
*** Discussion - 480
**** Using the App trait or main method - 481
**** Building the classpath - 482

*** See Also - 483

** TODO 14.11. Accessing Command-Line Arguments from a Script - 483
*** Problem - 483
*** Solution - 483
*** Discussion - 484

** TODO 14.12. Prompting for Input from a Scala Shell Script - 485
*** Problem - 485
*** Solution - 485
*** Discussion - 485
**** Reading multiple values from one line - 486
**** Fun with output - 488

*** See Also - 488

** TODO 14.13. Make Your Scala Scripts Run Faster - 489
*** Problem - 489
*** Solution - 489
*** Discussion - 490

* 15. Web Services - 491
** 15.1. Creating a JSON String from a Scala Object - 491
** 15.2. Creating a JSON String from Classes That Have Collections - 495
** 15.3. Creating a Simple Scala Object from a JSON String - 500
** 15.4. Parsing JSON Data into an Array of Objects - 501
** 15.5. Creating Web Services with Scalatra - 503
** 15.6. Replacing XML Servlet Mappings with Scalatra Mounts - 507
** 15.7. Accessing Scalatra Web Service GET Parameters - 509
** 15.8. Accessing POST Request Data with Scalatra - 510
** 15.9. Creating a Simple GET Request Client - 514
** 15.10. Sending JSON Data to a POST URL - 518
** 15.11. Getting URL Headers - 519
** 15.12. Setting URL Headers When Sending a Request - 520
** 15.13. Creating a GET Request Web Service with the Play Framework - 521
** 15.14. POSTing JSON Data to a Play Framework Web Service - 524

* 16. Databases and Persistence 527
** 16.1. Connecting to MySQL with JDBC - 528
** 16.2. Connecting to a Database with the Spring Framework - 530
** 16.3. Connecting to MongoDB and Inserting Data - 533
** 16.4. Inserting Documents into MongoDB with insert, save, or += - 537
** 16.5. Searching a MongoDB Collection - 539
** 16.6. Updating Documents in a MongoDB Collection - 542
** 16.7. Accessing the MongoDB Document ID Field - 544
** 16.8. Deleting Documents in a MongoDB Collection - 545
** 16.9. A Quick Look at Slick - 547

* TODO 17. Interacting with Java - 549
** TODO Introduction - 549
** TODO 17.1. Going to and from Java Collections - 549
*** Problem - 549
*** Solution - 550
*** Discussion - 550
**** Conversion tables - 552
**** Going from Scala collections to Java collections - 553
**** The JavaConverters object - 554

*** See Also - 554

** DONE 17.2. Add Exception Annotations to Scala Methods to Work with Java - 554
   CLOSED: [2018-02-28 Wed 14:24]
*** DONE Problem - 554
    CLOSED: [2018-02-28 Wed 14:14]
    You want to let Java users know that a method can throw one or more
    /exceptions/ so they can handle those exceptions with ~try/catch~ blocks.

*** DONE Solution - 554
    CLOSED: [2018-02-28 Wed 14:21]
    - Use the ~@throws~ annotation - see Section 5.8 for details.

    - From the point of view of a Java caller, the Scala code with ~@throws~ is
      just like some Java code with ~throws~, and the Java caller must use
      ~try/catch~ block to deal with it.

*** DONE Discussion - 555
    CLOSED: [2018-02-28 Wed 14:24]
    If your Scala code does throw some exception (/checked exception/ in Java),
    and you don't use ~@throws~ to let Java callers know, then Java callers will
    have no chance to know this until their applications crash -- this is BAD!!!

** TODO 17.3. Using ~@SerialVersionUID~ and Other Annotations - 556
*** Problem - 556
*** Solution - 556
*** Discussion - 556
*** See Also - 557

** TODO 17.4. Using the Spring Framework - 557
*** Problem - 557
*** Solution - 557
*** Discussion - 560
*** See Also - 560

** TODO 17.5. Annotating varargs Methods - 560
*** Problem - 560
*** Solution - 560
*** Discussion - 561

** TODO 17.6. When Java Code Requires JavaBeans - 562
*** Problem - 562
*** Solution - 562
*** Discussion - 563
*** See Also - 565

** TODO 17.7. Wrapping Traits with Implementations - 565
*** Problem - 565
*** Solution - 565
*** Discussion - 566
**** Other attempts - 566

* 18. The Simple Build Tool (SBT) - 569
** 18.1. Creating a Project Directory Structure for SBT - 570
** 18.2. Compiling, Running, and Packaging a Scala Project with SBT - 574
** 18.3. Running Tests with SBT and ScalaTest - 579
** 18.4. Managing Dependencies with SBT - 581
** 18.5. Controlling Which Version of a Managed Dependency Is Used - 584
** 18.6. Creating a Project with Subprojects - 586
** 18.7. Using SBT with Eclipse - 588
** 18.8. Generating Project API Documentation - 590
** 18.9. Specifying a Main Class to Run - 591
** 18.10. Using GitHub Projects as Project Dependencies - 593
** 18.11. Telling SBT How to Find a Repository (Working with Resolvers) - 595
** 18.12. Resolving Problems by Getting an SBT Stack Trace - 596
** 18.13. Setting the SBT Log Level - 597
** 18.14. Deploying a Single, Executable JAR File - 597
** 18.15. Publishing Your Library - 601
** 18.16. Using Build.scala Instead of build.sbt - 602
** 18.17. Using a Maven Repository Library with SBT - 604
** 18.18. Building a Scala Project with Ant - 606

* TODO 19. Types - 611
** TODO Introduction - 611
*** Variance - 611
*** Bounds - 612
*** Type Constraints - 613
*** Type Examples in Other Chapters - 613

** TODO 19.1. Creating Classes That Use Generic Types - 614
*** Problem - 614
*** Solution - 614
*** Discussion - 615
**** Type parameter symbols - 616
*** See Also - 617

** 19.2. Creating a Method That Takes a Simple Generic Type - 617
*** Problem - 
*** Solution - 
*** Discussion -

** 19.3. Using Duck Typing (Structural Types) - 618
*** Problem - 
*** Solution - 
*** Discussion -

** 19.4. Make Mutable Collections Invariant - 620
*** Problem - 
*** Solution - 
*** Discussion -
*** See Also -

** 19.5. Make Immutable Collections Covariant - 622
*** Problem - 
*** Solution - 
*** Discussion -

** 19.6. Create a Collection Whose Elements Are All of Some Base Type - 624
*** Problem - 
*** Solution - 
*** Discussion -
*** See Also -

** 19.7. Selectively Adding New Behavior to a Closed Model - 627
*** Problem - 
*** Solution - 
*** Discussion -
*** See Also -

** TODO 19.8. Building Functionality with Types - 630
*** Example 1: Creating a Timer - 630
*** Example 2: Writing Your Own "Try" Classes - 631
**** The Scala 2.10 Try classes - 633

* TODO 20. Idioms - 635
** DONE Introduction - 635
   CLOSED: [2018-02-18 Sun 00:21]
   - This chapter talks about writing Scala in the Scala way.
     #+BEGIN_QUOTE
     I wanted to write code that “makes it look like the language was made for
     the problem.
                                               -- Ward Cunningham (Clean Code) 
     #+END_QUOTE

   - Scala's best practices:
     + At the _application level_:
       * The 80/20 rule - try to write 80% of your appplication as pure
         functions, with a thin layer of other code on top of those functions for
         things like I/O.

       * Learn "Expression-Oriented Programming" (=TODO= Recipe 20.3).

       * Use the ~Actor~ classes to implement *concurrency* (=TODO= Chapter 13).

       * Move behavior from classes into more granular traits.
         This is best described in _the Scala Stackable Trait pattern_. =TODO=

     + At the _coding level_:
       * Learn how to write pure functions.

       * Learn how to pass functions around as variables (Recipes 9.2 to 9.4).

       * Learn how to use the _Scala collections API_. Know the most common classes
         and methods (10 and 11). =TODO=

       * Prefer immutable code.
         Use ~val~'s and /immutable collections/ first (Recipe 20.2).

       * Drop the ~null~ keyword from your vocabulary.
         Use the ~Option~ type (~Some~ and ~None~) and ~Try~ type (~Success~ and
         ~Failure~) classes instead (Recipe 20.6). =TODO= =TODO=

       * Use TDD and/or BDD testing tools like ScalaTest and specs2

     + Outside the code:
       * Learn how to use *SBT*.
         It’s the _de-facto_ /Scala build tool/ (Chapter 18).

       * Keep a /REPL/ session open while you’re coding (or use the /Scala
         Worksheet/), and constantly try small experiments (Recipes 14.1 to 14.4,
         and many examples throughout the book). =TODO= =TODO=

*** Other Resources
    - Highly recommended:
      Twitter's *Effective Scala document* (free online).

    - Recommended:
      *Scala Style Guide*

** TODO 20.1. Create Methods with No Side Effects (Pure Functions) - 636
*** Problem - 636
*** Solution - 636
**** Referential transparency - 637
**** Pure functions - 637
**** The Java approach - 639
**** Fixing the problems - 640

*** Discussion - 642
**** StockUtils or Stock object?

*** See Also

** TODO 20.2. Prefer Immutable Objects - 644
** TODO 20.3. Think “Expression-Oriented Programming” - 647
** DONE 20.4. Use Match Expressions and Pattern Matching - 650
   CLOSED: [2018-02-21 Wed 14:00]
*** DONE Problem - 650
    CLOSED: [2018-02-21 Wed 13:49]
*** TODO Solution - 651
**** DONE Replacement for the Java switch statement and unwieldy if/then statements - 651
     CLOSED: [2018-02-21 Wed 13:52]
**** DONE In ~try/catch~ expressions - 651
     CLOSED: [2018-02-21 Wed 13:53]
**** DONE As the body of a function or method - 652
     CLOSED: [2018-02-21 Wed 13:53]
     - In the case that the whole function body is a ~match~ expression.

     - In the case of the function is a /partial function/.
       #+BEGIN_SRC scala
         val divide: PartialFunction[Int, Int] = {
           case d: Int if d != 0 => 42 / d
         }
       #+END_SRC

**** DONE Use with ~Option/Some/None~ - 653
**** TODO In actors - 653
     =From Jian= I think this an outdated example. Now people use Akka rather than Actor.
                 However, I'm not sure.
     
     #+BEGIN_SRC scala
       class SarahsBrain extends Actor {
         def receive = {
           case StartMessage => handleStartMessage
           case StopMessage => handleStopMessage
           case SetMaxWaitTime(time) => helper ! SetMaxWaitTime(time)
           case SetPhrasesToSpeak(phrases) => helper ! SetPhrasesToSpeak(phrases)
           case _ => log.info("Got something unexpected.")
         }

         // other code here ...
       }
     #+END_SRC
**** DONE Summary - 654
     CLOSED: [2018-02-21 Wed 13:57]

*** TODO See Also - 653

** DONE 20.5. Eliminate ~null~ Values from Your Code - 654
   CLOSED: [2018-02-18 Sun 22:02]
*** DONE Problem - 654
    CLOSED: [2018-02-18 Sun 22:02]
    - Tony Hoare invents the ~null~ reference way back in 1965.

    - Tony Hoare refers the creation of the ~null~ value as his "billion dollar
      mistake."

    - In the modern best practice of programming,
      you should eliminate ~null~.

*** DONE Solution - 654
    CLOSED: [2018-02-18 Sun 22:02]
    - Guide line:
      + When a ~var~ field in a /class/ or /method/ does _not have an initial
        default value_,
        initialize it with ~Option~ instead of ~null~.

      + When a /method/ does _not produce the intended result_, you may be
        tempted to return ~null~.
        Use an ~Option~ or ~Try~ instead.

      + If you're _working with a Java library that returns ~null~,_
        *convert* it to an ~Option~, or *something else* =TODO=.

**** DONE Initialize ~var~ fields with ~Option~, not ~null~ - 655
     CLOSED: [2018-02-18 Sun 21:54]
     Use an example to illustrate:
     #+BEGIN_SRC scala
       case class Address(city: String, state: String, zip: String)
     #+END_SRC

     - Bad:
       #+BEGIN_SRC scala
         case class Address (city: String, state: String, zip: String)
         class User(email: String, password: String) {
           var firstName: String = _
           var lastName: String = _
           var address: Address = _
         }
       #+END_SRC

     - Good:
       #+BEGIN_SRC scala
         class User(email: String, password: String) {
           var firstName = Option.empty[String]
           var lastName = Option.empty[String]
           var address = Option.empty[Address]
         }
       #+END_SRC
       + The author use ~None: Option[TypeName]~ rather than the
         ~Option.empty[TypeName]~ value.
         =TODO: read the source code of the ~empty~ method=

       + =From Jian=
         I'm not sure the reason of the author not do this.
         The reason might be
         * the author didn't know this at that time.
           OR
         * there was NO ~empty~ method in the old librar???
           =TODO: do some research about his!=

     - How to exploit the ~Option~ type representation:
       #+BEGIN_SRC scala
         val u = new User("al@example.com", "secret")

         u.firstName = Some("Al")
         u.lastName = Some("Alexander")
         u.address = Some(Address("Talkeetna", "AK", "99676"))

         println(firstName.getOrElse("<not assigned>"))

         u.address.foreach { a =>
           println(a.city)
           println(a.state)
           println(a.zip)
         }
       #+END_SRC

     - Use ~Option~ type parameters in constructors:
       #+BEGIN_SRC scala
         case class Stock(id: Long,
                          var symbol: String,
                          var company: Option[String])
       #+END_SRC

**** DONE Don't return ~null~ from methods - 656
     CLOSED: [2018-02-18 Sun 04:10]
     - Q: How to avoid returning ~null~?

       A: Return an ~Option~.
          Or, if you need to know about an error that may have occurred in the
          method, use ~Try~ instead of ~Option~.

     - Use ~Option~:
       #+BEGIN_SRC scala
         def readTextFile(filename: String): Option[List[String]] = {
           try {
             Some(io.Source.fromFile(filename).getLines.toList)
           } catch {
             case e: Exception => None
           }
         }
       #+END_SRC

     - With error info -- use ~Try~: =IMPORTANT=
       #+BEGIN_SRC scala
         import scala.util.{Try, Success, Failure}

         object Test extends App {

           def readTextFile(filename: String): Try[List[String]] = {
             Try(io.Source.fromFile(filename).getLines.toList)
           }

           val filename = "/etc/passwd"
           readTextFile(filename) match {
             case Success(lines) => lines.foreach(println)
             case Failure(f)     => println(f)
           }
       #+END_SRC

     - The Twitter /Effective Scala/ page recommends *not overusing* ~Option~,
       and using the /Null Object Pattern/ where it makes sense.
       =IMPORTANT=

       + Null Object Patter :: =IMPORTANT=
            #+BEGIN_SRC scala
              trait Animal {
                def makeSound()
              }

              class Dog extends Animal {
                def makeSound() { println("woof") }
              }

              class NullAnimal extends Animal {
                def makeSound() {}
              }
            #+END_SRC

**** DONE Converting a ~null~ into an ~Option~, or something else - 657
     CLOSED: [2018-02-18 Sun 21:53]
     - ~null~ from Java legacy code:
       #+BEGIN_SRC scala
         def getName: Option[String] =
           Option(javaPerson.getName)
       #+END_SRC

**** DONE Benefits - 658
     CLOSED: [2018-02-18 Sun 22:00]
     Following these guidelines leads to these benefits:
     - NO ~NullPointerExceptions~.

     - Your code will be safer.

     - You won't have to write if statements to check for ~null~ values.

       =From Jian=
       MOSTLY, /pattern matching/ is NOT the best way to use types like ~Option~
       and ~Try~. Consider them as collections, and use ~flatMap~ and ~foreach~.

     - Adding an ~Option[T]~ return type declaration to a method is a terrific
       way to indicate that something is happening in the method such that the
       caller may receive a ~None~ instead of a ~Some[T]~.
         This is a much BETTER approach than returning ~null~ from a method that
       is expected to return an object.

     - You'll become more comfortable using ~Option~, and as a result, you'll be
       able to take advantage of how it's used in the collection libraries and
       other frameworks.

*** TODO See Also - 658

** DONE 20.6. Using the ~Option~, ~Some~, ~None~ Pattern - 658
   CLOSED: [2018-02-19 Mon 05:15]
*** DONE Problem - 658
    CLOSED: [2018-02-18 Sun 22:37]
*** DONE Solution - 658
    CLOSED: [2018-02-19 Mon 05:15]
    - There is some overlap between this recipe and the previous recipe.
      The previous recipe gives the solutions to
      + Using ~Option~ in /method and constructor parameters/

      + Using ~Option~ to /initialize/ class ~var~ fields (instead of using
        ~null~)

      + Converting ~null~ results from other code (such as Java code) into an
        ~Option~

    - This recipe adds these additional solutions:
      + *Returning* an ~Option~ from a /method/

      + *Getting* the value from an ~Option~

      + Using ~Option~ with /collections/

      + Using ~Option~ with _frameworks_

      + Using ~Try/Success/Failure~ when you need the error message (Scala 2.10
        and newer)

      + Using ~Either/Left/Right~ when you need the error message (*pre-Scala
        2.10*)

**** DONE Returning an ~Option~ from a method - 659
     CLOSED: [2018-02-18 Sun 22:50]
     Common pattern:
     #+BEGIN_SRC scala
       def toInt(s: String): Option[Int] = {
         try {
           Some(Integer.parseInt(s.trim))
         } catch {
           case e: Exception => None
         }
       }
     #+END_SRC
     
**** DONE Getting the value from an ~Option~ - 659
     CLOSED: [2018-02-18 Sun 22:50]
     Many ways:
     - Use ~getOrElse~
       get the _value_ if it is ~Some(v)~
       get the _default value_ if it is ~None~

     - Use ~foreach~
       Consume with side effect and no return value

     - Use a ~match~ expression
       pattern matching
     
**** DONE Using ~Option~ with Scala collections - 660
     CLOSED: [2018-02-18 Sun 23:09]
     Two ways:
     For example, get all the integers for a list below which includes (NOT only)
     number strings ~val bag = List("1", "2", "foo", "3", "bar")~. The result
     should be ~List(1, 2, 3)~

     - ~bag.flatMap(toInt)~

       + Redundant way:
         ~bag.map(toInt).flatten~

     - ~bag.map(toInt).collect { case Some(i) => i }~
       =From Jian=
       I don't think the ~collect~ /method/ is good for this use, if consider the
       solution with ~flatMap~. It can be a best practice to more complicated
       cases.

**** DONE Using ~Option~ with other frameworks - 661
     CLOSED: [2018-02-19 Mon 05:03]
     - Examples from the Play framework.
       =TODO=

       =From Jian= I don't understand Play, and I only understand the ~Option~
       inside the example. Explain the example in the paragraph above when I
       understand it.

     - *TIPS*
       The ~scala.util.control.Exception~ object gives you another way to use an
       ~Option~ -- which can replace the ~try ... catch~ block if you want.
       #+BEGIN_SRC scala
         import scala.util.control.Exception._

         def readTextFile(f: String): Option[List[String]] =
           allCatch.opt(Source.fromFile(f).getLines.toList)
       #+END_SRC
       + ~allCatch~ is described as a ~Catch~ object “that catches everything.”
         The ~opt~ /method/ returns
         * ~None~ if an exception is caught (such as a ~FileNotFoundException~)
           AND
         * ~Some(value)~ if the block of code succeeds.

       + ~allCatch~ methods support the ~Try~ and ~Either~ approaches.
         =TODO=

**** TODO Using ~Try~ (~Success~ and ~Failure~) - 662
     - ~scala.util.Try~ is introduced in Scala 2.10

     - Example:
       #+BEGIN_SRC scala
         import scala.util.{Try, Success, Failure}

         def divideXByY(x: Int, y: Int): Try[Int] =
           Try(x / y)

         divideXByY(1, 1)
         // res0: scala.util.Try[Int] = Success(1)

         divideXByY(1, 0)
         // res0: scala.util.Try[Int] = Failure(java.lang.ArithmeticException: / by zero)
       #+END_SRC

     - As with ~Option~, you can access the result using ~getOrElse~, use
       ~foreach~, or pattern matching.
       + If you don't care the error message, you can use ~getOrElse~ or
         ~foreach~
         #+BEGIN_SRC scala
           // -- getOrElse --
           // Success
           // scala>
           val x = divideXByY(1, 1).getOrElse(0)
           // x: Int = 1

           // Failure
           // scala>
           val y = divideXByY(1, 0).getOrElse(0)
           // y: Int = 0

           // -- foreach --
           // scala>
           divideXByY(1, 1).foreach(println)
           // 1

           // scala>
           divideXByY(1, 0).foreach(println)
           // (no output printed)
         #+END_SRC

       + Use pattern matching if you're interested in the ~Failure~ message.
         #+BEGIN_SRC scala
           divideXByY(1, 1) match {
             case Success(i) => println(s"Success, value is: $i")
             case Failure(s) => println(s"Failed, message is: $s")
           }
         #+END_SRC

     - As use ~Option~, you can use ~Try~ and chain your operation, catching
       /exceptions/ as you go. =TODO=
       #+BEGIN_SRC scala
         val z = for {
           a <- Try(x.toInt)
           b <- Try(y.toInt)
         } yield a * b

         val answer = z.getOrElse(0) * 2
       #+END_SRC

     - The ~readTextFile~ /method/ in *Recipe 20.5* shows another ~Try~ example.
       The /method/ from that example is REPEATED here:
       #+BEGIN_SRC scala
         def readTextFile(filename: String): Try[List[String]] = {
           Try(Source.fromFile(filename).getLines.toList)
         }
       #+END_SRC

     - =TODO= =TODO= =TODO= 
       The Try class includes a nice collection of methods that let you handle
       situations in many ways, including:
       + Collection-like implementations of ~filter~, ~flatMap~, ~flatten~,
         ~foreach~, and ~map~

       + ~get~, ~getOrElse~, and ~orElse~

       + ~toOption~, which lets you treat the result as an ~Option~

       + ~recover~, ~recoverWith~, and ~transform~, which let you gracefully
         handle ~Success~ and ~Failure~ results

**** DONE Using ~Either~ (~Left~ and ~Right~) - 664
     CLOSED: [2018-02-19 Mon 05:10]
     - Before Scala 2.10, there is NO ~Try~.
       ~Either~ is used:
       + ~Right~ is like ~Success~
         AND
       + ~Left~ is like ~Failure~

     - Usage (re-write the ~divideXByY~ example):
       #+BEGIN_SRC scala
         def divideXByY(x: Int, y: Int): Either[String, Int] = {
           if (y == 0) Left("Dude, can't divide by 0")
           else        Right(x / y)
         }

         val x = divideXByY(1, 1).right.getOrElse(0)  // returns 1
         val x = divideXByY(1, 0).right.getOrElse(0)  // returns 0

         // prints "Answer: Dude, can't divide by 0"
         divideXByY(1, 0) match {
           case Left(s)  => println("Answer: " + s)
           case Right(i) => println("Answer: " + i)
         }

         // scala>
         val x = divideXByY(1, 0)
         // x: Either[String,Int] = Left(Dude, can't divide by 0)

         // scala>
         x.isLeft
         // res0: Boolean = true

         // scala>
         x.left
         // res1: scala.util.Either.LeftProjection[String,Int] =
         //       LeftProjection(Left(Dude, can't divide by 0))
       #+END_SRC

     - =TODO= =From Jian=
       ~Try~ is much concise in dealing with success and failure.

       Then, does ~Either~ has any shining points???

*** DONE Discussion - 665
    CLOSED: [2018-02-19 Mon 05:15]
**** DONE Don't use the ~get~ method with ~Option~ - 665
     CLOSED: [2018-02-19 Mon 05:15]
     - Only ~Some~ class has ~get~ /method/.
       Use ~get~ when you have ~None~, the result is NOT any better than a
       ~NullPointerException~.

       If you test and then use ~get~ when you are sure about the value is
       ~Some~ type, then you can successfully get the result. However, the
       redundant code is then looks like what you did when you have ~null~.

     - Conclusion:
       As with ~null~ values, when you work with ~Option~ values, PLEASE just
       imagine the ~get~ does NOT exist.


*** TODO See Also - 666

* Index - 667
* TODO TodoList
  How to create a function to accept ANY (from ~Tuple1~ to ~Tuple22~) /tuple/
  argument.
