#+TITLE: Programming in Scala (2.12)
#+SUBTITLE: A comprehensive step-by-step guide
#+VERSION: 3rd
#+AUTHOR: Martin Odersky, Lex Spoon, Bill Venners
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Contents][Contents]]
- [[List of Figures][List of Figures]]
- [[List of Tables][List of Tables]]
- [[List of Listings][List of Listings]]
- [[Foreword][Foreword]]
- [[Acknowledgments][Acknowledgments]]
- [[Introduction][Introduction]]
- [[1 A Scalable Language][1 A Scalable Language]]
  - [[1.1 A language that grows on you][1.1 A language that grows on you]]
    - [[Growing new types][Growing new types]]
    - [[Growing new control constructs][Growing new control constructs]]
  - [[1.2 What makes Scala scalable?][1.2 What makes Scala scalable?]]
    - [[Scala is object-oriented][Scala is object-oriented]]
    - [[Scala is functional][Scala is functional]]
  - [[1.3 Why Scala?][1.3 Why Scala?]]
    - [[Scala is compatible][Scala is compatible]]
    - [[Scala is concise][Scala is concise]]
    - [[Scala is high-level][Scala is high-level]]
    - [[Scala is statically typed][Scala is statically typed]]
  - [[1.4 Scala's roots][1.4 Scala's roots]]
  - [[1.5 Conclusion][1.5 Conclusion]]
- [[2 First Steps in Scala - 64][2 First Steps in Scala - 64]]
  - [[Step 1. Learn to use the Scala interpreter - 64][Step 1. Learn to use the Scala interpreter - 64]]
  - [[Step 2. Define some variables - 66][Step 2. Define some variables - 66]]
  - [[Step 3. Define some functions - 68][Step 3. Define some functions - 68]]
  - [[Step 4. Write some Scala scripts - 70][Step 4. Write some Scala scripts - 70]]
  - [[Step 5. Loop with ~while~; decide with ~if~ - 71][Step 5. Loop with ~while~; decide with ~if~ - 71]]
  - [[Step 6. Iterate with ~foreach~ and ~for~ - 73][Step 6. Iterate with ~foreach~ and ~for~ - 73]]
  - [[Conclusion - 76][Conclusion - 76]]
- [[3 Next Steps in Scala - 77][3 Next Steps in Scala - 77]]
  - [[Step 7. Parameterize arrays with types - 77][Step 7. Parameterize arrays with types - 77]]
  - [[Step 8. Use lists - 81][Step 8. Use lists - 81]]
  - [[Step 9. Use tuples - 86][Step 9. Use tuples - 86]]
  - [[Step 10. Use sets and maps - 87][Step 10. Use sets and maps - 87]]
  - [[Step 11. Learn to recognize the functional style - 92][Step 11. Learn to recognize the functional style - 92]]
  - [[Step 12. Read lines from a file - 95][Step 12. Read lines from a file - 95]]
  - [[Conclusion - 98][Conclusion - 98]]
- [[4 Classes and Objects - 99][4 Classes and Objects - 99]]
  - [[4.1 Classes, fields, and methods - 99][4.1 Classes, fields, and methods - 99]]
  - [[4.2 Semicolon inference - 104][4.2 Semicolon inference - 104]]
  - [[4.3 Singleton objects - 105][4.3 Singleton objects - 105]]
  - [[4.4 A Scala application - 108][4.4 A Scala application - 108]]
  - [[4.5 The ~App~ trait - 110][4.5 The ~App~ trait - 110]]
  - [[4.6 Conclusion - 111][4.6 Conclusion - 111]]
- [[5 Basic Types and Operations - 112][5 Basic Types and Operations - 112]]
  - [[5.1 Some basic types - 112][5.1 Some basic types - 112]]
  - [[5.2 Literals - 113][5.2 Literals - 113]]
    - [[Integer literals][Integer literals]]
    - [[Floating point literals][Floating point literals]]
    - [[Character literals][Character literals]]
    - [[String literals][String literals]]
    - [[Symbol literals][Symbol literals]]
    - [[Boolean literals][Boolean literals]]
  - [[5.3 String interpolation - 119][5.3 String interpolation - 119]]
  - [[5.4 Operators are methods - 121][5.4 Operators are methods - 121]]
  - [[5.5 Arithmetic operations - 124][5.5 Arithmetic operations - 124]]
  - [[5.6 Relational and logical operations - 125][5.6 Relational and logical operations - 125]]
  - [[5.7 Bitwise operations - 127][5.7 Bitwise operations - 127]]
  - [[5.8 Object equality - 128][5.8 Object equality - 128]]
  - [[5.9 Operator precedence and associativity - 130][5.9 Operator precedence and associativity - 130]]
  - [[5.10 Rich wrappers - 133][5.10 Rich wrappers - 133]]
  - [[5.11 Conclusion - 133][5.11 Conclusion - 133]]
- [[6 Functional Objects - 135][6 Functional Objects - 135]]
  - [[6.1 A specification for class ~Rational~ - 135][6.1 A specification for class ~Rational~ - 135]]
  - [[6.2 Constructing a ~Rational~ - 136][6.2 Constructing a ~Rational~ - 136]]
  - [[6.3 Reimplementing the ~toString~ method - 138][6.3 Reimplementing the ~toString~ method - 138]]
  - [[6.4 Checking preconditions - 139][6.4 Checking preconditions - 139]]
  - [[6.5 Adding fields - 139][6.5 Adding fields - 139]]
  - [[6.6 Self references - 141][6.6 Self references - 141]]
  - [[6.7 Auxiliary constructors - 142][6.7 Auxiliary constructors - 142]]
  - [[6.8 Private fields and methods - 144][6.8 Private fields and methods - 144]]
  - [[6.9 Defining operators - 145][6.9 Defining operators - 145]]
  - [[6.10 Identifiers in Scala - 147][6.10 Identifiers in Scala - 147]]
  - [[6.11 Method overloading - 150][6.11 Method overloading - 150]]
  - [[6.12 Implicit conversions - 152][6.12 Implicit conversions - 152]]
  - [[6.13 A word of caution - 153][6.13 A word of caution - 153]]
  - [[6.14 Conclusion - 153][6.14 Conclusion - 153]]
- [[7 Built-in Control Structures - 155][7 Built-in Control Structures - 155]]
  - [[7.1 If expressions - 156][7.1 If expressions - 156]]
  - [[7.2 While loops - 157][7.2 While loops - 157]]
  - [[7.3 For expressions - 160][7.3 For expressions - 160]]
    - [[Iteration through collections][Iteration through collections]]
    - [[Filtering][Filtering]]
    - [[Nested iteration][Nested iteration]]
    - [[Mid-stream variable bindings][Mid-stream variable bindings]]
    - [[Producing a new collection][Producing a new collection]]
  - [[7.4 Exception handling with ~try~ expressions - 165][7.4 Exception handling with ~try~ expressions - 165]]
    - [[Throwing exceptions][Throwing exceptions]]
    - [[Catching exceptions][Catching exceptions]]
    - [[The ~finally~ clause][The ~finally~ clause]]
    - [[Yielding a value][Yielding a value]]
  - [[7.5 Match expressions - 169][7.5 Match expressions - 169]]
  - [[7.6 Living without ~break~ and ~continue~ - 171][7.6 Living without ~break~ and ~continue~ - 171]]
  - [[7.7 Variable scope - 173][7.7 Variable scope - 173]]
  - [[7.8 Refactoring imperative-style code - 177][7.8 Refactoring imperative-style code - 177]]
  - [[7.9 Conclusion - 179][7.9 Conclusion - 179]]
- [[8 Functions and Closures - 180][8 Functions and Closures - 180]]
  - [[8.1 Methods - 180][8.1 Methods - 180]]
  - [[8.2 Local functions - 182][8.2 Local functions - 182]]
  - [[8.3 First-class functions - 184][8.3 First-class functions - 184]]
  - [[8.4 Short forms of function literals - 186][8.4 Short forms of function literals - 186]]
  - [[8.5 Placeholder syntax - 187][8.5 Placeholder syntax - 187]]
  - [[8.6 Partially applied functions - 188][8.6 Partially applied functions - 188]]
  - [[8.7 Closures - 191][8.7 Closures - 191]]
  - [[8.8 Special function call forms - 195][8.8 Special function call forms - 195]]
    - [[Repeated parameters][Repeated parameters]]
    - [[Named arguments][Named arguments]]
    - [[Default parameter values][Default parameter values]]
  - [[8.9 Tail recursion - 198][8.9 Tail recursion - 198]]
    - [[Tracing tail-recursive functions][Tracing tail-recursive functions]]
    - [[Limits of tail recursion][Limits of tail recursion]]
  - [[8.10 Conclusion - 202][8.10 Conclusion - 202]]
- [[9 Control Abstraction - 203][9 Control Abstraction - 203]]
  - [[9.1 Reducing code duplication - 203][9.1 Reducing code duplication - 203]]
  - [[9.2 Simplifying client code - 207][9.2 Simplifying client code - 207]]
  - [[9.3 Currying - 209][9.3 Currying - 209]]
  - [[9.4 Writing new control structures - 211][9.4 Writing new control structures - 211]]
  - [[9.5 By-name parameters - 214][9.5 By-name parameters - 214]]
  - [[9.6 Conclusion - 217][9.6 Conclusion - 217]]
- [[10 Composition and Inheritance - 218 _ALMOST DONE_][10 Composition and Inheritance - 218 _ALMOST DONE_]]
  - [[10.1 A two-dimensional layout library - 218 =RE-READ=][10.1 A two-dimensional layout library - 218 =RE-READ=]]
  - [[10.2 Abstract classes - 219][10.2 Abstract classes - 219]]
  - [[10.3 Defining parameterless methods - 220][10.3 Defining parameterless methods - 220]]
  - [[10.4 Extending classes - 223][10.4 Extending classes - 223]]
  - [[10.5 Overriding methods and fields - 225][10.5 Overriding methods and fields - 225]]
  - [[10.6 Defining parametric fields - 226][10.6 Defining parametric fields - 226]]
  - [[10.7 Invoking superclass constructors - 228][10.7 Invoking superclass constructors - 228]]
  - [[10.8 Using ~override~ modifiers - 229][10.8 Using ~override~ modifiers - 229]]
  - [[10.9 Polymorphism and dynamic binding - 231][10.9 Polymorphism and dynamic binding - 231]]
  - [[10.10 Declaring ~final~ members - 233][10.10 Declaring ~final~ members - 233]]
  - [[10.11 Using composition and inheritance - 235][10.11 Using composition and inheritance - 235]]
  - [[10.12 Implementing ~above~, ~beside~, and ~toString~ - 236][10.12 Implementing ~above~, ~beside~, and ~toString~ - 236]]
  - [[10.13 Defining a factory object - 238][10.13 Defining a factory object - 238]]
  - [[10.14 Heighten and widen - 240][10.14 Heighten and widen - 240]]
  - [[10.15 Putting it all together - 244][10.15 Putting it all together - 244]]
  - [[10.16 Conclusion - 245][10.16 Conclusion - 245]]
- [[11 Scala's Hierarchy - 246][11 Scala's Hierarchy - 246]]
  - [[11.1 Scala's class hierarchy - 246][11.1 Scala's class hierarchy - 246]]
  - [[11.2 How primitives are implemented - 250][11.2 How primitives are implemented - 250]]
  - [[11.3 Bottom types - 252][11.3 Bottom types - 252]]
  - [[11.4 Defining your own value classes - 253][11.4 Defining your own value classes - 253]]
    - [[Avoiding a types monoculture][Avoiding a types monoculture]]
  - [[11.5 Conclusion - 256][11.5 Conclusion - 256]]
- [[12 Traits - 257 _ALMOST DONE_][12 Traits - 257 _ALMOST DONE_]]
  - [[12.1 How traits work - 257][12.1 How traits work - 257]]
  - [[12.2 Thin versus rich interfaces - 260 =RE-READ=][12.2 Thin versus rich interfaces - 260 =RE-READ=]]
  - [[12.3 Example: Rectangular objects - 261][12.3 Example: Rectangular objects - 261]]
  - [[12.4 The ~Ordered~ trait - 264][12.4 The ~Ordered~ trait - 264]]
  - [[12.5 Traits as stackable modifications - 266 =RE-READ=][12.5 Traits as stackable modifications - 266 =RE-READ=]]
  - [[12.6 Why not multiple inheritance? - 270][12.6 Why not multiple inheritance? - 270]]
  - [[12.7 To trait or not to trait? - 274 =RE-READ=][12.7 To trait or not to trait? - 274 =RE-READ=]]
  - [[12.8 Conclusion - 275][12.8 Conclusion - 275]]
- [[13 Packages and Imports - 276 _Re-READ_][13 Packages and Imports - 276 _Re-READ_]]
  - [[13.1 Putting code in packages - 277][13.1 Putting code in packages - 277]]
  - [[13.2 Concise access to related code - 281 =RE-READ=][13.2 Concise access to related code - 281 =RE-READ=]]
  - [[13.3 Imports - 285][13.3 Imports - 285]]
  - [[13.4 Implicit imports - 285][13.4 Implicit imports - 285]]
  - [[13.5 Access modifiers - 286][13.5 Access modifiers - 286]]
    - [[Private members][Private members]]
    - [[Protected members][Protected members]]
    - [[Public members][Public members]]
    - [[Scope of protection][Scope of protection]]
    - [[Visibility and companion objects][Visibility and companion objects]]
  - [[13.6 Package objects - 291][13.6 Package objects - 291]]
  - [[13.7 Conclusion - 293][13.7 Conclusion - 293]]
- [[14 Assertions and Tests - 294][14 Assertions and Tests - 294]]
  - [[14.1 Assertions - 294][14.1 Assertions - 294]]
  - [[14.2 Testing in Scala - 296][14.2 Testing in Scala - 296]]
  - [[14.3 Informative failure reports - 297][14.3 Informative failure reports - 297]]
  - [[14.4 Tests as specifications - 299][14.4 Tests as specifications - 299]]
  - [[14.5 Property-based testing - 302][14.5 Property-based testing - 302]]
  - [[14.6 Organizing and running tests - 304][14.6 Organizing and running tests - 304]]
  - [[14.7 Conclusion - 305][14.7 Conclusion - 305]]
- [[15 Case Classes and Pattern Matching - 306][15 Case Classes and Pattern Matching - 306]]
  - [[15.1 A simple example - 306][15.1 A simple example - 306]]
    - [[Case classes][Case classes]]
    - [[Pattern matching][Pattern matching]]
    - [[~match~ compared to ~switch~][~match~ compared to ~switch~]]
  - [[15.2 Kinds of patterns - 311][15.2 Kinds of patterns - 311]]
    - [[Wildcard patterns][Wildcard patterns]]
    - [[Constant patterns][Constant patterns]]
    - [[Variable patterns][Variable patterns]]
    - [[Constructor patterns][Constructor patterns]]
    - [[Sequence patterns][Sequence patterns]]
    - [[Tuple patterns][Tuple patterns]]
    - [[Typed patterns][Typed patterns]]
    - [[Variable binding][Variable binding]]
  - [[15.3 Pattern guards - 320][15.3 Pattern guards - 320]]
  - [[15.4 Pattern overlaps - 321][15.4 Pattern overlaps - 321]]
  - [[15.5 Sealed classes - 323][15.5 Sealed classes - 323]]
  - [[15.6 The ~Option~ type - 325][15.6 The ~Option~ type - 325]]
  - [[15.7 Patterns everywhere - 327][15.7 Patterns everywhere - 327]]
    - [[Patterns in variable definitions][Patterns in variable definitions]]
    - [[Case sequences as partial functions][Case sequences as partial functions]]
    - [[Patterns in ~for~ expressions][Patterns in ~for~ expressions]]
  - [[15.8 A larger example - 331][15.8 A larger example - 331]]
  - [[15.9 Conclusion - 339][15.9 Conclusion - 339]]
- [[16 Working with Lists - 340][16 Working with Lists - 340]]
  - [[16.1 List literals - 340][16.1 List literals - 340]]
  - [[16.2 The ~List~ type - 341][16.2 The ~List~ type - 341]]
  - [[16.3 Constructing lists - 341][16.3 Constructing lists - 341]]
  - [[16.4 Basic operations on lists - 342][16.4 Basic operations on lists - 342]]
  - [[16.5 List patterns - 343][16.5 List patterns - 343]]
  - [[16.6 First-order methods on class List - 345][16.6 First-order methods on class List - 345]]
    - [[Concatenating two lists][Concatenating two lists]]
    - [[The Divide and Conquer principle][The Divide and Conquer principle]]
    - [[Taking the length of a list: ~length~][Taking the length of a list: ~length~]]
    - [[Accessing the end of a list: ~init~ and ~last~][Accessing the end of a list: ~init~ and ~last~]]
    - [[Reversing lists: ~reverse~][Reversing lists: ~reverse~]]
    - [[Prefixes and suffixes: ~drop~, ~take~, and ~splitAt~][Prefixes and suffixes: ~drop~, ~take~, and ~splitAt~]]
    - [[Element selection: ~apply~ and ~indices~][Element selection: ~apply~ and ~indices~]]
    - [[Flattening a list of lists: ~flatten~][Flattening a list of lists: ~flatten~]]
    - [[Zipping lists: ~zip~ and ~unzip~][Zipping lists: ~zip~ and ~unzip~]]
    - [[Displaying lists: ~toString~ and ~mkString~][Displaying lists: ~toString~ and ~mkString~]]
    - [[Converting lists: ~iterator~, ~toArray~, ~copyToArray~][Converting lists: ~iterator~, ~toArray~, ~copyToArray~]]
    - [[Example: Merge sort][Example: Merge sort]]
  - [[16.7 Higher-order methods on class ~List~ - 357][16.7 Higher-order methods on class ~List~ - 357]]
    - [[Mapping over lists: ~map~, ~flatMap~ and ~foreach~][Mapping over lists: ~map~, ~flatMap~ and ~foreach~]]
    - [[Filtering lists: ~filter~, ~partition~, ~find~, ~takeWhile~, ~dropWhile~, and ~span~][Filtering lists: ~filter~, ~partition~, ~find~, ~takeWhile~, ~dropWhile~, and ~span~]]
    - [[Predicates over lists: ~forall~ and ~exists~][Predicates over lists: ~forall~ and ~exists~]]
    - [[Folding lists: ~/:~ and ~:\~][Folding lists: ~/:~ and ~:\~]]
    - [[Example: List reversal using fold][Example: List reversal using fold]]
    - [[Sorting lists: ~sortWith~][Sorting lists: ~sortWith~]]
  - [[16.8 Methods of the ~List~ object - 365][16.8 Methods of the ~List~ object - 365]]
    - [[Creating lists from their elements: ~List.apply~][Creating lists from their elements: ~List.apply~]]
    - [[Creating a range of numbers: ~List.range~][Creating a range of numbers: ~List.range~]]
    - [[Creating uniform lists: ~List.fill~][Creating uniform lists: ~List.fill~]]
    - [[Tabulating a function: ~List.tabulate~][Tabulating a function: ~List.tabulate~]]
    - [[Concatenating multiple lists: ~List.concat~][Concatenating multiple lists: ~List.concat~]]
  - [[16.9 Processing multiple lists together - 367][16.9 Processing multiple lists together - 367]]
  - [[16.10 Understanding Scala's type inference algorithm - 368][16.10 Understanding Scala's type inference algorithm - 368]]
  - [[16.11 Conclusion - 372][16.11 Conclusion - 372]]
- [[17 Working with Other Collections - 373][17 Working with Other Collections - 373]]
  - [[17.1 Sequences - 373][17.1 Sequences - 373]]
    - [[Lists][Lists]]
    - [[Arrays][Arrays]]
    - [[List buffers][List buffers]]
    - [[Array buffers][Array buffers]]
    - [[Strings (via ~StringOps~)][Strings (via ~StringOps~)]]
  - [[17.2 Sets and maps - 377][17.2 Sets and maps - 377]]
    - [[Using sets][Using sets]]
    - [[Using maps][Using maps]]
    - [[Default sets and maps][Default sets and maps]]
    - [[Sorted sets and maps][Sorted sets and maps]]
  - [[17.3 Selecting mutable versus immutable collections - 385][17.3 Selecting mutable versus immutable collections - 385]]
  - [[17.4 Initializing collections - 388][17.4 Initializing collections - 388]]
    - [[Converting to array or list][Converting to array or list]]
    - [[Converting between mutable and immutable sets and maps][Converting between mutable and immutable sets and maps]]
  - [[17.5 Tuples - 392][17.5 Tuples - 392]]
  - [[17.6 Conclusion - 394][17.6 Conclusion - 394]]
- [[18 Mutable Objects - 395][18 Mutable Objects - 395]]
  - [[18.1 What makes an object mutable? - 395][18.1 What makes an object mutable? - 395]]
  - [[18.2 Reassignable variables and properties - 398][18.2 Reassignable variables and properties - 398]]
  - [[18.3 Case study: Discrete event simulation - 401][18.3 Case study: Discrete event simulation - 401]]
  - [[18.4 A language for digital circuits - 402][18.4 A language for digital circuits - 402]]
  - [[18.5 The ~Simulation~ API - 405][18.5 The ~Simulation~ API - 405]]
  - [[18.6 Circuit Simulation - 409][18.6 Circuit Simulation - 409]]
    - [[The ~Wire~ class][The ~Wire~ class]]
    - [[The ~inverter~ method][The ~inverter~ method]]
    - [[The ~andGate~ and ~orGate~ methods][The ~andGate~ and ~orGate~ methods]]
    - [[Simulation output][Simulation output]]
    - [[Running the simulator][Running the simulator]]
  - [[18.7 Conclusion - 417][18.7 Conclusion - 417]]
- [[19 Type Parameterization - 418][19 Type Parameterization - 418]]
  - [[19.1 Functional queues - 418][19.1 Functional queues - 418]]
  - [[19.2 Information hiding - 422][19.2 Information hiding - 422]]
    - [[Private constructors and factory methods][Private constructors and factory methods]]
    - [[An alternative: private classes][An alternative: private classes]]
  - [[19.3 Variance annotations - 425][19.3 Variance annotations - 425]]
    - [[Variance and arrays][Variance and arrays]]
  - [[19.4 Checking variance annotations - 429 - =Re-READ=][19.4 Checking variance annotations - 429 - =Re-READ=]]
  - [[19.5 Lower bounds - 432][19.5 Lower bounds - 432]]
  - [[19.6 Contravariance - 434][19.6 Contravariance - 434]]
  - [[19.7 Object private data - 437][19.7 Object private data - 437]]
  - [[19.8 Upper bounds - 439][19.8 Upper bounds - 439]]
  - [[19.9 Conclusion - 442][19.9 Conclusion - 442]]
- [[20 Abstract Members - 443][20 Abstract Members - 443]]
  - [[20.1 A quick tour of abstract members - 443][20.1 A quick tour of abstract members - 443]]
  - [[20.2 Type members - 444][20.2 Type members - 444]]
  - [[20.3 Abstract ~val~'s - 445][20.3 Abstract ~val~'s - 445]]
  - [[20.4 Abstract ~var~'s - 446][20.4 Abstract ~var~'s - 446]]
  - [[20.5 Initializing abstract ~val~'s - 447][20.5 Initializing abstract ~val~'s - 447]]
    - [[Pre-initialized fields][Pre-initialized fields]]
    - [[Lazy ~val~'s][Lazy ~val~'s]]
  - [[20.6 Abstract types - 455][20.6 Abstract types - 455]]
  - [[20.7 Path-dependent types - 457][20.7 Path-dependent types - 457]]
  - [[20.8 Refinement types - 460][20.8 Refinement types - 460]]
  - [[20.9 Enumerations - 461][20.9 Enumerations - 461]]
  - [[20.10 Case study: Currencies - 463 - =RE-READ=][20.10 Case study: Currencies - 463 - =RE-READ=]]
  - [[20.11 Conclusion - 473][20.11 Conclusion - 473]]
- [[21 Implicit Conversions and Parameters - 474][21 Implicit Conversions and Parameters - 474]]
  - [[21.1 Implicit conversions - 474][21.1 Implicit conversions - 474]]
  - [[21.2 Rules for implicits - 477][21.2 Rules for implicits - 477]]
    - [[Naming an implicit conversion][Naming an implicit conversion]]
    - [[Where implicits are tried][Where implicits are tried]]
  - [[21.3 Implicit conversion to an expected type - 480][21.3 Implicit conversion to an expected type - 480]]
  - [[21.4 Converting the receiver - 482][21.4 Converting the receiver - 482]]
    - [[Interoperating with new types][Interoperating with new types]]
    - [[Simulating new syntax][Simulating new syntax]]
    - [[Implicit classes =Re-READ=][Implicit classes =Re-READ=]]
  - [[21.5 Implicit parameters - 485][21.5 Implicit parameters - 485]]
    - [[A style rule for implicit parameters][A style rule for implicit parameters]]
  - [[21.6 Context bounds - 491][21.6 Context bounds - 491]]
  - [[21.7 When multiple conversions apply - 494][21.7 When multiple conversions apply - 494]]
  - [[21.8 Debugging implicits - 496][21.8 Debugging implicits - 496]]
  - [[21.9 Conclusion - 497][21.9 Conclusion - 497]]
- [[22 Implementing Lists - 499][22 Implementing Lists - 499]]
  - [[22.1 The ~List~ class in principle - 499][22.1 The ~List~ class in principle - 499]]
    - [[The ~Nil~ object][The ~Nil~ object]]
    - [[The ~::~ class][The ~::~ class]]
    - [[Some more methods][Some more methods]]
    - [[List construction][List construction]]
  - [[22.2 The ~ListBuffer~ class - 505][22.2 The ~ListBuffer~ class - 505]]
  - [[22.3 The ~List~ class in practice - 507][22.3 The ~List~ class in practice - 507]]
  - [[22.4 Functional on the outside - 509][22.4 Functional on the outside - 509]]
  - [[22.5 Conclusion - 510][22.5 Conclusion - 510]]
- [[23 For Expressions Revisited - 512 =ALMOST DONE=][23 For Expressions Revisited - 512 =ALMOST DONE=]]
  - [[23.1 ~for~ expressions - 513][23.1 ~for~ expressions - 513]]
  - [[23.2 The n-queens problem - 515][23.2 The n-queens problem - 515]]
  - [[23.3 Querying with ~for~ expressions - 518][23.3 Querying with ~for~ expressions - 518]]
  - [[23.4 Translation of ~for~ expressions - 520 =Re-READ=][23.4 Translation of ~for~ expressions - 520 =Re-READ=]]
    - [[Translating ~for~ expressions with one generator][Translating ~for~ expressions with one generator]]
    - [[Translating ~for~ expressions starting with a generator and a filter][Translating ~for~ expressions starting with a generator and a filter]]
    - [[Translating ~for~ expressions starting with two generators][Translating ~for~ expressions starting with two generators]]
    - [[Translating patterns in generators][Translating patterns in generators]]
    - [[Translating definitions][Translating definitions]]
    - [[Translating ~for~ loops][Translating ~for~ loops]]
  - [[23.5 Going the other way - 524][23.5 Going the other way - 524]]
  - [[23.6 Generalizing ~for~ - 525][23.6 Generalizing ~for~ - 525]]
  - [[23.7 Conclusion][23.7 Conclusion]]
- [[24 Collections in Depth - 528][24 Collections in Depth - 528]]
  - [[24.1 Mutable and immutable collections - 529][24.1 Mutable and immutable collections - 529]]
  - [[24.2 Collections consistency - 531][24.2 Collections consistency - 531]]
  - [[24.3 Trait ~Traversable~ - 533][24.3 Trait ~Traversable~ - 533]]
  - [[24.4 Trait ~Iterable~ - 538][24.4 Trait ~Iterable~ - 538]]
    - [[Why have both ~Traversable~ and ~Iterable~?  =RE-READ=][Why have both ~Traversable~ and ~Iterable~?  =RE-READ=]]
    - [[Subcategories of ~Iterable~][Subcategories of ~Iterable~]]
  - [[24.5 The sequence traits ~Seq~, ~IndexedSeq~, and ~LinearSeq~ - 542][24.5 The sequence traits ~Seq~, ~IndexedSeq~, and ~LinearSeq~ - 542]]
    - [[Buffers][Buffers]]
  - [[24.6 Sets - 547][24.6 Sets - 547]]
  - [[24.7 Maps - 552][24.7 Maps - 552]]
  - [[24.8 Concrete immutable collection classes - 556][24.8 Concrete immutable collection classes - 556]]
    - [[List][List]]
    - [[Streams][Streams]]
    - [[Vectors][Vectors]]
    - [[Immutable stacks][Immutable stacks]]
    - [[Immutable queues][Immutable queues]]
    - [[Ranges][Ranges]]
    - [[Hash tries][Hash tries]]
    - [[Red-black trees][Red-black trees]]
    - [[Immutable bit sets][Immutable bit sets]]
    - [[List maps][List maps]]
  - [[24.9 Concrete mutable collection classes - 563][24.9 Concrete mutable collection classes - 563]]
    - [[Array buffers][Array buffers]]
    - [[List buffers][List buffers]]
    - [[String buffers][String buffers]]
    - [[Linked lists][Linked lists]]
    - [[Double linked lists][Double linked lists]]
    - [[Mutable lists][Mutable lists]]
    - [[Queues][Queues]]
    - [[Array sequences][Array sequences]]
    - [[Stacks][Stacks]]
    - [[Array stacks][Array stacks]]
    - [[Hash tables][Hash tables]]
    - [[Weak hash maps][Weak hash maps]]
    - [[Concurrent Maps][Concurrent Maps]]
    - [[Mutable bit sets][Mutable bit sets]]
  - [[24.10 Arrays - 570][24.10 Arrays - 570]]
  - [[24.11 Strings - 575][24.11 Strings - 575]]
  - [[24.12 Performance characteristics - 575][24.12 Performance characteristics - 575]]
  - [[24.13 Equality - 578][24.13 Equality - 578]]
  - [[24.14 Views - 579][24.14 Views - 579]]
  - [[24.15 Iterators - 584][24.15 Iterators - 584]]
    - [[Buffered iterators][Buffered iterators]]
  - [[24.16 Creating collections from scratch - 592][24.16 Creating collections from scratch - 592]]
  - [[24.17 Conversions between Java and Scala collections - 594][24.17 Conversions between Java and Scala collections - 594]]
  - [[24.18 Conclusion - 596][24.18 Conclusion - 596]]
- [[25 The Architecture of Scala Collections - 597][25 The Architecture of Scala Collections - 597]]
  - [[25.1 Builders - 597][25.1 Builders - 597]]
  - [[25.2 Factoring out common operations - 599][25.2 Factoring out common operations - 599]]
  - [[25.3 Integrating new collections - 604][25.3 Integrating new collections - 604]]
    - [[Integrating sequences][Integrating sequences]]
    - [[Integrating new sets and maps][Integrating new sets and maps]]
    - [[Summary][Summary]]
  - [[25.4 Conclusion - 620][25.4 Conclusion - 620]]
- [[26 Extractors - 621][26 Extractors - 621]]
  - [[26.1 An example: extracting email addresses - 621][26.1 An example: extracting email addresses - 621]]
  - [[26.2 Extractors - 622][26.2 Extractors - 622]]
  - [[26.3 Patterns with zero or one variables - 625][26.3 Patterns with zero or one variables - 625]]
  - [[26.4 Variable argument extractors - 627][26.4 Variable argument extractors - 627]]
  - [[26.5 Extractors and sequence patterns - 630][26.5 Extractors and sequence patterns - 630]]
  - [[26.6 Extractors versus case classes - 631][26.6 Extractors versus case classes - 631]]
  - [[26.7 Regular expressions - 632][26.7 Regular expressions - 632]]
    - [[Forming regular expressions][Forming regular expressions]]
    - [[Searching for regular expressions][Searching for regular expressions]]
    - [[Extracting with regular expressions][Extracting with regular expressions]]
  - [[26.8 Conclusion - 636 =Re-Read=][26.8 Conclusion - 636 =Re-Read=]]
- [[27 Annotations - 637 *Learn MORE*][27 Annotations - 637 *Learn MORE*]]
  - [[27.1 Why have annotations? - 637][27.1 Why have annotations? - 637]]
  - [[27.2 Syntax of annotations - 638][27.2 Syntax of annotations - 638]]
  - [[27.3 Standard annotations - 640][27.3 Standard annotations - 640]]
    - [[Deprecation][Deprecation]]
    - [[Volatile fields][Volatile fields]]
    - [[Binary serialization][Binary serialization]]
    - [[Automatic ~get~ and ~set~ methods *RE-READ*][Automatic ~get~ and ~set~ methods *RE-READ*]]
    - [[Tailrec][Tailrec]]
    - [[Unchecked][Unchecked]]
    - [[Native methods][Native methods]]
  - [[27.4 Conclusion - 644][27.4 Conclusion - 644]]
- [[28 Working with XML - 645][28 Working with XML - 645]]
  - [[28.1 Semi-structured data - 645][28.1 Semi-structured data - 645]]
  - [[28.2 XML overview - 646][28.2 XML overview - 646]]
  - [[28.3 XML literals - 647][28.3 XML literals - 647]]
  - [[28.4 Serialization - 649][28.4 Serialization - 649]]
  - [[28.5 Taking XML apart - 651][28.5 Taking XML apart - 651]]
  - [[28.6 Deserialization - 652][28.6 Deserialization - 652]]
  - [[28.7 Loading and saving - 653][28.7 Loading and saving - 653]]
  - [[28.8 Pattern matching on XML - 655][28.8 Pattern matching on XML - 655]]
  - [[28.9 Conclusion - 658][28.9 Conclusion - 658]]
- [[29 Modular Programming Using Objects - 659][29 Modular Programming Using Objects - 659]]
  - [[29.1 The problem - 660][29.1 The problem - 660]]
  - [[29.2 A recipe application - 661][29.2 A recipe application - 661]]
  - [[29.3 Abstraction - 664][29.3 Abstraction - 664]]
  - [[29.4 Splitting modules into traits - 667][29.4 Splitting modules into traits - 667]]
  - [[29.5 Runtime linking - 670][29.5 Runtime linking - 670]]
  - [[29.6 Tracking module instances - 671][29.6 Tracking module instances - 671]]
  - [[29.7 Conclusion - 673][29.7 Conclusion - 673]]
- [[30 Object Equality - 674][30 Object Equality - 674]]
  - [[30.1 Equality in Scala - 674][30.1 Equality in Scala - 674]]
  - [[30.2 Writing an equality method - 675][30.2 Writing an equality method - 675]]
    - [[Pitfall #1: Defining ~equals~ with the wrong signature][Pitfall #1: Defining ~equals~ with the wrong signature]]
    - [[Pitfall #2: Changing ~equals~ without also changing ~hashCode~][Pitfall #2: Changing ~equals~ without also changing ~hashCode~]]
    - [[Pitfall #3: Defining ~equals~ in terms of mutable fields][Pitfall #3: Defining ~equals~ in terms of mutable fields]]
    - [[Pitfall #4: Failing to define ~equals~ as an equivalence relation][Pitfall #4: Failing to define ~equals~ as an equivalence relation]]
  - [[30.3 Defining equality for parameterized types - 688][30.3 Defining equality for parameterized types - 688]]
  - [[30.4 Recipes for ~equals~ and ~hashCode~ - 692][30.4 Recipes for ~equals~ and ~hashCode~ - 692]]
    - [[Recipe for ~equals~][Recipe for ~equals~]]
    - [[Recipe for ~hashCode~][Recipe for ~hashCode~]]
  - [[30.5 Conclusion - 697][30.5 Conclusion - 697]]
- [[31 Combining Scala and Java - 698][31 Combining Scala and Java - 698]]
  - [[31.1 Using Scala from Java - 698][31.1 Using Scala from Java - 698]]
    - [[General rules][General rules]]
    - [[Value types][Value types]]
    - [[Singleton objects][Singleton objects]]
    - [[Traits as interfaces][Traits as interfaces]]
  - [[31.2 Annotations - 701][31.2 Annotations - 701]]
    - [[Additional effects from standard annotations][Additional effects from standard annotations]]
    - [[Exceptions thrown][Exceptions thrown]]
    - [[Java annotations][Java annotations]]
    - [[Writing your own annotations][Writing your own annotations]]
  - [[31.3 Wildcard types - 706][31.3 Wildcard types - 706]]
  - [[31.4 Compiling Scala and Java together - 709][31.4 Compiling Scala and Java together - 709]]
  - [[31.5 Java 8 integration in Scala 2.12 - 709][31.5 Java 8 integration in Scala 2.12 - 709]]
    - [[Lambda expressions and "SAM" types][Lambda expressions and "SAM" types]]
    - [[Using Java 8 Streams from Scala 2.12][Using Java 8 Streams from Scala 2.12]]
  - [[31.6 Conclusion - 713][31.6 Conclusion - 713]]
- [[32 Futures and Concurrency - 714][32 Futures and Concurrency - 714]]
  - [[32.1 Trouble in paradise - 714][32.1 Trouble in paradise - 714]]
  - [[32.2 Asynchronous execution and Trys - 716][32.2 Asynchronous execution and Trys - 716]]
  - [[32.3 Working with Futures - 718][32.3 Working with Futures - 718]]
    - [[Transforming ~Futures~ with ~map~][Transforming ~Futures~ with ~map~]]
    - [[Transforming ~Futures~ with ~for~ expressions][Transforming ~Futures~ with ~for~ expressions]]
    - [[Creating the ~Future~: ~Future.failed~, ~Future.successful~, ~Future.fromTry~, and ~Promises~][Creating the ~Future~: ~Future.failed~, ~Future.successful~, ~Future.fromTry~, and ~Promises~]]
    - [[Filtering: ~filter~ and ~collect~][Filtering: ~filter~ and ~collect~]]
    - [[Dealing with failure: ~failed~, ~fallBackTo~, ~recover~, and ~recoverWith~][Dealing with failure: ~failed~, ~fallBackTo~, ~recover~, and ~recoverWith~]]
    - [[Mapping both possibilities: ~transform~][Mapping both possibilities: ~transform~]]
    - [[Combining futures: ~zip~, ~Future.fold~, ~Future.reduce~, ~Future.sequence~, and ~Future.traverse~][Combining futures: ~zip~, ~Future.fold~, ~Future.reduce~, ~Future.sequence~, and ~Future.traverse~]]
    - [[Performing side-effects: ~foreach~, ~onComplete~, and ~andThen~][Performing side-effects: ~foreach~, ~onComplete~, and ~andThen~]]
    - [[Other methods added in 2.12: ~flatten~, ~zipWith~, and ~transformWith~][Other methods added in 2.12: ~flatten~, ~zipWith~, and ~transformWith~]]
  - [[32.4 Testing with Futures - 733][32.4 Testing with Futures - 733]]
  - [[32.5 Conclusion - 735][32.5 Conclusion - 735]]
- [[33 Combinator Parsing - 736][33 Combinator Parsing - 736]]
  - [[33.1 Example: Arithmetic expressions - 737][33.1 Example: Arithmetic expressions - 737]]
  - [[33.2 Running your parser - 739][33.2 Running your parser - 739]]
  - [[33.3 Basic regular expression parsers - 740][33.3 Basic regular expression parsers - 740]]
  - [[33.4 Another example: JSON - 741][33.4 Another example: JSON - 741]]
  - [[33.5 Parser output - 743][33.5 Parser output - 743]]
    - [[Symbolic versus alphanumeric names][Symbolic versus alphanumeric names]]
  - [[33.6 Implementing combinator parsers - 749][33.6 Implementing combinator parsers - 749]]
    - [[Parser input][Parser input]]
    - [[Parser results][Parser results]]
    - [[The ~Parser~ class][The ~Parser~ class]]
    - [[Aliasing ~this~][Aliasing ~this~]]
    - [[Single-token parsers][Single-token parsers]]
    - [[Sequential composition][Sequential composition]]
    - [[Alternative composition][Alternative composition]]
    - [[Dealing with recursion][Dealing with recursion]]
    - [[Result conversion][Result conversion]]
    - [[Parsers that don't read any input][Parsers that don't read any input]]
    - [[Option and repetition][Option and repetition]]
  - [[33.7 String literals and regular expressions - 758][33.7 String literals and regular expressions - 758]]
  - [[33.8 Lexing and parsing - 759][33.8 Lexing and parsing - 759]]
  - [[33.9 Error reporting - 759][33.9 Error reporting - 759]]
  - [[33.10 Backtracking versus LL(1) - 761][33.10 Backtracking versus LL(1) - 761]]
  - [[33.11 Conclusion - 763][33.11 Conclusion - 763]]
- [[34 GUI Programming - 765][34 GUI Programming - 765]]
  - [[34.1 A first Swing application - 765][34.1 A first Swing application - 765]]
  - [[34.2 Panels and layouts - 768][34.2 Panels and layouts - 768]]
  - [[34.3 Handling events - 770][34.3 Handling events - 770]]
  - [[34.4 Example: Celsius/Fahrenheit converter - 773][34.4 Example: Celsius/Fahrenheit converter - 773]]
  - [[34.5 Conclusion - 775][34.5 Conclusion - 775]]
- [[35 The SCells Spreadsheet - 777][35 The SCells Spreadsheet - 777]]
  - [[35.1 The visual framework - 777][35.1 The visual framework - 777]]
  - [[35.2 Disconnecting data entry and display - 780][35.2 Disconnecting data entry and display - 780]]
  - [[35.3 Formulas - 783][35.3 Formulas - 783]]
  - [[35.4 Parsing formulas - 785][35.4 Parsing formulas - 785]]
  - [[35.5 Evaluation - 790][35.5 Evaluation - 790]]
  - [[35.6 Operation libraries - 793][35.6 Operation libraries - 793]]
  - [[35.7 Change propagation - 796][35.7 Change propagation - 796]]
  - [[35.8 Conclusion - 800][35.8 Conclusion - 800]]
- [[Appendix A. Scala Scripts on Unix and Windows - 802][Appendix A. Scala Scripts on Unix and Windows - 802]]
- [[Glossary - 803][Glossary - 803]]
- [[Bibliography - 819][Bibliography - 819]]
- [[About the Authors - 822][About the Authors - 822]]
- [[Index - 823][Index - 823]]
- [[Tips (Added by Jian)][Tips (Added by Jian)]]
- [[TodoList (Added by Jian)][TodoList (Added by Jian)]]

* Contents
* List of Figures
* List of Tables
* List of Listings
* Foreword
  - 

* Acknowledgments
* Introduction
* DONE 1 A Scalable Language
  CLOSED: [2017-10-24 Tue 18:37]
  The name Scala stands for "scalable language."

  - It runs on the standard Java platform and interoperates seamlessly with all
    Java libraries.

  - This initial chapter answers the question, "Why Scala?"

** DONE 1.1 A language that grows on you
   CLOSED: [2017-10-24 Tue 18:13]
   =Re-READ=
*** Growing new types
*** Growing new control constructs

** DONE 1.2 What makes Scala scalable?
   CLOSED: [2017-10-24 Tue 18:37]
*** Scala is object-oriented
*** Scala is functional
    Two main points:
    - First-class function
    - (Mostly) side-effect free

** DONE 1.3 Why Scala?
   CLOSED: [2017-10-24 Tue 00:53]
   People have their reasons why the like Scala.
   Four of the most important aspects will be discussed in this section:
   + compatibility
   + brevity
   + high-level abstractions
   + advanced static typing

*** DONE Scala is compatible
    CLOSED: [2017-10-24 Tue 00:28]
*** DONE Scala is concise
    CLOSED: [2017-10-24 Tue 00:28]
    Example:
    - Java version
      #+BEGIN_SRC java
        class MyClass {
            private int index;
            private String name;
  
            public MyClass(int index, String name) {
                this.index = index;
                this.name = name;
            }
        }
      #+END_SRC

    - Scala version
      #+BEGIN_SRC scala
        class MyClass(index: Int, name: String)
      #+END_SRC

*** DONE Scala is high-level
    CLOSED: [2017-10-24 Tue 00:36]
    - Example
      - Java (< 8) version

        #+BEGIN_SRC java
          // Before Java 8
          boolean nameHasUpperCase = false;
    
          for (int i = 0; i < name.length(); ++i) {
              if (Character.isUpperCase(name.charAt(i))) {
                  nameHasUpperCase = true;
                  break;
              }
          }
        #+END_SRC

      - Java 8+ version
        #+BEGIN_SRC java
          boolean nameHasUpperCase =
              name.chars().anyMatch(
                  (int c) -> Character.isUpperCase((char) c)
              );
        #+END_SRC

      - Scala version
        #+BEGIN_SRC scala
          val nameHasUpperCase = name.exists(_.isUpper)
        #+END_SRC

*** DONE Scala is statically typed
    CLOSED: [2017-10-24 Tue 00:52]
    - It allows you to parameterize types with generics, to combine types using
      /intersections/, and to hide details of types using /abstract types/.
      =TODO=

    - Static types do NOT mean verbose and inflexible, but some specific type
      systems are.

      This is why Alan Kay once remarked: 
      "I'm NOT against types, but I don't know of any type systems that aren't a
      _complete pain_, so I still like dynamic typing.”
      (from footnote 14)

      However, the type system of Scala is good enough to say NOT COMPLETE PAIN,
      in fact, much better.

    - *Verifiable properties*
      + Edsger Dijkstra said, testing can only prove the presence of errors,
        never their absence.
        (footnote 15)

      + statically typed guarantees simple, however, which cannot be provided by
        testing.

    - *Safe refactorings*

    - *Documentation*
      + Unlike a normal comment, a type annotation can NEVER be out of date.

      + IDE's can use types as documentation to do something, and give you
        informative suggestions based on these info.

** DONE 1.4 Scala's roots
   CLOSED: [2017-10-24 Tue 00:14]
   Only a few features of Scala are genuinely new; most have been already
   applied in some form in other languages.

   Scala's innovations come primarily from how its constructs are put together.

   The list below cannot be exhaustive.

   - Surface level (Syntax):
     Scala <- Java / C# <- C / C++

   - Scala adopts Java's basic types, class libraries, execution model =TODO=.

   - Uniform object model:  =TODO=
     Scala <- Ruby <- Smalltalk

   - Universal nesting:
     Scala <- Algol, Simula, and, more recently, in Beta and gbeta =TODO=.

   - Uniform access principle:
     Eiffel

   - Functional programming:
     ML family

     + Higher-order functions in Scala's standard library: ML and Haskell

   - Implicit parameters were motivated by Haskell's type classes; they achieve
     analogous results in a more classical OO settings.
     =TODO=

   - Actor-based concurrency library (Akka):
     Erlang
     
   - Scala's type annotation is postfixed, which is good for type inference.
     It's hard for a compiler to do right thing if a prefixed type is omited.

     That's why C# 3.0 introduced ~var~ to tell compiler the programmer omit
     a type which need to be inferred.

** DONE 1.5 Conclusion
   CLOSED: [2017-10-24 Tue 00:14]

* DONE 2 First Steps in Scala - 64
  CLOSED: [2017-10-03 Tue 21:46]
  - footnote:
    This chapter Scala 2.11.7 is used,
    though 2.12 is written in the book cover.

** DONE Step 1. Learn to use the Scala interpreter - 64
   CLOSED: [2017-10-03 Tue 20:38]
  - The REPL evaluate the input expression, and save its value into a variable
    named in the pattern of ~resX~. The ~X~ here is a number. This variable can
    be re-used.
    #+BEGIN_SRC scala
      // scala> 1 + 2
      // res0: Int = 3

      // scala> res0 * 3
      // res1: Int = 9
    #+END_SRC

  - Meaningless value ~()~ won't be printed out
    #+BEGIN_SRC scala
      // scala> println("Hello, world!")
      // Hello, world!
    #+END_SRC

** DONE Step 2. Define some variables - 66
   CLOSED: [2017-10-03 Tue 20:55]
   - Declare a ~val~
     #+BEGIN_SRC scala
       // scala> val msg = "Hello, world!"
       // msg: String = Hello, world!

       //// You can't change the value of ~msg~.
       //// However, you can create a new one with the same (even with different type)
       //// to shadow the old one.
        
       // scala> msg = "Goodbye cruel world!"
       // <console>:8: error: reassignment to val
       //        msg = "Goodbye cruel world!"

       // scala> val msg = 3
       // msg: Int = 3
     #+END_SRC
     Scala doesn't have the feature of /same scope variable shadowing/ (=Jian create this name=).
     The shawdoing above is actually inner scope variable shadow the outer scope
     variable -- in Scala REPL, new input create a new inner scope.

     To be concrete, =See Section 7.7=
     1. this code cannot be compiled.
        #+BEGIN_SRC scala
          val a = 3
          val a = "String"
        #+END_SRC

     2. REPL actually create something like (=From Jian= guess):
        #+BEGIN_SRC scala
          val a = 3
          {
            val a = "String"
          }
        #+END_SRC

   - Declare a ~var~ and reassign a value to it
     #+BEGIN_SRC scala
       // scala> var greeting = "Hello, world!"
       // greeting: String = Hello, world!

       // scala> greeting = "Leave me alone, world!"
       // greeting: String = "Leave me alone, world!"
     #+END_SRC
     The "shadowing" metioned above also work with ~var~'s.

   - Scala strings are implemented by Java's ~String~ class.
     #+BEGIN_SRC scala
       // scala> val msg2: java.lang.String = "Hello again, world!"
       // msg2: String = Hello again, world!
     #+END_SRC

   - 

** DONE Step 3. Define some functions - 68
   CLOSED: [2017-10-03 Tue 21:06]
   - Define some function:
     #+BEGIN_SRC scala
       // scala>
       def max(x: Int, y: Int): Int = {
         if (x > y) x
         else y
       }

       // max: (x: Int, y: Int) Int
     #+END_SRC

     =IMPORTANT= Scala compiler does NOT infer function parameter types, you must
     type them manually!!!

   - Figure 2.1 The basic form of a function definition in Scala.

   - The /result type/ is not always required to be explicitly typed.
     However, you must write it explicitly when you write a /recursive function/.

     Nevertheless, indicate function result types explicitly is usually a good
     idea.

   - The curly braces is only optional, when the defined function has a one
     statement/expression body.

   - Define a function of no parameter and only used for side effect.
     #+BEGIN_SRC scala
       scala> def greet() = println("Hello, world!")
       greet: ()Unit
     #+END_SRC

   - Scala's ~Unit~ type is similar to Java's ~void~ type;

     _in fact_, every ~void~ returning method in Java is mapped to a
     ~Unit~-returning method in Scala.

   - Quit the Scala REPL:
     use ~:quit~ or ~:q~ for short.

** DONE Step 4. Write some Scala scripts - 70
   CLOSED: [2017-10-03 Tue 21:12]
   - Type ~println("Hello, world, from a script!")~ into file =hello.scala=, and
     run it with ~$ scala hello.scala~

   - Similar script as the above, with command line argument(s).
     Type ~println("Hello, " + args(0) + "!")~ into file =helloarg.scala=, and
     run it with ~$ scala helloarg.scala planet~

   - ~//~ is the line comment characters of Scala.

   - ~/*~ and ~*/~ is the block comment characters of Scala.

** DONE Step 5. Loop with ~while~; decide with ~if~ - 71
   CLOSED: [2017-10-03 Tue 21:31]
   - block :: the code between the curly braces
              =From Jian= I think one statement/expression block with no curly
              braces is also exist. This definition is not rigorous.

   - The recommended indentation style for Scala: _TWO_ spaces.

   - Scala doesn't have ~i++~ and ~++i~.

** DONE Step 6. Iterate with ~foreach~ and ~for~ - 73
   CLOSED: [2017-10-03 Tue 21:45]
   - functional literal ::

   - Code that use ~foreach~ method to do the same thing as the code in the last
     section (use ~while~):
     #+BEGIN_SRC scala
       // pa.scala script
       args.foreach(arg => println(arg))
     #+END_SRC

     Run it with ~$ scala pa.scala Concise is nice~
     The output:
     #+BEGIN_SRC text
       Concise
       is
       nice
     #+END_SRC

   - =TODO= =IMPORTANT=
     If a function literal consists of one statement that takes a single
     argument, you need not explicitly name and specify the argument

     footnote:
     This shorthand, called a /partially applied function/, is described in
     Section 8.6.

     For example, ~args.foreach(println)~

   - The ~for~ in Scala (you won't see its full power until Section 7.3) =TODO=

   - footnote 11:
     You can say ="in"= for the ~<-~ symbol.
     You'd read ~for (arg <- args)~, therefore, as "for arg in args."

   - The ~arg~ in ~for (arg <- args)~ is ~val~, rather than ~var~.
     Two facts can prove this:
     + ~arg~ cannot be re-assigned inside the body of ~for~

     + actually, in ~(arg <- args)~ for each element of ~args~, a NEW ~arg~ will
       created and initialized to the element value.

       =From Jian= =TODO= I want to see the implementation of this.

** DONE Conclusion - 76
   CLOSED: [2017-10-03 Tue 21:46]

* DONE 3 Next Steps in Scala - 77
  CLOSED: [2017-10-05 Thu 05:16]
** DONE Step 7. Parameterize arrays with types - 77
   CLOSED: [2017-10-07 Sat 17:05]
   - parameterize :: Use values and/or types to "configure" an instance when use
                     ~new~ to construct (instantiate) it.

   - The type parameterization portion forms part of the type of the instance.
     The value parameterization portion doesn't.

   - The syntax ~0 to 2~ is implicitly transformed into the method call
     ~(0).to(2)~. However, this syntax only works if you explicitly specify the
     /receiver/ of the method call.

   - =IMPORTANT=
     Scala doesn't technically have /operator overloading/ (like Java),
     because it doesn't actually have operators in the traditional sense -- 
     instead, characters such as ~+~, ~-~, ~*~, and ~/~ can be used in method
     names.

     In Scala, their is no concept "operators" on describeing operations, only
     /methods/ (there is a concept /operators/, which is a kind of Scala's
     /identifiers/).

     Scala supports /method overloading/ just like Java, and the
     /method overloading/ of Scala includes overloading methods with names that is
     usually considered as /operator/ in the other languages.

   - Q: Why arrays are accessed with parentheses in Scala?

     A: Scala has fewer special cases than Java.

     For example,
     1. ~greetStrings(i)~ gets transformed into ~greetStrings.apply(i)~.

     2. ~greetStrings(0) = "Hello"~ gets transformed into
        ~greetStrings.update(0, "Hello")~

   - Moreover, this uniformity does NOT incur a significant performance cost.
       
** DONE Step 8. Use lists - 81
   CLOSED: [2017-10-04 Wed 22:31]
   - Applying functional philosophy to the world of objects means making objects
     immutable.

   - Scala ~Array~ is mutable.

     Scala ~List~ is immutable, and it is designed to enable a functional style
     of programming.

     Java ~List~ is mutable.

   - List concatenation: ~List(1, 2) ::: List(3, 4)~

   - =TODO= Why not append to lists?
     + Chapter 24, ~:+~

     + Build a list efficiently by appending elements:
       * prepend them and when you're done call ~reverse~.
       * Use ~ListBuffer~ which has an append operation, and then ~toList~

   - Useful methods of ~List~
     + ~aList.count(s \equal{}> s.length == 4)~
     + ~aList.drop(2)~
     + ~aList.dropRight(2)~
     + ~aList.exists(s \equal{}> s == "until")~
     + ~aList.forall(s \equal{}> s.endsWith("1"))~
     + ~aList.init~: all but the last element
     + ~aList.isEmpty~
     + ~aList.mkString(",")~

** DONE Step 9. Use tuples - 86
   CLOSED: [2017-10-04 Wed 22:41]
   - Example
     #+BEGIN_SRC scala
       val pair: Tuple2[Int, String] = (99, "Luftballons")
       println(pair._1)
       println(pair._2)
     #+END_SRC

   - footnote:
     Although conceptually you could create tuples of any length,
     currently the Scala library only defines them up to ~Tuple22~.

   - Accessing the elements of a tuple
     + Q: Why use ~pair._1~ rather ~pair(0)~?
       A: Because we can't implement it with the ~apply~ method -- different
          ~_N~ return different type value.

     + ~_N~ numbers are _one-based_, instead of _zero-based_.

       This is a tradition set by other languages with statically typed tuples,
       such as Haskell and ML.

** DONE Step 10. Use sets and maps - 87
   CLOSED: [2017-10-05 Thu 04:59]
   - Figure 3.2 Class hierarchy for Scala sets.
                          ~scala.collection.Set~
                               <<trait>>
                                  /|\
                      _____________|___________________
                      |                                | 
       ~scala.collection.immutable.Set~    ~scala.collection.mutable.Set~
                  <<trait>>                        <<trait>>
                      |                                |
    ~scala.collection.immutable.HashSet~    ~scala.collection.mutable.HashSet~

   - When use ~+~, both mutable and immutable sets will return new sets.

   - Mutable sets offers ~+=~

   - Figure 3.3 Class hierarchy for Scala maps.
                          ~scala.collection.Map~
                               <<trait>>
                                  /|\
                      _____________|___________________
                      |                                | 
       ~scala.collection.immutable.Map~    ~scala.collection.mutable.Map~
                  <<trait>>                        <<trait>>
                      |                                |
    ~scala.collection.immutable.HashMap~    ~scala.collection.mutable.HashMap~
     
** DONE Step 11. Learn to recognize the functional style - 92
   CLOSED: [2017-10-05 Thu 05:06]
** DONE Step 12. Read lines from a file - 95
   CLOSED: [2017-10-05 Thu 05:16]
   - Version 1
     #+BEGIN_SRC scala
       import scala.io.Source

       if (args.length > 0) {
         for (line <- Source.fromFile(args(0)).getLines())
           println(line.length + " " + line)
       }
       else
         Console.err.println("Please enter filename")
     #+END_SRC
     + the ~fromFile~ method returns a ~Source~ object.

     + the ~getLines~ method returns an ~Iterator[String]~.

   - Version 2 (better format)
     #+BEGIN_SRC scala
       import scala.io.Source

       def widthOfLength(s: String) = s.length.toString.length

       if (args.length > 0) {
         val lines = Source.fromFile(args(0)).getLines().toList

         val longestLine = lines.reduceLeft(
           (a, b) => if (a.length > b.length) a else b
         )
         val maxWidth = widthOfLength(longestLine)

         for (line <lines) {
           val numSpaces = maxWidth widthOfLength(line)
           val padding = " " * numSpaces
           println(padding + line.length + " | " + line)
         }
       }
       else
         Console.err.println("Please enter filename")
     #+END_SRC

** DONE Conclusion - 98
   CLOSED: [2017-10-05 Thu 05:16]
   - x

* DONE 4 Classes and Objects - 99
  CLOSED: [2017-10-02 Mon 22:31]
** DONE 4.1 Classes, fields, and methods - 99
   CLOSED: [2017-10-02 Mon 21:15]
   - members :: /fields/ and /methods/

   - /Fields/ are also known as /instance variables/,
     because every instance gets its own set of the variables.

   - ~private~ fields can ONLY be accessed by methods defined in the same class,
     all the code that can update the state will be localized to the class.

   - /Public/ is Scala's default access level. No ~public~ keyword.

   - Method parameters in Scala is that they are ~val~'s,

   - A good manner of coding:
     11:w:wExplicitly provide the result types of public methods.

   - /procedure/ :: A method that is executed only for its side effects.
                    Its type is ~Unit~.

** DONE 4.2 Semicolon inference - 104
   CLOSED: [2017-10-02 Mon 21:15]
   _The rules of semicolon inference_
   The precise rules for statement separation are surprisingly simple for
   how well they work. In short, a line ending is treated as a semicolon
   unless one of the following conditions is true:

   1. The line in question ends in a word that would not be legal as the end of a
      statement, such as a period or an infix operator.

   2. The next line begins with a word that cannot start a statement.

   3. The line ends while inside parentheses (...) or brackets [...], because
      these cannot contain multiple statements anyway.

** DONE 4.3 Singleton objects - 105
   CLOSED: [2017-10-02 Mon 22:31]
   - Classes in Scala cannot have static members -- one reason why we say Scala
     is more OO than Java.

   - singleton objects ::

   - The syntax used to define a /singleton object/ looks like a /class/
     definition, except replace the keyword ~class~ with ~object~.

   - companion object :: a /singleton object/ that shares the same name with a
        class (the /companion class/ of this /singleton object/).

   - One /companion class/ and its /companion object/ must be defined in the
     _SAME_ source file.

   - A class and its companion object can access each other's _private_ members.

   - (from footnote) ~new~ is used to instantiate classes.
     ~new~ does not have any relation with /singleton objects/.

     To be concrete:
     Suppose we have class ~A~ and its companion object ~A~. All the ~A~'s in the
     ~new A~ expression is the ~A~ _class_.

   - Defining a singleton object doesn't define a type (at the Scala level of
     abstraction) -- you can't make a value of it, unless its /companion class/
     is also given.

   - However, /singleton objects/ extend a superclass and can mix in traits.

     Given each /singleton object/ is an instance of its superclasses and
     mixed-in traits, you can
     + invoke its methods via these types,
     + refer to it from variables of these types,
     + pass it to methods expecting these types.

     =TODO=
     We’ll show some examples of singleton objects inheriting from classes and
     traits in Chapter 13

   - One difference between /classes/ and /singleton objects/:
     + /singleton objects/ CANNOT take parameters
     + /classes/ can.

     Because you can't instantiate a /singleton object/ with the ~new~ keyword,
     you have no way to pass parameters to it.

   - Each /singleton object/ is implemented as an instance of a /synthetic class/
     referenced from a static variable, so they have the same initialization
     semantics as Java statics.

     In particular, a singleton object is initialized the first time some code
     accesses it.

     =TODO=

   - standalone object :: A /singleton object/ that does NOT share the same name
        with a /companion class/.

   - The usage of /standalone object/:
     + collect related utility methods togethe
     + define an entry point to a Scala application (See next section =TODO=)
     + ......

** DONE 4.4 A Scala application - 108
   CLOSED: [2017-10-02 Mon 22:25]
   - To run a Scala program, you _MUST_ supply the name of a /standalone
     singleton object/ with a ~main~ method (you can freely name the ONLY
     parameter):
     #+BEGIN_SRC scala
       def main(args: Array[String]): Unit = {
         // ...
       }
     #+END_SRC

   - ANY /standalone object/ with a ~main~ method of the proper signature
     can be used as the /entry point/ into an application.

   - Example:
     #+BEGIN_SRC scala
       // In file Summer.scala
       import ChecksumAccumulator.calculate

       object Summer {
         def main(args: Array[String]) = {
           for (arg <args)
             println(arg + ": " + calculate(arg))
         }
       }
     #+END_SRC
     + The ~import~ line:
       You can think this ~import~ as similar to the /static import/ feature
       introduced in Java 5.
         One difference in Scala is that you can import members from any object.
       not just /singleton objects/

     + static import :: allow /members/ defined in a class as ~public static~ to
                        be used in Java code; _WITHOUT_ specifying the class in
                        which the /members/ are defined.

   - Scala _implicitly_ imports members of packages
     + ~java.lang~
     + ~scala~
     + ~Predef~ (in ~scala~)

   - In Scala, you can name =.scala= files anything you want, no matter what
     Scala classes or code you put in them.

     However, in general in the case of non-scripts, the Java way (name the
     =.java= file with the name of the class inside it) is recommended.

   - For the application of this section, we can compile with a command:
     ~$ scalac ChecksumAccumulator.scala Summer.scala~

     This compiles your source files, but there may be a perceptible delay
     before the compilation finishes. The reason is that every time the compiler
     starts up, it spends time scanning the contents of jar files and doing
     other initial work before it even looks at the fresh source files you
     submit to it.

     For this reason, the Scala distribution also includes a Scala compiler
     daemon called ~fsc~ (fast Scala compiler):
     ~$ fsc ChecksumAccumulator.scala Summer.scala~

   - The first time you run ~fsc~, it will create a local server daemon attached
     to a port on your computer. It will then send the list of files to compile
     to the daemon via the port, and the daemon will compile the files.
       The next time you run ~fsc~, the daemon will already be running, so ~fsc~
     will simply send the file list to the daemon, which will immediately
     compile the files.

     Using ~fsc~, you only need to wait for the Java runtime to startup the first
     time.

     If you ever want to stop the ~fsc~ daemon, you can do so with
     ~$ fsc -shutdown~.

   - After compilation, run it with two arguments:
     ~$ scala Summer of love~

** DONE 4.5 The ~App~ trait - 110
   CLOSED: [2017-10-02 Mon 22:31]
   #+BEGIN_SRC scala
     import ChecksumAccumulator.calculate

     object FallWinterSpringSummer extends App {
       for (season <- List("fall", "winter", "spring"))
         println(season + ": " + calculate(season))
     }
   #+END_SRC
   + No need to write the ~main~ function.
     =TODO= =??? WHY=

   + The object which extends ~App~ can access command-line arguments through
     the array of string ~args~.

** DONE 4.6 Conclusion - 111
   CLOSED: [2017-10-02 Mon 22:31]

* DONE 5 Basic Types and Operations - 112
  CLOSED: [2017-10-20 Fri 21:54]
** DONE 5.1 Some basic types - 112
   CLOSED: [2017-10-05 Thu 05:24]
   - Table 5.1 Some basic types
     | Basic type | Range                                                               |
     |------------+---------------------------------------------------------------------|
     | Byte       | 8-bit signed two's complement integer (-2^7 to 2^7 - 1, inclusive)    |
     | Short      | 16-bit signed two's complement integer (-2^15 to 2^15 - 1, inclusive) |
     | Int        | 32-bit signed two's complement integer (-2^31 to 2^31 - 1, inclusive) |
     | Long       | 64-bit signed two's complement integer (-2^63 to 2^63 - 1, inclusive) |
     | Char       | 16-bit unsigned Unicode character (0 to 2^16 - 1, inclusive)         |
     | String     | a sequence of Chars                                                 |
     | Float      | 32-bit IEEE 754 single-precision float                              |
     | Double     | 64-bit IEEE 754 double-precision float                              |
     | Boolean    | true or false                                                       |

     + Other than ~String~, which resides in package ~java.lang~, all the other
       types shown in Table 5.1 are members of package ~scala~.

   - ~Byte~, ~Short~, ~Int~, ~Long~, and ~Char~ are called /integral types/.

   - The /integral types/ plust ~Float~ and ~Double~ are called /numerical types/.

   - Scala's basic types have the _exact same ranges_ as the corresponding types
     in Java.

     This enables the Scala compiler to transform instances of Scala
     /value types/, such as ~Int~ or ~Double~, down to Java /primitive types/ in
     the bytecodes it produces.

     =TODO= =???= /value types/

** DONE 5.2 Literals - 113
   CLOSED: [2017-10-12 Thu 03:16]
   - literal :: a way to write a constant value directly in code.

   - Scala does NOT support octal literals;
     integer literals that start with a 0, such as 031, do NOT compile.

*** DONE Integer literals
    CLOSED: [2017-10-05 Thu 13:20]
    - Integer literals :: for the types ~Int~, ~Long~, ~Short~, and ~Byte~ come
         in two forms:
      + decimal
      + hexadecimal - begin with ~0x~ or ~0X~

    - If an /integer literal/ ends in an ~L~ or ~l~, it is a ~Long~; otherwise it
      is an ~Int~.

    - NO suffix symbol for the literals of ~Short~ or ~Byte~.
      You must type them manually.
      #+BEGIN_SRC scala
        val little: Short = 367
        val littler: Byte = 38
      #+END_SRC

*** DONE Floating point literals
    CLOSED: [2017-10-05 Thu 20:22]
    - OPTIONALLY containing a decimal point.

    - OPTIONALLY followed by an ~E~ or ~e~ and an exponent.

    - Example
      #+BEGIN_SRC scala
        val big = 1.2345
        // big: Double = 1.2345

        val bigger = 1.2345e1
        // bigger: Double = 12.345

        val biggerStill = 1.23E45
        // biggerStill: Double = 1.23E47
      #+END_SRC

    - Suffixes for ~Float~ literal: ~F~ or ~f~

    - Suffixes for ~Double~ literal: ~D~ or ~d~

*** DONE Character literals
    CLOSED: [2017-10-05 Thu 20:22]
    - Example
      #+BEGIN_SRC scala
        val a = 'A'
        // a: Char = A

        val d = '\u0041'
        // d: Char = A
      #+END_SRC

    - In fact, Unicode characters can appear anywhere in a Scala program.
      #+BEGIN_SRC scala
        val B\u0041\u0044 = 1
        // BAD: Int = 1
      #+END_SRC

      This is not recommended.

    - Table 5.2 Special character literal escape sequences
      | Literal | Meaning                  |
      | ~\n~      | line feed (\u000A)       |
      | ~\b~      | backspace (\u0008)       |
      | ~\t~      | tab (\u0009)             |
      | ~\f~      | form feed (\u000C)       |
      | ~\r~      | carriage return (\u000D) |
      | ~\"~      | double quote (\u0022)    |
      | ~\'~      | single quote (\u0027)    |
      | ~\\~      | backslash (\u005C)       |

    - DB class
      2**(N/B) * ([log2 (N/B)] + 1)

*** DONE String literals
    CLOSED: [2017-10-05 Thu 20:28]
    - string literal :: characters surrounded by double quotes.

    - raw string :: characters surrounded by triple double quotes.

    - You can include anything except triple double quotes inside a /raw string/.
      #+BEGIN_SRC scala
        println("""Welcome to Ultamix 3000.
                   Type "HELP" for help.""")

        // Welcome to Ultamix 3000.
        //            Type "HELP" for help.
      #+END_SRC

    - Get rid of the leading spaces in the example above:
      #+BEGIN_SRC scala
        println("""|Welcome to Ultamix 3000.
                   |Type "HELP" for help.""".stripMargin)

        // Welcome to Ultamix 3000.
        // Type "HELP" for help.
      #+END_SRC

*** DONE Symbol literals
    CLOSED: [2017-10-12 Thu 03:16]
    - symbol literal :: Be written in the pattern of ~'symbolLiteral~, where the
                        sequence after the single quote ~'~ can be any
                        alphanumeric identifier.

    - Symbol literals are mapped to instances of the predefined class
      ~scala.Symbol~. Specifically, the literal ~'symbol~ will be expanded by the
      compiler to a factory method invocation: ~Symbol("symbol")~

    - Application scenario:
      where you would use just an identifier in a dynamically typed language.
      =TODO=

      - There is NOT MUCH you can do with a symbol, except find out its name:
        #+BEGIN_SRC scala
          val s = 'aSymbol
          // 'aSymbol

          val nm = s.name
          // aSymbol     //// a string
        #+END_SRC

      - Noteworthy:
        /symbols/ are /interned/.
        No matter how many times you write down a symbol literals, if they have
        the same sequence after ~'~, they are identical.

*** DONE Boolean literals
    CLOSED: [2017-10-05 Thu 13:36]
** DONE 5.3 String interpolation - 119
   CLOSED: [2017-10-06 Fri 01:45]
   - Example:
     #+BEGIN_SRC scala
       val name = "reader"
       println(s"Hello, $name!")
     #+END_SRC
     + The ~s"Hello, $name!"~ is a processed string literal.

     + The /s interpolator/ will
       1. evaluate each embedded expression
       2. invoke ~toString~ on each result
       3. replace the embedded expressions in the literal with those results

     + Here ~"Hello, reader!"~ is the same result as ~"Hello, " + name + "!"~.

   - In /string literals/, after the ~$~, Scala will interpret all characters up
     to the first non-identifier character as the expression.

     _If the expression includes nonidentifier characters, you must place it in
     curly braces_
     #+BEGIN_SRC scala
       s"The answer is ${6 * 7}."
       // The answer is 42.
     #+END_SRC

   - Two other /string interpolators/ provided by Scala:
     + ~raw~,
       which is like ~s~, except it does NOT recognize /character literal escape
       sequences/.
       #+BEGIN_SRC scala
         "No\\\\escape!"
         // No\\\\escape!
       #+END_SRC

     + ~f~, which allows you to attach printf-style formatting instructions to
       embedded expressions. It use the syntax specified by ~java.util.Formatter~.
       #+BEGIN_SRC scala
         f"${math.Pi}%.5f"
         // 3.14159
       #+END_SRC
       * if no formatting instruction, the ~f string interpolator~ will default
         to ~%s~.

   - In Scala, /string interpolation/ is implemented by rewriting code at compile
     time.

     The compiler will treat any expression consisting of an identifier followed
     immediately by the open double quote of a string literal as a string
     interpolator expression. (=From Jian= Here is also a definition to
     /string interpolation/)

     The ~s~, ~f~, and ~raw~ /string interpolators/ are implemented via this
     general mechanism.

     _Libraries and users can define other string interpolators for other purposes._

** DONE 5.4 Operators are methods - 121
   CLOSED: [2017-10-06 Fri 02:58]
   Scala provides a rich set of operators for its basic types.
   These operators are actually just a nice syntax for ordinary method calls.

   - For example,
     + ~1 + 2~ is actually ~1.+(2)~.
       In fact, ~Int~ contains several /overloaded/ ~+~ methods that take
       different parameter types.

     + ~s~ is a ~String~.
       ~s.indexOf('o')~ can be written as ~s indexOf 'o'~,
       ~s.indexOf('o', 5)~ can be written as ~s indexOf ('o', 5)~

     + ~7.toLong~ can be written as ~7 toLong~

     + ~(2.0).unary_-~ is usually written as ~-0.2~

   - In Scala operators are not special language syntax; any method can be an
     operator.

   - The _ONLY_ identifiers that can be used as /prefix operators/ are ~+~, ~-~,
     ~!~, and ~~~.

     This is why when you see, for example, ~p.unary_*~, you cannot write it as
     ~*p~. It ought to be written as ~*.p~

   - Convetions for no parameter methods:
     + always have ~()~ when a method is used for side effect.
     + call a method without taking ~()~ when no side effect.

** DONE 5.5 Arithmetic operations - 124
   CLOSED: [2017-10-06 Fri 02:00]
   - Example:
     #+BEGIN_SRC scala
       'b' - 'a'
       // 1

       11.0 % 4.0
       // 3.0
     #+END_SRC

   - =TODO= =RE-READ=
     The floating-point remainder you get with ~%~ is NOT the one defined by the
     IEEE 754 standard.

     The IEEE 754 remainder uses rounding division, not truncating division, in
     calculating the remainder, so it is quite different from the integer
     remainder operation.

     If you really want an IEEE 754 remainder, you can call ~IEEEremainder~ on
     ~scala.math~, as in:
     #+BEGIN_SRC scala
       math.IEEEremainder(11.0, 4.0)
       // -1.0
     #+END_SRC

   - The numeric types also offer unary prefix operators ~+~ (method ~unary_+~)
     and ~-~ (method ~unary_-~), which allow you to indicate whether a literal
     number is positive or negative, as in ~-3~ or ~+4.0~.   
     #+BEGIN_SRC scala
       val neg = 1 + -3
       // -2

       val y = +3
       // 3

       -neg
       // 2
     #+END_SRC
     unary ~+~ exists solely for symmetry with unary ~-~, but has NO effect.

** DONE 5.6 Relational and logical operations - 125
   CLOSED: [2017-10-06 Fri 02:04]
   - short-circuit /logic and/ and /logic or/ (as in Java):
     + ~&&~
     + ~||~

   - non-short-circuit /logic and/ and /logic or/:
     + ~&~
     + ~|~

** DONE 5.7 Bitwise operations - 127
   CLOSED: [2017-10-06 Fri 02:09]
   - bitwise-and (~&~), bitwise-or (~|~), and bitwise-xor (~^~).

   - unary bitwise complement operator: ~~~, the method ~unary_~~

   - shift left (~<<~)
     shift righ (~>>~) 
     unsigned shift righ (~>>>~) 

** DONE 5.8 Object equality - 128
   CLOSED: [2017-10-06 Fri 02:18]
   - Use ~==~ and ~!=~

     You can even use them to compare against ~null~.
     NO exception will be throw, even if it seems ~null~ is the receiver.
     #+BEGIN_SRC scala
       List(1, 2, 3) == null
       // false


       null == List(1, 2, 3)
       // false
     #+END_SRC

     In the backgound, ~==~ first do ~null~ check to the receiver, and then call
     the ~equals~ method with the right hand side value.

   - =IMPORTANT=
     How Scala's ~==~ differs from Java's
     + Java's ~==~ do /value equality/ check for primitive type values.
       Java's ~==~ do /reference equality/ check for objects.

     + Scala's ~==~ is always used to do /value equality/ check.
       Scala's ~==~ use ~eq~ and ~ne~ to do /reference equality/ check.

       =TODO= Section 11.1 and 11.2

** DONE 5.9 Operator precedence and associativity - 130
   CLOSED: [2017-10-20 Fri 21:50]
   - Given that Scala doesn't have operators, per se, just a way to use methods
     in operator notation.

   - _Scala decides precedence based on the first character of the methods used in
     operator notation_ (there’s one exception to this rule) =TODO=

   - Table 5.3 Operator precedence =IMPORTANT=
     | (all other special characters) |
     | * / %                          |
     | + -                            |
     | :                              |
     | \equal{} !                            |
     | < >                            |
     | &                              |
     | ^                              |
     | \vert{}                              |
     | (all letters)                  |
     | (all assignment operators)     |

   - ONE EXCEPTION: /assignment operators/, which end in an equals character:
     If an operator ends in an equals character (~=~), and the operator is NOT
     one of the comparison operators ~<=~, ~>=~, ~==~, or ~!=~, then the
     precedence of the operator is the same as that of simple assignment (~=~).

   - The /associativity/ of an operator in Scala is determined by its
     _LAST character_.

   - NO MATTER what /associativity/ an operator has, however, its operands are
     _always evaluated left to right_.

   - If ~a~ is an expression that is _NOT_ just a simple reference to an
     immutable value, then ~a ::: b~ is more precisely treated as the following
     block: ~{ val x = a; b.:::(x) }~

   - This /associativity/ rule also plays a role when multiple operators of the
     _SAME precedence_ appear side by side.

     If the methods _end in_ ~:~, they are _grouped right to left_;
     otherwise, they are _grouped left to right_.
       For example, ~a ::: b ::: c~ is treated as ~a ::: (b ::: c)~.
     But ~a * b * c~, by contrast, is treated as ~(a * b) * c~.

** DONE 5.10 Rich wrappers - 133
   CLOSED: [2017-10-06 Fri 03:02]
   In Scala, you can call many more methods on its basic types than in Java.
   The reasons are:
   1. Scala defines "rich wrapper" classes for these types.

   2. Scala uses /implicit conversions/, and convert Java basic types to its
      class with "rich wrapper". Then more methods can be used.
      =TODO= /implicit conversions/ - Chapter 21

** DONE 5.11 Conclusion - 133
   CLOSED: [2017-10-20 Fri 21:54]
   =TODO=

* DONE 6 Functional Objects - 135
  CLOSED: [2017-10-07 Sat 17:49]
** DONE 6.1 A specification for class ~Rational~ - 135
   CLOSED: [2017-10-07 Sat 16:12]
   - At the end of this chapter you'll be able to do this with class ~Rational~:
     #+BEGIN_SRC scala
       val oneHalf = new Rational(1, 2)
       // onehalf: Rational = 1/2

       val twoThirds = new Rational(2, 3)
       // twoThirds: Rational = 2/3

       (oneHalf / 7) + (1 - twoThirds)
       // res0: Rational = 17/42
     #+END_SRC

** DONE 6.2 Constructing a ~Rational~ - 136
   CLOSED: [2017-10-07 Sat 16:12]
   - The Scala compiler will compile any code you place in the class body, which
     isn't part of a field or a method definition, into the primary constructor.
     #+BEGIN_SRC scala
       class Rational(n: Int, d: Int) {
         println("Created " + n + "/" + d)
       }

       new Rational(1, 2)
       // print out // Created 1/2
       // Rational@2591e0c9
     #+END_SRC

** DONE 6.3 Reimplementing the ~toString~ method - 138
   CLOSED: [2017-10-07 Sat 16:12]
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       override def toString = n + "/" + d
     }
   #+END_SRC

** DONE 6.4 Checking preconditions - 139
   CLOSED: [2017-10-07 Sat 16:14]
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       require(d != 0)
       override def toString = n + "/" + d
     }
   #+END_SRC
   - If ~d != 0~ is ~false~, an ~IllegalArgumentException~ will be thrown out.

** DONE 6.5 Adding fields - 139
   CLOSED: [2017-10-07 Sat 16:22]
   - The code before this section doesn't make the passed in ~n~ and ~d~ be
     fields.
     #+BEGIN_SRC scala
       // This will NOT compile
       class Rational(n: Int, d: Int) {
         require(d != 0)

         override def toString = n + "/" + d

         def add(that: Rational): Rational =
           new Rational(n * that.d + that.n * d, d * that.d)
       }

       // When compile
       // <console>:11: error: value d is not a member of Rational
       //            new Rational(n * that.d + that.n * d, d * that.d)
       //                                  ˆ
       // <console>:11: error: value d is not a member of Rational
       //            new Rational(n * that.d + that.n * d, d * that.d)
       //                                                           ˆ
     #+END_SRC

   - To create two fields for a ~Rational~ class:
     #+BEGIN_SRC scala
       class Rational(n: Int, d: Int) {
         require(d != 0)
         val numer: Int = n
         val denom: Int = d

         override def toString = numer + "/" + denom

         def add(that: Rational): Rational =
           new Rational(
             numer * that.denom + that.numer * denom,
             denom * that.denom
           )
       }
     #+END_SRC
     =TODO= In Section 10.6 you'll find out about /parametric fields/, which
     provide a shorthand for writing the same code. 

** DONE 6.6 Self references - 141
   CLOSED: [2017-10-07 Sat 16:24]
   ~this~
** DONE 6.7 Auxiliary constructors - 142
   CLOSED: [2017-10-07 Sat 16:33]
   - auxiliary constructors :: constructors other than the primary constructor.

   - /Auxiliary constructors/ in Scala start with ~def this(...).~ 

   - Example
     #+BEGIN_SRC scala
       class Rational(n: Int, d: Int) {
         require(d != 0)
         val numer: Int = n
         val denom: Int = d

         def this(n: Int) = this(n, 1) // auxiliary constructor

         override def toString = numer + "/" + denom

         def add(that: Rational): Rational =
           new Rational(
             numer * that.denom + that.numer * denom,
             denom * that.denom
           )
       }
     #+END_SRC

   - In Scala, _EVERY_ /auxiliary constructor/ _MUST_ invoke another constructor
     of the same class _as its FIRST action_.
       In other words, the first statement in every /auxiliary constructor/ in
     every Scala class will have the form ~this(...)~.

     The net effect of this rule is that _EVERY_ constructor invocation in Scala
     will _end up eventually_ calling the /primary constructor/ of the class.

     The /primary constructor/ is thus _the single point of entry_ of a class.

   - The rule about constructor for Scala is more restrictive than Java's:
     + In Java, a constructor must either invoke another constructor of the same
       class, or directly invoke a constructor of the superclass, as its first
       action.

     + In Scala, ONLY the /primary constructor/ can invoke a superclass
       constructor.

** DONE 6.8 Private fields and methods - 144
   CLOSED: [2017-10-07 Sat 16:37]
   - Normalize a fraction to its equivalent reduced form (e.g. 66/42 -> 11/7):
     #+BEGIN_SRC scala
       class Rational(n: Int, d: Int) {
         require(d != 0)
         private val g = gcd(n.abs, d.abs)
         val numer = n / g
         val denom = d / g

         def this(n: Int) = this(n, 1)

         def add(that: Rational): Rational =
           new Rational(
             numer * that.denom + that.numer * denom,
             denom * that.denom
           )

         override def toString = numer + "/" + denom

         private def gcd(a: Int, b: Int): Int =
           if (b == 0) a else gcd(b, a % b)
       }
     #+END_SRC
     + Use ~g~ to modify the /initializers/.

** DONE 6.9 Defining operators - 145
   CLOSED: [2017-10-07 Sat 16:46]
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       require(d != 0)

       private val g = gcd(n.abs, d.abs)
       val numer = n / g
       val denom = d / g

       def this(n: Int) = this(n, 1)

       def + (that: Rational): Rational =
         new Rational(
           numer * that.denom + that.numer * denom,
           denom * that.denom
         )

       def * (that: Rational): Rational =
         new Rational(numer * that.numer, denom * that.denom)

       override def toString = numer + "/" + denom

       private def gcd(a: Int, b: Int): Int =
         if (b == 0) a else gcd(b, a % b)
     }


     val x = new Rational(1, 2)
     val y = new Rational(2, 3)

     // About the precedence
     x + x + y
     // 5/6

     (x + x) * y
     // 2/3

     x + (x * y)
     // 5/6
   #+END_SRC

   - Read Section 5.9 for more about the /operator precedence/ topic.
     =TOOD=

** DONE 6.10 Identifiers in Scala - 147
   CLOSED: [2017-10-07 Sat 17:39]
   - alphanumeric identifier :: its definition is like the /identifier/ defintion
        of the C language.

        Only one difference, you can use ~$~ as a letter.
        _However_, ~$~ is used by the compiler. Programmers shouldn't create
        identifiers with ~$~ inside, which might lead to name clashes with
        identifiers generated by the Scala compiler. Though this will never
        affect the process of compilation, it will affect the correctness of the
        result of compilation.

   - Camel-case names of /fields/, /method parameters/, /local variables/, and
     /functions/ should start with a _lower case_ letter;

     Camel-case names of /classes/ and /traits/ should start with an _UPPER case_
     letter.

   - You shouldn't use _trailing underscore identifiers_, for some reason
     (=TODO=) ~val name_: Int = 1~ will trigger an compilation error, and the
     compiler thinks you create a name ~name_:~, rather than ~name_~.

     In this case, if you still want to create a ~name_~ name, you must add a
     space before ~:~.

   - ~val~'s remain constant after it is initialized, it is still a variable.
     For example, method parameters are used as ~val~ (though not write ~val~
     explicitly), the change everytime you call this method.

     A constant is more permanent. The naming convention of constant in Scala is
     the same as class names.

     Comparison between Java and Scala constant names convetion:
     + Java - ~X_OFFSET~

     + Scala - ~XOffset~

   - operator characters :: printable ASCII characters such as +, :, ?, ~ or #.

        =TODO= =Re-Read=
        Footnote 7: More precisely, an operator character belongs to the Unicode
        set of mathematical symbols(Sm) or other symbols(So), or to the 7-bit
        ASCII characters that are not letters, digits, parentheses, square
        brackets, curly braces, single or double quote, or an underscore,
        period, semi-colon, comma, or back tick character.

   - operator identifier :: it consists of one or more operator characters.

   - The Scala compiler will internally "mangle" /operator identifiers/ to turn
     them into legal Java identifiers with embedded ~$~ characters.

     For instance, the identifier ~:->~ would be represented internally as
     ~$colon$minus$greater~.

     If you ever wanted to access this identifier from Java code, you'd need to
     use this internal representation.

   - Because operator identifiers in Scala can become arbitrarily long, there is
     a small difference between Java and Scala. =TODO= =WHY=

     In Java, the input ~x<-y~ would be parsed as _four_ lexical symbols, so it
     would be equivalent to ~x < - y~.

     In Scala, ~<-~ would be parsed as a single identifier, giving ~x <- y~.

     If you want the first interpretation, you need to separate the ~<~ and ~-~
     the characters by a space.

     NOT a problem in practice.
     =TODO=

   - mixed identifier :: consists of an /alphanumeric identifier/, which is
        followed by an _underscore_ and an /operator identifier/.

        =TODO= MUST be an underscore and an operator indentifier ???????

     For example,
     + ~unary_+~
     + ~myvar_=~

     In addition, the /mixed identifier/ form ~myvar_=~ is generated by the Scala
     compiler to support /properties/ (more on that in Chapter 18).
     =TOOD=

   - literal identifier :: an ARBITRARY string enclosed in _back ticks_.
        For instance, ~`x`~, ~`<clinit>`~, ~`yield`~

     A typical use case is accessing the static ~yield~ method in Java's ~Thread~
     class. You cannot write ~Thread.yield()~ in Scala because ~yield~ is a
     /reserved word/ in Scala. However, you can still name the method in back
     ticks, e.g., ~Thread.`yield`()~.

** DONE 6.11 Method overloading - 150
   CLOSED: [2017-10-07 Sat 16:56]
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       require(d != 0)

       private val g = gcd(n.abs, d.abs)
       val numer = n / g
       val denom = d / g

       def this(n: Int) = this(n, 1)

       def + (that: Rational): Rational =
         new Rational(
           numer * that.denom + that.numer * denom,
           denom * that.denom
         )

       def + (i: Int): Rational =
         new Rational(numer + i * denom, denom)

       def - (that: Rational): Rational =
         new Rational(
           numer * that.denom - that.numer * denom,
           denom * that.denom
         )

       def - (i: Int): Rational =
         new Rational(numer - i * denom, denom)

       def * (that: Rational): Rational =
         new Rational(numer * that.numer, denom * that.denom)

       def * (i: Int): Rational =
         new Rational(numer * i, denom)

       def / (that: Rational): Rational =
         new Rational(numer * that.denom, denom * that.numer)

       def / (i: Int): Rational =
         new Rational(numer, denom * i)

       override def toString = numer + "/" + denom

       private def gcd(a: Int, b: Int): Int =
         if (b == 0) a else gcd(b, a % b)
   #+END_SRC
** DONE 6.12 Implicit conversions - 152
   CLOSED: [2017-10-07 Sat 17:49]
   After finishing the method overloading in section 6.11, you can do ~r * 2~,
   but you cannot do ~2 * r~, of which the /receiver/ ~2~ doesn't have a
   overloaded method ~*~ with parameter type ~Rational~.

   Solution: You can create an /implicit conversion/ that automatically converts
   integers to rational numbers when needed.
   #+BEGIN_SRC scala
     implicit def intToRational(x: Int) = new Rational(x)

     // The you can do:

     val r = new Rational(2, 3)
     2 * r
     // 4/3

   #+END_SRC
   - An /implicit conversion/ works only when it's in scope.

   - If you place this /implicit method/ definition inside class ~Rational~, it
     will _NOT_ be in scope in the interpreter.

** DONE 6.13 A word of caution - 153
   CLOSED: [2017-10-07 Sat 17:44]
** DONE 6.14 Conclusion - 153
   CLOSED: [2017-10-07 Sat 17:42]
   - _TODO_: Chapter 30 - override ~equals~ and ~hashcode~

   - _TODO_: Chapter 21 - place implicit method definitions in a companion object
     for ~Rational~ so they can be more easily placed into scope when client
     programmers are working with Rationals.

* DONE 7 Built-in Control Structures - 155
  CLOSED: [2017-10-21 Sat 12:02]
  Programmers can use these result values to simplify their code, just as they
  use return values of functions. Without this facility, the programmer must
  create temporary variables just to hold results that are calculated inside a
  control structure. Removing these temporary variables makes the code a little
  simpler, and it also prevents many bugs where you set the variable in one
  branch but forget to set it in another.

  =From Jian= In Java, if not use the API added by Java 8 and 9, we often need
  to set a object value ~null~.

** DONE 7.1 If expressions - 156
   CLOSED: [2017-10-09 Mon 02:23]
   - equational reasoning :: with /reference transparency/ and /substitution
        rule/, we can do /equational reasoning/.

   - Compare the imperative way and the functional way of using ~if~:
     #+BEGIN_SRC scala
       var filename_i = "default.txt"
       if (!args.isEmpty)
         filename_i = args(0)

       val filename =
         if (!args.isEmpty) args(0)
         else "default.txt"
     #+END_SRC

   - Two advantages:
     + Use ~val~
     + Support /equational reasoning/

** DONE 7.2 While loops - 157
   CLOSED: [2017-10-09 Mon 02:41]
   - ~while~ and ~do ... while~. The type of their results is ~Unit~.
     They are imperative.
     #+BEGIN_SRC scala
       def gcdLoop(x: Long, y: Long): Long = {
         var a = x
         var b = y
         while (a != 0) {
           val temp = a
           a = b % a
           b = temp
         }
       }
  
       var line = ""
       do {
         line = readLine()
         println("Read: " + line)
       } while (line != "")
     #+END_SRC

   - The functional way (no ~while~ / ~do ...while~, and use recursion):
     #+BEGIN_SRC scala
       def gcd(x: Long, y: Long): Long =
         if (y == 0) x else gcd(y, x % y)
     #+END_SRC

** DONE 7.3 For expressions - 160
   CLOSED: [2017-10-09 Mon 03:32]
   ~for~ is versatile
*** DONE Iteration through collections
    CLOSED: [2017-10-09 Mon 03:14]
    - Examples
      #+BEGIN_SRC scala
        val filesHere: Array[File] = (new java.io.File(".")).listFiles

        for (file <- filesHere)
          println(file)
      #+END_SRC
      + The ~file <- filesHere~ syntax is called /generator/.

      #+BEGIN_SRC scala
        for (i <- 1 to 4)
          println("Iteration " + i)
      #+END_SRC
      + Use range ~1 to 4~

      + Use range that exclusive ~1 until 4~

*** DONE Filtering
    CLOSED: [2017-10-09 Mon 03:14]
    - One filter:
      #+BEGIN_SRC scala
        for (file <- filesHere if file.getName.endsWith(".scala"))
          println(file)
      #+END_SRC

    - Multiple filters:
      #+BEGIN_SRC scala
        for (
          file <- filesHere
          if file.isFile
          if file.getName.endsWith(".scala")
        ) println(file)
      #+END_SRC

*** DONE Nested iteration
    CLOSED: [2017-10-09 Mon 03:19]
    #+BEGIN_SRC scala
      def fileLines(file: java.io.File) =
        scala.io.Source.fromFile(file).getLines().toList

      def grep(pattern: String) =
        for (
          file <- filesHere
          if file.getName.endsWith(".scala");
          line <- fileLines(file)
          if line.trim.matches(pattern)
        ) println(file + ": " + line.trim)

      grep(".*gcd.*")
    #+END_SRC
    Pay attentoin to the location of ~;~

*** DONE Mid-stream variable bindings
    CLOSED: [2017-10-09 Mon 03:25]
    #+BEGIN_SRC scala
      def grep(pattern: String) =
        for {
          file <- filesHere
          if file.getName.endsWith(".scala")
          line <- fileLines(file)
          trimmed = line.trim
          if trimmed.matches(pattern)
        } println(file + ": " + trimmed)

      grep(".*gcd.*")
    #+END_SRC

*** DONE Producing a new collection
    CLOSED: [2017-10-09 Mon 03:32]
    #+BEGIN_SRC scala
      def scalaFiles =
        for {
          file <- filesHere
          if file.getName.endsWith(".scala")
        } yield file
    #+END_SRC

    The output collection type is the same as the input collection type, for
    instance, ~Array~ in ~Array~ out, and ~List~ in ~List~ out.

** DONE 7.4 Exception handling with ~try~ expressions - 165
   CLOSED: [2017-10-09 Mon 04:04]
*** DONE Throwing exceptions
    CLOSED: [2017-10-09 Mon 03:39]
    - ~throw~ is an expression that has a result type.
      #+BEGIN_SRC scala
        val half =
          if (n % 2 == 0)
            n / 2
          else
            throw new RuntimeExpression("n must be even")
      #+END_SRC
      + Technically, an exception throw has type ~Nothing~.
      + You can use a ~throw~ as an expression even though it will _NEVER actual-
        ly evaluate to anything_. =TOOD=
      + Type ~Nothing~ is discussed further in Section 11.3. =TODO=

*** DONE Catching exceptions
    CLOSED: [2017-10-09 Mon 03:50]
    - Scala's ~catch~ always uses /pattern matching/.
      #+BEGIN_SRC scala
        import java.io.FileReader
        import java.io.FileNotFoundException
        import java.io.IOException

        try {
          val f = new FileReader("input.txt")
          // Use and close file
        } catch {
          case ex: FileNotFoundException => ??? // Handle missing file
          case ex: IOException => ??? // Handl other I/O error
        }
      #+END_SRC

    - _Note_
      One difference you'll quickly notice in Scala is that, _UNLIKE_ Java,
      Scala does _NOT_ require you to ~catch~ /checked exceptions/ or _declare_
      them in a ~throws~ (Scala doesn't have this) clause.

      You can declare a /throws clause/ if you wish with the ~@throws~
      annotation, but it is not required. See Section 31.2 for more information
      on ~@throws~. =TODO=

    - =From Jian= Need to know more about Java's /checked exceptions/.

*** DONE The ~finally~ clause
    CLOSED: [2017-10-09 Mon 03:55]
    #+BEGIN_SRC scala
      import java.io.FileReader

      val file = new FileReader("input.txt")
      try {
        // Use the file
      } finally {
        file.close()  // Be sure to close the file
      }
    #+END_SRC

    - *Note*
      Listing 7.12 shows the idiomatic way to ensure a non-memory resource, such
      as a file, socket, or database connection, is closed. First you acquire
      the resource. Then you start a try block in which you use the resource.
      Lastly, you close the resource in a finally block. This idiom is the same
      in Scala as in Java;

      =TODO=
      alternatively, in Scala you can employ a technique called the
      /loan pattern/ to achieve the same goal more concisely. The loan pattern
      will be described in Section 9.4.

*** DONE Yielding a value
    CLOSED: [2017-10-09 Mon 04:02]
    - If you're familiar with Java, it’s worth noting that Scala’s behavior differs
      from Java only because Java’s ~try-finally~ does not result in a value. As
      in Java, if a finally clause includes an explicit return statement, or
      throws an exception, that return value or exception will “overrule” any
      previous one that originated in the try block or one of its catch clauses.
      For example, given this, rather contrived, function definition:
      =See Java specification or the book Java Puzzler=
      + code
        #+BEGIN_SRC scala
          // Always return 2
          def f(): Int = try return 1 finally return 2

          // Always return 1
          def g(): Int = try 1 finally 2
        #+END_SRC

      You usually don't want to return value in ~finally~ block.

** DONE 7.5 Match expressions - 169
   CLOSED: [2017-10-09 Mon 04:07]
** DONE 7.6 Living without ~break~ and ~continue~ - 171
   CLOSED: [2017-10-21 Sat 11:38]
   - The simplest and most straightfoward approach is to replace
     + every ~continue~ by an no-else ~if~
       (a ~if~ with side effect)

     + every ~break~ by a /boolean variable/ that indicates whether the enclosing
       ~while~ loop should continue
       (~var~ is required)

   - For example,
     + Original version (Java)
       #+BEGIN_SRC java
         int i = 0;
         boolean foundIt = false;

         while (i < args.length) {
             if (args[i].startsWith("-")) {
                 i = i + 1;
                 continue;
             }

             if (args[i].endsWith(".scala")) {
                 foundIt = true;
                 break;
             }

             i = i + 1;
         }
       #+END_SRC

     + No ~break~ No ~continue~ version (Scala)
       #+BEGIN_SRC scala
         var i = 0
         var foundIt = false

         while (i < args.length && !foundIt) {
           if (!args(i).startsWith("-")) {
             if (args(i).endsWith(".scala")) {
               foundIt = true
             }
           }
           i = i + 1
         }
       #+END_SRC

     + Even no ~var~ version (Scala)
       #+BEGIN_SRC scala
         def searchFrom(i: Int): Int =
           if (i >= args.length) -1
           else if (args(i).startsWith("-")) searchFrom(i + 1)
           else if (args(i).endsWith(".scala")) i
           else searchFrom(i + 1)

         val i = searchFrom(0)
       #+END_SRC
       /tail-calls/ are optimized automatically. =TODO= Section 8.9

   - The is no keyword ~break~ in Scala.
     If you still want to use it, use the class ~Breaks~ in the package
     ~scala.util.control~, which offers a ~break~ method and can be used to exit
     an enclosing block that's marked with ~breakable~.

     For exmaple, a program that repeatedly read non-empty lines from the
     standard input.
     #+BEGIN_SRC scala
       import scala.util.control.Breaks._
       import java.io._

       val in = new BufferedReader(new InputStreamReader(System.in))

       breakable {
         while (true) {
           println("? ")
           if (in.readLine() == "") break
         }
       }
     #+END_SRC

   - The ~Breaks~ class implements ~break~ _by throwing an exception_ that is
     caught by an enclosing application of the ~breakable~ method.

     Therefore, the call to ~break~ does NOT need to be in the same method as
     the call to ~breakable~. =TODO= =???=

** DONE 7.7 Variable scope - 173
   CLOSED: [2017-10-21 Sat 11:51]
   - It is almost identical to Java. Only one exception:
     + you can define variables of the same name in nested scopes.

   - One thing is also can be considered as a "exception":
     + Sometimes you use curly braces in place of parentheses.
       In this case, you won't create a new scope

   - The REPL is special, whe you type in REPL that
     #+BEGIN_SRC scala
       scala> val a = 1
       scala> val a = 2
       scala> println(a)  // 2
     #+END_SRC

     It acutally implicitly help you create nested code (scope):
     #+BEGIN_SRC scala
       val a = 1
       {
         val a = 2
         {
           println(a)
         }
       }
     #+END_SRC

** DONE 7.8 Refactoring imperative-style code - 177
   CLOSED: [2017-10-21 Sat 12:02]
   A functional way to create a multiplication table (see the last section for
   the imperative way version)
   #+BEGIN_SRC scala
     // Returns a row as a sequence
     def makeRowSeq(row: Int) =
       for (col <1
            to 10) yield {
         val prod = (row * col).toString
         val padding = " " * (4 prod.
                                length)
         padding + prod
       }
     // Returns a row as a string
     def makeRow(row: Int) = makeRowSeq(row).mkString
     // Returns table as a string with one row per line
     def multiTable() = {
       val tableSeq = // a sequence of row strings
         for (row <1
              to 10)
         yield makeRow(row)
       tableSeq.mkString("\n")
     }
   #+END_SRC

** DONE 7.9 Conclusion - 179
   CLOSED: [2017-10-21 Sat 12:02]

* DONE 8 Functions and Closures - 180
  CLOSED: [2017-10-09 Mon 19:57]
  In fact, Scala offers several ways to define functions that are _NOT present_
  in Java.
  + methods :: functions that are members of some object
  + nested functions
  + function literals
  + function values
  + ???

** DONE 8.1 Methods - 180
   CLOSED: [2017-10-09 Mon 04:22]
   #+BEGIN_SRC scala
     import scala.io.Source

     object LongLines {
       def processFile(filename: String, width: Int) = {
         val source = Source.fromFile(filename)
         for (line <- source.getLines())
           processLine(filename, width, line)
       }

       private def processLine(filename: String,
                               width: Int, line: String) = {
         if (line.length > width)
           println(filename + ": " + line.trim)
       }
     }

     object FindLongLines {
       def main(args: Array[String]) = {
         val width = args(0).toInt
         for (arg <- args.drop(1))
           LongLines.processFile(arg, width)
       }
     }
   #+END_SRC

   - The concept of a /function/ in Scala is more general than a /method/.
     =TODO=
     Scala's other ways to express functions will be explained in the following
     sections.

** DONE 8.2 Local functions - 182
   CLOSED: [2017-10-09 Mon 04:24]
** DONE 8.3 First-class functions - 184
   CLOSED: [2017-10-09 Mon 04:35]
   - A /function literal/ is compiled into a class that when instantiated at
     runtime is a /function value/.

     Thus the _distinction_ between /function literals/ and /values/:
     + /function literals/ exist _in the source code_,
       whereas
     + /function values/ exist as /objects/ _at runtime_.

     The distinction is much like that between /classes/ (source code) and
     /objects/ (runtime).

   - footnote 2:
     Every /function value/ is an instance of some class that extends one of
     several ~FunctionN~ traits in package scala, such as ~Function0~ for
     functions with no parameters, ~Function1~ for functions with one parameter,
     and so on.

     =From Jian= The string represention of a ~FunctionN~ type /function value/
     is ~<functionN>~

     Each ~FunctionN~ trait has an ~apply~ method used to invoke the function.

   - Examples:
     #+BEGIN_SRC scala
       val someNumbers = List(-11, -10, -5, 0, 5, 10)

       someNumbers.foreach((x: Int) => println(x))
       // -11
       // -10
       // -5
       // 0
       // 5
       // 10

       someNumbers.filter((x: Int) => x > 0)
       // List(5, 10)
     #+END_SRC

** DONE 8.4 Short forms of function literals - 186
   CLOSED: [2017-10-09 Mon 04:38]
   - target typing :: ...
                      type inference related -- you don't always need to
                      explicitly type the parameter(s).

   - No parenthese required for single input parameter that no explicit type.

** DONE 8.5 Placeholder syntax - 187
   CLOSED: [2017-10-09 Mon 04:50]
   - One parameter: ~someNumbers.filter(_ > 0)~

   - Multiple parameters:
     #+BEGIN_SRC scala
     val f = (_: Int) + (_: Int)
     #+END_SRC
     + If these parameters are NOT typed, a compilation error will happen.

     + Multiple underscores mean multiple parameters, NOT reuse of a single
       parameter repeatedly, and use them in the input order.

** DONE 8.6 Partially applied functions - 188
   CLOSED: [2017-10-09 Mon 19:57]
   - You could write ~someNumbers.foreach(println _)~, rather than
     + ~someNumbers.foreach(x => println(x))~
     + ~someNumbers.foreach(println(_))~

     Thus, the underscore in this case is
     + NOT a placeholder for a single parameter.
     + but a placeholder for an entire parameter list.

     When you use an underscore in this way, you are writing a /partially applied
     function/.

   - ~val b = sum(1, _: Int, 3)~

   - You can only use a function as a parameter directly in the place where the
     compiler knows a function is required:
     ~someNumbers.foreach(println)~

     However, ~val c = sum~ is illegal. You must write it in the way
     + ~val d = sum _~
       or
     + (=From Jian=) ~val d: (Int, Int, Int) => Int = sum~

     to tell the compiler ~d~ is a function.

** DONE 8.7 Closures - 191
   CLOSED: [2017-10-09 Mon 19:02]
   - free variable ::

   - bound variable ::

   - closure ::

   - closed term :: a function literal with no /free variables/, such as
                    ~(x: Int) => x + 1~

   - open term :: a function literal with /free variables/, such as
                  ~(x: Int) => x + more~

   - The /free variables/ can be both ~val~ or ~var~.
     =From Jian= this is different from Java.

** DONE 8.8 Special function call forms - 195
   CLOSED: [2017-10-09 Mon 05:16]
*** DONE Repeated parameters
    CLOSED: [2017-10-09 Mon 05:16]
    - Scala allows you to indicate that _the LAST parameter_ to a function may be
      _repeated_.

      Example:
      #+BEGIN_SRC scala
        def echo(args: String*) =
          for (arg <- args) println(arg)

        // echo: (args: String*)Unit
      #+END_SRC

      Inside the function, the type of the repeated parameter is an ~Array~ of
      the declared type of the parameter.

    - You can also pass an array of the appropriate type paremeters to a function
      that accept repeated paraemters. To accomplish this, use ~_*~
      #+BEGIN_SRC scala
        val arr = Array("What's", "up", "doc?")

        echo(arr: _*)
      #+END_SRC
      This ~_*~ tells the compiler to pass the element in this array
      one by one individually, not like an array.

*** DONE Named arguments
    CLOSED: [2017-10-09 Mon 05:07]
    #+BEGIN_SRC scala
      def speed(distance: Float, time: Float): Float =
        distance / time

      speed(100, 10)
      // 10.0

      speed(distance = 100, time = 10)
      // 10.0

      speed(time = 10, distance = 100)
      // 10.0
    #+END_SRC

    - =IMPORTANT=
      It is also possible to mix positional and named arguments.
      In that case, the positional arguments come first.

      Named arguments are most frequently used in combination with
      /default parameter values/.

*** DONE Default parameter values
    CLOSED: [2017-10-09 Mon 05:10]
    #+BEGIN_SRC scala
      def printTime(out: java.io.PrintStream = Console.out) =
        out.println("time = " + System.currentTimeMillis())
    #+END_SRC

    - /Default parameters/ are especially helpful when used in combination with
      /named parameters/.

** DONE 8.9 Tail recursion - 198
   CLOSED: [2017-10-09 Mon 19:46]
   - tail recursive ::

*** DONE Tracing tail-recursive functions
    CLOSED: [2017-10-09 Mon 19:31]
    - *Tail call optimization*

    - Example (=From Jian= I can't see stack info like this):
      #+BEGIN_SRC scala
        def bang(x: Int): Int =
          if (x == 0) throw new Exception("bang!")
          else bang(x - 1)

        // Only one stack
        bang(5)
        // java.lang.Exception: bang!
        //   at .bang(<console>:5)
        //   at .<init>(<console>:6) ...


        // scalac with `-g:notailcalls`
        bang(5)
        // java.lang.Exception.Exception: bang!
        //       at .bang(<console>:5)
        //       at .bang(<console>:5)
        //       at .bang(<console>:5)
        //       at .bang(<console>:5)
        //       at .bang(<console>:5)
        //       at .bang(<console>:5)
        //       at .<init>(<console>:6)
      #+END_SRC

*** DONE Limits of tail recursion
    CLOSED: [2017-10-09 Mon 19:44]
    The use of tail recursion in Scala is fairly limited because the JVM
    instruction set makes implementing more advanced forms of tail recursion
    very difficult.

    - Scala only optimizes directly recursive calls.
      It can't optimize mutually recursive functions.

    - You also won't get a tail-call optimization if the final call goes to a
      function value.
      #+BEGIN_SRC scala
        val funValue = nestedFun _

        def nestedFun(x: Int): Unit = {
          if (x != 0) {
            println(x)
            funValue(x - 1)
          }
        }
      #+END_SRC

    - Tail-call optimization is limited to situations where a method or nested
      function calls itself directly as its last operation, without going through
      a function vlaue or some other intermediary.

      =TODO= See Section 8.9 for more

** DONE 8.10 Conclusion - 202
   CLOSED: [2017-10-09 Mon 19:49]

* DONE 9 Control Abstraction - 203
  CLOSED: [2017-10-09 Mon 23:01]
 - Show you how to apply function values to create new control abstractions.

 - Learn about currying and by-name parameters.

** DONE 9.1 Reducing code duplication - 203
   CLOSED: [2017-10-09 Mon 20:21]
   - Non-higher-order functions compose
     + its common part (the no-change source code)
     + its non-common part (the passed in non-function values)

     It represent one algorithm

   - Higher-order functions compose
     + its common part (the no-change source code)
     + its non-common part (the passed in function values)

     _It represent one family of algorithms_:
       The common part is a kind of algorithm, and passed in function values
     also have other algorithms (which can be different every time you invoke
     this higher-order functions). This is why higher-order functions have extra
     capacity of expressiveness.

   - One benefit of higher-order functions is they enable you to create control
     abstractions that allow you to reduce code duplication.

   - Example:
     #+BEGIN_SRC scala
       object FileMatcher {
         private def filesHere = (new java.io.File(".")).listFiles

         private def filesMatching(matcher: String => Boolean) =
           for (file <filesHere;
                if matcher(file.getName))
           yield file

         def filesEnding(query: String) =
           filesMatching(_.endsWith(query))

         def filesContaining(query: String) =
           filesMatching(_.contains(query))

         def filesRegex(query: String) =
           filesMatching(_.matches(query))
       }
     #+END_SRC

** DONE 9.2 Simplifying client code - 207
   CLOSED: [2017-10-09 Mon 21:39]
   The previous example demonstrated that higher-order functions can help reduce
   code duplication as you implement an API.
   _Create an API with higher-order functions_

   Another important use of higher-order functions is to put them in an API
   itself to make client code more concise.
   _Use an higher-order function API to simplify you code_

   For instance, use the special-purpose looping methods of Scala's collection
   types:

   - use ~def containsNeg(nums: List[Int]) = nums.exists(_ < 0)~,
     rahter than define the body with loop and ~var~.

   - special-purpose looping :: (Many of these are listed in Table 3.1)
        (footnote 1: These special-purpose looping methods are defined in trait
         ~Traversable~, which is extended by ~List~, ~Set~, and ~Map~.
         =TODO= See Chapter 17 for a discussion.)

** DONE 9.3 Currying - 209
   CLOSED: [2017-10-09 Mon 20:55]
   - Use /currying/ you can make /control abstractions/ that you created feel
     more like language extensions.

   - Non-currying and currying:
     #+BEGIN_SRC scala
       def plainOldSum(x: Int, y: Int) = x + y

       plainOldSum(1, 2)


       def curriedSum(x: Int)(y: Int) = x + y

       curriedSum(1)(2)
     #+END_SRC

   - Create essential currying functions with or without /currying/ syntax:
     #+BEGIN_SRC scala
       def first(x: Int) = (y: Int) => x + y
       // first: (x: Int)Int => Int

       val second = first(1)
       // second: Int => Int = <funciton1>

       second(2)
       // 3


       val onePlus = curriedSum(1)_
       // oneplus: Int => Int = <function1>

       onePlus(2)
       // 3
     #+END_SRC

     =IMPORTANT= You can see the difference: The function created use the
     currying syntax when not fully applied, must use the
     ~partially applied function~ syntax.

** DONE 9.4 Writing new control structures - 211
   CLOSED: [2017-10-09 Mon 22:48]
   - loan pattern ::

   - The original version:
     #+BEGIN_SRC scala
       def withPrintWriter(file: File, op: PrintWriter => Unit) = {
         val writer = new PrintWriter(file)
         try {
           op(writer)
         } finally {
           writer.close()
         }
       }

       // Usage
       withPrintWriter(
         new File("date.txt"),
         writer => writer.println(new java.util.Date)
       )
     #+END_SRC

   - You can use ~{}~ instead of ~()~ in some scenarios
     #+BEGIN_SRC scala
       println("Hello, world!")

       println { "Hello, world!" }
     #+END_SRC
     The syntax use ~{}~ is like a build-in syntax structure.

   - You can't use ~,~ in curly braces block:
     #+BEGIN_SRC scala
       val g = "Hello, world!"
       g.substring { 7 , 9 }
       // <console>:1: error: ';' expected but ',' found.
       //        g.substring { 7, 9 }
       //                       ^

       g.substring(7, 9)
       // wo
     #+END_SRC

   - The modified version (NOT the final version. See the next section for the
     final version):
     #+BEGIN_SRC scala
       def withPrintWriter(file: File)(op: PrintWriter => Unit) = {
         val writer = new PrintWriter(file)
         try {
           op(writer)
         } finally {
           writer.close()
         }
       }

       // Usage
       withPrintWriter(new File("date.txt")) { writer =>
         writer.println(new java.util.Date)
       }
     #+END_SRC

** DONE 9.5 By-name parameters - 214
   CLOSED: [2017-10-09 Mon 22:05]
    - Use /by-name type/, put ~=>~ in front of a normal type.

    - A by-name type, in which the empty parameter list, ~()~, is left out, is
      only allowed for parameters.

      There is NO such thing as a by-name variable or a by-name field.
      (=From Jian= but there is ~lazy~ keyword, right???) =TOOD=

** DONE 9.6 Conclusion - 217
   CLOSED: [2017-10-09 Mon 23:01]

* TODO 10 Composition and Inheritance - 218 _ALMOST DONE_
  - We'll compare two fundamental relationships between classes:
    /composition/ and /inheritance/.

    + /Composition/ means one class holds a reference to another, using the
      referenced class to help it fulfill its mission.

    + /Inheritance/ is the superclass/subclass relationship.

  - We'll also discuss:
    + /abstract classes/
    + /parameterless methods/
    + /extending classes/
    + /overriding methods and fields/
    + /parametric fields/
    + /invoking superclass constructors/
    + /polymorphism and dynamic binding/
    + /final members and classes/
    + /factory objects and methods/

** DONE 10.1 A two-dimensional layout library - 218 =RE-READ=
   CLOSED: [2017-10-09 Mon 23:58]
** DONE 10.2 Abstract classes - 219
   CLOSED: [2017-10-09 Mon 23:58]
   #+BEGIN_SRC scala
     abstract class Element {
       def contents: Array[String]
     }
   #+END_SRC
   - The ~abstract~ modifier signifies that the class may have /abstract members/
     that do not have an implementation.

   - You cannot use an /abstract class/ to create an object.

   - A method is abstract if it does not have an implementation (i.e., no equals
     sign or body). UNLIKE Java, _NO_ ~abstract~ modifier is necessary (or
     allowed) on method declarations.

   - concrete methods ::

   - declarations ::

   - definitions ::

   - Class ~Element~ declares the /abstract method/ ~contents~, but currently
     defines NO /concrete methods/.

** DONE 10.3 Defining parameterless methods - 220
   CLOSED: [2017-10-10 Tue 00:18]
   #+BEGIN_SRC scala
     abstract class Element {
       def contents: Array[String]
       def height: Int = contents.length
       def width: Int = if (height == 0) 0 else contents(0).length
     }
   #+END_SRC
   - The ~height~ method returns the number of lines in ~contents~.

   - The ~width~ method returns the length of the first line, or if there are no
     lines in the element, returns zero. (This means you _CANNOT_ define an
     element with a ~height~ of zero and a non-zero ~width~.)

   - parameterless methods ::

   - empty-paren methods ::

   - the uniform access principle :: that client code should not be affected by a
        decision to implement an attribute as a /field/ or /method/.
        =From Jian= if the method does NOT change mutable states.

   - From the performance point of view:
     + A /field/ is pre-computed and no change in the future, it is usually
       faster than a /method/.
         At the same time, it requires memory to save the pre computed values.

     + A /method/ is required to access mutable states. Since they keep changing,
       they can't be pre-computed, and no extra memory is required.

   - A slight complication: =TODO=
     Java does NOT implement the /uniform access principle/.
     So it's ~string.length()~ in Java, not ~string.length~, even though it's
     ~array.length~, not ~array.length()~.

     =From Jian= Java use the ~length~ field to access the length of a immutable
     object.

     =From Jian= Java use the ~size~ method to access the size of a mutable object.

** DONE 10.4 Extending classes - 223
   CLOSED: [2017-10-10 Tue 04:18]
   #+BEGIN_SRC scala
     class ArrayElement(conts: Array[String]) extends Element {
       def contents: Array[String] = conts
     }
   #+END_SRC

   - If you leave out an ~extends~ clause, the Scala compiler implicitly assumes
     your class extends from ~scala.AnyRef~, which on the Java platform is the
     same as class ~java.lang.Object~.

   - /Inheritance/ means that all members of the superclass are also members
     of the subclass, with _TWO exceptions_:
     1. /private members/ of the superclass are _NOT_ inherited in a subclass.

     2. a member of a superclass is not inherited if a member with the same name
        and parameters is already implemented in the subclass.

        This is /override/.

        Implements the abstract method in the subclasss is also a kind of
        /override/, though we often use a more specific word /implement/.

** DONE 10.5 Overriding methods and fields - 225
   CLOSED: [2017-10-10 Tue 05:47]
   - About /methods/ and /fields/:
     + Scala has /uniform access principle/, and Java does _NOT_ have.
     + In Scala, /fields/ and /methods/ belong to the same namespace.

   - The second point above
     + makes it possible for a /field/ to _override_ a /parameterless method/.

     + forbids define a field and method with the same name in the same class in
       Scala, whereas this is allowed in Java.

   - Generally, Scala has just _TWO_ namespaces for definitions in place of
     Java's _FOUR_.

     + Java's four namespaces:
       * fields
       * methods
       * types
       * packages.

     + Scala's two namespaces:
       * values (fields, methods, packages, and singleton objects)
       * types (class and trait names)

   - footnote 4: The reason that /packages/ share the same namespace as /fields/
     and /methods/ in Scala is to enable you to import /packages/ (in addition to
     just the names of types) and the /fields/ and /methods/ of singleton
     objects.

     =TODO=
     This is also something you can’t do in Java. It will be described in
     Section 13.3.

** DONE 10.6 Defining parametric fields - 226
   CLOSED: [2017-10-10 Tue 05:56]
   - Combine the /default constructor/ with the header of the class declaration:
     ~class ArrayElement(val contents: Array[String]) extends Element~

   - Modifiers ~private~, ~protected~, and ~override~ can also be used.
     #+BEGIN_SRC scala
       class Cat {
         val dangerous = false
       }

       class Tiger(
         override val dangerous: Boolean,
         private var age: Int
       ) extends Cat
     #+END_SRC

** DONE 10.7 Invoking superclass constructors - 228
   CLOSED: [2017-10-10 Tue 06:08]
   #+BEGIN_SRC scala
     class LineElement(s: String) extends ArrayElements(Array(s)) {
       override def width = s.length
       override def height = 1
     }
   #+END_SRC

   - Invoke superclass constructors through the syntax
     ~extends ArrayElement(Array(s))~

** DONE 10.8 Using ~override~ modifiers - 229
   CLOSED: [2017-10-10 Tue 06:21]
   - The modifier ~override~ is optional if a member implements an abstract
     member with the same name.

     This rule provides useful information for the compiler that helps avoid
     some hard-to-catch errors and makes system evolution safer.

   - The ~override~ convention is even more important when it comes to system
     evolution.

     For instance, suppose you have a base class, and a subclass. Later you add a
     method named ~foo~ to the base class (a evolution). If, accidently, the
     subclass has a method of this name already, a compiler error will be
     issued for the reason that this subclass method doesn't have ~override~ --
     a subclass method CANNOT override a exist-in-the-future method of the /base
     class/.

   - Java introduces @Override annotation from 1.5 on.
     However, this is NOT mandatory, and use it is just a good habit.

** DONE 10.9 Polymorphism and dynamic binding - 231
   CLOSED: [2017-10-10 Tue 06:41]
   - The /ploymorphism/ discussed in this section is /subtyping polymorphism/.

     =TODO= footnote 7: Chapter 19 discusses /universal polymorphism/.

   - dynamically bound :: the actual method implementation invoked is determined
        at run time based on the class of the object, NOT the EXACT type of the
        variable or expression.

        =From Jian= I add the word "EXACT".
        =TODO= Try to recommend this to the author???

        #+BEGIN_SRC scala
          abstract class Element {
            def demo() = {
              println("Element's implementation invoked")
            }
          }
          class ArrayElement extends Element {
            override def demo() = {
              println("ArrayElement's implementation invoked")
            }
          }
          class LineElement extends ArrayElement {
            override def demo() = {
              println("LineElement's implementation invoked")
            }
          }
            // UniformElement inherits Element's demo
          class UniformElement extends Element

          def invokeDemo(e: Element) = {
            e.demo()
          }


          // Invoke and inspect the OUTPUTs:

          // #1
          invokeDemo(new ArrayElement)
          // ArrayElement's implementation invoked

          // #2
          invokeDemo(new LineElement)
          // LineElement's implementation invoked

          // #3
          invokeDemo(new UniformElement)
          // Element's implementation invoked
        #+END_SRC

** DONE 10.10 Declaring ~final~ members - 233
   CLOSED: [2017-10-10 Tue 06:50]
   Use ~final~ to stop class extention or method overriding.
   This is the same as in Java.
   - forbid subclass method overriding ~final override def demo() = { ...~

   - forbid create subclasses to this class:
     ~final class ArrayElement extends Element { ...~

** DONE 10.11 Using composition and inheritance - 235
   CLOSED: [2017-10-10 Tue 07:04]
   - If what you're after is primarily _code reuse_, you should in general prefer
     composition to inheritance.
     + Only inheritance suffers from the /fragile base class problem/, in which
       you can inadvertently break subclasses by changing a superclass.

     + If you want to use /inheritance/, you need to consider two questions:
       1. whether it models an *is-a* relationship.
          footnote 8: Meyers, Effective C++ [Mey91]

       2. whether clients will want to use the subclass type as a superclass type.
          footnote 9: Eckel, Thinking in Java [Eck98]

   - Example:
     In the former section, we define ~LineElement~ as a subclass of
     ~ArrayElement~ to re-use ~ArrayElement~'s definition of ~contents~.

     It is better to define ~LineElement~ as a direct subclass of ~Element~:
     #+BEGIN_SRC scala
       class LineElement(s: String) extends Element {
         val contents = Array(s)
         override def width = s.length
         override def height = 1
       }
     #+END_SRC
     + If ~LineElement~ extends ~ArrayElement~, this is a /inheritance relation/
       between these two classes.

     + If ~LineElement~ extends ~Element~ directly, it is more important to
       forcus on the /composition relation/ between ~LineElement~ and ~Array~.

** DONE 10.12 Implementing ~above~, ~beside~, and ~toString~ - 236
   CLOSED: [2017-10-10 Tue 07:11]
** TODO 10.13 Defining a factory object - 238
   - A factory object contains methods that construct other objects.

   - An advantage of this approach is that object creation can be centralized and
     the details of how objects are represented with classes can be hidden.

     This hiding will both make your library simpler for clients to understand,
     because less detail is exposed, and provide you with more opportunities to
     change your library's implementation later without breaking client code.

   - Example of a factory class:
     #+BEGIN_SRC scala
       abstract class Element {
         def contents: Array[String]

         def width: Int =
           if (height == 0) 0 else contents(0).length

         def height: Int = contents.length

         def above(that: Element): Element =
           new ArrayElement(this.contents ++ that.contents)

         def beside(that: Element): Element =
           new ArrayElement(
             for (
               (line1, line2) <- this.contents zip that.contents
             ) yield line1 + line2
           )

         override def toString = contents mkString "\n"
       }
     #+END_SRC

   - Use companion object as a factory:
     #+BEGIN_SRC scala
       object Element {
         def elem(contents: Array[String]): Element =
           new ArrayElement(contents)

         def elem(chr: Char, width: Int, height: Int): Element =
           new UniformElement(chr, width, height)

         def elem(line: String): Element =
           new LineElement(line)
       }
     #+END_SRC

** TODO 10.14 Heighten and widen - 240
   One last enhancement:
   The version of ~Element~ shown in Listing 10.11 is NOT quite sufficient
   because it does _NOT allow clients to align different size ~Element~'s_.

   Here _"NOT allow"_ means the ~above~ and ~beside~ before this section can't
   work properly. We should adjust different elements, and make them the same
   size first.

   #+BEGIN_SRC scala
     object Element {
       private class ArrayElement(
         val contents: Array[String]
       ) extends Element

       private class LineElement(s: String) extends Element {
         val contents = Array(s)
         override def width = s.length
         override def height = 1
       }

       private class UniformElement(
         ch: Char,
         override val width: Int,
         override val height: Int
       ) extends Element {
         private val line = ch.toString * width
         def contents = Array.fill(height)(line)
       }

       def elem(contents: Array[String]): Element =
         new ArrayElement(contents)

       def elem(chr: Char, width: Int, height: Int): Element =
         new UniformElement(chr, width, height)

       def elem(line: String): Element =
         new LineElement(line)
     }


     import Element.elem

     abstract class Element {
       def contents: Array[String]
       def width: Int = contents(0).length
       def height: Int = contents.length

       def above(that: Element): Element = {
         val this1 = this widen that.width
         val that1 = that widen this.width
         elem(this1.contents ++ that1.contents)
       }

       def beside(that: Element): Element = {
         val this1 = this heighten that.height
         val that1 = that heighten this.height
         elem(
           for ((line1, line2) <- this1.contents zip that1.contents)
           yield line1 + line2
         )
       }

       def widen(w: Int): Element =
         if (w <= width) this
         else {
           val left = elem(' ', (w - width) / 2, height)
           val right = elem(' ', w - width - left.width, height)
           left beside this beside right
         }

       def heighten(h: Int): Element =
         if (h <= height) this
         else {
           val top = elem(' ', width, (h - height) / 2)
           val bot = elem(' ', width, h - height - top.height)
           top above this above bot
         }
       override def toString = contents mkString "\n"
     }
   #+END_SRC

** TODO 10.15 Putting it all together - 244
   - x
** DONE 10.16 Conclusion - 245
   CLOSED: [2017-10-11 Wed 18:03]

* DONE 11 Scala's Hierarchy - 246
  CLOSED: [2017-10-12 Thu 00:16]
  In Scala, every class inherits from a common superclass named ~Any~.

  Scala also defines some interesting classes at the _bottom_ of the hierarchy,
  ~Null~ and ~Nothing~, which essentially act as common subclasses.

  ~Nothing~ is a subclass of ~Null~.

** DONE 11.1 Scala's class hierarchy - 246
   CLOSED: [2017-10-11 Wed 18:39]
   - The ~hashCode~ method has an alias ~##~

   - The ~==~ method is essentially the same as ~equals~ and ~!=~ is _ALWAYS_ the
     negation of ~equals~.

     footnote 1:
     The only case where ~==~ does not directly call ~equals~ is for Java's boxed
     numeric classes, such as ~Integer~ or ~Long~. In Java, a ~new Integer(1)~
     does NOT equal a ~new Long(1)~ even though for /primitive values/ ~1 == 1L~.
       Since Scala is a more regular language than Java, it was necessary to
     correct this discrepancy by special-casing the ~==~ method for these classes.
     Likewise, the ~##~ method provides a Scala version of hashing that is the
     same as Java’s ~hashCode~, except for boxed numeric types, where it works
     consistently with ~==~. For instance ~new Integer(1)~ and ~new Long(1)~
     hash the same with ~##~ even though their Java ~hashCodes~ are different.

     =From Jian= this is NOT always the case if in Java due to its /boxed type/
     and /reference equality/.

   - ~Any~ has two direct subclasses:
     + ~AnyVal~ :: the parent class of /value classes/.
                   
       There are _NINE_ /value classes/ built into Scala, they are subtypes of
       ~scala.AnyVal~, but they do NOT subclass each other:
       * ~Byte~
       * ~Short~
       * ~Char~
       * ~Int~
       * ~Long~
       * ~Float~
       * ~Double~
       * ~Boolean~
       * ~Unit~

       The instances of /these classes/ are all written as /literals/ in Scala.
       You cannot create instances of these classes using ~new~. This is enforced
       by the "trick" that value classes are all defined to be both ~abstract~
       and ~final~.

     + ~AnyRef~ :: the base class of all /reference classes/ in Scala.

       This is just an alias for class ~java.lang.Object~. So classes written in
       Java, as well as classes written in Scala, all inherit from ~AnyRef~.

       One way to think of ~java.lang.Object~, therefore, is as the way ~AnyRef~
       is implemented on the Java platform. Thus, although you can use ~Object~
       and ~AnyRef~ interchangeably in Scala programs on the Java platform,
       _the recommended style is to use ~AnyRef~ everywhere_.

** DONE 11.2 How primitives are implemented - 250
   CLOSED: [2017-10-11 Wed 19:01]
   - Scala stores integers in the same way as Java -- as 32-bit words.
     This is important for efficiency on the JVM and also for interoperability
     with Java libraries.

     Integers of type ~Int~ are converted transparently to "boxed integers" of
     type ~java.lang.Integer~ whenever necessary. This is like /auto-boxing/ in
     Java 5+ and it is indeed quite similar.
       There's _ONE crucial difference_ though: /Boxing/ in Scala is much less
       visible than /boxing/ in Java -- you cannot distinguish them in Scala.

   - _Java is NOT a pure object-oriented language_.
     There is a difference between /primitive types/ and /reference types/ that
     can be clearly observed.
     #+BEGIN_SRC java
       boolean isEqual(int x, int y) {
           return x == y;
       }

       isEqual(42, 42);  // true

       boolean isEqualObj(Integer x, Integer y) {
           return x == y;
       }

       isEqualObj(42, 42);  // false
     #+END_SRC

   - For /reference types/ other than Java's boxed numeric types, ~==~ is treated
     as an alias of the ~equals~ method inherited from ~Object~.

     One example that the result is
     ~true~ in Scala,
     but ~false~ in Java (~equals~ returns ~true~):
     #+BEGIN_SRC scala
       val x = "abcd".substring(2)
       val y = "abcd".substring(2)

       x == y  // true
     #+END_SRC

   - =TODO= /hash cons/

   - Class ~AnyRef~ defines an additional ~eq~ method, which _CANNOT be
     overridden_ and is implemented as /reference equality/ (behaves like ~==~ in
     Java for /reference types/). It has a negation ~ne~.
     #+BEGIN_SRC scala
       val x = new String("abc")
       val y = new String("abc")

       x == y  // true
       x eq y  // false
       x ne y  // true
     #+END_SRC

   - =TODO=
     Equality in Scala is discussed further in Chapter 30.

** DONE 11.3 Bottom types - 252
   CLOSED: [2017-10-12 Thu 00:03]
   - Class ~Null~ is the type of the ~null~ reference; it is a subclass of every
     reference class (i.e., every class that itself inherits from ~AnyRef~).

     ~Null~ is NOT compatible with /value types/.

   - ~Nothing~ is at the very bottom of Scala's class hierarchy; it is a subtype
     of every other type. However, there exist NO values of this type whatsoever.

     Q: Why does it make sense to have a type without values?
     A: (partial) As discussed in Section 7.4, one use of ~Nothing~ is that is
        singnals abnormal termination.
        For instance, the ~error~ method in the ~Predef~ object:
        #+BEGIN_SRC scala
          def error(message: String): Nothing =
            throw new RuntimeException(message)
        #+END_SRC

** DONE 11.4 Defining your own value classes - 253
   CLOSED: [2017-10-12 Thu 00:15]
   - For a class to be a /value class/,
     + it must have exactly ONE parameter
     + it must have NOTHING inside it except ~def~'s.
     + NO other class can extend a /value class/
     + cannot redefine ~equals~ or ~hashCode~.

   - Example:
     #+BEGIN_SRC scala
       class Dollars(val amount: Int) extends AnyVal {
         override def toString() = "$" + amount
       }
     #+END_SRC

*** DONE Avoiding a types monoculture
    CLOSED: [2017-10-12 Thu 00:15]
    To get the most benefit from the Scala class hierarchy,
    _try to define a new class for each domain concept_,
    even when it would be possible to reuse the same class for different
    purposes. Even if such a class is a so-called /tiny type/ with no methods or
    fields,
    _defining the additional class is a way to help the compiler be helpful to
    you._

** DONE 11.5 Conclusion - 256
   CLOSED: [2017-10-12 Thu 00:15]

* TODO 12 Traits - 257 _ALMOST DONE_
  - /Traits/ are a fundamental unit of code reuse in Scala.

  - A /trait/ encapsulates /method/ and /field/ definitions,
    which can then be reused by mixing them into classes.

  - This chapter shows you
    + how traits work
    + TWO of the most common ways they are useful:
      * widening thin interfaces to rich ones
      * defining stackable modifications
      * 
  - It also shows
    + how to use the ~Ordered~ trait
    + compares traits to the multiple inheritance of other languages.

** DONE 12.1 How traits work - 257
   CLOSED: [2017-10-12 Thu 00:37]
   - A trait does NOT declare a superclass, so like a class, it has the default
     superclass of ~AnyRef~.

   - /traits/ can do anything calls can do, with only _TWO exceptions_:
     + a trait cannot have any /class parameter/ (i.e. parameters passed to the
       primary constructor of a class).

     + Whereas in classes, the ~super~ calls are _statically_ bound; in traits,
       they are dynamically bound.

       ~super~ is undefined when you define the ~trait~ that includes it.
       Rather, the implementation to invoke will be determined anew each time
       the trait is mixed into a concrete class.

       =TODO=
       This curious behavior of super is key to allowing traits to work as
       /stackable modifications/, which will be described in Section 12.5.

       =TODO=
       The rules for resolving super calls will be given in Section 12.6.

   - stackable modifications :: =TODO=

** DONE 12.2 Thin versus rich interfaces - 260 =RE-READ=
   CLOSED: [2017-10-12 Thu 03:17]
   - 

   - To enrich an interface using traits, simply define a trait with a small number
     of abstract methods -- the thin part of the trait's interface -- and a
     potentially large number of concrete methods, all implemented in terms of
     the abstract methods. Then you can mix the enrichment trait into a class,
     implement the thin portion of the interface, and end up with a class that
     has all of the rich interface available.

** DONE 12.3 Example: Rectangular objects - 261
   CLOSED: [2017-10-12 Thu 01:21]
** DONE 12.4 The ~Ordered~ trait - 264
   CLOSED: [2017-10-12 Thu 01:38]
   Do comparison manually:

   footnote 1: This example is based on the ~Rational~ class shown in Listing 6.5
   on page 151, with ~equals~, ~hashCode~, and modifications to ensure a
   _positive_ ~denom~ added.
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) {
       def < (that: Rational) =
         this.numer * that.denom < that.numer * this.denom

       def > (that: Rational) = that < this

       def <= (that: Rational) = (this < that) || (this == that)

       def >= (that: Rational) = (this > that) || (this == that)
     }
   #+END_SRC

   Use the ~Ordered~ trait
   #+BEGIN_SRC scala
     class Rational(n: Int, d: Int) extends Ordered[Rational] {
       //...
       def compare(that: Rational) =
         (this.numer * that.denom) - (that.numer * this.denom)
     }
   #+END_SRC

** DONE 12.5 Traits as stackable modifications - 266 =RE-READ=
   CLOSED: [2017-10-12 Thu 03:04]
   - One major use of traits:
     turning a thin interface into a rich one.

   - Now turn to a second major use of traits:
     providing stackable modifications to classes.

   - Traits let you modify the methods of a class, and they do so in a way that
     allows you to stack those modifications with each other (order matters).

   - As an example,
     _consider stacking modifications to a queue of integers_.

     + Two basic operations to the queue (FIFO):
       * ~put~
       * ~get~

     + Code:
       #+BEGIN_SRC scala
         abstract class IntQueue {
           def get(): Int
           def put(x: Int)
         }

         import scala.collection.mutable.ArrayBuffer

         class BasicIntQueue extends IntQueue {
           private val buf = new ArrayBuffer[Int]
           def get() = buf.remove(0)
           def put(x: Int) = { buf += x }
         }
       #+END_SRC

     + Given a class that implements such a queue, you could define traits to
       perform modifications such as these:
       * ~Doubling~: double all integers that are put in the queue
       * ~Incrementing~: increment all integers that are put in the queue
       * ~Filtering~: filter out negative integers from a queue

       These THREE traits represent /modifications/, because they modify the
       behavior of an underlying queue class rather than defining a full queue
       class themselves.

       The three are also /stackable/ -- you can select any of the three you
       like, mix them into a class, and obtain a new class that has all of the
       modifications you chose.

     + The implementations of three traits.
       #+BEGIN_SRC scala
         trait Doubling extends IntQueue {
           abstract override def put(x: Int) = { super.put(2 * x) }
         }

         trait Incrementing extends IntQueue {
           abstract override def put(x: Int) = { super.put(x + 1) }
         }

         trait Filtering extends IntQueue {
           abstract override def put(x: Int) = {
             if (x >= 0) super.put(x)
           }
         }
       #+END_SRC

       * If a /trait/ extends a class A, _ONLY_ classes that extends A can mix in
         this /trait/. For instance, you can mix ~Doubling~ into ~BasicIntQueue~,
         but NOT into ~Rational~.

       * If a /trait/ can have ~super~ call on a method declared ~abstract~.
         =TODO= =???=
         - Such calls are illegal for normal /classes/ because they will
           certainly fail at run time.
           =From Jian= since the current method ~m~ is ~abstract~, the ~m~
           method of the superclass is also ~abstract~.

         - For a trait, however, since ~super~ calls is dynamically bound, such a
           call can actually succeed.

         In this example the ~super~ call in ~trait Doubling~ will work so long
         as _the trait is mixed in after another trait or class that gives a
         concrete definition to the method_.

         This arrangement is frequently needed with traits that implement stackable
         modifications. To tell the compiler you are doing this on purpose, you
         must mark such methods as ~abstract override~. _This combination of
         modifiers is only allowed for members of traits, not classes_, and it
         means that the trait must be mixed into some class that has a concrete
         definition of the method in question.

     + Run and check the result:
       * Non-stacked
         #+BEGIN_SRC scala
           class MyQueue extends BasicIntQueue with Doubling

           val queue = new MyQueue
           // OR //
           // Use anonymous class `val queue = new BasicIntQueue with Doubling`

           queue.put(10)
           queue.get()
           // 20
         #+END_SRC

       * Stacked
         #+BEGIN_SRC scala
           val queue = (new BasicIntQueue
                            with Incrementing with Filtering)
           queue.put(-1)
           queue.put(0)
           queue.put(1)

           queue.get()
           // Int = 1
           queue.get()
           // Int = 2
         #+END_SRC

       * Stacked (different order)
         #+BEGIN_SRC scala
           val queue = (new BasicIntQueue
                            with Filtering with Incrementing)
           queue.put(-1)
           queue.put(0)
           queue.put(1)

           queue.get()
           // Int = 0
           queue.get()
           // Int = 1
           queue.get()
           // Int = 2
         #+END_SRC

     + Rules (roughly): =TODO= see the next section for details
       + traits further to the right take effect first.
         When you call a method on a class with mixins, the method in the trait
         furthest to the right is called first.

       + If that method calls ~super~, it invokes the method in the next trait to
         its left, and so on.

   - Since _the order of traits is significant_,
     you must keep eyes open for opportunities to arrange code as stackable
     modifications.

   - mixin :: a trait that is mixed into a class.
              (from footnote 1)

** TODO 12.6 Why not multiple inheritance? - 270
   - x

** DONE 12.7 To trait or not to trait? - 274 =RE-READ=
   CLOSED: [2017-10-12 Thu 03:36]
   Q: Use /traits/ or /abstract classes/?
   A: NO firm rules, only guidelines to consider:

   - If the behavior will _NOT be reused_, then make it a /concrete class/. It
     is not reusable behavior after all.

   - If it might be reused in _multiple, unrelated classes_, make it a /trait/.
     Only traits can be mixed into different parts of the class hierarchy.

   - If you want to _inherit from it in Java code_, use an /abstract class/.
     Since traits with code do not have a close Java analog, it tends to be
     awkward to inherit from a trait in a Java class.

     Inheriting from a Scala class, meanwhile, is exactly like inheriting from a
     Java class.

     _As one EXCEPTION_,
     _a /Scala trait/ with only abstract members translates directly to a /Java
     interface/_, so you should feel free to define such traits even if you
     expect Java code to inherit from it.
     =TODO= =IMPORTANT=
     See Chapter 31 for more information on working with Java and Scala together.

   - If you plan to _distribute it in compiled form_, and you expect outside groups
     to write classes inheriting from it, you might lean towards using an
     /abstract class/.

     The issue is that when a trait gains or loses a member, any classes that
     inherit from it must be recompiled, even if they have not changed.

     If outside clients will only call into the behavior, instead of inheriting
     from it, then using a trait is fine.

   - If you _still do not know, after considering the above_, then START BY making
     it as a /trait/. You can always change it later, and in general using a
     /trait/ _keeps more options open_.

** DONE 12.8 Conclusion - 275
   CLOSED: [2017-10-12 Thu 03:39]
   _Mix in multiple traits_ are similar to /multiple inheritance/.
   But because /traits/ interpret ~super~ using /linearization/, they both
   + _AVOID_ some of the difficulties of traditional multiple inheritance
     and
   + _ALLOW_ you to stack behaviors.

* DONE 13 Packages and Imports - 276 _Re-READ_
  CLOSED: [2017-10-21 Sat 17:53]
  This chapter shows several constructs that help you program in a modular style.

  It shows
  + how to place things in packages
  + make names visible through imports
  + control the visibility of definitions through access modifiers

** DONE 13.1 Putting code in packages - 277
   CLOSED: [2017-10-21 Sat 15:28]
   - The example code you’ve seen so far in this book has been in the
     /unnamed package/.

   - Two ways to place code into named packages:
     + place the contents of an ENTIRE FILE into a package: use the ~package~
       clause at the top of the file.
       #+BEGIN_SRC scala
         package com.bobsrockets.navigation

         class Navigator
       #+END_SRC
       From the outside you can reference ~Navigator~ through
       ~com.bobsrockets.navigation.Navigator~

     + Not ENTIRE FILE packages, more like C# namespaces -- the /packaging/
       syntax:
       #+BEGIN_SRC scala
         package com.bobsrockets.navigation {
           class Navigator
         }
       #+END_SRC

   - For simple cases, you usually choose the entire file package syntax.
     In general use the /packaging/ syntax, you have more control.

** DONE 13.2 Concise access to related code - 281 =RE-READ=
   CLOSED: [2017-10-21 Sat 15:50]
   - Want to use the including package members?
     The nested structure must be explicit:
     + Compilable
       #+BEGIN_SRC scala
         package bobsrockets {
           class Ship

           package fleets {
             class Fleet {
               // Compilable! Ship is in scope.
               def addShip() = { new Ship }
             }
           }
         }
       #+END_SRC

     + Does NOT compile
       #+BEGIN_SRC scala
         package bobsrockets {
           class Ship
         }
         package bobsrockets.fleets {
           class Fleet {
             // Doesn't compile! Ship is not in scope.
             def addShip() = { new Ship }
           }
         }
       #+END_SRC

   - ~_root_~
     #+BEGIN_SRC scala
       // In file launch.scala
       package launch {
         class Booster3
       }

       // In file bobsrockets.scala
       package bobsrockets {
         package navigation {
           package launch {
             class Booster1
           }

           class MissionControl {
             val booster1 = new launch.Booster1
             val booster2 = new bobsrockets.launch.Booster2
             val booster3 = new _root_.launch.Booster3
           }
         }

         package launch {
           class Booster2
         }
       }
     #+END_SRC

   - Use /chained packages clauses/ to avoid the right shift of code of the
     /packaging/ syntax.
     #+BEGIN_SRC scala
       package bobsrockets

       package fleets

       class Fleet {
         // No need to say bobsrockets.Ship
         def addShip() = { new Ship }
       }
     #+END_SRC

** DONE 13.3 Imports - 285
   CLOSED: [2017-10-21 Sat 16:21]
   - =TODO=
     #+BEGIN_SRC scala
       package bobsdelights

       abstract class Fruit(
         val name: String,
         val color: String
       )

       object Fruits {
         object Apple extends Fruit("apple", "red")
         object Orange extends Fruit("orange", "orange")
         object Pear extends Fruit("pear", "yellowish")
         val menu = List(Apple, Orange, Pear)
       }
     #+END_SRC
     + This corresponds to Java's single type import.
       ~import bobsdelights.Fruit~

     + This corresponds to Java's on-demand import.
       The only difference is that Scala's on-demand imports are written with a
       trailing underscore (~_~) instead of an asterisk (~*~).
       (After all, * is a valid identifier in Scala!)
       ~import bobsdelights._~

     + This corresponds to Java's import of static class fields.
       ~import bobsdelights.Fruits._~

   - Scala imports are actually much more general than Java.
     + imports in Scala can appear _anywhere_, not just at the beginning of a
       compilation unit.

     + they can refer to arbitrary values. =???=

     For example,
     #+BEGIN_SRC scala
       def showFruit(fruit: Fruit) = {
         import fruit._
         println(name + "s are" + color)
       }
     #+END_SRC
     The ~name~ and ~color~ above are ~fruit.name~ and ~fruit.color~.
     =TODO=
     This syntax is particularly useful when you use objects as modules =Chapter 29=

   - Scala's flexible imports
     Scala's import clauses are quite a bit more flexible than Java's.
     There are three principal differences. In Scala, imports:
     + may appear anywhere
     + may refer to objects (singleton or regular) in addition to packages
     + let you _rename_ and _hide_ some of the imported members

   - xxx

   - /import selector clause/
     + ~import Fruits.{Apple, Orange}~
     + ~import Fruits.{Apple => McIntosh, Orange}~
     + ~import java.sql.{Date => SDate}~
     + ~import Fruits.{_}~ is the same as ~import Fruits._~
     + ~import Fruits.{Apple => McIntosh, _}~
     + ~import Fruits.{Pear => _, _}~
       Hide ~Pear~ and import all the other things

** DONE 13.4 Implicit imports - 285
   CLOSED: [2017-10-21 Sat 16:22]
   Scala adds some imports implicitly to every program.
   This is equivalent to do
   #+BEGIN_SRC scala
     import java.lang._ // everything in the java.lang package
     import scala._ // everything in the scala package
     import Predef._ // everything in the Predef object
   #+END_SRC
   on the top of every source file with extension =.scala=

   The order above is important, it implies that the latter can overshadow the
   former. For example, ~scala.StringBuilder~ overshadows
   ~java.lang.StringBuilder~.

** DONE 13.5 Access modifiers - 286
   CLOSED: [2017-10-21 Sat 17:40]
   _Members_ of /packages/, /classes/, or /objects/ can be labeled with the
   /access modifiers/ ~private~ and ~protected~.

*** DONE Private members
    CLOSED: [2017-10-21 Sat 16:54]
    A member labeled private is visible ONLY inside the /class/ or /object/ that
    contains the member definition.
    #+BEGIN_SRC scala
      class Outer {
        class Inner {
          private def f() = { println("f") }

          class InnerMost {
            f() // OK
          }
        }
          (new Inner).f() // error: f is not accessible
      }
    #+END_SRC
    _MORE restrictive than in Java_

    By contrast, in Java, both of the two accesses to the ~f~ method above are
    legal.

    =From Jian= the Scala way is more reasonable for me.

*** DONE Protected members
    CLOSED: [2017-10-21 Sat 16:54]
    #+BEGIN_SRC scala
      package p {
        class Super {
          protected def f() = { println("f") }
        }

        class Sub extends Super {
          f()
        }

        class Other {
          (new Super).f()  // error: f is NOT accessible
        }
      }
    #+END_SRC
    _MORE restrictive than in Java_
    - In Scala, a protected member is ONLY accessible from /subclasses/ of the
      class in which the member is defined.

    - In Java such accesses are also possible from other classes _in the same
      package_. Both of the accesses above can succeed in Java.
      
    =TODO= =???=
    In Scala, there is another way to achieve this effect so ~protected~ is free
    to be left as is. 

    footnote: Using /qualifiers/, described in “Scope of protection” on page 288.

*** DONE Public members
    CLOSED: [2017-10-21 Sat 16:53]
    Any member with no ~private~ and ~protected~ modifier are /public/.

*** DONE Scope of protection
    CLOSED: [2017-10-21 Sat 17:26]
    #+BEGIN_SRC scala
      package bobsrockets

      package navigation {
        private[bobsrockets] class Navigator {
          protected[navigation] def useStarChart() = {}

          class LegOfJourney {
            private[Navigator] val distance = 100
          }

          private[this] var speed = 200
        }
      }

      package launch {
        import navigation._
        object Vehicle {
          private[launch] val guide = new Navigator
        }
      }
    #+END_SRC

    - /Access modifiers/ in Scala can be _AUGMENTED with qualifiers_.

      A modifier of the form ~private[X]~ or ~protected[X]~ means that access is
      _private_ or _protected_ *UP TO* X, where X designates some enclosing
      package, class or singleton object.

    - ~private[this]~ is called /object-private/.

*** DONE Visibility and companion objects
    CLOSED: [2017-10-21 Sat 17:39]
    - In Java, /static members/ and /instance members/ belong to the same class,
      so /access modifiers/ apply _uniformly_ to them.

      In Scala there are no /static members/; instead you can have a /companion
      object/ that contains members that exist only once.

    - One exception where the similarity between Scala and Java _breaks down_
      concerns ~protected static~ members.
      + In Java A protected static member of a class C can be accessed in all
        subclasses of C.

      + In Scala, a /protected member/ in a /companion object/ _makes no sense_,
        as singleton objects don't have any subclasses.

** DONE 13.6 Package objects - 291 
   CLOSED: [2017-10-21 Sat 17:50]
   - Any kind of definition that you can put inside a class can also be at the
     top level of a package.

     + Q: How to do it?

     + A: put the definitions in a /package object/.

   - Each /package/ is allowed to have one /package object/.
     Any definitions placed in a /package object/ are considered members of the
     /package/ itself.

   - Example:
     #+BEGIN_SRC scala
       // In file bobsdelights/package.scala
       package object bobsdelights {
         def showFruit(fruit: Fruit) = {
           import fruit._
           println(name + "s are " + color)
         }
       }

       // In file PrintMenu.scala
       package printmenu
       import bobsdelights.Fruits
       import bobsdelights.showFruit
       object PrintMenu {
         def main(args: Array[String]) = {
           for (fruit <Fruits.
                menu) {
             showFruit(fruit)
           }
         }
       }
     #+END_SRC

   - Package objects are frequently used to hold
     + package-wide type aliases (Chapter 20)
     + implicit conversions (Chapter 21).

     The top-level ~scala~ package has a /package object/, and its definitions
     are available to all Scala code.

   - /Package objects/ are compiled to class files named ~package.class~ that are
     the located in the directory of the package that they augment.

     It's useful to _keep the same convention_ for source files.
     So you would typically put the source file of the /package object/
     ~bobsdelights~ of Listing 13.14 into a file named =package.scala= that
     resides in the ~bobsdelights~ directory.

** DONE 13.7 Conclusion - 293
   CLOSED: [2017-10-21 Sat 17:53]

* TODO 14 Assertions and Tests - 294
** DONE 14.1 Assertions - 294
   CLOSED: [2017-10-23 Mon 12:52]
   - The expression ~assert(condition)~ throws an ~AssertionError~
     if condition does NOT hold.

   - Footnote 1: ~assert~ is defined in ~Predef~

   - There are also a two-argument version of ~assert~:
     ~assert(condition, explanation)~, where ~explanation~ is of type ~Any~.
     When use it, the ~assert~ method will call ~toString~ on it to get a string
     explantion to place inside the ~AssertionError~.

   - Example:
     #+BEGIN_SRC scala
       def above(that: Element): Element = {
         val this1 = this widen that.width
         val that1 = that widen this.width
         assert(this1.width == that2.width)
         elem(this1.contents ++ that1.contents)
       }
     #+END_SRC

   - ~ensuring~

   - Example:
     #+BEGIN_SRC scala
       private def widen(w: Int): Element =
         if (w <= width)
           this
         else {
           val left = elem(' ', (w - width) / 2, height)
           val right = elem(' ', w - width - left.width, height)
           left beside this beside right
         } ensuring (w <= _.width)
     #+END_SRC
     The ~ensuring~ method is called on a implicitly conversion of the ~Element~
     value, rather than the ~Element~ value itself.

     If the passed in predicate return ~true~, return the result;
     otherwise, ensuring will throw an ~AssertionError~.

   - Enable and disable assertions in JVM:
     use the =-ea= and =-da= flags respectively.

** DONE 14.2 Testing in Scala - 296
   CLOSED: [2017-10-23 Mon 15:23]
   - Tools:
     + in Java:
       * JUnit
       * TestNG

     + in Scala:
       * ScalaTest
       * specs2
       * ScalaCheck

   - Start with ScalaTest, which is the most flexible -- teams can use whatever
     testing style fits their needs best.
     + for teams familar with JUnit, they can use ~FunSuite~ style.
       #+BEGIN_SRC scala
         import org.scalatest.FunSuite
         import Element.elem

         class ElementSuite extends FunSuite {
           test("elem result should have passed width") {
             val ele = elem('x', 2, 3)
             assert(ele.with == 2)
           }
         }
       #+END_SRC

   - suite :: a collection of tests.

   - test :: anything with a name that can start and either
     + succeed
     + fail
     + be pending
     + be cancled.

   - Trait ~Suite~ is the central unit of composition in ~ScalaTest~.

     It declares "lifecycle" methods defining a default way to run tests, which
     can be overridden to customize how tests are written and run.

   - ~ScalaTest~
     + offers /style traits/ that extend ~Suite~ and override /lifecycle methods/
       to support different testing styles.

     + provides /mixin traits/ that override /lifecycle methods/ to address
       particular testing needs.

   - Define test classes by composing ~Suite~ style and mixin traits.
     Define test suites by composing ~Suite~ instances.

   - ~FunSuite~ :: "Fun" for "function".

   - ~test~ is a method defined in ~FunSuite~, which is invoked by the /primary
     constructor/ of ~ElementSuite~.

   - =TODO= DETAILS????
     ~ScalaTest~ is integrated into common build tools (such as /sbt/ and
     /Maven/) and IDEs (such as /IntelliJ IDEA/ and /Eclipse/).

   - You can run a ~Suite~ directly via ~ScalaTest~'s ~Runner~ application
     =TODO=

     or

     from the Scala interpreter simply by invoking ~execute~ on it.
     For example,
     #+BEGIN_SRC scala
       scala> (new ElementSuite).execute()
       // ElementSuite:
       // - elem result should have passed width
     #+END_SRC

   - All styles generate specification-like output that can facilitate
     communication among stakeholders.

     The style you choose dictates only how the declarations of your tests will
     look. Everything else in ~ScalaTest~ works consistently the same way no
     matter what style you choose.

** DONE 14.3 Informative failure reports - 297
   CLOSED: [2017-10-23 Mon 22:36]
   - Use ~DiagrammedAssertions~, whose error messages display a diagram of the
     expression passed to ~assert~. See example in page 298.

   - ScalaTest's ~assert~ methods do NOT differentiate between the _actual_ and
     _expected_ result in error messages.

     The ~assertResult~ method can differentiate between them.
     #+BEGIN_SRC scala
       assertResult(2) {
         ele.width
       }
     #+END_SRC

   - Check exceptions:
     #+BEGIN_SRC scala
       assertThrows[IllegalArgumentException] {
         elem('x', -2, 3)
       }
     #+END_SRC

   - Intercept exception to use:
     #+BEGIN_SRC scala
       val caught =
         intercept[ArithmeticException] {
           1 / 0
         }

       assert(caught.getMessage == "/ by zero")
     #+END_SRC

** TODO 14.4 Tests as specifications - 299
** TODO 14.5 Property-based testing - 302
** TODO 14.6 Organizing and running tests - 304
** TODO 14.7 Conclusion - 305

* TODO 15 Case Classes and Pattern Matching - 306
** DONE 15.1 A simple example - 306
   CLOSED: [2017-10-21 Sat 20:08]
*** DONE Case classes
    CLOSED: [2017-10-21 Sat 20:04]
    - footnote 1: Modeling the root of a class hierarchy as an ~abstract class~
      may be slightly more efficient.
      =TODO= =???=

    - Example:
      #+BEGIN_SRC scala
        abstract class Expr
        case class Var(name: String) extends Expr
        case class Number(num: Double) extends Expr
        case class UnOp(operator: String, arg: Expr) extends Expr
        case class BinOp(operator: String,
                         left: Expr, right: Expr) extends Expr
      #+END_SRC

    - Conveniences:
      + a ~apply~ method is automatically implemented -- create a new instance
        with ~new~.

      + all arguments in the parameter list of a /case class/ implicitly get a
        ~val~ prefix, so they are maintained as fields.

      + a ~copy~ method is automatically implemented -- you can use it to create
        a similar object:
        #+BEGIN_SRC scala
          val op = BinOp("+", Number(1.0), Var(x))

          op.copy(operator = "-")
          // BinOp("-", Number(1.0), Var(x))
        #+END_SRC

*** DONE Pattern matching
    CLOSED: [2017-10-21 Sat 20:08]
    If there is NO /pattern matching/, try to imagine match
    ~UnOp("-", UnOp("-", e))~. The method you can use now is:
    + write this match in /visitor design pattern/.
    + use embeded ~if ... else~'s.

*** DONE ~match~ compared to ~switch~
    CLOSED: [2017-10-21 Sat 19:53]
    - There are three differences to keep in mind:
      + ~match~ is an /expression/ in Scala (i.e., it always results in a value).
      + Scala's alternative expressions _NEVER_ /fall through/ into the next case.
        =From Jian= How about if I want /fall through/ in some low-level cases???
        =TODO=

      + if none of the patterns match, an exception named ~MatchError~ is thrown.
        This means you always have to make sure that all cases are covered, even
        if it means adding a default case where there's nothing to do.

    - Example (the value can be generated if the second pattern matchs ~()~):
      #+BEGIN_SRC scala
        expr match {
          case BinOp(op, left, right) =>
            println(expr + " is a binary operation")
          case _ =>
        }
      #+END_SRC

    - Apply ~@swtich~ to switch-like ~match~ (only /constant patterns/), and this
      ~match~ expression will be optimized.

** DONE 15.2 Kinds of patterns - 311
   CLOSED: [2017-10-21 Sat 19:34]
*** DONE Wildcard patterns
    CLOSED: [2017-10-21 Sat 19:09]
    ~_~

*** DONE Constant patterns
    CLOSED: [2017-10-21 Sat 19:09]
    _A /constant pattern/ matches only itself._
    It includes:
    + any literal
    + any ~val~
    + any singleton object

*** DONE Variable patterns
    CLOSED: [2017-10-21 Sat 19:19]
    - A /variable pattern/ matches any object, just like a /wildcard/, but with
      bind it.

    - pattern variable :: A simple name _starting with a lowercase letter_.

    - How to use a starting-with-a-lowercase-letter name as /constant pattern/:
      + with qualifiers -- ~this.pi~ is a /constant pattern/, and ~pi~ is NOT.
      + use back-tick to quote it -- ~`pi`~ is a /constant pattern/.

    - Recall the usage of back-ticks. All its usages are for some special cases:
      + Section 6.10, use a word as identifier rahter than a keyword.
        ~Thread.`yield`()~

      + use a starting-with-a-lowercase-letter name as /constant pattern/

*** DONE Constructor patterns
    CLOSED: [2017-10-21 Sat 19:20]
*** DONE Sequence patterns
    CLOSED: [2017-10-21 Sat 19:21]

    =IMPORTANT=
    If you want to match against a sequence without specifying how long it can
    be, you can specify ~_*~ as the last element of the pattern.
    #+BEGIN_SRC scala
      expr match {
        case List(0, _*) => println("found it")
        case _ => //...
      }
    #+END_SRC

*** DONE Tuple patterns
    CLOSED: [2017-10-21 Sat 19:22]
*** DONE Typed patterns
    CLOSED: [2017-10-21 Sat 19:22]
    #+BEGIN_SRC scala
      def generalSize(x: Any) = x match {
        case s: String => s.length
        case m: Map[_, _] => m.size
        case _ => 1
      }
    #+END_SRC
    
    - As you will have noted by now, writing type tests and casts is rather
      verbose in Scala. That's intentional because it is not encouraged practice.
      #+BEGIN_SRC scala
        // Test
        expr.isInstanceOf[String]

        // Cast
        expr.asInstanceOf[String]
      #+END_SRC

    - Due to /type erasure/, you CANNOT do /typed patterns/ match with the type
      information of generics like ~Map[Int, Int]~.
      =From Jian= Hope this can be changed in the future Java 10.

      If you do this,
      + when compile, there will be a warning.
      + when run, there can be wrong results (~Map("abc"->"abc")~ can match a
        pattern typed ~Map[Int, Int]~).

    - _One Exception_:
      You can use /typed patterns/ with exact info about arrays like ~Array[Int]~

*** DONE Variable binding
    CLOSED: [2017-10-21 Sat 19:34]
    Use ~@~ to bind a entire pattern and its inner structures.
    For example,
    #+BEGIN_SRC scala
      expr match {
        case UnOp("abc", e @ UnOp("abs", _)) => e
        case _ => //...
      }
    #+END_SRC

** DONE 15.3 Pattern guards - 320
   CLOSED: [2017-10-21 Sat 19:36]
   #+BEGIN_SRC scala
     def simplifyAdd(e: Expr) = e match {
       case BinOp("+", x, x) => BinOp("*", x, Number(2))
       case _ => e
     }

     // <console>:14: error: x is already defined as value x
     //          case BinOp("+", x, x) => BinOp("*", x, Number(2))
   #+END_SRC

   This fails because Scala restricts patterns to be linear:
   _a pattern variable may only appear once in a pattern_.

   Use /guard/ to solve this problem.

** DONE 15.4 Pattern overlaps - 321
   CLOSED: [2017-10-21 Sat 19:44]
   - Patterns are tried in the order in which they are written.

   - Catch-all patterns should be after more specific patterns.

   - Unreachable patterns will trigger warnings.

   =From Jian=
   1. The latter patterns include the former patterns can be resonable and clear,
      though they should be arranged in right order.

   2. "Not including, only intersection" is NOT reasonable. I can't imagine when
      can I apply this kind of patterns.

** DONE 15.5 Sealed classes - 323
   CLOSED: [2017-10-21 Sat 20:12]
** DONE 15.6 The ~Option~ type - 325
   CLOSED: [2017-10-21 Sat 20:16]
   Suppose ~Option[T]~ has two values:
   - ~Some(x)~ where ~x~ is of type ~T~
   - ~None~

   Why the ~None~ of ~Option[T]~ type is better than ~null~:
   + ~Option[T]~ is explicit: ~Some("aString")~ and ~None~ is much clearer than
     ~"aString"~ and ~null~. Though syntactically ~null~'s type is a subtype of
     ~String~, semantically ~null~ is nothing (NOT a string).

   + ~None~ won't propagate like ~null~.
     /Flunet style/ can be used to process a ~Option[T]~ type value. The methods
     can be used to process a ~Option[T]~ value always include a mechanism to
     process ~None~ properly.

   + The type system can help you managing values of ~Option[T]~ types, but not
     ~null~, which is always a legal value for all reference types.

** DONE 15.7 Patterns everywhere - 327
   CLOSED: [2017-10-23 Mon 23:25]
*** DONE Patterns in variable definitions
    CLOSED: [2017-10-23 Mon 22:39]
    #+BEGIN_SRC scala
      val myTuple = (123, "abc")
      val (number, string) = myTuple

      val exp = new BinOp("*", Number(5), Number(1))
      val BinOp(op, left, right) = exp
    #+END_SRC

*** DONE Case sequences as partial functions
    CLOSED: [2017-10-23 Mon 23:22]
    A /sequence of cases/ (i.e., alternatives) in curly braces can be used
    ANYWHERE a /function literal/ can be used. Essentially, a case sequence is a
    /function literal/, only more general (multiple entrances).

    - Only indicate the type doesn't tell the compiler a /partial function/
      exists. Use ~PartialFunction~. For example,
      #+BEGIN_SRC scala
        val second: PartialFunction[List[Int], Int] = {
          case x :: y :: _ => y
        }
      #+END_SRC

    - Stackoverflow (=From Jian=):
      why scala doesn't have a built-in ~PartialFunctionN~?

    - Use the ~isDefineAt~ method (of a type ~PartialFunction~ value) and a input
      pattern to check if a pattern is supported by a /partial function/.
      #+BEGIN_SRC scala
        second.isDefineAt(List(5, 6, 7))
        // true

        second.isDefineAt(List())
        // false
      #+END_SRC

    - What does scala do to a /partial function/ definition?
      ~second~ is translated to
      #+BEGIN_SRC scala
        new PartialFunction[List[Int], Int] {
          def apply(xs: List[Int]) = xs match {
            case x :: y :: _ => y
          }

          def isDefinedAt(xs: List[Int]) = xs match {
            case x :: y :: _ => true
            case _ => false
          }
        }
      #+END_SRC

      This translation takes effect _whenever_ the declared type of a function
      literal is ~PartialFunction~.

      If the declared type is just ~Function1~, or is missing, the /function
      literal/ is instead translated to a /complete function/.

    - Of course, you should work with /complete functions/ whenever possible,
      because /partial functions/ allow for runtime errors that the compiler
      cannot help you with.

      However,
      + there are context that you know some patterns will never show up, and
        then you /partial functions/.

      + Alternatively, you might be using a framework that expects /partial
        functions/ and so will always check ~isDefinedAt~ before calling the
        function.

*** DONE Patterns in ~for~ expressions
    CLOSED: [2017-10-23 Mon 23:25]
    A good feature: patterns which are NOT matched will be discard directly.
    #+BEGIN_SRC scala
      val results = List(Some("apple"), None, Some("orange"))

      for (Some(fruit) <- results) println(fruit)
    #+END_SRC

** TODO 15.8 A larger example - 331
** DONE 15.9 Conclusion - 339
   CLOSED: [2017-10-23 Mon 23:28]
   - If you want to use /pattern matching/ on one of your classes, but you do NOT
     want to open access to your classes the way /case classes/ do, you can use
     the /extractors/ described in Chapter 26.
     =TODO=

* TODO 16 Working with Lists - 340
** DONE 16.1 List literals - 340
   CLOSED: [2017-10-24 Tue 01:16]
** DONE 16.2 The ~List~ type - 341
   CLOSED: [2017-10-24 Tue 01:24]
   - Lists are /homogeneous/.

   - The list type in Scala is /covariant/.

     /convariant/ for /list types/ means:
     Two types ~S~ and ~T~. If ~S~ is a subtype of ~T~, then ~List[S]~ is a
     subtype of ~List[T]~.

   - Since the /convariant/ property, ~List()~ is of type ~List[Nothing]~.

   - Because lists are /covariant/, it follows that ~List[Nothing]~ is a subtype
     of ~List[T]~ for ANY type ~T~.

     This is why /empty list/ ~List()~ is of type ~List[Nothing]~,
     though it is permissible to write code like:
     ~val xs: List[String] = List()~

** DONE 16.3 Constructing lists - 341
   CLOSED: [2017-10-24 Tue 01:44]
   Empty list ~Nil~ and an infix operator ~::~
** DONE 16.4 Basic operations on lists - 342
   CLOSED: [2017-10-24 Tue 01:45]
   - ~head~

   - ~tail~

   - ~isEmpty~

** DONE 16.5 List patterns - 343
   CLOSED: [2017-10-24 Tue 01:46]
** TODO 16.6 First-order methods on class List - 345
   - first-order method :: a method that does not take any functions as arguments

*** DONE Concatenating two lists
    CLOSED: [2017-10-24 Tue 01:48]
    ~:::~

*** DONE The Divide and Conquer principle
    CLOSED: [2017-10-24 Tue 01:49]
*** DONE Taking the length of a list: ~length~
    CLOSED: [2017-10-24 Tue 01:49]
*** DONE Accessing the end of a list: ~init~ and ~last~
    CLOSED: [2017-10-24 Tue 01:49]
*** DONE Reversing lists: ~reverse~
    CLOSED: [2017-10-24 Tue 01:52]
    =TODO= PAGE 363

*** DONE Prefixes and suffixes: ~drop~, ~take~, and ~splitAt~
    CLOSED: [2017-10-24 Tue 01:54]
    ~xs splitAt n~ equals ~(xs take n, xs drop n)~
    However, ~splitAt~'s implementation AVOIDS traversing the list xs twice.

*** DONE Element selection: ~apply~ and ~indices~
    CLOSED: [2017-10-24 Tue 01:57]
    - ~abcde apply 2~ results in ~'c'~.
      ~apply~ is rarely used explicitly. 
      ~abcde(2)~ is the often used form.

      ~xs apply n~ equals ~(xs drop n).head~

    - ~abcde.indices~ is ~scala.collection.immutable.Range(0, 1, 2, 3, 4)~

*** DONE Flattening a list of lists: ~flatten~
    CLOSED: [2017-10-24 Tue 01:58]
    ~List(List(1, 2), List(3), List(), List(4, 5)).flatten~ is
    ~List(1, 2, 3, 4, 5)~

*** DONE Zipping lists: ~zip~ and ~unzip~
    CLOSED: [2017-10-24 Tue 02:05]
    - ~zip~:
      ~abcde.indices zip abcde~ is of type
      ~scala.collection.immutable.IndexedSeq[(Int, Char)]~.

      Its value is ~Vector((0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'))~

    - ~zipWithIndex~:
      ~abcde.zipWithIndex~ is of type
      ~List[(Char, Int)]~

      Its value is ~List(('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 4))~

    - ~unzip~:
      ~zipped.unzip~ is of type
      ~(List[Char], List[Int])~

      Its value is ~(List('a', 'b', 'c'), List(1, 2, 3))~

*** DONE Displaying lists: ~toString~ and ~mkString~
    CLOSED: [2017-10-24 Tue 02:11]
    - ~xs mkString sep~ equals ~xs mkString ("", sep, "")~
      ~xs.mkString~ equals ~xs mkString ""~

    - ~scala.StringBuilder~ is NOT ~java.lang.StringBuilder~
      #+BEGIN_SRC scala
        val buf = new StringBuilder
        // buf: StringBuilder =

        abcde addString (buf, "(", ";" ,")")
        // StringBuilder = (a;b;c;d;e)
      #+END_SRC

    - The ~mkString~ and ~addString~ methods are inherited from ~List~'s
      /super trait/ ~Traversable~, so they are applicable to all other
      collections as well.

*** DONE Converting lists: ~iterator~, ~toArray~, ~copyToArray~
    CLOSED: [2017-10-24 Tue 02:17]
    #+BEGIN_SRC scala
      val arr = abcde.toArray
      // arr: Array[Char] = Array(a, b, c, d, e)

      arr.toList
      // res26: List[Char] = List(a, b, c, d, e)

      val arr2 = new Array[Int](10)
      // arr2: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

      List(1, 2, 3) copyToArray (arr2, 3)
      arr2
      // res28: Array[Int] = Array(0, 0, 0, 1, 2, 3, 0, 0, 0, 0)


      val it = abcde.iterator
      // it: Iterator[Char] = non-empty iterator

      it.next
      // res29: Char = a

      it.next
      // res30: Char = b
    #+END_SRC

*** TODO Example: Merge sort
    #+BEGIN_SRC scala
      def msort[T](less: (T, T) => Boolean)
               (xs: List[T]): List[T] = {
        def merge(xs: List[T], ys: List[T]): List[T] =
          (xs, ys) match {
            case (Nil, _) => ys
            case (_, Nil) => xs
            case (x :: xs1, y :: ys1) =>
              if (less(x, y)) x :: merge(xs1, ys)
              else y :: merge(xs, ys1)
          }

        val n = xs.length / 2
        if (n == 0) xs
        else {
          val (ys, zs) = xs splitAt n
          merge(msort(less)(ys), msort(less)(zs))
        }
      }
    #+END_SRC

** DONE 16.7 Higher-order methods on class ~List~ - 357
   CLOSED: [2017-10-24 Tue 17:39]
*** DONE Mapping over lists: ~map~, ~flatMap~ and ~foreach~
    CLOSED: [2017-10-24 Tue 12:55]
*** DONE Filtering lists: ~filter~, ~partition~, ~find~, ~takeWhile~, ~dropWhile~, and ~span~
    CLOSED: [2017-10-24 Tue 13:09]
    - ~xs partition p~ equals ~(xs filter p, xs filter (!p(_)))~

    - ~find~ return ONLY the first element fullfill the requirement.
      The type of its return value is ~Option[T]~.

    - ~xs span p~ equals ~(xs takeWhile p, xs dropWhile p)~
      Like ~splitAt~, ~span~ avoids traversing the list ~xs~ twice.

*** DONE Predicates over lists: ~forall~ and ~exists~
    CLOSED: [2017-10-24 Tue 13:10]
*** DONE Folding lists: ~/:~ and ~:\~
    CLOSED: [2017-10-24 Tue 17:39]
    - ~(z /: List(a, b, c)) (op)~ equals ~op(op(op(z, a), b), c)~
      The ~/:~ operator is pronounced /fold right/.

               op
              /  \
             op   c
            /  \
           op   b
          /  \
         z    a

    - ~(List(a, b, c) :\ z) (op)~ equals ~op(a, op(b, op(c, z)))~
      The ~:\~ operator is pronounced /fold right/.

               op
              /  \
             a    op
                 /  \
                b    op
                    /  \
                   c    z

    - ~flattenRight~ is more efficient than ~flattenLeft~

      ~flattenLeft~ copy the first element of ~xss~ n - 1 times, while
      ~flattenRight~ do it only once.

*** DONE Example: List reversal using fold
    CLOSED: [2017-10-24 Tue 17:30]
    #+BEGIN_SRC scala
      def reverseLeft[T](xs: List[T]) = (List() /: xs) {(ys, y) => y :: ys}
    #+END_SRC

*** DONE Sorting lists: ~sortWith~
    CLOSED: [2017-10-24 Tue 17:33]
    #+BEGIN_SRC scala
      List(1, -3, 4, 2, 6) sortWith (_ < _)

      words sortWith (_.length > _.length)
    #+END_SRC

** DONE 16.8 Methods of the ~List~ object - 365
   CLOSED: [2017-10-24 Tue 02:42]
*** DONE Creating lists from their elements: ~List.apply~
    CLOSED: [2017-10-24 Tue 02:41]
    ~List(1, 2, 3)~ is simply the application of the object ~List~ to the
    elements ~1~, ~2~, ~3~ -- ~List.apply(1, 2, 3)~

*** DONE Creating a range of numbers: ~List.range~
    CLOSED: [2017-10-24 Tue 02:41]
    ~List.range(from, until)~
    ~List.range(from, until, step)~
    #+BEGIN_SRC scala
      List.range(1, 5)
      // res54: List[Int] = List(1, 2, 3, 4)

      List.range(1, 9, 2)
      // res55: List[Int] = List(1, 3, 5, 7)

      List.range(9, 1, -3)
      // res56: List[Int] = List(9, 6, 3)
    #+END_SRC
*** DONE Creating uniform lists: ~List.fill~
    CLOSED: [2017-10-24 Tue 02:33]
    #+BEGIN_SRC scala
      List.fill(5)('a')
      // res57: List[Char] = List(a, a, a, a, a)

      List.fill(3)("hello")
      // res58: List[String] = List(hello, hello, hello, hello, hello)

      List.fill(2, 3)('b')
      // res59: List[List[Char]] = List(List(b, b, b), List(b, b, b))

      // From Jian
      // This is NOT the design intent of `List.fill`, use `List.tabulate`
      var i = 0
      def inc: Int = {
        i += 1
        i
      }

      List.fill(3)(inc)
      // res60: List[Int] = List(1, 2, 3)
    #+END_SRC

*** DONE Tabulating a function: ~List.tabulate~
    CLOSED: [2017-10-24 Tue 02:37]
    #+BEGIN_SRC scala
      val squares = List.tabulate(5)(n => n * n)
      // squares: List[Int] = List(0, 1, 4, 9, 16)

      val multiplication = List.tabulate(5, 5)(_ * _)
      // multiplication: List[List[Int]] = List(List(0, 0, 0, 0, 0),
      //     List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8),
      //     List(0, 3, 6, 9, 12), List(0, 4, 8, 12, 16))
    #+END_SRC

*** DONE Concatenating multiple lists: ~List.concat~
    CLOSED: [2017-10-24 Tue 02:38]
    #+BEGIN_SRC scala
      List.concat(List(), List('b'), List('c'))
      //res61: List[Char] = List(b, c)
    #+END_SRC

** DONE 16.9 Processing multiple lists together - 367
   CLOSED: [2017-10-24 Tue 13:43]
   ~(List(10, 20), List(3, 4, 5)).zipped.map(_ * _)~

** TODO 16.10 Understanding Scala's type inference algorithm - 368
   - /Type inference/ in Scala is flow based.

   - Example 1:
     #+BEGIN_SRC scala
       // abcde = ['a', 'b', 'c', 'd', 'e']
       // #1
       msort((x: Char, y: Char) => x > y)(abcde)

       // #2
       abcde sortWith (_ > _)
     #+END_SRC

     #1 must be explicitly typed
     + The ~msort~ method needs to be instantiated with a type parameter before
       it can be applied to its arguments.

   - This inference scheme suggests the following *library design principle*:
     When designing a /polymorphic method/ that takes
     1. some /non-function arguments/
        and
     2. a /function argument/, place the function argument last in a curried
        parameter list on its own.

     That way, the method's correct instance type can be inferred from the
     non-function arguments, and that type can in turn be used to type check the
     function argument.
       The net effect is that users of the method will be able to give less type
     information and write function literals in more compact ways.

   - 

** DONE 16.11 Conclusion - 372
   CLOSED: [2017-10-24 Tue 13:45]

* DONE 17 Working with Other Collections - 373
  CLOSED: [2017-11-03 Fri 23:39]
** DONE 17.1 Sequences - 373
   CLOSED: [2017-11-01 Wed 03:57]
   - Sequence ::  a group of data lined up in order.

*** DONE Lists
    CLOSED: [2017-11-01 Wed 03:23]
*** DONE Arrays
    CLOSED: [2017-11-01 Wed 03:26]
    - footnote 1: The _difference_ in variance of _Scala's_ and _Java's arrays_
      -- i.e., whether ~Array[String]~ is a subtype of ~Array[AnyRef]~ -- will be
      discussed in Section 19.3. =TODO=

*** DONE List buffers
    CLOSED: [2017-11-01 Wed 03:41]
    - ~List~ has its limitation -- if you want to append element to the end of a
      /list/, you can append to the head, and ~reverse~ at the end.

    - Another alternative, which avoid ~reverse~, is to use a ~ListBuffer~.
      ~ListBuffer~ is a mutable object (contained in package
      ~scala.collection.mutable~), which can help you build lists more
      efficiently when you need to _append_ -- constant time _append_ and
      _prepend_ operations:

      + append operator: ~+=~
      + prepend operator: ~+=:~

    - Example:
      #+BEGIN_SRC scala
        import scala.collection.mutable.ListBuffer

        val buf = new ListBuffer[Int]
        buf += 1
        buf += 2
        buf
        //  buf.type = ListBuffer(1, 2)

        3 +=: buf
        buf
          //  buf.type = ListBuffer(3, 1, 2)

        buf.toList
        // List[Int] = List(3, 1, 2)
      #+END_SRC

    - Another reason to use ListBuffer instead of List is to _prevent_ the
      _potential for stack overflow_.

      If you can build a /list/ in the desired order by _prepending_, but the
      recursive algorithm that would be required is _NOT tail recursive_, you can
      use a ~for~ expression or ~while~ loop and a ~ListBuffer~ instead. You'll
      see ~ListBuffer~ being used in this way in Section 22.2.

      =TODO=

*** DONE Array buffers
    CLOSED: [2017-11-01 Wed 03:53]
    - ~ArrayBuffer~ is like ~Array~, EXCEPT the additional _add_ and _remove_
      elements from the beginning and end of the sequence.

      + ALL
        ~Array~ operations are available, though they are a little slower due to
        a layer of wrapping in the implementation.

      + The new addition and removal operations are constant time on average, but
        occasionally require linear time due to the implementation needing to
        allocate a new array to hold the buffer's contents.

    - Similar to ~ListBuffer~, ~ArrayBuffer~ has the ~+=~, ~+=:~, ~toArray~
      operations.

*** DONE Strings (via ~StringOps~)
    CLOSED: [2017-11-01 Wed 03:57]
    - ~StringOps~ implements many sequence methods.

      ~Predef~ has an implicit conversion from ~String~ to ~StringOps~.

    - Example (Methods in ~StringOps~, NOT Java ~String~):
      #+BEGIN_SRC scala
        def hasUpperCase(s: String) = s.exists(_.isUpper)

        hasUpperCase("Robert Frost")  // true
        hasUpperCase("e e cummings")  // false
      #+END_SRC

** DONE 17.2 Sets and maps - 377
   CLOSED: [2017-11-03 Fri 22:16]
   - By default when you write “Set” or “Map” you get an _immutable_ object.

     You DO need ~import~ to work with their _mutable_ variants.

     #+BEGIN_SRC scala
       object Predef {
         type Map[A, +B] = collection.immutable.Map[A, B]
         type Set[A] = collection.immutable.Set[A]
         val Map = collection.immutable.Map
         val Set = collection.immutable.Set
         //...
       }
     #+END_SRC
     + Here ~type~ define aliases.

     + =TODO= More in 378

*** DONE Using sets
    CLOSED: [2017-11-01 Wed 04:14]
   - ~val words = mutable.Set.empty[String]~

   - ~+=~, ~-=~

   - ~--=~ like ~-=~, but one operand is a collection, NOT single value.
     ~words --= List("do", "re", "mi")~

   - ~++=~ like ~+=~, but one operand is a collection, NOT single value.
     ~words ++= List("do", "do", "re")~

   - The ~clear~ method.

*** DONE Using maps
    CLOSED: [2017-11-01 Wed 20:11]
    - ~val map = mutable.Map.empty[String, Int]~

    - Table 17.2 Common operations for maps
      + Add one entry: ~+~

      + Remove one entry: ~-~
        For example: ~nums - keyValue~

      + Concatenate: ~++~
        For example: ~nums ++ List("iii" -> 3, "v" -> 5)~

      + Remove multple entries: ~--~
        For example: ~nums -- List("iii", "v")~

      + ~contains~ method

      + ~keys~ method returns an ~Iterable~

      + ~keySet~ method returns keys as /set/

      + ~values~ method

      + ~isEmpty~ method

      + ~+=~ for /mutable maps/

      + ~-=~ for /mutable maps/

      + ~++=~ for /mutable maps/

      + ~--=~ for /mutable maps/

*** DONE Default sets and maps
    CLOSED: [2017-11-03 Fri 22:00]
    Both immutable ~Set~ and ~Map~ have 

    The class returned by the ~scala.collection.immutable.Set()~ factory method
    depends on how many elements you pass to it. It tries to maximize performance.
    There are
    + ~scala.collection.immutable.EmptySet~
    + ~scala.collections.immutable.Set1~
    + ~scala.collections.immutable.Set2~
    + ~scala.collections.immutable.Set3~
    + ~scala.collections.immutable.Set4~
    + ~scala.collections.immutable.HashSet~
      
    It is similar to ~scala.collection.immutable.Map()~.

*** DONE Sorted sets and maps
    CLOSED: [2017-11-03 Fri 22:15]
    - For the purpose of use a map or a set in a particular order, the Scala
      ~collections~ library provides /traits/ ~SortedSet~ and ~SortedMap~.
      These /traits/ are implemented by classes ~TreeSet~ and ~TreeMap~, which
      use a /red-black tree/ to keep /elements/ (in the case of ~TreeSet~) or
      /keys/ (in the case of ~TreeMap~) in order.

    - The order is determined by the ~Ordered~ trait, which the element type of
      the set, or key type of the map, must either mix in or be implicitly
      convertible to.

    - These classes ONLY come in _immutable_ variants.

    - Example:
      #+BEGIN_SRC scala
        import scala.collection.immutable.TreeSet
        val ts = TreeSet(9, 3, 1, 8, 0, 2, 7, 4, 6, 5)
        // ts: scala.collection.immutable.TreeSet[Int] =
        //     TreeSet(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

        import scala.collection.immutable.TreeMap
        val tm = TreeMap(3 -> 'x', 1 -> 'x', 4 -> 'x')
        // tm: scala.collection.immutable.TreeSet[Int, Char] =
        //     Map(1 -> x, 3 -> x, 4 -> x)

        tm += (2 -> 'x')
        tm
        // res30: scala.collection.immutable.TreeSet[Int, Char] =
        //     Map(1 -> x, 2 -> x, 3 -> x, 4 -> x)
      #+END_SRC

** DONE 17.3 Selecting mutable versus immutable collections - 385
   CLOSED: [2017-11-03 Fri 23:27]
   - When you don't know, choose /immutable collections/ first.

   - When you don't want copy, use /mutable collections/.

   - /immutable collections/ is more efficient in using space.
     For example,
     + an empty mutable map in its default representation of ~HashMap~ takes up
       about 80 bytes, and about 16 more are added for each entry that's added to
       it.

       An empty immutable ~Map~ is a single object that's share between all
       references, so referring to it essentially costs just a single pointer
       field.

     + The Scala CURRENTLY store /immutable collections/ with up to four entries
       in a single object, which typically takes up between 16 and 40 bytes,
       depending on the number of entires stored in the collection.

       Conclusion: So for _SMALL_ maps and sets, the /immutable/ versions are
       much _more compact than_ the /mutable/ ones.

   - Scala provides some syntactic sugar.
     Whenever you write ~a += b~, and ~a~ does NOT support ~a~ method named +=,
     Scala will try interpreting it as ~a = a + b~.

     =From Jian= DO NOT use this feature. It misleading to the reader.

   - Remember: you can save /immutable collections/ in ~var~!

** DONE 17.4 Initializing collections - 388
   CLOSED: [2017-11-03 Fri 23:39]
*** DONE Converting to array or list
    CLOSED: [2017-11-03 Fri 23:35]
    - ~aList.toArray~ and ~anArray.toList~

    - When you invoke ~toList~ or ~toArray~ on a collection, the order of the
      elements in the resulting list or array will be the same as the order of
      elements produced by an /iterator/ obtained by invoking ~elements~ on that
      collection.

    - Keep in mind, however, that conversion to lists or arrays usually requires
      _copying all_ of the elements of the collection, and thus may be _SLOW for
      LARGE collections_.

*** DONE Converting between mutable and immutable sets and maps
    CLOSED: [2017-11-03 Fri 23:39]
    - Convert a mutable set or map to an immutable one, or vice versa:
      ~emptyTargetCollectionTypeValue ++ existCollectionValue~ 

** DONE 17.5 Tuples - 392
   CLOSED: [2017-10-24 Tue 17:44]
   - Because /tuples/ can combine objects of _different types_, tuples do NOT
     inherit from ~Traversable~.

   - Use ~_n~ method to access the nth element of a tuple.

     The n here starts from 1, which is a convention even in other languages like
     Haskell.

** DONE 17.6 Conclusion - 394
   CLOSED: [2017-11-03 Fri 23:39]
* TODO 18 Mutable Objects - 395
** TODO 18.1 What makes an object mutable? - 395
** TODO 18.2 Reassignable variables and properties - 398
** TODO 18.3 Case study: Discrete event simulation - 401
** TODO 18.4 A language for digital circuits - 402
** TODO 18.5 The ~Simulation~ API - 405
** TODO 18.6 Circuit Simulation - 409
*** The ~Wire~ class
*** The ~inverter~ method
*** The ~andGate~ and ~orGate~ methods
*** Simulation output
*** Running the simulator

** TODO 18.7 Conclusion - 417
* TODO 19 Type Parameterization - 418
** DONE 19.1 Functional queues - 418
   CLOSED: [2017-11-04 Sat 17:22]
   - A functional queue is a data structure with three operations:
     + head :: returns the first element of the queue
     + tail :: returns a queue without its first element
     + enqueue ::  returns a new queue with a given element appended at the end

   - Example (~enqueue~ has O(n) complexity):
     #+BEGIN_SRC scala
       class SlowAppendQueue1[T](elems: List[T]) { // Not efficient
         def head = elems.head
         def tail = new SlowAppendQueue(elems.tail)
         def enqueue(x: T) = new SlowAppendQueue(elems ::: List(x))
       }
     #+END_SRC

   - Example (~enqueue~ has O(1) complexity, but ~head~ and ~tail~ have O(n)
     compleixty):
     #+BEGIN_SRC scala
       // The list is saved reversely (the "smele" is the reverse of "elems")
       class SlowHeadQueue2[T](smele: List[T]) { // Not efficient
                                                 // smele is elems reversed
         def head = smele.last
         def tail = new SlowHeadQueue(smele.init)
         def enqueue(x: T) = new SlowHeadQueue(x :: smele)
       }
     #+END_SRC

   - Example (amortized complexity is constant)
     #+BEGIN_SRC scala
       class Queue[T](
         private val leading: List[T],
         private val trailing: List[T]
       ) {
         private def mirror =
           if (leading.isEmpty)
             new Queue(trailing.reverse, Nil)
           else
             this

         def head = mirror.leading.head

         def tail = {
           val q = mirror
           new Queue(q.leading.tail, q.trailing)
         }

         def enqueue(x: T) =
           new Queue(leading, x :: trailing)
       }
     #+END_SRC
     =IMPORTANT= ANALYSIS 421

** DONE 19.2 Information hiding - 422
   CLOSED: [2017-11-04 Sat 16:27]
*** DONE Private constructors and factory methods
    CLOSED: [2017-11-04 Sat 16:19]
    - A /primary constructor/ is the base of a class, but some /primary
      constructors/ do NOT work in a natural way from the client's point of view,
      and they need to be hidden and called the other /constructors/.

    - The /primary constructor/ in Scala does NOT have an explicit definition,
      and we can use Java-like syntax to make it private, but we have similar
      syntax:
      #+BEGIN_SRC scala
        class Queue[T] private (
          private val leading: List[T],
          private val trailing: List[T]
        )
      #+END_SRC

    - After _hiding_ the /primary constructor/, you need a /constructor/ for the
      client.
      #+BEGIN_SRC scala
        // #0
        // In the Queue class
        def this(elem: T*) = this(elems.toList, Nil)

        // #1
        object Queue {
          def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
        }
      #+END_SRC
      + With the ~apply~ method, from the client' point of view, construct an
        instance of a class is like to call a globally defined factory method,
        though Scala has no globally visible methods -- ~Queue(1, 2, 3)~ is
        expanded to ~Queue.apply(1, 2, 3)~ automatically.

*** DONE An alternative: private classes
    CLOSED: [2017-11-04 Sat 16:27]
    - /Private constructors/ and /private members/ are one way to _hide_ the
      initialization and representation of a class.

      Another more radical way is to _hide_ the class itself and only /export a
      trait/ that reveals the public interface of the class.

    - Example:
      #+BEGIN_SRC scala
        trait Queue[T] {
          def head: T
          def tail: Queue[T]
          def enqueue(x: T): Queue[T]
        }

        object Queue {
          def apply[T](xs: T*): Queue[T] =
            new QueueImpl[T](xs.toList, Nil)

          private class QueueImpl[T](
            private val leading: List[T],
            private val trailing: List[T]
          ) extends Queue[T] {

            def mirror =
              if (leading.isEmpty)
                new QueueImpl(trailing.reverse, Nil)
              else
                this

            def head: T = mirror.leading.head

            def tail: QueueImpl[T] = {
              val q = mirror
              new QueueImpl(q.leading.tail, q.trailing)
            }

            def enqueue(x: T) =
              new QueueImpl(leading, x :: trailing)
          }
        }
      #+END_SRC

** DONE 19.3 Variance annotations - 425
   CLOSED: [2017-11-05 Sun 03:42]
   - /Type constructor/, /generic trait/

   - /variance/:
     + /covariant/, ~+~ type prefix

     + /nonvariant/

     + /contravariant/, ~-~ type prefix

   - The ~+~ and ~-~ symbols that can prefix a type parameter are called
     /variance annotations/.

   - =IMPORTANT=
     In a purely functional world, many types are _naturally_ /covariant/
     (flexible).

     However, the situation changes once you introduce mutable data.

*** Variance and arrays
    - Scala treats arrays as /nonvariant/ (rigid)

    - Java didn't have /generics/ before Java 5.

      To have a simple means to treat arrays generically, Java language decides
      to treat its ~Array~ as /covariant/, though some operations lead to runtime
      errors. For example:
      #+BEGIN_SRC java
        String[] a1 = { "abc" };
        Object[] a2 = a1;
        a2[0] = new Integer(17);
        String s = a1[0];

        // // Runtime Error
        // //
        // Exception in thread "main" java.lang.ArrayStoreException:
        // java.lang.Integer
        //         at JavaArrays.main(JavaArrays.java:8)
      #+END_SRC

      After having /generics/, there is a simple mean to treat arrays generical-
      ly. The /covariant/ property of ~Array~'s still exist just for
      compatibility.

    - =IMPORTANT=
      Since Scala treats arrays as /nonvariant/ (rigid), so an ~Array[String]~ is
      _NOT_ considered to conform to an ~Array[Any]~.

      Sometimes it is necessary to interact with legacy methods in Java that use
      an ~Object~ array as a means to emulate a generic array. For instance, you
      might want to call a ~sort~ method like the one described previously with
      an array of ~String~'s as argument. To make this possible, Scala lets you
      cast an array of ~T~'s to an array of any supertype of ~T~:
      #+BEGIN_SRC scala
        val a2: Array[Object] =
          a1.asInstanceOf[Array[Object]]

        // a2: Array[Object] = Array(abc)
      #+END_SRC
      The cast is always legal at compile-time, and it will always succeed at
      runtime because the JVM’s underlying run-time model treats arrays as
      covariant, just as Java the language does. But you might get ArrayStore
      exceptions afterwards, again just as you would in Java.

** DONE 19.4 Checking variance annotations - 429 - =Re-READ=
   CLOSED: [2017-11-05 Sun 05:43]
** DONE 19.5 Lower bounds - 432
   CLOSED: [2017-11-07 Tue 00:14]
   #+BEGIN_SRC scala
     class Queue[+T] (private val leading: List[T],
                      private val trailing: List[T]) {
       def enqueue[U >: T](x: U) =
         new Queue[U](leading, x :: trailing) //...
     }
   #+END_SRC

** DONE 19.6 Contravariance - 434
   CLOSED: [2017-11-07 Tue 00:34]
   - It is safe to assume that a type ~T~ is a /subtype/ of a type ~U~ if you can
     substitute a value of type ~T~ wherever a value of type ~U~ is required.

       This is called the /Liskov Substitution Principle/.

   - The principle holds if ~T~ supports the same operations as ~U~, and all of
     ~T~'s operations _require less and provide more_ than the corresponding
     operations in ~U~.

     For example,
     #+BEGIN_SRC scala
       trait OutputChannel[-T] {
         def write(x: T)
       }
     #+END_SRC
     ~OutputChannel[AnyRef]~ is a subtype of ~OutputChannel[String]~.

   - Example:
     #+BEGIN_SRC scala
       trait Function1[-S, +T] {
         def apply(x: S): T
       }
     #+END_SRC

     ~Function1~ is
     + /contravariant/ in the function argument type ~S~
     + /convariant/ in the reulst type ~T~.

   - =TODO= Listing 19.9

** TODO 19.7 Object private data - 437
** TODO 19.8 Upper bounds - 439
** TODO 19.9 Conclusion - 442
* DONE 20 Abstract Members - 443
  CLOSED: [2017-11-12 Sun 01:26]
  - abstract member :: A member of a /class/ or /trait/ is abstract if the member
       does _not have a complete definition_.

  - In Scala you can declare /abstract fields/ and even /abstract types/ as
    members of /classes/ and /traits/. This goes beyond Java, which only lets you
    declare /abstract methods/.

  - In this chapter
    we'll describe all _FOUR_ kinds of /abstract member/:
    + vals
    + vars
    + methods
    + types

  - Along the way of describing all four kinds of /abstract member/,
    we'll discuss
    + pre-initialized fields
    + lazy vals
    + path-dependent types =TODO= =???=
    + enumerations

** DONE 20.1 A quick tour of abstract members - 443
   CLOSED: [2017-11-09 Thu 20:54]
   - A /trait/ includes four kinds of /abstract members/:
     #+BEGIN_SRC scala
       trait Abstract {
         type T
         def transform(x: T): T
         val initial: T
         var current: T
       }
     #+END_SRC

     A concrete implementation of the ~Abstract~ /trait/.
     #+BEGIN_SRC scala
       class Concrete extends Abstract {
         type T = String
         def transform(x: String) = x + x
         val initial = "hi"
         var current = initial
       }
     #+END_SRC

** DONE 20.2 Type members - 444
   CLOSED: [2017-11-09 Thu 20:58]
   A type /alias/ that uses the ~type~ keyword to declare.

** DONE 20.3 Abstract ~val~'s - 445
   CLOSED: [2017-11-09 Thu 21:04]
   An abstract ~val~ can't be /overrided/ by a subtype with ~def~.

** DONE 20.4 Abstract ~var~'s - 446
   CLOSED: [2017-11-09 Thu 21:09]
   When you declare an abstract ~var~, you implicitly declare an abstract
   /getter/ and /setter/. For instance, there are two exactly equivalent
   definitions:
   #+BEGIN_SRC scala
     trait AbstractTime {
       var hour: Int
       var minute: Int
     }
   #+END_SRC

   #+BEGIN_SRC scala
     trait AbstractTime {
       def hour: Int      // getter for `hour`
       def hour_=: Int    // setter for `hour`
       def minute: Int    // getter for `minute`
       def minute_=: Int  // setter for `minute`
     }
   #+END_SRC

** DONE 20.5 Initializing abstract ~val~'s - 447
   CLOSED: [2017-11-11 Sat 21:03]
   - Create a /instance/ of an /anonymous class/ that /mixes in/ the /trait/ and
     is defined by the body.
     #+BEGIN_SRC scala
       trait RationalTrait {
         val numerArg: Int
         val denomArg: Int
       }

       val r = new RationalTrait {
         val numerArg = 1
         val denomArg = 2
       }
     #+END_SRC

   - This particular /anonymous class instantiation/ has an effect _analogous to_
     the instance creation ~new Rational(1, 2)~.

     However, this analogy is NOT perfect.
     + For classes, When you write: ~new Rational(expr1, expr2)~, the two
       expressions, ~expr1~ and ~expr2~, are evaluated before class ~Rational~
       is initialized, so the values of ~expr1~ and ~expr2~ are available for
       the initialization of class ~Rational~.

     + For traits, When you write:
       #+BEGIN_SRC scala
         new RationalTrait {
           val numerArg = expr1
           val denomArg = expr2
         }
       #+END_SRC
       * ~expr1~ and ~expr2~, are evaluated as part of the initialization of the
         /anonymous class/,

       * but the /anonymous class/ is _initialized AFTER_ the ~RationalTrait~.

       So the /values/ of ~numerArg~ and ~denomArg~ are _NOT available_ during
       the initialization of ~RationalTrait~ (more precisely, a selection of
       either value would yield the /default value/ for type ~Int~, ~0~).
         This is NOT a problem for the example above.
         A problematic example is showed below.

   - Example:
     #+BEGIN_SRC scala
       trait RationalTrait {
         val numerArg: Int
         val denomArg: Int

         require(denomArg != 0)

         private val g = gcd(numerArg, denomArg)
         val numer = numerArg / g
         val denom = denomArg / g

         private def gcd(a: Int, b: Int): Int =
           if (b == 0) a else gcd(b, a % b)

         override def toString = numer + "/" + denom
       }

       val x = 2

       new RationalTrait {
         val numerArg = 1 * x
         val denomArg = 2 * x
       }

       // java.lang.IllegalArgumentException: requirement failed
       //   at scala.Predef$.require(Predef.scala:207)
       //   at RationalTrait$class.$init$(<console>:10)
       //   ... 28 elided
     #+END_SRC

     The pre-requisite is not fullfilled due to the reason mentioned above.

   - Scala offers _TWO_ alternative solutions to this problem:
     + /pre-initialized fields/
     + /lazy vals/

     =TODO= They are presented in the remainder of this section.

*** Pre-initialized fields
    - pre-initialized fields :: A syntax that lets you initialize a field of a
         /subclass/ _BEFORE_ the /superclass/ is called.

    - Example:
      #+BEGIN_SRC scala
        //// initialize an anonymous class
        new {
          val numerArg = 1 * x
          val denomArg = 2 * x
        } with RationalTrait


        //// define object
        object twoThirds extends {
          val numerArg = 2
          val denomArg = 3
        } with RationalTrait


        //// define class
        class RationalClass(n: Int, d: Int) extends {
          val numerArg = n
          val denomArg = d
        } with RationalTrait {
          def + (that: RationalClass) = new RationalClass(
            numer * that.denom + that.numer * denom,
            denom * that.denom
          )
        }
      #+END_SRC

    - Because /pre-initialized fields/ are initialized _BEFORE_ the /superclass
      constructor/ is called, their initializers CANNOT refer to the object
      that's being constructed.

      Consequently, if such an initializer refers to ~this~, the reference goes
      to
      + the object CONTAINING the class
        (=From Jian= if this is successful, the result is usually not the wanted)

      + object that's _being constructed_,
        (=From Jian= this can always be an error???)

      NOT the _constructed object_ itself.

    - Example (in REPL):
      #+BEGIN_SRC scala
        // scala>
        new {
          val numerArg = 1
          val denomArg = this.numerArg * 2
        } with RationalTrait

        // <console>:11: error: value numerArg is not a member of object
        //  $iw
        //                 val denomArg = this.numerArg * 2
      #+END_SRC
      =Re-READ=
      The example did _NOT compile_ because the reference ~this.numerArg~ was
      looking for a ~numerArg~ field in _the object containing this ~new~
      expression_ (which in this case was the synthetic object named ~$iw~, into
      which the interpreter puts user input lines). Once more, pre-initialized
      fields behave in this respect like class constructor arguments.

*** Lazy ~val~'s
    - Comparison:
      + Strict
        #+BEGIN_SRC scala
          // scala>
          object Demo {
            val x = { println("initializing x"); "done" }
          }

          // scala>
          Demo
          // initializing x
          // res3: Demo.type = Demo$@2129a843

          // scala>
          Demo.x
          // res4: String = done
        #+END_SRC

      + Lazy
        #+BEGIN_SRC scala
          // scala>
          object Demo {
            lazy val x = { println("initializing x"); "done" }
          }
          // define object Demo

          // scala>
          Demo
          // res5: Demo.type = Demo$@5b1769c

          // scala>
          Demo.x
          // initializing x
          // res6: String = done

        #+END_SRC

    - Unlike a ~def~, a /lazy/ ~val~ is NEVER evaluated more than once.
      The evaluted value is cached for later use.

    - Reformulate ~RationalTrait~ to ~LazyRationalTrait~:
      #+BEGIN_SRC scala
        trait LazyRationalTrait {
          val numerArg: Int
          val denomArg: Int
          lazy val numer = numerArg / g
          lazy val denom = denomArg / g
          override def toString = numer + "/" + denom
          private lazy val g = {
            require(denomArg ! = 0)
            gcd(numerArg, denomArg)
          }
          private def gcd(a: Int, b: Int): Int =
            if (b == 0) a else gcd(b, a % b)
        }
      #+END_SRC
      + If we put the ~require~ statement in the original position as in
        ~RationalTrait~, ~denomArg~ will be forced to evaluate too early.
        Thus, we put the ~require~ statement just before the call to ~gcd~, where
        the condition ~denomArg != 0~ is important.

      + One important property of lazy ~val~'s:
        The textual order of their definitions does NOT matter because values get
        initialized on demand.
          However, this advantage holds only as long as the initialization of
        lazy ~val~'s neither produces side effects nor depends on them.
          So _lazy ~val~'s are an ideal complement to functional objects_, where
        the order of initializations does NOT matter, as long as everything gets
        initialized eventually.

** DONE 20.6 Abstract types - 455
   CLOSED: [2017-11-11 Sat 21:46]
   - Example (why do we need /abstract types/):
     + Wrong way
       #+BEGIN_SRC scala
         class Food
  
         abstract class Animal {
           def eat(food: Food)
         }
  
  
         class Grass extends Food
  
         class Cow extends Animal {
           override def eat(food: Grass) = {}  // This won't compile
         }
       #+END_SRC

     + Wrong way but compilable
       #+BEGIN_SRC scala
         class Food

         abstract class Animal {
           def eat(food: Food)
         }

         class Cow extends Animal {
           override def eat(food: Food) = {}
         }

         class Fish extends Food
         val bessy: Animal = new Cow
         bessy eat (new Fish)  // Everything is OK, but the meaning in the real world.
       #+END_SRC

     + Right way
       #+BEGIN_SRC scala
         class Food

         abstract class Animal {
           type SuitableFood <: Food
           def eat(food: SuitableFood)
         }


         class Grass extends Food

         class Cow extends Animal {
           type SuitableFood = Grass
           override def eat(food: Grass) = {}
         }
       #+END_SRC

** DONE 20.7 Path-dependent types - 457
   CLOSED: [2017-11-11 Sat 22:39]
   - path-dependent type :: A type like ~bessy.SuitableFood~

   - A /path-dependent type/ resembles the syntax for an /innter class type/
     _in Java_, _but there is a CRUCIAL difference_:
     + a /path-dependent type/ names an /outer object/
     + an /inner class/ type names an /outer class/.

   - Scala can also create /inner class/ types.
     The sytax of definition is similar to Java, while the syntax of usage is
     different, use ~Outer#Inner~ -- Scala keep ~.~ for objects ONLY.

     For example,
     #+BEGIN_SRC scala
       class Outer {
         class Inner
       }

       val o1 = new Outer
       val o2 = new Outer
     #+END_SRC
     Here ~o1.Inner~ and ~o2.Inner~ are two /path-dependent types/ (and they are
     _DIFFERENT_ types). Both of these types conform to (are subtypes of) the more
     general type ~Outer#Inner~, which represents the ~Inner~ class with an
     arbitrary outer object of type Outer.

     By contrast, type ~o1.Inner~ refers to the ~Inner~ class with a specific
     outer object (the one referenced from ~o1~). Likewise, type ~o2.Inner~
     refers to the ~Inner~ class with a different, specific outer object (the one
     referenced from ~o2~).

   - In Scala, as in Java, /inner class instances/ _hold a reference to an
     enclosing_ /outer class instance/. This allows an /inner class/, for
     example, to access members of its /outer class/.

     Thus you _CANNOT_ instantiate an /inner class/ without in some way
     specifying an /outer class instance/.

   - You can ~new o1.Inner~ -- it knows its outer object is ~o1~.
     You cannot ~new Outer#Inner~ -- NO outer object specified.

** DONE 20.8 Refinement types - 460
   CLOSED: [2017-11-11 Sat 22:48]
   - nominal subtype ::

   - structural subtyping ::

   - Use the /nominal subtype/ way, if you want to define a class ~Pasture~ that
     can contain animals that eat grass, you need to first define a trait
     ~AnimalThatEatsGrass~ and mix it into every class where it applies. This is
     _VERBOSE_.

   - Use the /structural subtyping/ way (use /refinement type/):
     #+BEGIN_SRC scala
       class Pasture {
         var animals: List[Animal { type SuitableFood = Grass }] = Nil
         //...
       }
     #+END_SRC

** DONE 20.9 Enumerations - 461
   CLOSED: [2017-11-11 Sat 23:46]
   Extend the ~scala.Enumeration~ class to create /enumerations/.

   - Syntax:
     #+BEGIN_SRC scala
       object Color extends Enumeration {
         val Red = Value
         val Green = Value
         val Blue = Value
       }
     #+END_SRC

   - syntactic sugared version:
     #+BEGIN_SRC scala
       object Color extends Enumeration {
         val Red, Green, Blue = Value
       }
     #+END_SRC

   - /Enumeration/ defines an /inner class/ named ~Value~, and the same-named
     parameterless ~Value~ method returns a fresh instance of that class.
       It means in the above example, ~Color.Red~, ~Color.Green~, ~Color.Blue~ is
     of type ~Color.Value~.

   - Associate names to the variants of a /enumeration/.
     #+BEGIN_SRC scala
       object Direction extends Enumeration {
         val North = Value("North")
         val East = Value("East")
         val South = Value("South")
         val West = Value("West")
       }

       for (d <- Direction.values) print(d + " ")
       // North East South West
     #+END_SRC

   - Values of an enumeration are numbered from 0, and use the ~id~ method to
     find out them: ~Direction.East.id~

   - Get a variant of /enumeration/ from a integer. For example the result of
     ~Direction(1)~ is ~Direction.East~

** DONE 20.10 Case study: Currencies - 463 - =RE-READ=
   CLOSED: [2017-11-12 Sun 01:26]
** DONE 20.11 Conclusion - 473
   CLOSED: [2017-11-12 Sun 01:26]

* DONE 21 Implicit Conversions and Parameters - 474
  CLOSED: [2017-11-18 Sat 00:02]
** DONE 21.1 Implicit conversions - 474
   CLOSED: [2017-11-16 Thu 03:34]
   - /Implicit conversions/ help by _reducing_ the number of _explicit_
     conversions that are needed from one type to another.

   - Example:
     #+BEGIN_SRC scala
       // Use Swing
       val button = new JButton

       // If no implicit convertion
       button.addActionListener(
         new ActionListener {
           def actionPerformed(event: ActionEvent) = {
             println("pressed!")
           }
         }
       )


       // Eliminate information-free boilerplate code.
       // (Scala 2.12, which includes support to Java 8 feature, can compile the code
       // below)
       button.addActionListener(
         // Type mismatch if no implicit conversion or Scala that < 2.12!
         (_: ActionEvent) => println("pressed!")
       )


       // With implicit convertion
       implicit def function2ActionListener(f: ActionEvent => Unit) =
         new ActionListener {
           def actionPerformed(event: ActionEvent) = f(event)
         }

       button.addActionListener(
         (_: ActionEvent) => println("pressed!")
       )
     #+END_SRC

** DONE 21.2 Rules for implicits - 477
   CLOSED: [2017-11-17 Fri 23:58]
   - Marking rule :: Only definitions marked ~implicit~ are available.
     + You can use ~implicit~ to mark any
       * /variable/ definition =???=
       * /function/ definition
       * /object/ definition =???=

   - Scope rule :: An inserted /implicit conversion/ must
     + be in scope as a /single identifier/
       For example, ~someVariable.convert~ won't be considered (not a /single
       indentifier/), you must import and use ~convert~ directly

       or

     + be associated with the source or target type of the
       conversion.

       The companion object will be considered without explicitly import.
       #+BEGIN_SRC scala
         object Dollar {
           implicit def dollarToEuro(x: Dollar): Euro = ...
         }

         class Dollar { ... }
       #+END_SRC
       The /implicit conversion/ function can also be in the ~Euro~ companion
       object. Both works.

   - It is common for libraries to include a ~Preamble~ object including a number
     of useful implicit conversions. Code that uses the library can then do a
     single ~import Preamble._~ to access the library's /implicit conversions/.

   - One-at-a-time rule :: Only one implicit is inserted.

   - Explicits-first rule :: Whenever code type checks as it is written, no
        implicits are attempted.

*** DONE Naming an implicit conversion
    CLOSED: [2017-11-16 Thu 04:31]
    - The name of an /implicit conversion/ matters only in _TWO_ situations:
      + If you want to write it explicitly in a method application
      + for determining which implicit conversions are available at any place in
        the program -- you can import (by name) only the ones you need.

*** DONE Where implicits are tried
    CLOSED: [2017-11-17 Fri 23:59]
    - There are _THREE_ places /implicits/ are used in the language:
      + conversions to an expected type:
        /Implicit conversions/ to an expected type let you use one type in a
        context where a different type is expected.
        For example, ~String~ to ~IndexedSeq[Char]~

      + conversions of the receiver of a selection:
        Conversions of the receiver let you adapt the receiver of a method call
        (i.e., the object on which a method is invoked), if the method is not
        applicable on the original type.

        For example, ~"abc".exists~ to ~stringWrapper("abc").exists~
        (~exist~ is available on ~IndexedSeq~'s rather than ~String~'s)


      + implicit parameters: like the type class in Haskell - add /implicit
        parameters/ to a generic function to provide more information to the
        generic type(s).

** DONE 21.3 Implicit conversion to an expected type - 480
   CLOSED: [2017-11-16 Thu 04:31]
   Example:
   #+BEGIN_SRC scala
     // This is in `Predef`
     implicit def int2double(x: Int): Double = x.toDouble
   #+END_SRC
   That's why in Scala ~Int~ values can be stored in variables of type ~Double~.
     There's _NO_ special rule in the type system for this; it's just an
   /implicit conversion/ that gets applied.

   The Scala compiler backend will treat the conversion specially, however,
   translating it to a special ~i2d~ bytecode. So the compiled image is the same
   as in Java.

** DONE 21.4 Converting the receiver - 482
   CLOSED: [2017-11-16 Thu 06:19]
*** DONE Interoperating with new types
    CLOSED: [2017-11-16 Thu 05:48]
    #+BEGIN_SRC scala
      class Rational(n: Int, d: Int) {
        // ...
        def + (that: Rational): Rational = ...
        def + (that: Int): Rational = ...
      }

      val oneHalf = new Rational(1, 2)
      oneHalf + oneHalf  // res0: Rational = 1/1
      oneHalf + 1        // res1: Rational = 3/2

      // BUT this doesn't compile
      1 + oneHalf

      // Then
      implicit def intToRational(x: Int) = new Rational(x, 1)

      1 + oneHalf
      // res2: Rational = 3/2
      //// In the background: `intToRational(1) + oneHalf`
    #+END_SRC

*** DONE Simulating new syntax
    CLOSED: [2017-11-16 Thu 06:03]
    - Consider the ~->~ in a ~Map~ like ~Map(1 -> "one", 2 -> "two",
      3 -> "three")~
      + It is NOT syntax!

      + It is a method of the class ~ArrowAssoc~, a class defined inside the
        standard Scala preamble (~scala.Predef)~.

        The preamble also defines an /implicit conversion/ from ~Any~ to
        ~ArrowAssoc~ (the the ~->~ method can be used).

      #+BEGIN_SRC scala
        package scala

        object Predef {
          class ArrowAssoc[A](x: A) {
            def -> [B](y: B): Tuple2[A, B] = Tuple2(x, y)
          }

          implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =
            new ArrowAssoc(x)

          //...
        }
      #+END_SRC

    - There are a lot of ~RichSomething~ classes.
      That class is likely adding syntax-like methods to type ~Something~.

    - An internal DSL can be defined as a library with the help of /implicit
      conversion/.

*** DONE Implicit classes =Re-READ=
    CLOSED: [2017-11-16 Thu 06:19]
    - /Implicit classes/ were added in Scala _2.10_ to make it easier to write
      /rich wrapper classes/.

      For any such class, the compiler generates an /implicit conversion/

      *from* the class's constructor parameter *to* the class itself.

      Such a conversion is just what you need if you plan to use the class for
      the /rich wrappers pattern/.

    - Example:
      #+BEGIN_SRC scala
        case class Rectangle(width: Int, height: Int)

        implicit class RectangleMaker(width: Int) {
          def x(height: Int) = Rectangle(width, height)
        }

        // Then we can do
        val myRectangle = 3 x 4
        // myRectangle: Rectangle = Rectangle(3, 4)
      #+END_SRC

    - NOT any class can have ~implicit~ put in front of it.

      An /implicit class/
      + CANNOT be a /case class/
      + its constructor MUST have exactly _ONE_ parameter.
      + an /implicit class/ MUST be located within some other /object/, /class/,
        or /trait/.

      In practice, so long as you use /implicit classes/ as /rich wrappers/ to
      add a few methods onto an _existing class_, these restrictions should NOT
      matter.

** DONE 21.5 Implicit parameters - 485
   CLOSED: [2017-11-16 Thu 18:38]
   - Example (default parameters):
     #+BEGIN_SRC scala
       class PreferredPrompt(val preference: String)
       class PreferredDrink(val preference: String)
  
       object Greeter {
         def greet(name: String)(implicit prompt: PreferredPrompt,
                                 drink: PreferredDrink) = {
           println("Welcome, " + name + ". The system is ready.")
           print("But while you work, ")
           println("why not enjoy a cup of " + drink.preference + "?")
           println(prompt.preference)
         }
       }
  
       object JoesPrefs {
         implicit val prompt = new PreferredPrompt("Yes, master> ")
         implicit val drink = new PreferredDrink("tea")
       }
  
       Greeter.greet("Joe")(prompt, drink)
       // OR
       Greeter.greet("Joe")
  
       // Welcome, Joe. The system is ready.
       // But while you work, why not enjoy a cup of tea?
       // Yes, master>
     #+END_SRC


   - They are perhaps most often used to provide information about a type
     mentioned _explicitly_ in an earlier parameter list, similar to the /type
     classes/ of Haskell.

   - Example (type-classes-like):
     #+BEGIN_SRC scala
       //// _Replace_
       // def maxListOrdering[T](elements: List[T])
       //                    (ordering: Ordering[T]): T =
       //// _With_
       def maxListOrdering[T](elements: List[T])
                          (implicit ordering: Ordering[T]): T =
         elements match {
           case List() =>
             throw new IllegalArgumentException("empty list!")
           case List(x) => x
           case x :: rest =>
             val maxRest = maxListOrdering(rest)(ordering)
             if (ordering.gt(x, maxRest)) x
             else maxRest
         }
     #+END_SRC

     This pattern is so common that the standard Scala library provides implicit
     "ordering" methods for many common types. That's way we can mostly use
     ~maxListImpParm~ without providing the implicit ~ordering~ argument.

*** DONE A style rule for implicit parameters
    CLOSED: [2017-11-16 Thu 18:38]
    It is best to use a custom named type in the types of /implicit parameters/.
    As a counterexample,
    #+BEGIN_SRC scala
      def maxListPoorStyle[T](elements: List[T])
                          (implicit orderer: (T, T) => Boolean): T
    #+END_SRC
    - The ~(T, T) => Boolean~ is a farily generic type that, however, without
      indicating anything at all about what the type is for -- it could be
      + a equality test
      + a less than test
      + a greater-than test
      + a something else

    - The good style one is of type ~Ordering[T]~, which is informative.

    - Thus *the style rule*:
      Use at least one role-determining name within the type of an /implicit
      parameter/.

** DONE 21.6 Context bounds - 491
   CLOSED: [2017-11-17 Fri 15:07]
   #+BEGIN_SRC scala
     def maxList[T](elements: List[T])
                (implicit ordering: Ordering[T]): T =
       elements match {
         case List() =>
           throw new IllegalArgumentException("empty list!")
         case List(x) => x
         case x :: rest =>
           val maxRest = maxList(rest)
           if (implicitly[Ordering[T]].gt(x, maxRest)) x
           else maxRest
     }
   #+END_SRC
   We can get rid of the ~ordering~ inside the body of ~maxList~ by
   - Use the already in-scope implicit argument(s):
     ~maxList(rest)(ordering)~ is simplified to ~maxList(rest)~

   - Use the ~implicitly[T]~ function, which is defined in the standard library
     as ~def implicitly[T](implicit t: T) = t~:
     ~ordering.gt(x, maxRest)~ is simplified (globally, rather than locally --
     the length is longer) to ~implicitly[Ordering[T]].gt(x, maxRest)~

     =TODO= =RE-READ= page 492

     After applying the two steps above, there is no ~ordering~ inside the body
     of ~maxList~, which is good that when changing the name of the /implicit
     parameter/, there is no need to change the body of this function.

   - This pattern if common, Scala lets you leave out the name of this parameter
     and shorten the method header by using a /context bound/.
     #+BEGIN_SRC scala
       def maxList[T : Ordering](elements: List[T]): T = ...
     #+END_SRC
     With /context bound/ we don't have the name of the implicit parameter, the
     use of ~implicitly[T]~ is then not just "another way", but the only way.

   - Comparison
     + ~[T <: Ordered[T]]~: ~T~ is an ~Ordered[T]~.

     + ~[T : Ordering]~: some form of ordering associated with ~T~.
       This is more flexible than the ~[T <: Ordered[T]]~.

** DONE 21.7 When multiple conversions apply - 494
   CLOSED: [2017-11-17 Fri 15:36]
   If MULTIPLE implicit conversions exist,
   - Up through Scala 2.7, this triggers compiler error

   - Scala 2.8+ lossened this rule -- the more specific one is chosen. 

     What does the "specific" here means?
     + The argument type of the former is a subtype of the latter's.

     + Both conversions are methods, and the enclosing class of the former
       extends the enclosing class of the latter.
       For example, ~Predef~ extends ~LowPriorityImplicits~

   - In Scala 2.7, for example, since Java ~String~ doesn't have the ~reverse~
     method,
     + in ~val cba = "abc".reverse~, ~cba~ is a collection.

     + ~"abc" == "abc".reverse.reverse~ was ~false~

   - With Scala 2.8, the type of ~cba~ is ~String~.

     The old implicit conversion to a Scala collection (~WrappedString~) is
     retained. HOWEVER, there is a more specific conversion supplied from
     ~String~ to a new type called ~StringOps~.
       The conversion to ~StringOps~ is defined directly in ~Predef~, whereas the
     conversion to a Scala collection is defined in a new class,
     ~LowPriorityImplicits~, which is extended by ~Predef~. Apply the second
     rule, we know the /implicit conversion/ in ~Predef~ is preferred.

** DONE 21.8 Debugging implicits - 496
   CLOSED: [2017-11-17 Fri 23:22]
   - Some debug tips:
     1. When you see some error you don't quite get it, try to convert the
        /implicit conversion/ explicitly. Then the error message may become
        clear.
        #+BEGIN_SRC scala
          // scala>
          val chars: List[Char] = "xyz"
          // <console>:24: error: type mismatch;
          //  found : String("xyz")
          //  required: List[Char]
          //        val chars: List[Char] = "xyz"
          //                                ^

          scala> val chars: List[Char] = wrapString("xyz")
          // <console>:24: error: type mismatch;
          //  found : scala.collection.immutable.WrappedString
          //  required: List[Char]
          //        val chars: List[Char] = wrapString("xyz")
          //                                          ^
        #+END_SRC

     2. After applying 1, if there is not any error, you need to consider the
        other reasons (such as the Scope Rule) that prevent the /implicit
        conversion/ from being applied.

     3. Try the ~-Xprint:typer~ option of ~scalac~, and the compiler will show
        you what your code looks like after all implicit conversions have been
        added by the type checker.
        #+BEGIN_SRC scala
          object Mocha extends App {
            class PreferredDrink(val preference: String)
            implicit val pref = new PreferredDrink("mocha")
            def enjoy(name: String)(implicit drink: PreferredDrink) = {
              print("Welcome, " + name)
              print(". Enjoy a ")
              print(drink.preference)
              println("!")
            }
            enjoy("reader")
          }

          // $ scalac -Xprint:typer mocha.scala
          // [[syntax trees at end of typer]]// Scala source: mocha.scala
          // package <empty> {
          //   final object Mocha extends java.lang.Object with Application
          //       with ScalaObject {
          //     // ...
          //     private[this] val pref: Mocha.PreferredDrink =
          //       new Mocha.this.PreferredDrink("mocha");
          //     implicit <stable> <accessor>
          //     def pref: Mocha.PreferredDrink = Mocha.this.pref;
          //     def enjoy(name: String)
          //              (implicit drink: Mocha.PreferredDrink): Unit = {
          //       scala.this.Predef.print("Welcome, ".+(name));
          //       scala.this.Predef.print(". Enjoy a ");
          //       scala.this.Predef.print(drink.preference);
          //       scala.this.Predef.println("!")
          //     };
          //     Mocha.this.enjoy("reader")(Mocha.this.pref)
          //   }
          // }
        #+END_SRC

** DONE 21.9 Conclusion - 497
   CLOSED: [2017-11-17 Fri 23:54]
   - /Implicit/ are a powerful, _code-condensing_ feature of Scala.

   - Warning:
     /implicits/ can make code confusing if they are used too frequently.

   - Before adding a new implicit conversion, first try other means, such as
     + inheritance
     + mixin composition
     + method overloading

* TODO 22 Implementing Lists - 499
  =DONE= without notes
** TODO 22.1 The ~List~ class in principle - 499
*** The ~Nil~ object
*** The ~::~ class
*** Some more methods
*** List construction

** TODO 22.2 The ~ListBuffer~ class - 505
** TODO 22.3 The ~List~ class in practice - 507
** TODO 22.4 Functional on the outside - 509
** TODO 22.5 Conclusion - 510

* TODO 23 For Expressions Revisited - 512 =ALMOST DONE=
  - More generally,
    + ALL ~for~ expressions that ~yield~ a result are _translated_ by the
      compiler into combinations of invocations of the higher-order methods
      ~map~, ~flatMap~, and ~withFilter~.

    + ALL ~for~ loops WITHOUT ~yield~ are translated into a smaller set of
      higher-order functions: just ~withFilter~ and ~foreach~.

  - In this chapter, you'll find out
    1. the precise rules of writing for expressions
    2. how they can make combinatorial problems easier to solve.
    3. how ~for~ expressions are translated, and how as a result, ~for~
       expressions can help you "grow" the Scala language into new application
       domains.

** DONE 23.1 ~for~ expressions - 513
   CLOSED: [2017-10-21 Sat 21:52]
   Syntax: ~for ( seq ) yield expr~

   - Here, ~seq~ is a sequence of /generators/, /definitions/, and /filters/,
     with semicolons between successive elements.

   - Enclose the ~seq~ in /braces/ instead of /parentheses/. Then the semicolons
     become _optional_:
     #+BEGIN_SRC scala
       for (p <- persons; n = p.name; if (n startsWith "To"))
       yield n

       // OR

       for {
         p <- persons             // a generator
         n = p.name               // a definition
         if (n startsWith "To")   // a filter
       } yield n
     #+END_SRC

     + A /generator/ is of the form: ~pat <- expr~
       The ~pat~ gets matched one-by-one against all elements. If the match fails
       the element is simply discarded from the iteration (=From Jian= this will
       be proved a good feature)

       * the most common case: a variable. Then simply iterates over all elements

     + If there are multiple generators, later ones are for inner iterations.

       =From Jian= I don't think write a embeded structure in a flat form is a
       good idea.

   - 

** TODO 23.2 The n-queens problem - 515
** DONE 23.3 Querying with ~for~ expressions - 518
   CLOSED: [2017-10-21 Sat 22:00]
** DONE 23.4 Translation of ~for~ expressions - 520 =Re-READ=
   CLOSED: [2017-10-21 Sat 22:25]
*** DONE Translating ~for~ expressions with one generator
    CLOSED: [2017-10-21 Sat 22:10]
    ~for (x <- expr1) yield expr2~    ------->    ~expr1.map(x => expr2)~

*** DONE Translating ~for~ expressions starting with a generator and a filter
    CLOSED: [2017-10-21 Sat 22:10]
    ~for (x <- expr1 if expr2) yield expr3~  
    ------->    ~for (x <- expr1 withFilter (x => expr2)) yield expr3~
    ------->    ~expr1 withFilter (x => expr2) map (x => expr3)~


    ~for (x <- expr1 if expr2; seq) yield expr3~
    ------->    ~for (x <- expr1 withFilter (x => expr2); seq) yield expr3~
    Then translation continues with the second expression, which is again shorter
    by one element than the original one.

*** DONE Translating ~for~ expressions starting with two generators
    CLOSED: [2017-10-21 Sat 22:10]
    ~for (x <- expr1; y <expr2; seq) yield expr3~
    ------->    ~expr1.flatMap (x => for (y <- expr2; seq) yield expr3)~

    - Example:
      In Section 23.3 we have
      #+BEGIN_SRC scala
        for (b1 <- books; b2 <- books if b1 != b2;
             a1 <- b1.authors; a2 <- b2.authors if a1 == a2)
        yield a1

        // Translation
        books flatMap (b1 =>
          books withFilter (b2 => b1 != b2) flatMap (b2 =>
            b1.authors flatMap (a1 =>
              b2.authors withFilter (a2 => a1 == a2) map (a2 =>
                a1))))
      #+END_SRC
    
*** DONE Translating patterns in generators
    CLOSED: [2017-10-21 Sat 22:15]
    ~for ((x1, ..., xn) <- expr1) yield expr2~
    ------->    ~expr1.map { case (x1, ..., xn) => expr2 }~

    More general patterns,
    ~for (pat <- expr1) yield expr2~
    ------->
    #+BEGIN_SRC scala
      expr1 withFilter {
        case pat => true
        case _ => false
      } map {
        case pat => expr2
      }
    #+END_SRC

    More than one patterns cases don't add much new insight, just omit them here.
    (More info about this in *Scala Language Specification*)

*** DONE Translating definitions
    CLOSED: [2017-10-21 Sat 22:21]
    ~for (x <- expr1; y = expr2; seq) yield expr3~
    Assume again that ~seq~ is a (possibly empty) sequence of /generators/,
    /definitions/, and /filters/. This expression is translated to this one:

    ------->
    #+BEGIN_SRC scala
      // From Jian: expr2 is often a function of x.
      //            If not, no reason to re-evaluate expr2 every iteration
      for ((x, y) <- for (x <- expr1) yield (x, expr2); seq)
      yield expr3
    #+END_SRC

*** DONE Translating ~for~ loops
    CLOSED: [2017-10-21 Sat 22:24]
    In principle, wherever the previous translation scheme used a ~map~ or a
    ~flatMap~ in the translation, the translation scheme for /for loops/ uses
    just a ~foreach~.

    ~for (x <- expr1) body~
    -------> ~expr1 foreach (x => body)~

    ~for (x <- expr1; if expr2; y <- expr3) body~
    -------> ~expr1 withFilter (x => expr2) foreach (x =>
                expr3 foreach (y => body))~

** DONE 23.5 Going the other way - 524
   CLOSED: [2017-10-21 Sat 22:29]
   Every application of a ~map~, ~flatMap~, or ~filter~ can be represented as a
   /for expression/.

   #+BEGIN_SRC scala
     object Demo {
       def map[A, B](xs: List[A], f: A => B): List[B] =
         for (x <- xs) yield f(x)

       def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] =
         for (x <- xs; y <- f(x)) yield y

       def filter[A](xs: List[A], p: A => Boolean): List[A] =
         for (x <- xs if p(x)) yield x
     }
   #+END_SRC

   Not surprisingly, the body of the above definitions (for expression) will be
   translated to higher order functions by Scala in the background.

** TODO 23.6 Generalizing ~for~ - 525
** DONE 23.7 Conclusion
   CLOSED: [2017-10-21 Sat 22:29]

* TODO 24 Collections in Depth - 528
  - Easy to use
  - Concise
  - Safe
  - Fast
  - Universal

** DONE 24.1 Mutable and immutable collections - 529
   CLOSED: [2017-11-21 Tue 05:51]
   - All /collection/ classes are found in the package ~scala.collection~ or one
     of its subpackages: ~mutable~, ~immutable~, and ~generic~.

   - Most /collection/ classes needed by client code exist in _THREE_ variants,
     each of which has DIFFERENT characteristics with respect to /mutability/.
       The three variants are located in packages
     + ~scala.collection~
     + ~scala.collection.immutable~
     + ~scala.collection.mutable~

   - A /collection/ in package ~scala.collection~ can be _either /mutable/ or
     /immutable/_.
       For instance, ~scala.collection.IndexedSeq[T]~ is a /supertrait/ of both
     ~scala.collection.immutable.IndexedSeq[T]~ and its mutable sibling
     ~scala.collection.mutable.IndexedSeq[T]~.

       Generally, the /root collections/ in package ~scala.collection~ define the
     _SAME interface as the /immutable/ collections_. And typically, the /mutable
     collections/ in package ~scala.collection.mutable~ add some side-effecting
     modification operations to this immutable interface.

   - =TODO= =???= 530 
     The _DIFFERENCE_ between /root collections/ and /immutable collections/
     + clients of an /immutable collection/ have a guarantee that nobody can
       mutate the collection,

     + whereas clients of a /root collection/ only know that they can't change
       the collection themselves.

   - =TODO= ~collection.generic~
     This package contains _building blocks_ for _IMPLEMENTING_ collections.
     Typically, collection classes defer the implementations of some of their
     operations to classes in ~generic~.

** DONE 24.2 Collections consistency - 531
   CLOSED: [2017-11-21 Tue 05:55]
   - All collections support the API provided by ~Traversable~.

   - Figure 24.1  Colleciton hierarchy
     #+BEGIN_SRC text
       Traversable
           Iterable
               Seq
                   IndexedSeq
                       Vector
                       ResizableArray
                       GenericArray
                   LinearSeq
                       MutableList
                       List
                       Stream
                   Buffer
                       ListBuffer
                       ArrayBuffer
               Set
                   SortedSet
                       TreeSet
                   HashSet (mutable)
                   LinkedHashSet
                   HashSet (immutable)
                   BitSet
                   EmptySet, Set1, Set2, Set3, Set4
               Map
                   SortedMap
                       TreeMap
                   HashMap (mutable)
                   LinkedHashMap (mutable)
                   HashMap (immutable)
                   EmptyMap, Map1, Map2, Map3, Map4
     #+END_SRC

   - Most of the classes above exist in _THREE_ variants:
     + root
     + mutable
     + immutable

     The ONLY EXCEPTION is the ~Buffer~ trait, which ONLY exists as a /mutable
     collection/.

** DONE 24.3 Trait ~Traversable~ - 533
   CLOSED: [2017-12-03 Sun 00:22]
   - Its ONLY abstract operation is ~foreach~:
     ~def foreach[U](f: Elem => U)~

   - ~Traversable~ also defines many concrete methods, which are all listed in
     _Table 24.1 on page 535_. These methods fall into the following categories:
     + Addtion ~++~
       * append two /traversables/ together
       * append all elements of an /iterator/ to a /traversable/.

     + Map operations ~map~, ~flatMap~, and ~collect~

     + Conversions ~toIndexedSeq~, ~toIterable~, ~toStream~, ~toArray~, ~toList~,
       ~toSeq~, ~toSet~, and ~toMap~.

         general traversables --> specific traversables

         If the receiver of these method is already the target type, nothing will
       be transformed -- just return the receiver value.

     + Copying operations ~copyToBuffer~ and ~copyToArray~

     + Size operations ~isEmpty~, ~nonEmpty~, ~size~, and ~hasDefiniteSize~

       /Collections/ that are traversable can be /finite/ or /infinite/.

       DO NOT use ~traversable.size == 0~ to check if a /traversable/ is empty or
       not! Two reasons:
       * Complexity:
         ~size~ is ~O(n)~
         ~isEmpty~, ~nonEmpty~, and ~hasDefiniteSize~ are ~O(1)~'s

       * Get a size of an /infinite traversable/ is a disaster. 

       ~hashDefiniteSize~
       * returns true, the collection is certainly _finite_.
       * returns false, the collection might be _infinite_, in which case ~size~
         will emit an error or not return.

     + Element retrieval operations ~head~, ~last~, ~headOption~, ~lastOption~,
       and ~find~.
         A _pitfall_: NOT all /traversables/ have definite order. DO NOT apply
       these methods to NO order /traversables/.

     + Subcollection retrieval operations ~takeWhile~, ~tail~, ~init~, ~slice~,
       ~take~, ~drop~, ~filter~, ~dropWhile~, ~filterNot~, and ~withFilter~.

       They return some subcollection identified by
       * an index range
         or
       * a predicate

     + Subdivision operations ~splitAt~, ~span~, ~partition~, and ~groupBy~
       =TODO=

     + Element tests ~exists~, ~forall~ and ~count~
       Test collection elements with a given predicate.

     + Folds ~foldLeft~, ~foldRight~, ~/:~, ~:\~, ~reduceLeft~, ~reduceRight~
       They apply a binary operation to successive elements.
       =TODO=

     + Specific folds ~sum~, ~product~, ~min~, and ~max~
       They works to specific types (numeric or comparable).

     + String operations ~mkString~, ~addString~, and ~stringPrefix~
       They provide alternative ways of converting a collection to a string.

       #+BEGIN_SRC scala
         List(1, 2, 3).
           addString(new StringBuilder, "List(", ", ", ")").
           toString

         // "List(1, 2, 3)"

         List(1, 2, 3).stringPrefix
         // "List"
       #+END_SRC

     + View operations consisting of two overloaded variants of the ~view~ method
       A view is a collection that's evaluated lazily.
       =TODO= more about view in Section 24.14

   - Table 24.1  Operations in trait ~Traversable~

** TODO 24.4 Trait ~Iterable~ - 538
   - All methods in ~Iterable~ trait are defined in terms of an abstract method,
     ~iterator~, which yields the collection's elements one by one.

   - The abstract ~foreach~ method inherited from ~Traversable~ is implemented in
     ~Iterable~ in terms of ~iterator~.
     #+BEGIN_SRC scala
       def foreach[U](f: Elem => U): Unit = {
         val it = iterator
         while (it.hasNext) f(it.next())
       }
     #+END_SRC

   - Quite a few subclasses of ~Iterable~ override this standard implementation
     of ~foreach~ in ~Iterable~, because they can provide a _more efficient_
     implementation.

       Remember that ~foreach~ is the basis of the implementation of _all_
     operations in ~Traversable~, so _its performance matters_.

   - _TWO_ more methods exist in ~Iterable~ that return /iterators/:
     + ~grouped~
       For example,
       ~List(1, 2, 3, 4, 5) grouped 3~ generates an /interator/ includes
       ~List(1, 2, 3)~ and ~List(4, 5)~ in order.

     + ~sliding~
       For example,
       ~List(1, 2, 3, 4, 5) sliding 3~ generates an /interator/ includes
       ~List(1, 2, 3)~, ~List(2, 3, 4)~, and ~List(3, 4, 5)~ in order.

   - Trait ~Iterable~ also adds some other methods to ~Traversable~ that can be
     implemented efficiently ONLY if an ~iterator~ is available.
       They are summarized in Table 24.2, page 540

*** TODO Why have both ~Traversable~ and ~Iterable~?  =RE-READ=
    One reason for having ~Traversable~ is that sometimes it is _easier or more
    efficient_ to provide an implementation of ~foreach~ than to provide an
    implementation of ~iterator~.

    For example: =TODO=
    + Make a binary tree traversable,
      With ~Traversable~, the cost of visiting all leaves takes O(N) time --
      N + N - 1 steps.
      #+BEGIN_SRC scala
        sealed abstract class Tree extends Traversable[Int] {
          def foreach[U](f: Int => U) = this match {
            case Node(elem) => f(elem)
            case Branch(l, r) => l foreach f; r foreach f
          }
        }

        case class Branch(left: Tree, right: Tree) extends Tree
        case class Node(elem: Int) extends Tree
      #+END_SRC

    + Make a binary tree iterable,
      With ~Iterable~, the cost of visiting all leaves takes O(N*logN) --
      logN for indirection.
      =TODO=
      #+BEGIN_SRC scala
        sealed abstract class Tree extends Iterable[Int] {
          def iterator: Iterator[Int] = this match {
            case Node(elem) => Iterator.single(elem)
            case Branch(l, r) => l.iterator ++ r.iterator
          }
        }

        case class Branch(left: Tree, right: Tree) extends Tree
        case class Node(elem: Int) extends Tree
      #+END_SRC

*** DONE Subcategories of ~Iterable~
    CLOSED: [2017-12-03 Sun 02:07]
    In the inheritance hierarchy below ~Iterable~ you find _THREE_ traits:
    ~Seq~, ~Set~, ~Map~

    All of these three implement the ~PartialFunction~ trait with its ~apply~ and
    ~isDefineAt~ methods. However, in _DIFFERENT_ way.

    - The ~apply~ of ~Seq~ news and returns a ~Seq~

    - The ~apply~ of ~Set~ check if the element is in this set.

    - The ~apply~ of ~Map~ is a selection.

** DONE 24.5 The sequence traits ~Seq~, ~IndexedSeq~, and ~LinearSeq~ - 542
   CLOSED: [2017-12-07 Thu 12:44]
   - A sequence (~Seq~) is
     + a kind of iterable that has a ~length~
     + its elements have fixed index positions, starting from 0.

   - Methods
     + *Indexing and length operations* ~apply~, ~isDefinedAt~, ~length~,
       ~indices~, and ~lengthCompare~
       * ~apply~ (for ~Seq~) means /indexing/ -- hence ~Seq[T]~ extends
         ~PartialFunction[Int, T]~.

       * ~length~ is an alias of ~size~ in more general collections.

       * ~lengthCompare~ time complexity is _O(min(seq1.length, seq2.length))_,
         rather than _O(seq1.length + seq2.length)_ when you try to get the exact
         values of two sequences to compare, which is a _BAD idea_.

     + *Index search operations* ~indexOf~, ~lastIndexOf~, ~indexOfSlice~,
       ~lastIndexOfSlice~, ~indexWhere~, ~lastIndexWhere~, ~segmentLength~, and
       ~prefixLength~
       They return a index.

     + *Addition operations* ~+:~, ~:+~, and ~padTo~

     + *Update operations* ~updated~ and ~patch~
       =TODO= Read API ~patch~

     + *Sorting operations* ~sorted~, ~sortWith~, and ~sortBy~

     + *Reversal operations* ~reverse~, ~reverseIterator~, and ~reverseMap~
       =IMPORTANT= Never use a pattern like ~seq.map(...).reverse~

     + *Comparison operations* ~startsWith~, ~endsWith~, ~contains~,
       ~corresponds~, and ~containsSlice~
       =TODO= Read API

     + *Multiset operations* ~intersect~, ~diff~, ~union~, and ~distinct~

     + mutable sequences have a side-effecting update method ~update~.
       =From Jian= Why NOT use name ~updateInPlace~, which is much clearer.

   - Table 24.3 · Operations in trait ~Seq~
     =IMPORTANT=

   - Two subtraits of ~Seq~ (NO additional operations, but different performance
     characteristics):
     + ~LinearSeq~: for example ~List~
       It is good at ~head~ and ~tail~

     + ~IndexedSeq~: for example ~Array~, ~ArrayBuffer~ (actually this is a
       ~Buffer~, not a ~IndexedSeq~)

       It is good at ~apply~, ~length~, and (if mutable) ~update~ operations.

     + ~Vector~ is a ~IndexedSeq~, but it has balanced performance -- CONSTANT
       time for both linear access and indexing.
         Because of this, vectors are a good foundation for mixed access
       patterns.
     
*** Buffers
    - ~Buffer~ is a MUTABLE sequence subtrait.

    - ~Buffer~'s allow
      + NOT only _updates_ of existing elements
      + BUT ALSO element _insertions_, element _removals_, and _efficient
        additions_ of new elements _at the end_ of the buffer.

    - Table 24.4 · Operations in trait ~Buffer~
      =From Jian= I modified some description of this Table to clarify something.

** TODO 24.6 Sets - 547
   - ~Set~'s :: ~Iterable~ that contain NO duplicate elements.

   - Table 24.5 · Operations in trait ~Set~

   - Table 24.6 · Operations in trait ~mutable.Set~

   - Methods
     + *Tests* ~contains~, ~apply~, and ~subsetOf~

     + *Additions* ~+~ and ~++~

     + *Removals* ~-~ and ~--~

     + *Set operations* /union/, /intersection/, and /difference/.
       These operations have two forms:
       * alphabetic: ~intersect~, ~union~, and ~diff~
       * symbolic: ~&~, ~|~, ~&~~

     + The ~++~ that ~Set~ inherits from ~Traversable~ can be seen as yet
       _another alias_ of ~union~ or ~|~, _EXCEPT_ that
       * ~++~ takes a ~Traversable~ argument
       * whereas ~union~ and ~|~ take /sets/.

   - =TODO=
     =TODO=
     =TODO=

   - For small sets (size <= 4), /immutable sets/ are 
     + more compact
     + more effcient
     than /mutable sets/.

** DONE 24.7 Maps - 552
   CLOSED: [2017-12-17 Sun 03:11]
   - ~Map~'s :: ~Iterable~'s of pairs of keys and values.

   - /Maps/ are also named /mappings/ or /associations/.

   - In Scala, /maps/ can be written in two forms:
     + ~Map("x" -> 24, "y" -> 25, "z" -> 26)~

     + ~Map(("x", 24), ("y", 25), ("z", 26))~

     The first one will be implicitly converted (by a function imported from
     ~Predef~) to the second one.

   - A TYPO in this page (I've already submitted this type to the official
     errata):
     ~Predef~ class _should be_ ~Predef~ object.

   - Methods (Table 24.7):
     + *Lookups* ~apply~, ~get~, ~getOrElse~, ~contains~, and ~isDefinedAt~
       * ~apply~ and ~isiDefineAt~ come from the ~PartialFunction~ /trait/.

       * One ~apply(key: K): V~ from ~PartialFunction~ and
         one ~apply[A, B](elems: (A, B)*): Map[A, B]~ from the ~Map~ /object/.

       * ~get~ returns a ~Option[V]~ type value, while
         the ~apply~ from ~PartialFunction~ returns a ~V~ type value (if the
         given key doesn't exist, throw an exception).

     + *Additions and updates* ~+~, ~++~, and ~updated~

     + *Removals* ~-~ and ~--~

     + *Subcollection producers* ~keys~, ~keySet~, ~keysIterator~,
       ~valuesIterator~, and ~values~,

     + *Transformations* ~filterKeys~ and ~mapValues~

   - Table 24.7 · Operations in trait ~Map~

   - Table 24.8 · Operations in trait ~mutable.Map~

   - Like all other /immutable/ and /mutable/ collections, /mutable maps/ support
     no side-effect (or called not destructive) operations like ~+~, ~-~, but
     they are rarely used -- if frequently use them, why not just use the
     /immutable maps/.

   - The ~getOrElseUpdate~ is useful for accessing maps that act as /caches/.
     #+BEGIN_SRC scala
       def f(x: String) = {
         println("taking my time.");
         Thread.sleep(100)
         x.reverse
       }

       val cache = collection.mutable.Map.empty[String, String]
       def cacheF(s: String) = cache.getOrElseUpdate(s, f(s))

       cacheF("abc")
       // take my time.
       // res16: String = cba

       cacheF("abc")
       // res17: String = cba
     #+END_SRC
     It is obvious that the second parameter of ~getOrElseUpdate~ is defined lazy.

     This is much simpler than the equivalent code with out ~getOrElseUpdate~:

     #+BEGIN_SRC scala
       def cacheF(arg: String) = cache get arg match {
         case Some(result) => result
         case None =>
           val result = f(arg)
           cache(arg) = result
           result
       }
     #+END_SRC

** TODO 24.8 Concrete immutable collection classes - 556
*** TODO List
*** TODO Streams
*** TODO Vectors
*** TODO Immutable stacks
*** TODO Immutable queues
*** TODO Ranges
*** TODO Hash tries
*** TODO Red-black trees
*** TODO Immutable bit sets
*** TODO List maps

** TODO 24.9 Concrete mutable collection classes - 563
*** TODO Array buffers
*** TODO List buffers
*** TODO String buffers
*** TODO Linked lists
*** TODO Double linked lists
*** TODO Mutable lists
*** TODO Queues
*** TODO Array sequences
*** TODO Stacks
*** TODO Array stacks
*** TODO Hash tables
*** TODO Weak hash maps
*** TODO Concurrent Maps
*** TODO Mutable bit sets

** TODO 24.10 Arrays - 570
** TODO 24.11 Strings - 575
** TODO 24.12 Performance characteristics - 575
** TODO 24.13 Equality - 578
** TODO 24.14 Views - 579
** TODO 24.15 Iterators - 584
*** Buffered iterators

** TODO 24.16 Creating collections from scratch - 592
** TODO 24.17 Conversions between Java and Scala collections - 594
** TODO 24.18 Conclusion - 596
* TODO 25 The Architecture of Scala Collections - 597
** TODO 25.1 Builders - 597 
** TODO 25.2 Factoring out common operations - 599
** TODO 25.3 Integrating new collections - 604
*** TODO Integrating sequences
*** TODO Integrating new sets and maps
*** TODO Summary

** TODO 25.4 Conclusion - 620
* DONE 26 Extractors - 621
  CLOSED: [2017-12-02 Sat 23:56]
  This chapter explains what /extractors/ are and how you can use them to define
  patterns that are decoupled from an object's representation.

** DONE 26.1 An example: extracting email addresses - 621
   CLOSED: [2017-12-02 Sat 01:34]
   - =FROM JIAN= =TODO=
     All the examples before are oversimplified, modify them to runnable real
     world code later!!!

   - Compare
     + Access function:
       #+BEGIN_SRC scala
         def isEMail(s: String): Boolean = ???
         def domain(s: String): String = ???
         def user(s: String): String = ???

         if (isEMail(s)) println(user(s) + " AT " + domain(s))
         else            println("not an email address")
       #+END_SRC

     + Pattern matching:
       #+BEGIN_SRC scala
         toEmail(s) match {
           case EMail(user, domain) => println(user + " AT " + domain)
           case _                   => println("not an email address")
         }
       #+END_SRC

   - More complicated example - find two successive email addresses with the same
     user part:
     + Access function:
       #+BEGIN_SRC scala
         def isEMail(s: String): Boolean = ???
         def domain(s: String): String = ???
         def user(s: String): String = ???

         val sep: String = ???

         val result: Option[List[EMail]] = ss.
           split(sep).
           sliding(2).
           find { case List(e1, e2) =>
             isEMail(e1) && isEMail(e2) && user(e1) == user(e2)
           }

         if (result.isEmpty)
           println("not successive email addresses with the same user part")
         else
           println(f"Two successive email addresses with the same user part ${user(reslt.get.head)}")
       #+END_SRC

     + Pattern matching:
       #+BEGIN_SRC scala
         @annotation.tailrec
         def findSuccessiveSameUser(ss: List[EMail]): Unit = {
           ss match {
             case Nil =>
               println("not successive email addresses with the same user part")
             case EMail(u1, d1) :: EMail(u2, d2) :: _ if u1 == u2 =>
               println(f"Two successive email addresses with the same user part ${u1}")
             case _ :: tl =>
               findSuccessiveSameUser(tl)
           }
         }

         findSuccessiveSameUser(ss.split(sep).sliding(2).map(toEmail))
       #+END_SRC

   - Scala's /extractors/  let you define new /patterns/ for _preexisting_ types,
     where the /pattern/ need NOT follow the internal representation of the type.

** DONE 26.2 Extractors - 622
   CLOSED: [2017-12-02 Sat 05:57]
   - extractor :: an object that has a method called ~unapply~ as one of its
                  members.

   - xxx
     #+BEGIN_SRC scala
       object EMail {
         // The injection method (optional)
         def apply(user: String, domain: String) = user + "@" + domain

         def unapply(str: String): Option[(String, String)] =
           (str split "@") match {
             case List(u, d) => Some(u, d)
             case _          => None
           }
       }
     #+END_SRC

   - ~selectorString match { case EMail(user, domain) => ... }~
     would lead to the call:
     ~EMail.unapply(selectorString)~. This call will lead to two kinds of return
     value:
     + ~Some(user, domain)~
       If this is the case, then bind and run the expression after ~=>~

     + ~None~
       If this is the case, then try next pattern or fail (when NO pattern left)
       with a ~MatchError~ exception.

   - If the being matched value's annotated doesn't conform the parameter type
     that ~unapply~ require, check if this value can be the required type:
     + If it is, just cast and proceed.
     + If not, the pattern fails immediately.
       
   - injection :: ~apply~

   - extraction :: ~unapply~

   - Design principle:
     Dual methods ~apply~ and ~unapply~, it they both exist in a class, should
     satisfy the requirements:
     #+BEGIN_SRC scala
       // #1 - a direction
       Email.unapply(EMail.apply(user, domain))
       // SHOULD return `Some(user, domain)`


       // #2 - another redirection
       EMail.unapply(obj) match {
         case Some(u,d) => EMail.apply(u, d)
       }
       // The generated `EMail` SHOULD be equal to the input `obj`
     #+END_SRC

** DONE 26.3 Patterns with zero or one variables - 625
   CLOSED: [2017-12-02 Sat 21:44]
   - To return just one pattern element: 
     Since there is NO one-tuple in Scala, the ~unapply~ method simply wraps the
     element itself directly into a ~Some~. 
       This time ~Some(v)~ is NOT ~Some(Tuple1(v))~, which is a special case for
     ~unapply~, though write it in this way is so much natural.

     Example:
     #+BEGIN_SRC scala
       object Twice {
         def apply(s: String): String = s + s

         def unapply(s: String): Option[String] = {
           val length = s.length / 2
           val half = s.substring(0, length)
           if (half == s.substring(length)) Some(half) else None
         }
       }
     #+END_SRC

   - It's also possible that an extractor pattern does _NOT bind any_ variables.
     In this case the corresponding ~unapply~ method returns a boolean.

     Example:
     #+BEGIN_SRC scala
       object UpperCase {
         def unapply(s: String): Boolean = s.toUpperCase == s
       }
     #+END_SRC
     In this case, only ~unapply~, NO ~apply~:
     it would make NO sense to define an ~apply~, as there's _nothing to
     construct_.

   - Apply all the previously defined extractors together in its pattern matching
     code:
     #+BEGIN_SRC scala
       def userTwiceUpper(s: String) = s match {
         case EMail(Twice(x @ UpperCase()), domain) =>
           "match: " + x + " in domain " + domain
         case _ =>
           "no match"
       }
     #+END_SRC

     The pattern here is a little complicated:
     1. You MUSTN'T omit the empty parameter list in ~UpperCase()~, otherwise the
        match would test for equality with object UpperCase!

     2. You can consider the code like this:
     #+BEGIN_SRC scala
       val unapplyEMail = Email.unapply(s)

       if (unapplyEMail.nonEmpty) {
         Some(user, domain) = unapplyEMail
         val unapplyTwice = Twice.unapply(user)

         if (unapplyTwice.nonEmpty && Uppercase.unapply(unapplyTwice.get)) {
             "match: " + x + " in domain " + domain
         } else  // the catch all pattern `_`
             "no match"
       } else  // the catch all pattern `_`
           "no match"
     #+END_SRC

** DONE 26.4 Variable argument extractors - 627
   CLOSED: [2017-12-02 Sat 22:20]
   - Use ~unapplySeq~ can do something like
     #+BEGIN_SRC scala
       dom match {
         case Domain("org", "acm") => println("acm.org")
         case Domain("com", "sun", "java") => println("java.sun.com")
         case Domain("net", _*) => println("a .net domain")
       }
     #+END_SRC

   - Implementation of ~Domain~:
     #+BEGIN_SRC scala
       object Domain {
         // The injection method (optional)
         def apply(parts: String*): String =
           parts.reverse.mkString(".")

         // The extraction method (mandatory)
         def unapplySeq(whole: String): Option[Seq[String]] =
           Some(whole.split("\\.").reverse)
       }
     #+END_SRC

   - Example:
     #+BEGIN_SRC scala
       def isTomInDotCom(s: String): Boolean = s match {
         case EMail("tom", Domain("com", _*)) => true
         case _ => false
       }

       isTomInDotCom("tom@sun.com")    // true
       isTomInDotCom("peter@sun.com")  // false
       isTomInDotCom("tom@acm.org")    // false
     #+END_SRC

   - It's also possible to _return some fixed elements_ from an ~unapplySeq~
     _together with the variable part_.

     This is expressed by returning _all elements in a tuple_, where the variable
     part comes last, as usual.

     Example:
     #+BEGIN_SRC scala
       object ExpandedEMail {
         def unapplySeq(email: String)
             : Option[(String, Seq[String])] = {
           val parts = email split "@"

           if (parts.length == 2)
             Some(parts(0), parts(1).split("\\.").reverse)
           else
             None
         }
       }

       val s = "tom@support.epfl.ch"

       val ExpandedEMail(name, topdom, subdoms @ _*) = s
       // name: String = tom
       // topdom: String = ch
       // subdoms: Seq[String] = WrappedArray(epfl, support)
     #+END_SRC

** DONE 26.5 Extractors and sequence patterns - 630
   CLOSED: [2017-12-02 Sat 22:24]
   In the standard library
   #+BEGIN_SRC scala
     package scala

     object List {
       def apply[T](elems: T*) = elems.toList

       def unapplySeq[T](x: List[T]): Option[Seq[T]] = Some(x)
     }
   #+END_SRC
   Similar to ~Array~

** DONE 26.6 Extractors versus case classes - 631
   CLOSED: [2017-12-02 Sat 23:56]
   - Even though they are very useful, /case classes/ have one _SHORTCOMING_:
     they _expose the concrete representation of data_.

       This means that the name of the class in a constructor pattern
     corresponds to the concrete representation type of the selector object.

   - /Extractors/ _BREAK_
     this link between /data representations/ and /patterns/.

   - /representation independence/ allows you to change an implementation type
     used in a set of components without affecting clients of these components.

   - Since /case classes/ have no /representation independence/, if your
     component had _defined and exported_ a set of /case classes/, you'd be stuck
     with them BECAUSE
     client code could already contain pattern matches against these case classes.

   - /Representation independence/ is an important advantage of /extractors/
     over /case classes/.

   - /Case classes/ have some advantages:
     + More concise

     + Usually more efficient pattern matches than extractors.
         The Scala compiler can optimize patterns over /case classes/ much better
       than patterns over /extractors/ -- the mechanisms of /case classes/ are
       fixed, whereas an ~unapply~ or ~unapplySeq~ method in an /extractor/
       could do almost anything.

     + /Exhaustiveness check/ for /case classes/ inherit from /sealed classes/.

   - Summary: It depends
     + closed application: you usually prefer /case classes/

     + Expose a type to unknown clients: /extractors/ can help you maintain
       /representation independence/.

   - If it is NOT clear when you start a new project, you can always start from
     /case classes/, and then, when you think you need /representation
     independence/, change to /extractors/.

     You can do this because the syntax for /pattern matching/ is always the
     same, NO MATTER there are /extractors/ or /case classes/.

** DONE 26.7 Regular expressions - 632
   CLOSED: [2017-12-02 Sat 23:26]
   - One particularly useful application area of /extractors/ are /regular
     expressions/.

     Like Java, Scala provides /regular expressions/ through a library, but
     /extractors/ make it much nicer to interact with them.
     =TODO= =???=

*** DONE Forming regular expressions
    CLOSED: [2017-12-02 Sat 23:13]
    - Review some basic pattern of Java regex (~java.util.regex.Pattern~)
      page 632 - 633

    - ~scala.util.matching.Regex~

    - Example:
      #+BEGIN_SRC scala
        // The pattern is `(-)?(\d+)(\.\d*)?`
        val Decimal = new Regex("(-)?(\\d+)(\\.\\d*)?")

        // Use raw string
        val Decimal = new Regex("""(-)?(\d+)(\.\d*)?""")

        // Use raw string and method `r`
        val Decimal = """(-)?(\d+)(\.\d*)?""".r
      #+END_SRC

    - The definition of ~r~ is
      #+BEGIN_SRC scala
        package scala.runtime

        import scala.util.matching.Regex

        class StringOps(self: String) ... {
          // ...
          def r = new Regex(self)
        }
      #+END_SRC

*** DONE Searching for regular expressions
    CLOSED: [2017-12-02 Sat 23:13]
    - ~regex findFirstIn str~
      Return an ~Option~ value

    - ~regex findAllIn str~
      Return an ~Iterator~ value

    - ~regex findPrefixOf str~
      Return an ~Option~ value

    - Example:
      #+BEGIN_SRC scala
        val input = "for -1.0 to 99 by 3"

        for (s <- Decimal findAllIn input)
          println(s)

        Decimal findFirstIn input
        // Some("-1.0")

        Decimal findPrefixOf input
        // None
      #+END_SRC

*** DONE Extracting with regular expressions
    CLOSED: [2017-12-02 Sat 23:26]
    #+BEGIN_SRC scala
      val Decimal(sign, integerPart, decimalPart) = "-1.23"
      // sign: String = -
      // integerPart: String = 1
      // decimalPart: String = .23


      val Decimal(sign, integerPart, decimalPart) = "1.0"
      // sign: String = null
      // integerPart: String = 1
      // decimalPart: String = .0


      for (Decimal(s, i, d) <- Decimal findAllIn input)
        println("sign: " + s + ", integer: " +
            i + ", decimal: " + d)
      // sign: -, integer: 1, decimal: .0
      // sign: null, integer: 99, decimal: null
      // sign: null, integer: 3, decimal: null
    #+END_SRC

** DONE 26.8 Conclusion - 636 =Re-Read=
   CLOSED: [2017-12-02 Sat 23:27]
* DONE 27 Annotations - 637 *Learn MORE*
  CLOSED: [2017-10-21 Sat 19:01]
  - annotations :: structured information added to program source code.

    + Like /comments/,
      they can be sprinkled throughout a program and attached to any variable,
      method, expression, or other program element.

    + Unlike /comments/,
      _they have structure, thus making them easier to machine process._

  - This chapter
    + shows how to use annotations in Scala,
    + shows their general syntax and how to use several standard annotations.

  - This chapter does NOT show how to write new annotation processing tools,
    because it is _beyond the scope of this book_.

      Chapter 31 shows one technique, but not the only one.

    _This chapter focuses on how to use annotations._

** DONE 27.1 Why have annotations? - 637
   CLOSED: [2017-10-21 Sat 18:59]
   - There are many things you can do with a program _other than_ compiling and
     running it. Some examples are:
     1. Automatic generation of documentation as with *Scaladoc*.
        =TODO=

     2. Pretty printing code so that it matches your preferred style.
        =TODO=

     3. Checking code for common errors such as opening a file but, on some
        control paths, never closing it.
        =TODO=

     4. Experimental type checking, for example to manage side effects or ensure
        ownership properties.
        =TODO=

   - Such tools are called /meta-programming/ tools, because they are programs
     that take other programs as input.

   - /Annotations/ can improve the previously listed tools as follows:
     1. A documentation generator could be instructed to document certain methods
        as _deprecated_.

     2. A pretty printer could be instructed to skip over parts of the program
        that have been carefully hand formatted.

     3. A checker for non-closed files could be instructed to ignore a particular
        file that has been manually verified to be closed.

     4. A side-effects checker could be instructed to verify that a specified
        method has no side effects.
        =TODO= =???=

** DONE 27.2 Syntax of annotations - 638
   CLOSED: [2017-10-21 Sat 18:59]
   - Annotations can also be applied to an expression, as with the ~@unchecked~
     annotation for pattern matching (see Chapter 15). To do so, place a colon
     (~:~) after the expression and then write the annotation. Syntactically, it
     looks like the annotation is being used as a type:
     #+BEGIN_SRC scala
       (e: @unchecked) match {
         // nonexhaustive
         cases...
       }
     #+END_SRC

   - /Annotations/ have a richer general form: @annot(exp1, exp2, ...)
     Though much simpler form annotations are often seen.

   - Internally,
     Scala represents an annotation as just a constructor call of an annotation
     class -- replace the ~@~ by ~new~ and you have a valid instance creation
     expression.

   - One slightly tricky bit concerns annotations that conceptually take other
     annotations as arguments, which are required by some frameworks.

     You _CANNOT_ write an annotation directly as an argument to an annotation,
     because _annotations are NOT valid expressions_. In such cases you must use
     ~new~ instead of ~@~, as illustrated here:
     #+BEGIN_SRC scala
       scala> import annotation._
       // import annotation._

       scala> class strategy(arg: Annotation) extends Annotation
       // defined class strategy

       scala> class delayed extends Annotation
       // defined class delayed

       scala> @strategy(@delayed) def f() = {}
       // <console>:1: error: illegal start of simple expression
       //        @strategy(@delayed) def f() = {}
       //                  ˆ

       scala> @strategy(new delayed) def f() = {}
       // f: ()Unit
     #+END_SRC

** DONE 27.3 Standard annotations - 640
   CLOSED: [2017-10-21 Sat 18:45]
*** DONE Deprecation
    CLOSED: [2017-10-21 Sat 18:34]
    ~@deprecated~

    - ~@deprecated def bigMistake() = // ...~

    - With message (use this in most cases):
      #+BEGIN_SRC scala
        @deprecated("use newShinyMethod() instead")
        def bigMistake() = //...
      #+END_SRC

*** DONE Volatile fields
    CLOSED: [2017-10-21 Sat 18:39]
    ~@volatile~

    Scala's concurrency support is /message passing/ and a _minimum_ of /shared
    mutable state/. =TODO= See Chapter 32

    Nonetheless, sometimes programmers want to use /mutable state/ in their
    concurrent programs. The ~@volatile~ annotation helps in such cases.

    - The ~@volatile~ keyword gives different guarantees on different platforms.

      On the Java platform, however, you get the same behavior as if you wrote
      the field in Java code and marked it with the Java volatile modifier.

*** TODO Binary serialization
*** DONE Automatic ~get~ and ~set~ methods *RE-READ*
    CLOSED: [2017-10-21 Sat 18:45]
    Scala doesn't need ~get~ and ~set~ methods.
    Some platform-specific frameworks do expect ~get~ and ~set~ methods, however.

    Scala provides the ~@scala.reflect.BeanProperty~ annotation. It informs the
    compiler to generate ~get~ and ~set~ methods for you automatically. For
    example, ~getCrazy~ and ~setCrazy~ for a field named ~crazy~.

    =IMPORTANT= =RE-READ=
    The generated ~get~ and ~set~ methods are ONLY available _AFTER_ a compilation
    pass completes.

*** DONE Tailrec
    CLOSED: [2017-10-21 Sat 18:04]
    Use ~@tailrec~, and if the _optimization CANNOT be performed_, you will then
    get a warning together with an explanation of the reasons.

*** DONE Unchecked
    CLOSED: [2017-10-21 Sat 18:06]
    ~@unchecked~

    Tell the compiler don't worry if the ~match~ expression seems to leave out some cases.
    =TODO= See Section 15.5 for details.

*** TODO Native methods
    ~@native~

    =TODO= =???=

** TODO 27.4 Conclusion - 644
   =TODO=
   Chapter 31 gives additional, Java-specific information on annotations. It
   covers annotations only available when targeting Java, additional meanings of
   standard annotations when targeting Java, how to interoperate with Java-based
   annotations, and how to use Java-based mechanisms to define and process
   annotations in Scala.

* TODO 28 Working with XML - 645
** TODO 28.1 Semi-structured data - 645
** TODO 28.2 XML overview - 646
** TODO 28.3 XML literals - 647
** TODO 28.4 Serialization - 649
** TODO 28.5 Taking XML apart - 651
** TODO 28.6 Deserialization - 652
** TODO 28.7 Loading and saving - 653
** TODO 28.8 Pattern matching on XML - 655
** TODO 28.9 Conclusion - 658
* TODO 29 Modular Programming Using Objects - 659
** TODO 29.1 The problem - 660
** TODO 29.2 A recipe application - 661
** TODO 29.3 Abstraction - 664
** TODO 29.4 Splitting modules into traits - 667
** TODO 29.5 Runtime linking - 670
** TODO 29.6 Tracking module instances - 671
** TODO 29.7 Conclusion - 673
* TODO 30 Object Equality - 674
  Define object equality is more tricky than it looks at first glance.

** DONE 30.1 Equality in Scala - 674
   CLOSED: [2017-11-25 Sat 00:39]
   - As mentioned in Section 11.2, the definition of equality is _DIFFERENT_ in
     Scala and Java.

   - Java has _TWO_ equality comparisons:
     + ~==~ operator :: natural equality check for /value types/ and /object
                        identity for reference types/

     + ~equals~ method :: (user-defined) canonical equality for reference types.

   - Java's _TWO_ equality comparisons are problematic -- the more natural
     symbol, ~==~, does NOT always correspond to the natural notion of equality.

   - Scala also has an equality method signifying /object identity/, but it is
     not used much -- ~eq~.

   - In Scala ~==~ is value comparison, just like in Java.

     For reference types, ~==~ is the same as ~equals~ in Scala.
     You can redefine the behavior of ~==~ of new types by overriding the
     ~equals~ method, which is _always inherited from_ class ~Any~.

     This inherited ~equals~, which takes effect _unless_ overridden, is /object
     identity/, as in the case in Java. So ~equals~ (and with it, ~==~) is by
     default the same as ~eq~, but you can change its behavior by overriding the
     ~equals~ method in the classes you define.

   - It is not possible to override ~==~ directly, as it is defined as a /final
     method/ in class ~Any~.
     #+BEGIN_SRC scala
       // In the class `Any`
       final def == (that: Any): Boolean =
         if (null eq this) {null eq that} else {this equals that}
     #+END_SRC

** TODO 30.2 Writing an equality method - 675
   - footnote:
     All but the _third_ pitfall are described in the context of Java in the
     book, Effective Java Second Edition, by Joshua Bloch.

   - ~class Point(val x: Int, val y: Int)~

*** DONE Pitfall #1: Defining ~equals~ with the wrong signature
    CLOSED: [2017-11-25 Sat 00:54]
    #+BEGIN_SRC scala
      // An utterly WRONG definition of equals
      def equals(other: Point): Boolean =
        this.x = other.x && this.y == other.y

      val p1, p2 = new Point(1, 2)
      // p1: Point = Point@37d7d90f
      // p2: Point = Point@3beb846d

      val coll = mutable.HashSet(p1)
      // coll: scala.collection.mutable.HashSet[Point] =
      // Set(Point@37d7d90f)

      coll contains p2
      // res2: Boolean = false

      val p2a: Any = p2
      // p2a: Any = Point@3beb846d

      p1 equals p2a
      // res3: Boolean = false
    #+END_SRC

    The given ~equals~ above is NOT /overridden/ -- it is /overload/, which is
    wrong.
      The *RIGHT* input type should be ~Any~, as in the ~Any~ class, and then the
    definition is:
    #+BEGIN_SRC scala
      // A better definition, but still not perfect
      override def equals(other: Any) = other match {
        case that: Point => this.x == that.x && this.y == that.y
        case _ => false
      }
    #+END_SRC

*** DONE Pitfall #2: Changing ~equals~ without also changing ~hashCode~
    CLOSED: [2017-11-25 Sat 01:25]
    #+BEGIN_SRC scala
      val p1, p2 = new Point(1, 2)
      // p1: Point = Point@122c1533
      // p2: Point = Point@c23d097

      collection.mutable.HashSet(p1) contains p2
      //// The output is NOT certain: can be `true` or `false`
    #+END_SRC
    - The ~contains~ method of a ~HashSet~ instance will search ~p2~ in the same
      "hash bucket" of ~p1~. The result is true when ~p1~ and ~p2~ can be put in
      the same "hash bucket" . However, since ~hashCode~ is NOT overridden for
      ~Point~, ~p1~ and ~p2~ have different hash code, and they can be in the
      same or different "hash bucket". Then the result can be ~true~ or ~false~.

    - The problem is that the last implementation of ~Point~ _violated the
      contract_ on ~hashCode~ as defined for class ~Any~:
      #+BEGIN_QUOTE
      If two objects are equal according to the equals method, then calling the
      ~hashCode~ method on each of the two objects must produce the same integer
      result.
      #+END_QUOTE

    - footnote:
      The text of ~Any~'s ~hashCode~ contract is inspired by the Javadoc
      documentation of class ~java.lang.Object~.

    - The new implementation (Better but not all right):
      #+BEGIN_SRC scala
        class Point(val x: Int, val y: Int) {
          override def hashCode = (x, y).##
          override def equals(other: Any) = other match {
            case that: Point => this.x == that.x && this.y == that.y
            case _ => false
          }
        }
      #+END_SRC
      + This is just ONE of many possible implementations of ~hashCode~.

      + ~##~ method :: a shorthand for computing hash codes that works for
        * primitive values
        * reference types
        * ~null~

        When invoked on a collection or a tuple, it computes a mixed hash that
        is _sensitive to the hash codes of all the elements_ in the collection.

*** DONE Pitfall #3: Defining ~equals~ in terms of mutable fields
    CLOSED: [2017-11-25 Sat 01:35]
    You put an object into a ~HashSet~, this object is then put in a specific
    "hash bucket" according to its hash code. After modifing its mutable fields,
    its hash code is changed. Only a similar to the original hash code object
    will be equality checked in this "hash bucket", a similar to the new hash
    code object will mostly be equality checked in other "hash bucket".

    - Solution:
      1. Hash codes shouldn't depend on mutable fields.

      2. If hash codes depend on mutable fields, try NOT modify them.

      3. If all the above can be satisfied, try to define your own method to
         check equality without hash code, for example, use a name like
         ~equalContents~.

*** TODO Pitfall #4: Failing to define ~equals~ as an equivalence relation

** DONE 30.3 Defining equality for parameterized types - 688
   CLOSED: [2017-11-25 Sat 01:50]
   This is special due to /type erasure/.

   - Example code with parameterized types:
     #+BEGIN_SRC scala
       trait Tree[+T] {
         def elem: T
         def left: Tree[T]
         def right: Tree[T]
       }

       object EmptyTree extends Tree[Nothing] {
         def elem =
           throw new NoSuchElementException("EmptyTree.elem")
         def left =
           throw new NoSuchElementException("EmptyTree.left")
         def right =
           throw new NoSuchElementException("EmptyTree.right")
       }

       class Branch[+T](
         val elem: T,
         val left: Tree[T],
         val right: Tree[T]
       ) extends Tree[T]
     #+END_SRC

   - No overridden ~equals~, ~hashCode~, and ~canEqual~ is required for ~EmptyTree~.
     =Explained in Page 689=

   - Define ~equals~
     #+BEGIN_SRC scala
       class Branch[T](
         val elem: T,
         val left: Tree[T],
         val right: Tree[T]
       ) extends Tree[T] {
         override def equals(other: Any) = other match {
           case that: Branch[T] => this.elem == that.elem &&
               this.left == that.left &&
               this.right == that.right
           case _ => false
         }
       }
     #+END_SRC
     This code will issue an unchecked warnings.
     Use ~fsc -unchecked Tree.scala~ to check:
     #+BEGIN_QUOTE
     $ fsc unchecked
     Tree.scala
     Tree.scala:14: warning: non variable typeargument T in type
     pattern is unchecked since it is eliminated by erasure
         case that: Branch[T] => this.elem == that.elem && 
     #+END_QUOTE
     This is due to /type erasure/.

     + Fix it
       ~case that: Branch[T]~ to
       * ~case that: Branch[t]~ =TODO= details
         OR
       * ~case that: Branch[_]~

   - Define ~hashCode~ for ~Branch~ as usual
     ~override def hashCode: Int = (elem, left, right).##~

   - Define ~canEqual~ for ~Branch~:
     #+BEGIN_SRC scala
       def canEqual(other: Any) = other match {
         case that: Branch[_] => true
         case _ => false
       }

       // OR

       def canEqual(other: Any) = otherisInstanceOf[Branch[_]]
     #+END_SRC
     =TODO=
     The type parameter, rather than type pattern, ~_~ is explained in the next
     chapter.
     
** TODO 30.4 Recipes for ~equals~ and ~hashCode~ - 692
*** Recipe for ~equals~
    1. x
    2. 
    3. 
    4. 
    5. 
    6. 
    7. 

*** Recipe for ~hashCode~
    - If the ~equals~ method invokes ~super.equals(that)~ as part of its calcula-
      tion, you should start your ~hashCode~ calculation with an invocation of
      ~super.hashCode~. For example,
      #+BEGIN_SRC scala
        override def hashCode: Int = (super.hashCode, numer, denom).##
      #+END_SRC

** TODO 30.5 Conclusion - 697
* TODO 31 Combining Scala and Java - 698
** TODO 31.1 Using Scala from Java - 698
*** General rules
*** Value types
*** Singleton objects
*** Traits as interfaces

** TODO 31.2 Annotations - 701
   Scala's general annotations system is discussed in Chapter 27.
   This section discusses Java-specific aspects of annotations.

*** Additional effects from standard annotations
*** Exceptions thrown
*** Java annotations
*** Writing your own annotations

** TODO 31.3 Wildcard types - 706
** TODO 31.4 Compiling Scala and Java together - 709
** TODO 31.5 Java 8 integration in Scala 2.12 - 709
*** Lambda expressions and "SAM" types
*** Using Java 8 Streams from Scala 2.12

** TODO 31.6 Conclusion - 713

* TODO 32 Futures and Concurrency - 714
** TODO 32.1 Trouble in paradise - 714
** TODO 32.2 Asynchronous execution and Trys - 716
** TODO 32.3 Working with Futures - 718
*** Transforming ~Futures~ with ~map~
*** Transforming ~Futures~ with ~for~ expressions
*** Creating the ~Future~: ~Future.failed~, ~Future.successful~, ~Future.fromTry~, and ~Promises~
*** Filtering: ~filter~ and ~collect~
*** Dealing with failure: ~failed~, ~fallBackTo~, ~recover~, and ~recoverWith~
*** Mapping both possibilities: ~transform~
*** Combining futures: ~zip~, ~Future.fold~, ~Future.reduce~, ~Future.sequence~, and ~Future.traverse~
*** Performing side-effects: ~foreach~, ~onComplete~, and ~andThen~
*** Other methods added in 2.12: ~flatten~, ~zipWith~, and ~transformWith~

** TODO 32.4 Testing with Futures - 733
** TODO 32.5 Conclusion - 735
* TODO 33 Combinator Parsing - 736
** TODO 33.1 Example: Arithmetic expressions - 737
** TODO 33.2 Running your parser - 739
** TODO 33.3 Basic regular expression parsers - 740
** TODO 33.4 Another example: JSON - 741
** TODO 33.5 Parser output - 743
*** Symbolic versus alphanumeric names

** TODO 33.6 Implementing combinator parsers - 749
   - The core of Scala's combinator parsing framework is contained in the /trait/
     ~scala.util.parsing.combinator.Parsers~.

     This trait defines the ~Parser~ type as well as _all fundamental
     combinators_. If not being stated explicitly, 

     (Except where stated explicitly otherwise, the definitions explained in the
      following two subsections all reside in this trait.)

   - As a first _approximation_, the type could be written as follows:
     ~type Parser[T] = Input => ParseResult[T]~

*** DONE Parser input
    CLOSED: [2017-11-23 Thu 01:21]
    - ~type Input = Reader[Elem]~
      The class ~Reader~ comes from the package ~scala.util.parsing.input~

      A ~Reader~ is similar to a ~Stream~, but also keeps track of the positions
      of all the elements it reads.

    - ~type Elem~
      ~Elem~ is abstract.

      For instance, the subtraits of ~Parser~, ~RegexParsers~ and
      ~JavaTokenParsers~ fix ~Elem~ to be equal to ~Char~.

*** DONE Parser results
    CLOSED: [2017-11-23 Thu 01:32]
    A parser might either _succeed_ or _fail_ on some given input.
    Consequently class ~ParseResult~ has two subclasses for representing them:
    #+BEGIN_SRC scala
      sealed abstract class ParseResult[+T]
      case class Success[T](result: T, in: Input)
        extends ParseResult[T]
      case class Failure(msg: String, in: Input)
        extends ParseResult[Nothing]
    #+END_SRC

    - ~Success~: the field ~in~ is needed for chaining parsers.

    - ~Failure~: the field ~in~ is, of course, not used for chaining, but to
      position the error message at the correct place in the input stream.

    - That ~ParseResult~'s are defined to be /covariant/ in the type parameter
      ~T~. That is, a parser returning ~Strings~ as result, say, is compatible
      with a parser returning ~AnyRefs~.

*** DONE The ~Parser~ class
    CLOSED: [2017-11-23 Thu 03:04]
    #+BEGIN_SRC scala
      abstract class Parser[+T] extends (Input => ParseResult[T])
      { p =>
        // An unspecified method that defines
        // the behavior of this parser.
        def apply(in: Input): ParseResult[T]
        def ~ ...
        def | ...
        ...
      }
    #+END_SRC

*** DONE Aliasing ~this~
    CLOSED: [2017-11-23 Thu 03:18]
    - The definition given in the last subsection
      ~abstract class Parser[+T] extends ... { p =>~

      A clause such as ~id =>~ immediately after the opening brace of a class
      template defines the identifier ~id~ as an alias for ~this~ in the class.

      From the alias point of view, it's like ~val id = this~. However, this is not
      what exactly it is -- ~id~ will be considered as a normal identifier.
      =???= =re-read= =why not??=

    - Aliasing can also be a good abbreviation when you need to access the ~this~
      of an outer class. Here's an example:
      #+BEGIN_SRC scala
        class Outer { outer =>
          class Inner {
            println(Outer.this eq outer)  // prints: true
          }
        }
      #+END_SRC
      The ~Outer.this~ is the Java way, and the ~outer~ is the Scala way. The
      are same things (point to same thing) in this example.


*** TODO Single-token parsers
*** TODO Sequential composition
*** TODO Alternative composition
*** TODO Dealing with recursion
*** TODO Result conversion
*** TODO Parsers that don't read any input
*** TODO Option and repetition

** TODO 33.7 String literals and regular expressions - 758
** TODO 33.8 Lexing and parsing - 759
** TODO 33.9 Error reporting - 759
** TODO 33.10 Backtracking versus LL(1) - 761
** TODO 33.11 Conclusion - 763
* TODO 34 GUI Programming - 765
** TODO 34.1 A first Swing application - 765
** TODO 34.2 Panels and layouts - 768
** TODO 34.3 Handling events - 770
** TODO 34.4 Example: Celsius/Fahrenheit converter - 773
** TODO 34.5 Conclusion - 775
* TODO 35 The SCells Spreadsheet - 777
** TODO 35.1 The visual framework - 777
** TODO 35.2 Disconnecting data entry and display - 780
** TODO 35.3 Formulas - 783
** TODO 35.4 Parsing formulas - 785
** TODO 35.5 Evaluation - 790
** TODO 35.6 Operation libraries - 793
** TODO 35.7 Change propagation - 796
** TODO 35.8 Conclusion - 800

* DONE Appendix A. Scala Scripts on Unix and Windows - 802
  CLOSED: [2017-10-03 Tue 21:25]
  - In a Unix flavor system:
    #+BEGIN_SRC bash
      #!/bin/sh
      exec scala "$0" "$@"
      !#
      // Say hello to the first argument
      println("Hello, " + args(0) + "!")
    #+END_SRC
    1. ~$ chmod +x helloarg~
    2. ~$ ./helloarg globe~

    The output is =Hello, globe!=

    =From Jian=
    Start the JVM takes sometime.
    If you want to run this script for multiple times, read
    https://alvinalexander.com/scala/how-make-scala-shell-scripts-run-faster-with-savecompiled-argument
    However, this is NOT a real solution, just a kind of not-so-good walkaround.

  - =Question from Jian= =TODO= =???=
    Why can't I use ~#!/usr/bin/env bash~ as the first line?????

  - In Windows:
    1. Create a =helloarg.bat= file

    2. Add the code below to the top of this file, and then the scala code
       #+BEGIN_SRC bat
         ::#!
         @echo off
         call scala %0 %*
         goto :eof
         ::!#
       #+END_SRC

       =TODO= 
       =From Jian= I never tried this. Try it later.

* Glossary - 803
* Bibliography - 819
* About the Authors - 822
* Index - 823
* Tips (Added by Jian)
  + You can leave off one pair of parentheses when passing a tuple to a function
    that takes a single argument. ---- footnote 1 - page 624

    For example, ~Some(a, b)~ means the same as ~Some((a, b))~

* TodoList (Added by Jian)
