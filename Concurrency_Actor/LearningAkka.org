#+TITLE: Learning Akka
#+VERSION: 2015
#+AUTHOR: Jason Goodwin
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Preface - ix][Preface - ix]]
- [[Chapter 1: Starting Life as an Actor - 1][Chapter 1: Starting Life as an Actor - 1]]
  - [[What's in this book? - 2][What's in this book? - 2]]
  - [[Chapter overview - 2][Chapter overview - 2]]
  - [[What is Akka - 3][What is Akka - 3]]
    - [[Actor Model origins - 3][Actor Model origins - 3]]
    - [[What's an Actor anyway? - 3][What's an Actor anyway? - 3]]
    - [[Actors and Message passing - 4][Actors and Message passing - 4]]
      - [[The Evolution of supervision and fault tolerance in Erlang - 8][The Evolution of supervision and fault tolerance in Erlang - 8]]
      - [[The Evolution of distribution and location transparency - 9][The Evolution of distribution and location transparency - 9]]
  - [[What we will build - 10][What we will build - 10]]
    - [[Example - 1 – handling distributed state - 10][Example - 1 – handling distributed state - 10]]
    - [[Example - 2 – getting lots of work done - 10][Example - 2 – getting lots of work done - 10]]
  - [[Setting up your environment - 11][Setting up your environment - 11]]
    - [[Choosing a language - 11][Choosing a language - 11]]
    - [[Installing Java – Oracle JDK8 - 12][Installing Java – Oracle JDK8 - 12]]
      - [[Installing on Windows - 12][Installing on Windows - 12]]
      - [[Installing on OS X -12][Installing on OS X -12]]
      - [[Installing on Linux or Unix (Universal instructions) - 12][Installing on Linux or Unix (Universal instructions) - 12]]
    - [[Ensuring Java is configured in your environment - 13][Ensuring Java is configured in your environment - 13]]
    - [[Installing Scala - 13][Installing Scala - 13]]
    - [[Installing Typesafe Activator - 13][Installing Typesafe Activator - 13]]
      - [[Windows - 13][Windows - 13]]
      - [[Linux/Unix/OS X - 14][Linux/Unix/OS X - 14]]
      - [[OS X - 14][OS X - 14]]
    - [[Creating a new project - 15][Creating a new project - 15]]
    - [[Installing an IDE - 16][Installing an IDE - 16]]
      - [[Install IntelliJ CE - 16][Install IntelliJ CE - 16]]
      - [[Eclipse - 16][Eclipse - 16]]
  - [[Creating your first Akka application – setting up the SBT project - 19][Creating your first Akka application – setting up the SBT project - 19]]
    - [[Adding Akka to build.sbt - 20][Adding Akka to build.sbt - 20]]
      - [[A note on getting the right Scala version with %% - 21][A note on getting the right Scala version with %% - 21]]
      - [[Adding other Dependencies from Maven Central - 21][Adding other Dependencies from Maven Central - 21]]
    - [[Creating your first Actor - 21][Creating your first Actor - 21]]
      - [[Making the Message first - 21][Making the Message first - 21]]
      - [[Defining Actor response to the Message - 22][Defining Actor response to the Message - 22]]
    - [[Validating the code with unit tests - 25][Validating the code with unit tests - 25]]
      - [[Akka Testkit - 25][Akka Testkit - 25]]
    - [[Running the test - 28][Running the test - 28]]
  - [[Homework][Homework]]
  - [[Summary][Summary]]
- [[Chapter 2: Actors and Concurrency - 31][Chapter 2: Actors and Concurrency - 31]]
  - [[Reactive system design - 31][Reactive system design - 31]]
  - [[The 4 reactive tenets - 32][The 4 reactive tenets - 32]]
    - [[Responsive - 32][Responsive - 32]]
    - [[Elastic - 32][Elastic - 32]]
    - [[Resilient - 33][Resilient - 33]]
    - [[Event-driven/message-driven - 33][Event-driven/message-driven - 33]]
    - [[Reactive Tenet Correlation - 33][Reactive Tenet Correlation - 33]]
  - [[Anatomy of an Actor - 34][Anatomy of an Actor - 34]]
    - [[Java Actor API - 34][Java Actor API - 34]]
    - [[Scala Actor API - 34][Scala Actor API - 34]]
  - [[Creating an actor - 38][Creating an actor - 38]]
    - [[Props - 39][Props - 39]]
  - [[Promises, futures, and event-driven programming models - 41][Promises, futures, and event-driven programming models - 41]]
    - [[Blocking versus event-driven APIs - 41][Blocking versus event-driven APIs - 41]]
      - [[Skills check-point  - 45][Skills check-point  - 45]]
    - [[Having an Actor respond via a future - 45][Having an Actor respond via a future - 45]]
      - [[Java example - 46][Java example - 46]]
      - [[Scala example - 48][Scala example - 48]]
      - [[Blocking threads in tests - 50][Blocking threads in tests - 50]]
    - [[Understanding futures and promises - 51][Understanding futures and promises - 51]]
      - [[Future – expressing failure and latency in types - 51][Future – expressing failure and latency in types - 51]]
    - [[Preparing the DB and messages - 60][Preparing the DB and messages - 60]]
      - [[The messages - 61][The messages - 61]]
      - [[Implementing the DB functionality - 62][Implementing the DB functionality - 62]]
      - [[Enabling remoting - 63][Enabling remoting - 63]]
      - [[Main - 64][Main - 64]]
      - [[Publishing the messages - 64][Publishing the messages - 64]]
      - [[Starting the DB - 65][Starting the DB - 65]]
    - [[Producing the client - 65][Producing the client - 65]]
      - [[Scaffolding the project - 65][Scaffolding the project - 65]]
      - [[Modifying build.sbt - 66][Modifying build.sbt - 66]]
      - [[Building the client - 66][Building the client - 66]]
      - [[Testing - 67][Testing - 67]]
  - [[Homework - 68][Homework - 68]]
    - [[General learning - 68][General learning - 68]]
    - [[Project homework - 68][Project homework - 68]]
  - [[Summary - 69][Summary - 69]]
- [[Chapter 3: Getting the Message Across - 71][Chapter 3: Getting the Message Across - 71]]
  - [[Setting the stage with an example problem - 71][Setting the stage with an example problem - 71]]
    - [[Sketching the project - 72][Sketching the project - 72]]
    - [[Core functionality - 72][Core functionality - 72]]
  - [[Messaging delivery - 73][Messaging delivery - 73]]
    - [[Messages should be immutable - 73][Messages should be immutable - 73]]
    - [[Ask message pattern - 77][Ask message pattern - 77]]
      - [[Designing with Ask - 78][Designing with Ask - 78]]
      - [[Callbacks execute in another execution context - 82][Callbacks execute in another execution context - 82]]
      - [[Timeouts are required - 83][Timeouts are required - 83]]
      - [[Timeout stacktraces aren't useful - 84][Timeout stacktraces aren't useful - 84]]
      - [[Ask has overhead - 85][Ask has overhead - 85]]
      - [[Complexity of Actors and Ask - 85][Complexity of Actors and Ask - 85]]
    - [[Tell - 86][Tell - 86]]
      - [[Designing with Tell - 87][Designing with Tell - 87]]
      - [[Forward - 94][Forward - 94]]
      - [[Pipe - 96][Pipe - 96]]
  - [[Homework - 97][Homework - 97]]
    - [[General learning - 97][General learning - 97]]
    - [[Project homework - 97][Project homework - 97]]
  - [[Summary - 98][Summary - 98]]
- [[Chapter 4: Actor Lifecycle – Handling State and Failure - 99][Chapter 4: Actor Lifecycle – Handling State and Failure - 99]]
  - [[The - 8 Fallacies of Distributed Computing - 99][The - 8 Fallacies of Distributed Computing - 99]]
    - [[The network is reliable - 100][The network is reliable - 100]]
    - [[Bandwidth is infinite - 101][Bandwidth is infinite - 101]]
    - [[The network is secure - 101][The network is secure - 101]]
    - [[Network topology doesn't change - 102][Network topology doesn't change - 102]]
    - [[There is one administrator - 102][There is one administrator - 102]]
    - [[Transport cost is zero - 102][Transport cost is zero - 102]]
    - [[The network is homogeneous - 103][The network is homogeneous - 103]]
  - [[Failure - 103][Failure - 103]]
    - [[Isolating failure - 104][Isolating failure - 104]]
      - [[Redundancy - 104][Redundancy - 104]]
    - [[Supervision - 104][Supervision - 104]]
      - [[Supervision hierarchies - 105][Supervision hierarchies - 105]]
      - [[Supervision strategies and the drunken sushi chef - 106][Supervision strategies and the drunken sushi chef - 106]]
      - [[Defining supervisor strategies - 107][Defining supervisor strategies - 107]]
      - [[Actor lifecycle - 109][Actor lifecycle - 109]]
      - [[Messages in restart, stop - 110][Messages in restart, stop - 110]]
      - [[Terminating or killing an Actor - 111][Terminating or killing an Actor - 111]]
      - [[Lifecycle monitoring and DeathWatch - 111][Lifecycle monitoring and DeathWatch - 111]]
      - [[Safely restarting - 111][Safely restarting - 111]]
    - [[State - 113][State - 113]]
      - [[Online/Offline state - 113][Online/Offline state - 113]]
      - [[Conditional statements - 115][Conditional statements - 115]]
      - [[Hotswap: Become/Unbecome - 116][Hotswap: Become/Unbecome - 116]]
      - [[Using restarts to transition through states - 124][Using restarts to transition through states - 124]]
  - [[Homework - 124][Homework - 124]]
  - [[Summary - 125][Summary - 125]]
- [[Chapter 5: Scaling Up - 127][Chapter 5: Scaling Up - 127]]
  - [[Moore's law - 127][Moore's law - 127]]
  - [[Multicore architecture as a distribution problem - 128][Multicore architecture as a distribution problem - 128]]
  - [[Choosing Futures or Actors for concurrency - 129][Choosing Futures or Actors for concurrency - 129]]
  - [[Doing work in parallel - 130][Doing work in parallel - 130]]
    - [[Doing work In parallel with futures - 130][Doing work In parallel with futures - 130]]
    - [[Doing work in parallel with Actors - 132][Doing work in parallel with Actors - 132]]
      - [[Introducing Routers - 133][Introducing Routers - 133]]
      - [[Routing logic - 134][Routing logic - 134]]
      - [[Sending Messages to All Actors in a Router Group/Pool - 135][Sending Messages to All Actors in a Router Group/Pool - 135]]
    - [[Supervising the Routees in a Router Pool - 135][Supervising the Routees in a Router Pool - 135]]
  - [[Working with Dispatchers - 136][Working with Dispatchers - 136]]
    - [[Dispatchers explained - 136][Dispatchers explained - 136]]
    - [[Executors - 138][Executors - 138]]
    - [[Creating Dispatchers - 138][Creating Dispatchers - 138]]
    - [[Deciding Which Dispatcher to use where - 140][Deciding Which Dispatcher to use where - 140]]
    - [[Default Dispatcher - 143][Default Dispatcher - 143]]
    - [[Blocking IO dispatcher use with futures - 144][Blocking IO dispatcher use with futures - 144]]
    - [[Article parsing dispatcher - 147][Article parsing dispatcher - 147]]
      - [[Using a configured dispatcher with Actors - 147][Using a configured dispatcher with Actors - 147]]
      - [[Using BalancingPool/BalancingDispatcher - 149][Using BalancingPool/BalancingDispatcher - 149]]
    - [[Optimal parallelism - 150][Optimal parallelism - 150]]
  - [[Homework - 150][Homework - 150]]
  - [[Summary - 151][Summary - 151]]
- [[Chapter 6: Successfully Scaling Out – Clustering - 153][Chapter 6: Successfully Scaling Out – Clustering - 153]]
  - [[Introducing Akka Cluster - 153][Introducing Akka Cluster - 153]]
  - [[One Giant Monolith or Many Micro Services? -154][One Giant Monolith or Many Micro Services? -154]]
  - [[Definition of a Cluster - -155][Definition of a Cluster - -155]]
    - [[Failure Detection - 155][Failure Detection - 155]]
    - [[Gossiping an Eventually Consistent View - 156][Gossiping an Eventually Consistent View - 156]]
  - [[CAP Theorem - 157][CAP Theorem - 157]]
    - [[C – Consistency - 157][C – Consistency - 157]]
    - [[A – Availability - 157][A – Availability - 157]]
    - [[P – Partition Tolerance - 157][P – Partition Tolerance - 157]]
    - [[Compromises in CAP Theorem - 158][Compromises in CAP Theorem - 158]]
      - [[CP System – Preferring Consistency - 158][CP System – Preferring Consistency - 158]]
      - [[AP System – Preferring Availability - 159][AP System – Preferring Availability - 159]]
      - [[Consistency as a Sliding Scale - 160][Consistency as a Sliding Scale - 160]]
  - [[Building Systems with Akka Cluster - 160][Building Systems with Akka Cluster - 160]]
    - [[Creating the Cluster - 161][Creating the Cluster - 161]]
      - [[Configuring the Project - 161][Configuring the Project - 161]]
      - [[Seed Nodes - 162][Seed Nodes - 162]]
      - [[Subscribing to Cluster Events - 163][Subscribing to Cluster Events - 163]]
      - [[Starting the Cluster - 165][Starting the Cluster - 165]]
      - [[Leaving the Cluster Gracefully - 167][Leaving the Cluster Gracefully - 167]]
    - [[Cluster Member States - 168][Cluster Member States - 168]]
      - [[Failure Detection - 168][Failure Detection - 168]]
    - [[Routing Messages to the Cluster - 169][Routing Messages to the Cluster - 169]]
    - [[Producing a Distributed Article Parse Service - 169][Producing a Distributed Article Parse Service - 169]]
    - [[Cluster Client for Clustered Services - 170][Cluster Client for Clustered Services - 170]]
      - [[Setting up the Server Project - 171][Setting up the Server Project - 171]]
      - [[Setting up the Client Project - 173][Setting up the Client Project - 173]]
      - [[Sharing the Message Class between Client and Server - 173][Sharing the Message Class between Client and Server - 173]]
      - [[Sending Messages to the Cluster - 174][Sending Messages to the Cluster - 174]]
      - [[Building a Distributed Key Value Store - 176][Building a Distributed Key Value Store - 176]]
      - [[Disclaimer – Distributed Systems are Hard - 177][Disclaimer – Distributed Systems are Hard - 177]]
    - [[Designing the Cluster - 177][Designing the Cluster - 177]]
      - [[Basic Key-Value Store Design - 178][Basic Key-Value Store Design - 178]]
      - [[Coordinating Node - 179][Coordinating Node - 179]]
      - [[Redundant Nodes - 181][Redundant Nodes - 181]]
  - [[Combining Sharding and Replication - 183][Combining Sharding and Replication - 183]]
    - [[Pre-Sharding And Redistributing Keys to New Nodes - 184][Pre-Sharding And Redistributing Keys to New Nodes - 184]]
  - [[Addressing Remote Actors - 185][Addressing Remote Actors - 185]]
    - [[Using akka.actor.Identify to Find a Remote Actor - 186][Using akka.actor.Identify to Find a Remote Actor - 186]]
  - [[Homework - 186][Homework - 186]]
  - [[Summary - 187][Summary - 187]]
- [[Chapter 7: Handling Mailbox Problems - 189][Chapter 7: Handling Mailbox Problems - 189]]
    - [[Overwhelming your weakest link - 189][Overwhelming your weakest link - 189]]
    - [[Ballooning response times - 191][Ballooning response times - 191]]
    - [[Crashing - 191][Crashing - 191]]
  - [[Resiliency - 192][Resiliency - 192]]
    - [[Mailboxes - 192][Mailboxes - 192]]
      - [[Configuring mailboxes - 193][Configuring mailboxes - 193]]
      - [[Deciding which mailbox to use - 194][Deciding which mailbox to use - 194]]
  - [[Staying responsive under load - 196][Staying responsive under load - 196]]
    - [[Circuit breakers - 197][Circuit breakers - 197]]
      - [[Circuit breaker listeners - 198][Circuit breaker listeners - 198]]
      - [[Circuit breaker examples - 199][Circuit breaker examples - 199]]
  - [[Homework - 203][Homework - 203]]
  - [[Summary - 203][Summary - 203]]
- [[Chapter 8: Testing and Design - 205][Chapter 8: Testing and Design - 205]]
    - [[Example problem - 206][Example problem - 206]]
    - [[Approaching application design - 206][Approaching application design - 206]]
      - [[High-Level design - 208][High-Level design - 208]]
    - [[Designing, building, and testing the Domain model - 209][Designing, building, and testing the Domain model - 209]]
      - [[Specifications - 209][Specifications - 209]]
      - [[Designing the Domain model - 210][Designing the Domain model - 210]]
      - [[Testing and building the Domain model - 211][Testing and building the Domain model - 211]]
      - [[Building by specification - 213][Building by specification - 213]]
    - [[Testing actors - 216][Testing actors - 216]]
      - [[Testing Actor behavior and state - 216][Testing Actor behavior and state - 216]]
      - [[Testing Message flow - 219][Testing Message flow - 219]]
    - [[Testing Advice - 222][Testing Advice - 222]]
    - [[Homework - 223][Homework - 223]]
    - [[Summary - 224][Summary - 224]]
- [[Chapter 9: A Journey's End - 225][Chapter 9: A Journey's End - 225]]
  - [[Other Akka Features and Modules - 226][Other Akka Features and Modules - 226]]
    - [[Logging in Akka - 226][Logging in Akka - 226]]
    - [[Message Channels and EventBus - 228][Message Channels and EventBus - 228]]
    - [[Agents - 231][Agents - 231]]
    - [[Akka Persistence - 234][Akka Persistence - 234]]
    - [[Akka I/O - 235][Akka I/O - 235]]
    - [[Akka streams and HTTP - 235][Akka streams and HTTP - 235]]
  - [[Deployment Tools - 236][Deployment Tools - 236]]
  - [[Monitoring Logs and Events - 237][Monitoring Logs and Events - 237]]
    - [[Writing some Actor Code - 238][Writing some Actor Code - 238]]
    - [[Coursera Courses - 239][Coursera Courses - 239]]
  - [[Summary - 240][Summary - 240]]
- [[Index 241][Index 241]]

* Preface - ix
* Chapter 1: Starting Life as an Actor - 1
** What's in this book? - 2
** Chapter overview - 2
** What is Akka - 3
*** Actor Model origins - 3
*** What's an Actor anyway? - 3
*** Actors and Message passing - 4
**** The Evolution of supervision and fault tolerance in Erlang - 8
**** The Evolution of distribution and location transparency - 9

** What we will build - 10
*** Example - 1 – handling distributed state - 10
*** Example - 2 – getting lots of work done - 10

** Setting up your environment - 11
*** Choosing a language - 11
*** Installing Java – Oracle JDK8 - 12
**** Installing on Windows - 12
**** Installing on OS X -12 
**** Installing on Linux or Unix (Universal instructions) - 12

*** Ensuring Java is configured in your environment - 13
*** Installing Scala - 13
*** Installing Typesafe Activator - 13
**** Windows - 13
**** Linux/Unix/OS X - 14
**** OS X - 14

*** Creating a new project - 15
*** Installing an IDE - 16
**** Install IntelliJ CE - 16
**** Eclipse - 16

** Creating your first Akka application – setting up the SBT project - 19
*** Adding Akka to build.sbt - 20
**** A note on getting the right Scala version with %% - 21
**** Adding other Dependencies from Maven Central - 21

*** Creating your first Actor - 21
**** Making the Message first - 21
**** Defining Actor response to the Message - 22

*** Validating the code with unit tests - 25
**** Akka Testkit - 25

*** Running the test - 28

** Homework
** Summary

* Chapter 2: Actors and Concurrency - 31
  - The chapter will cover the following topics:
    + The *anatomy of*, *creation of*, and *communication with* an /actor/

    + The _tools_ and _knowledge_ necessary to *deal with /asynchronous responses/
      from the Actor API*.

    + Working with Futures—place-holders of results that will be available in the
      future that can succeed or fail

** DONE Reactive system design - 31
   CLOSED: [2018-08-26 Sun 12:51]
   This section will briefly introduce the _FOUR_ tenets of the *Reactive Manifesto*.

** TODO The 4 reactive tenets - 32
*** DONE Responsive - 32
    CLOSED: [2018-08-26 Sun 13:00]
    Our applications should respond to requests as fast as possible.
    - If we have a choice between getting data in a *serial* manner or in *parallel*,
      we should *always choose to get the data in parallel* in order to get a
      response back to a user faster.

    - If there is a potential error situation,
      we should *return a notification of the problem to the user immediately*
      rather than having them wait for the timeout.

*** DONE Elastic - 32
    CLOSED: [2018-08-26 Sun 13:02]
    Our applications should be able to scale under varying workload (especially
    achieved by adding more computing resources).
      In order to achieve elasticity, our systems should aim to eliminate
    bottlenecks.

*** DONE Resilient - 33
    CLOSED: [2018-08-26 Sun 13:06]
    Our applications should expect faults to occur and react to them gracefully.

    - If a component of the system fails, it *should not* cause a lack of
      availability for requests that do not touch that component.

    - If possible, failure of a component should not cause any impact in behavior
      by employing replication and redundancy in critical components and data.

*** TODO Event-driven/message-driven - 33
*** TODO Reactive Tenet Correlation - 33

** DONE Anatomy of an Actor - 34
   CLOSED: [2018-08-26 Sun 13:20]
*** TODO Java Actor API - 34
*** DONE Scala Actor API - 34
    CLOSED: [2018-08-26 Sun 13:20]
    #+BEGIN_SRC scala
      class ScalaPongActor extends Actor {
        override def receive: Receive = {
          case "Ping" => sender() ! "Pong"
          case _      => sender() ! Status.Failure(new Exception("unknown message"))
        }
      }
    #+END_SRC

    - =TODO=
      NOTE

** DONE Creating an actor - 38
   CLOSED: [2018-08-26 Sun 14:22]
   #+BEGIN_SRC scala
     val actor: ActorRef =
       actorSystem.actorSystem(Props(classOf[ScalaPongActor]))
   #+END_SRC

   - The /actor/ are encapsulated -- they *should NOT* be accessible.

*** Props - 39
    - You can use ~ActorRef~ to get a /reference/ to an /actor/.

    - You can use ~ActorRef.path~ to get the /path/ of an /actor/, for example:
      + Local /actor/:
        ~akka://default/user/BruceWillis~

      + Remote /actor/:
        ~akka.tcp://my-sys@remotehost:5678/user/CharlieChaplin~

    - If you know the /path/ of an /actor/, you can also use ~actorSelection~ to
      get a /reference/ to an /actor/.
      #+BEGIN_SRC scala
        val selection: ActorSelection =
          system.actorSelection("akka.tcp://actorSystem@host.jason-goodwin.com:5678/user/KeanuReeves")
      #+END_SRC

      + The ~ActorSelection~ here is a reference to a remote actor -- we can use the
        ~ActorSelection~ like the ~ActorRef~ to communicate over the network.

    - =TODO=
      NOTE

** TODO Promises, futures, and event-driven programming models - 41
   - what if we need to get some output from the actor in response to that message?
     Let's say we need to get a record from our in-memory key-value store?

*** DONE Blocking versus event-driven APIs - 41
    CLOSED: [2018-08-26 Sun 15:50]
    - To summarize, there are a few problems with using many threads to handle
      blocking IO:
      + Code does not obviously express failure in the response type
      + Code does not obviously express latency in the response type
      + Blocking models have throughput limitations due to fixed threadpool sizes
      + Creating and using many threads has a performance overhead due to context-switching

    - 

**** Skills check-point  - 45

*** TODO Having an Actor respond via a future - 45
**** Java example - 46
**** Scala example - 48
**** Blocking threads in tests - 50
     - TIP:
       *Don't sleep or block outside tests.*
     - 

*** Understanding futures and promises - 51
    - Modern /futures/ make _TWO_ effects implicit:
      + failure
      + latency

    - To see how we can move *from* /blocking IO/ *to* /non-blocking IO/,
      we MUST *learn some abstractions* that express handling with _failure_ and
      _latency_ in different ways.

**** Future – expressing failure and latency in types - 51
***** Preparing for the Java example - 51
***** Preparing for the Scala example - 52
***** Note on sleeping - 52
***** Anatomy of a future - 53
***** Handling success cases - 53
****** Executing code with the result - 53
****** Transforming the result - 53
****** Transforming the result asynchronously - 54

***** Handling failure cases - 55
****** Executing code in the failure case - 55
****** Recovering from failure - 55
****** Recovering from failure asynchronously - 56

***** Composing futures - 56
****** Chaining operations together - 56
****** Combining futures - 57
****** Dealing with lists of futures - 58

***** Future cheat-sheet - 59
      | Operation                   | Scala Future                   | Java CompletableFuture                           |
      |-----------------------------+--------------------------------+--------------------------------------------------|
      | Transform Value             | ~.map(x => y)~                 | ~.thenApply(x -> y)~                             |
      | Transform Value Async       | ~.flatMap(x => futureOfY)~     | ~.thenCompose(x -> futureOfY)~                   |
      | Return Value if Error       | ~.recover(t => y)~             | ~.exceptionally(t -> y)~                         |
      | Return Value Async if Error | ~.recoverWith(t => futureOfY)~ | ~.handle(t, x -> futureOfY).thenCompose(x -> x)~ |

***** Composing a Distributed System – AkkademyDb and client - 59

*** Preparing the DB and messages - 60
**** The messages - 61
**** Implementing the DB functionality - 62
**** Enabling remoting - 63
**** Main - 64
**** Publishing the messages - 64
**** Starting the DB - 65

*** Producing the client - 65
**** Scaffolding the project - 65
**** Modifying build.sbt - 66
**** Building the client - 66
**** Testing - 67

** TODO Homework - 68
*** General learning - 68
*** Project homework - 68

** TODO Summary - 69

* Chapter 3: Getting the Message Across - 71
** Setting the stage with an example problem - 71
*** Sketching the project - 72
*** Core functionality - 72

** Messaging delivery - 73
*** Messages should be immutable - 73
*** Ask message pattern - 77
**** Designing with Ask - 78
**** Callbacks execute in another execution context - 82
**** Timeouts are required - 83
**** Timeout stacktraces aren't useful - 84
**** Ask has overhead - 85
**** Complexity of Actors and Ask - 85

*** Tell - 86
**** Designing with Tell - 87
**** Forward - 94
**** Pipe - 96

** Homework - 97
*** General learning - 97
*** Project homework - 97

** Summary - 98

* Chapter 4: Actor Lifecycle – Handling State and Failure - 99
** The - 8 Fallacies of Distributed Computing - 99
*** The network is reliable - 100
*** Bandwidth is infinite - 101
*** The network is secure - 101
*** Network topology doesn't change - 102
*** There is one administrator - 102
*** Transport cost is zero - 102
*** The network is homogeneous - 103

** Failure - 103
*** Isolating failure - 104
**** Redundancy - 104

*** Supervision - 104
**** Supervision hierarchies - 105
**** Supervision strategies and the drunken sushi chef - 106
**** Defining supervisor strategies - 107
**** Actor lifecycle - 109
**** Messages in restart, stop - 110
**** Terminating or killing an Actor - 111
**** Lifecycle monitoring and DeathWatch - 111
**** Safely restarting - 111

*** State - 113
**** Online/Offline state - 113
***** Transitioning state - 114
***** Stashing messages between states - 114

**** Conditional statements - 115
**** Hotswap: Become/Unbecome - 116
***** Stash leaks - 118
***** Finite State Machines (FSM) - 118
***** Defining states - 120
***** Defining the state container - 121
***** Defining behavior in FSMs - 121

**** Using restarts to transition through states - 124


** Homework - 124
** Summary - 125

* Chapter 5: Scaling Up - 127
** Moore's law - 127
** Multicore architecture as a distribution problem - 128
** Choosing Futures or Actors for concurrency - 129
** Doing work in parallel - 130
*** Doing work In parallel with futures - 130
*** Doing work in parallel with Actors - 132
**** Introducing Routers - 133
**** Routing logic - 134
**** Sending Messages to All Actors in a Router Group/Pool - 135

*** Supervising the Routees in a Router Pool - 135

** Working with Dispatchers - 136
*** Dispatchers explained - 136
*** Executors - 138
*** Creating Dispatchers - 138
*** Deciding Which Dispatcher to use where - 140
*** Default Dispatcher - 143
*** Blocking IO dispatcher use with futures - 144
*** Article parsing dispatcher - 147
**** Using a configured dispatcher with Actors - 147
**** Using BalancingPool/BalancingDispatcher - 149

*** Optimal parallelism - 150

** Homework - 150
** Summary - 151

* Chapter 6: Successfully Scaling Out – Clustering - 153
** Introducing Akka Cluster - 153
** One Giant Monolith or Many Micro Services? -154
** Definition of a Cluster - -155
*** Failure Detection - 155
*** Gossiping an Eventually Consistent View - 156

** CAP Theorem - 157
*** C – Consistency - 157
*** A – Availability - 157
*** P – Partition Tolerance - 157
*** Compromises in CAP Theorem - 158
**** CP System – Preferring Consistency - 158
**** AP System – Preferring Availability - 159
**** Consistency as a Sliding Scale - 160

** Building Systems with Akka Cluster - 160
*** Creating the Cluster - 161
**** Configuring the Project - 161
**** Seed Nodes - 162
**** Subscribing to Cluster Events - 163
**** Starting the Cluster - 165
**** Leaving the Cluster Gracefully - 167

*** Cluster Member States - 168
**** Failure Detection - 168

*** Routing Messages to the Cluster - 169
*** Producing a Distributed Article Parse Service - 169
*** Cluster Client for Clustered Services - 170
**** Setting up the Server Project - 171
**** Setting up the Client Project - 173
**** Sharing the Message Class between Client and Server - 173
**** Sending Messages to the Cluster - 174
**** Building a Distributed Key Value Store - 176
**** Disclaimer – Distributed Systems are Hard - 177
    
*** Designing the Cluster - 177
**** Basic Key-Value Store Design - 178
**** Coordinating Node - 179
**** Redundant Nodes - 181

** Combining Sharding and Replication - 183
*** Pre-Sharding And Redistributing Keys to New Nodes - 184

** Addressing Remote Actors - 185
*** Using akka.actor.Identify to Find a Remote Actor - 186

** Homework - 186
** Summary - 187

* Chapter 7: Handling Mailbox Problems - 189
*** Overwhelming your weakest link - 189
*** Ballooning response times - 191
*** Crashing - 191

** Resiliency - 192
*** Mailboxes - 192
**** Configuring mailboxes - 193
**** Deciding which mailbox to use - 194

** Staying responsive under load - 196
*** Circuit breakers - 197
**** Circuit breaker listeners - 198
**** Circuit breaker examples - 199

** Homework - 203
** Summary - 203

* Chapter 8: Testing and Design - 205
*** Example problem - 206
*** Approaching application design - 206
**** High-Level design - 208

*** Designing, building, and testing the Domain model - 209
**** Specifications - 209
**** Designing the Domain model - 210
**** Testing and building the Domain model - 211
**** Building by specification - 213

*** Testing actors - 216
**** Testing Actor behavior and state - 216
**** Testing Message flow - 219
***** Using the test Itself as an Actor - 219
***** Using TestProbes as mock Actors - 221

*** Testing Advice - 222
*** Homework - 223
*** Summary - 224

* Chapter 9: A Journey's End - 225
** Other Akka Features and Modules - 226
*** Logging in Akka - 226
*** Message Channels and EventBus - 228
*** Agents - 231
*** Akka Persistence - 234
*** Akka I/O - 235
*** Akka streams and HTTP - 235

** Deployment Tools - 236
** Monitoring Logs and Events - 237
*** Writing some Actor Code - 238
*** Coursera Courses - 239

** Summary - 240

* Index 241
