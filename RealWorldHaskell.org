#+TITLE: Real World Haskell
#+VERSION: 2009
#+AUTHOR: Bryan O'Sullivan, John Goerzen & Don Stewart
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Preface][Preface]]
- [[1 Getting Started][1 Getting Started]]
  - [[Your Haskell Environment][Your Haskell Environment]]
  - [[Getting Started with ghci, the Interpreter][Getting Started with ghci, the Interpreter]]
  - [[Basic Interaction: Using ghci as a Calculator][Basic Interaction: Using ghci as a Calculator]]
    - [[Simple Arithmetic][Simple Arithmetic]]
    - [[An Arithmetic Quirk: Writing Negative Numbers][An Arithmetic Quirk: Writing Negative Numbers]]
    - [[Boolean Logic, Operators, and Value Comparisons][Boolean Logic, Operators, and Value Comparisons]]
    - [[Operator Precedence and Associativity][Operator Precedence and Associativity]]
    - [[Undefined Values, and Introducing Variables][Undefined Values, and Introducing Variables]]
    - [[Dealing with Precedence and Associativity Variables][Dealing with Precedence and Associativity Variables]]
  - [[Command-Line Editing in ghci][Command-Line Editing in ghci]]
  - [[Lists][Lists]]
    - [[Operators on List][Operators on List]]
  - [[Strings and Characters][Strings and Characters]]
  - [[First Steps and Characters][First Steps and Characters]]
  - [[A Simple Program][A Simple Program]]
- [[2 Types and Functions][2 Types and Functions]]
  - [[Why Care About Types?][Why Care About Types?]]
  - [[Haskell's Type System][Haskell's Type System]]
    - [[Strong Types][Strong Types]]
    - [[Static Types][Static Types]]
    - [[Type Inference][Type Inference]]
  - [[What to Expect from the Type System][What to Expect from the Type System]]
  - [[Some Common Basic Types][Some Common Basic Types]]
  - [[Function Application][Function Application]]
  - [[Useful Composite Data Types: Lists and Tuples][Useful Composite Data Types: Lists and Tuples]]
  - [[Functions over Lists and Tuples][Functions over Lists and Tuples]]
    - [[Passing an Expression to a Function][Passing an Expression to a Function]]
  - [[Function Types and Purity][Function Types and Purity]]
  - [[Haskell Source Files, and Writing Simple Functions][Haskell Source Files, and Writing Simple Functions]]
    - [[Just What Is a Variable, Anyway?][Just What Is a Variable, Anyway?]]
    - [[Conditional Evaluation][Conditional Evaluation]]
  - [[Understanding Evaluation by Example][Understanding Evaluation by Example]]
    - [[Lazy Evaluation][Lazy Evaluation]]
    - [[A More Involved Example][A More Involved Example]]
    - [[Recursion][Recursion]]
    - [[Ending the Recursion][Ending the Recursion]]
    - [[Returning from the Recursion][Returning from the Recursion]]
    - [[What Have We Learned?][What Have We Learned?]]
  - [[Polymorphism in Haskell][Polymorphism in Haskell]]
    - [[Reasoning About Polymorphic Functions][Reasoning About Polymorphic Functions]]
    - [[Further Reading][Further Reading]]
  - [[The Type of a Function of More Than One Argument][The Type of a Function of More Than One Argument]]
  - [[Why the Fuss over Purity?][Why the Fuss over Purity?]]
  - [[Conclusion][Conclusion]]
- [[3 Defining Types, Streamlining Functions][3 Defining Types, Streamlining Functions]]
  - [[Defining a New Data Type][Defining a New Data Type]]
    - [[Naming Types and Values][Naming Types and Values]]
  - [[Type Synonyms][Type Synonyms]]
  - [[Algebraic Data Types][Algebraic Data Types]]
    - [[Tuples, Algebraic Data Types, and When to Use Each][Tuples, Algebraic Data Types, and When to Use Each]]
    - [[Analogues to Algebraic Data Types in Other Languages][Analogues to Algebraic Data Types in Other Languages]]
  - [[Pattern Matching][Pattern Matching]]
    - [[Construction and Deconstruction][Construction and Deconstruction]]
    - [[Further Adventures][Further Adventures]]
    - [[Variable Naming in Patterns][Variable Naming in Patterns]]
    - [[The Wild Card Pattern][The Wild Card Pattern]]
    - [[Exhaustive Patterns and Wild Cards][Exhaustive Patterns and Wild Cards]]
  - [[Record Syntax][Record Syntax]]
  - [[Parameterized Types][Parameterized Types]]
  - [[Recursive Types][Recursive Types]]
  - [[Reporting Errors][Reporting Errors]]
    - [[A More Controlled Approach][A More Controlled Approach]]
  - [[Introducing Local Variables][Introducing Local Variables]]
    - [[Shadowing][Shadowing]]
    - [[The where Clause][The where Clause]]
    - [[Local Functions, Global Variables][Local Functions, Global Variables]]
  - [[The Offside Rule and Whitespace in an Expression][The Offside Rule and Whitespace in an Expression]]
    - [[A Note About Tabs Versus Spaces][A Note About Tabs Versus Spaces]]
    - [[The Offside Rule Is Not Mandatory][The Offside Rule Is Not Mandatory]]
  - [[The case Expression][The case Expression]]
  - [[Common Beginner Mistakes with Patterns][Common Beginner Mistakes with Patterns]]
    - [[Incorrectly Matching Against a Variable][Incorrectly Matching Against a Variable]]
    - [[Incorrectly Trying to Compare for Equality][Incorrectly Trying to Compare for Equality]]
  - [[Conditional Evaluation with Guards][Conditional Evaluation with Guards]]
- [[4 Functional Programming][4 Functional Programming]]
  - [[Thinking in Haskell][Thinking in Haskell]]
  - [[A Simple Command-Line Framework][A Simple Command-Line Framework]]
  - [[Warming Up: Portably Splitting Lines of Text][Warming Up: Portably Splitting Lines of Text]]
    - [[A Line-Ending Conversion Program][A Line-Ending Conversion Program]]
  - [[Infix Functions][Infix Functions]]
  - [[Working with Lists][Working with Lists]]
    - [[Basic List Manipulation][Basic List Manipulation]]
    - [[Safely and Sanely Working with Crashy Functions][Safely and Sanely Working with Crashy Functions]]
    - [[Partial and Total Functions][Partial and Total Functions]]
    - [[More Simple List Manipulations][More Simple List Manipulations]]
    - [[Working with Sublists][Working with Sublists]]
    - [[Searching Lists][Searching Lists]]
    - [[Working with Several Lists at Once][Working with Several Lists at Once]]
    - [[Special String-Handling Functions][Special String-Handling Functions]]
  - [[How to Think About Loops][How to Think About Loops]]
    - [[Explicit Recursion][Explicit Recursion]]
    - [[Transforming Every Piece of Input][Transforming Every Piece of Input]]
    - [[Mapping over a List][Mapping over a List]]
    - [[Selecting Pieces of Input][Selecting Pieces of Input]]
    - [[Computing One Answer over a Collection][Computing One Answer over a Collection]]
    - [[The Left Fold][The Left Fold]]
    - [[Why Use Folds, Maps, and Filters?][Why Use Folds, Maps, and Filters?]]
    - [[Folding from the Right][Folding from the Right]]
    - [[Left Folds, Laziness, and Space Leaks][Left Folds, Laziness, and Space Leaks]]
    - [[Further Reading][Further Reading]]
  - [[Anonymous (lambda) Functions][Anonymous (lambda) Functions]]
  - [[Partial Function Application and Currying][Partial Function Application and Currying]]
    - [[Sections][Sections]]
  - [[As-patterns][As-patterns]]
  - [[Code Reuse Through Composition][Code Reuse Through Composition]]
    - [[Use Your Head Wisely][Use Your Head Wisely]]
  - [[Tips for Writing Readable Code][Tips for Writing Readable Code]]
  - [[Space Leaks and Strict Evaluation][Space Leaks and Strict Evaluation]]
    - [[Avoiding Space Leaks with seq][Avoiding Space Leaks with seq]]
    - [[Learning to Use seq][Learning to Use seq]]
- [[5 Writing a Library: Working with JSON Data][5 Writing a Library: Working with JSON Data]]
  - [[A Whirlwind Tour of JSON][A Whirlwind Tour of JSON]]
  - [[Representing JSON Data in Haskell][Representing JSON Data in Haskell]]
  - [[The Anatomy of a Haskell Module][The Anatomy of a Haskell Module]]
  - [[Compiling Haskell Source][Compiling Haskell Source]]
  - [[Generating a Haskell Program and Importing Modules][Generating a Haskell Program and Importing Modules]]
  - [[Printing JSON Data][Printing JSON Data]]
  - [[Type Inference Is a Double-Edged Sword][Type Inference Is a Double-Edged Sword]]
  - [[A More General Look at Rendering][A More General Look at Rendering]]
  - [[Developing Haskell Code Without Going Nuts][Developing Haskell Code Without Going Nuts]]
  - [[Pretty Printing a String][Pretty Printing a String]]
  - [[Arrays and Objects, and the Module Header][Arrays and Objects, and the Module Header]]
  - [[Writing a Module Header][Writing a Module Header]]
  - [[Fleshing Out the Pretty-Printing Library][Fleshing Out the Pretty-Printing Library]]
    - [[Compact Rendering][Compact Rendering]]
    - [[True Pretty Printing][True Pretty Printing]]
    - [[Following the Pretty Printer][Following the Pretty Printer]]
  - [[Creating a Package][Creating a Package]]
    - [[Writing a Package Description][Writing a Package Description]]
    - [[GHC’s Package Manager][GHC’s Package Manager]]
    - [[Setting Up, Building, and Installing][Setting Up, Building, and Installing]]
  - [[Practical Pointers and Further Reading][Practical Pointers and Further Reading]]
- [[6 Using Typeclasses][6 Using Typeclasses]]
  - [[The Need for Typeclasses][The Need for Typeclasses]]
  - [[What Are Typeclasses?][What Are Typeclasses?]]
  - [[Declaring Typeclass Instances][Declaring Typeclass Instances]]
  - [[Important Built-in Typeclasses][Important Built-in Typeclasses]]
    - [[Show][Show]]
    - [[Read][Read]]
    - [[Serialization with read and show][Serialization with read and show]]
    - [[Numeric Types][Numeric Types]]
    - [[Equality, Ordering, and Comparisons][Equality, Ordering, and Comparisons]]
  - [[Automatic Derivation][Automatic Derivation]]
  - [[Typeclasses at Work: Making JSON Easier to Use][Typeclasses at Work: Making JSON Easier to Use]]
    - [[More Helpful Errors][More Helpful Errors]]
    - [[Making an Instance with a Type Synonym][Making an Instance with a Type Synonym]]
  - [[Living in an Open World][Living in an Open World]]
    - [[When Do Overlapping Instances Cause Problems?][When Do Overlapping Instances Cause Problems?]]
    - [[Relaxing Some Restrictions on Typeclasses][Relaxing Some Restrictions on Typeclasses]]
    - [[How Does Show Work for Strings?][How Does Show Work for Strings?]]
  - [[How to Give a Type a New Identity][How to Give a Type a New Identity]]
    - [[Differences Between Data and Newtype Declarations][Differences Between Data and Newtype Declarations]]
    - [[Summary: The Three Ways of Naming Types][Summary: The Three Ways of Naming Types]]
  - [[JSON Typeclasses Without Overlapping Instances][JSON Typeclasses Without Overlapping Instances]]
  - [[The Dreaded Monomorphism Restriction][The Dreaded Monomorphism Restriction]]
  - [[Conclusion][Conclusion]]
- [[7 I/O][7 I/O]]
  - [[Classic I/O in Haskell][Classic I/O in Haskell]]
    - [[Pure Versus I/O][Pure Versus I/O]]
    - [[Why Purity Matters][Why Purity Matters]]
  - [[Working with Files and Handles][Working with Files and Handles]]
    - [[More on openFile][More on openFile]]
    - [[Closing Handles][Closing Handles]]
    - [[Seek and Tell][Seek and Tell]]
    - [[Standard Input, Output, and Error][Standard Input, Output, and Error]]
    - [[Deleting and Renaming Files][Deleting and Renaming Files]]
    - [[Temporary Files][Temporary Files]]
  - [[Extended Example: Functional I/O and Temporary Files][Extended Example: Functional I/O and Temporary Files]]
  - [[Lazy I/O][Lazy I/O]]
    - [[hGetContents][hGetContents]]
    - [[readFile and writeFile][readFile and writeFile]]
    - [[A Word on Lazy Output][A Word on Lazy Output]]
    - [[interact][interact]]
  - [[The IO Monad][The IO Monad]]
    - [[Actions][Actions]]
    - [[Sequencing][Sequencing]]
    - [[The True Nature of Return][The True Nature of Return]]
  - [[Is Haskell Really Imperative?][Is Haskell Really Imperative?]]
  - [[Side Effects with Lazy I/O][Side Effects with Lazy I/O]]
  - [[Buffering][Buffering]]
    - [[Buffering Modes][Buffering Modes]]
    - [[Flushing The Buffer][Flushing The Buffer]]
  - [[Reading Command-Line Arguments][Reading Command-Line Arguments]]
  - [[Environment Variables][Environment Variables]]
- [[8 Efficient File Processing, Regular Expressions, and Filename Matching][8 Efficient File Processing, Regular Expressions, and Filename Matching]]
  - [[Efficient File Processing][Efficient File Processing]]
    - [[Binary I/O and Qualified Imports][Binary I/O and Qualified Imports]]
    - [[Text I/O][Text I/O]]
  - [[Filename Matching][Filename Matching]]
  - [[Regular Expressions in Haskell][Regular Expressions in Haskell]]
    - [[The Many Types of Result][The Many Types of Result]]
  - [[More About Regular Expressions][More About Regular Expressions]]
    - [[Mixing and Matching String Types][Mixing and Matching String Types]]
    - [[Other Things You Should Know][Other Things You Should Know]]
  - [[Translating a glob Pattern into a Regular Expression][Translating a glob Pattern into a Regular Expression]]
  - [[An important Aside: Writing Lazy Functions][An important Aside: Writing Lazy Functions]]
  - [[Making Use of Our Pattern Matcher][Making Use of Our Pattern Matcher]]
  - [[Handling Errors Through API Design][Handling Errors Through API Design]]
  - [[Putting Our Code to Work][Putting Our Code to Work]]
- [[9 I/O Case Study: A Library for Searching the Filesystem][9 I/O Case Study: A Library for Searching the Filesystem]]
  - [[The find Command][The find Command]]
  - [[Starting Simple: Recursively Listing a Directory][Starting Simple: Recursively Listing a Directory]]
    - [[Revisiting Anonymous and Named Functions][Revisiting Anonymous and Named Functions]]
    - [[Why Provide Both mapM and forM?][Why Provide Both mapM and forM?]]
  - [[A Naive Finding Function][A Naive Finding Function]]
  - [[Predicates: From Poverty to Riches, While Remaining Pure][Predicates: From Poverty to Riches, While Remaining Pure]]
  - [[Sizing a File Safely][Sizing a File Safely]]
    - [[The Acquire-Use-Release Cycle][The Acquire-Use-Release Cycle]]
  - [[A Domain-Specific Language for Predicates][A Domain-Specific Language for Predicates]]
    - [[Avoiding Boilerplate with Lifting][Avoiding Boilerplate with Lifting]]
    - [[Gluing Predicates Together][Gluing Predicates Together]]
    - [[Defining and Using New Operators][Defining and Using New Operators]]
  - [[Controlling Traversal][Controlling Traversal]]
  - [[Density, Readability, and the Learning Process][Density, Readability, and the Learning Process]]
  - [[Another Way of Looking at Traversal][Another Way of Looking at Traversal]]
  - [[Useful Coding Guidelines][Useful Coding Guidelines]]
    - [[Common Layout Styles][Common Layout Styles]]
- [[10 Code Case Study: Parsing a Binary Data Format][10 Code Case Study: Parsing a Binary Data Format]]
  - [[Grayscale Files][Grayscale Files]]
  - [[Parsing a Raw PGM File][Parsing a Raw PGM File]]
  - [[Getting Rid of Boilerplate Code][Getting Rid of Boilerplate Code]]
  - [[Implicit State][Implicit State]]
    - [[The Identity Parser][The Identity Parser]]
    - [[Record Syntax, Updates, and Pattern Matching][Record Syntax, Updates, and Pattern Matching]]
    - [[A More Interesting Parser][A More Interesting Parser]]
    - [[Obtaining and Modifying the Parse State][Obtaining and Modifying the Parse State]]
    - [[Reporting Parse Errors][Reporting Parse Errors]]
    - [[Chaining Parsers Together][Chaining Parsers Together]]
  - [[Introducing Functors][Introducing Functors]]
    - [[Constraints on Type Definitions Are Bad][Constraints on Type Definitions Are Bad]]
    - [[Infix Use of fmap][Infix Use of fmap]]
    - [[Flexible Instances][Flexible Instances]]
    - [[Thinking More About Functors][Thinking More About Functors]]
  - [[Writing a Functor Instance for Parse][Writing a Functor Instance for Parse]]
  - [[Using Functors for Parsing][Using Functors for Parsing]]
  - [[Rewriting Our PGM Parser][Rewriting Our PGM Parser]]
  - [[Future Directions][Future Directions]]
- [[11 Testing and Quality Assurance][11 Testing and Quality Assurance]]
  - [[QuickCheck: Type-Based Testing][QuickCheck: Type-Based Testing]]
    - [[Testing for Properties][Testing for Properties]]
    - [[Testing Against a Model][Testing Against a Model]]
  - [[Testing Case Study: Specifying a Pretty Printer][Testing Case Study: Specifying a Pretty Printer]]
    - [[Generating Test Data][Generating Test Data]]
    - [[Testing Document Construction][Testing Document Construction]]
    - [[Using Lists as a Model][Using Lists as a Model]]
    - [[Putting It All Together][Putting It All Together]]
  - [[Measuring Test Coverage with HPC][Measuring Test Coverage with HPC]]
- [[12 Barcode Recognition][12 Barcode Recognition]]
  - [[A Little Bit About Barcodes][A Little Bit About Barcodes]]
    - [[EAN-13 Encoding][EAN-13 Encoding]]
  - [[Introducing Arrays][Introducing Arrays]]
    - [[Arrays and Laziness][Arrays and Laziness]]
    - [[Folding over Arrays][Folding over Arrays]]
    - [[Modifying Array Elements][Modifying Array Elements]]
  - [[Encoding an EAN-13 Barcode][Encoding an EAN-13 Barcode]]
  - [[Constraints on Our Decoder][Constraints on Our Decoder]]
  - [[Divide and Conquer][Divide and Conquer]]
  - [[Turning a Color Image into Something Tractable][Turning a Color Image into Something Tractable]]
    - [[Parsing a Color Image][Parsing a Color Image]]
    - [[Grayscale Conversion][Grayscale Conversion]]
    - [[Grayscale to Binary and Type Safety][Grayscale to Binary and Type Safety]]
  - [[What Have We Done to Our Image?][What Have We Done to Our Image?]]
  - [[Finding Matching Digits][Finding Matching Digits]]
    - [[Run Length Encoding][Run Length Encoding]]
    - [[Scaling Run Lengths, and Finding Approximate Matches][Scaling Run Lengths, and Finding Approximate Matches]]
    - [[List Comprehensions][List Comprehensions]]
    - [[Remembering a Match’s Parity][Remembering a Match’s Parity]]
    - [[Chunking a List][Chunking a List]]
    - [[Generating a List of Candidate Digits][Generating a List of Candidate Digits]]
  - [[Life Without Arrays or Hash Tables][Life Without Arrays or Hash Tables]]
    - [[A Forest of Solutions][A Forest of Solutions]]
    - [[A Brief Introduction to Maps][A Brief Introduction to Maps]]
    - [[Further Reading][Further Reading]]
  - [[Turning Digit Soup into an Answer][Turning Digit Soup into an Answer]]
    - [[Solving for Check Digits in Parallel][Solving for Check Digits in Parallel]]
    - [[Completing the Solution Map with the First Digit][Completing the Solution Map with the First Digit]]
    - [[Finding the Correct Sequence][Finding the Correct Sequence]]
  - [[Working with Row Data][Working with Row Data]]
  - [[Pulling It All Together][Pulling It All Together]]
  - [[A Few Comments on Development Style][A Few Comments on Development Style]]
- [[13 Data Structures][13 Data Structures]]
  - [[Association Lists][Association Lists]]
  - [[Maps][Maps]]
  - [[Functions Are Data, Too][Functions Are Data, Too]]
  - [[Extended Example: /etc/passwd][Extended Example: /etc/passwd]]
  - [[Extended Example: Numeric Types][Extended Example: Numeric Types]]
    - [[First Steps][First Steps]]
    - [[Completed Code][Completed Code]]
  - [[Taking Advantage of Functions as Data][Taking Advantage of Functions as Data]]
    - [[Turning Difference Lists into a Proper Library][Turning Difference Lists into a Proper Library]]
    - [[Lists, Difference Lists, and Monoids][Lists, Difference Lists, and Monoids]]
  - [[General-Purpose Sequences][General-Purpose Sequences]]
- [[14 Monads][14 Monads]]
  - [[Revisiting Earlier Code Examples][Revisiting Earlier Code Examples]]
    - [[Maybe Chaining][Maybe Chaining]]
    - [[Implicit State][Implicit State]]
  - [[Looking for Shared Patterns][Looking for Shared Patterns]]
  - [[The Monad Typeclass][The Monad Typeclass]]
  - [[And Now, a Jargon Moment][And Now, a Jargon Moment]]
  - [[Using a New Monad: Show Your Work!][Using a New Monad: Show Your Work!]]
    - [[Information Hiding][Information Hiding]]
    - [[Controlled Escape][Controlled Escape]]
    - [[Leaving a Trace][Leaving a Trace]]
    - [[Using the Logger Monad][Using the Logger Monad]]
  - [[Mixing Pure and Monadic Code][Mixing Pure and Monadic Code]]
  - [[Putting a Few Misconceptions to Rest][Putting a Few Misconceptions to Rest]]
  - [[Building the Logger Monad][Building the Logger Monad]]
    - [[Sequential Logging, Not Sequential Evaluation][Sequential Logging, Not Sequential Evaluation]]
    - [[The Writer Monad][The Writer Monad]]
  - [[The Maybe Monad][The Maybe Monad]]
    - [[Executing the Maybe Monad][Executing the Maybe Monad]]
    - [[Maybe at Work, and Good API Design][Maybe at Work, and Good API Design]]
  - [[The List Monad][The List Monad]]
    - [[Understanding the List Monad][Understanding the List Monad]]
    - [[Putting the List Monad to Work][Putting the List Monad to Work]]
  - [[Desugaring of do Blocks][Desugaring of do Blocks]]
    - [[Monads as a Programmable Semicolon][Monads as a Programmable Semicolon]]
    - [[Why Go Sugar-Free?][Why Go Sugar-Free?]]
  - [[The State Monad][The State Monad]]
    - [[Almost a State Monad][Almost a State Monad]]
    - [[Reading and Modifying the State][Reading and Modifying the State]]
    - [[Will the Real State Monad Please Stand Up?][Will the Real State Monad Please Stand Up?]]
    - [[Using the State Monad: Generating Random Values][Using the State Monad: Generating Random Values]]
    - [[A First Attempt at Purity][A First Attempt at Purity]]
    - [[Random Values in the State Monad][Random Values in the State Monad]]
    - [[Running the State Monad][Running the State Monad]]
    - [[What About a Bit More State?][What About a Bit More State?]]
  - [[Monads and Functors][Monads and Functors]]
    - [[Another Way of Looking at Monads][Another Way of Looking at Monads]]
  - [[The Monad Laws and Good Coding Style][The Monad Laws and Good Coding Style]]
- [[15 Programming with Monads][15 Programming with Monads]]
  - [[Golfing Practice: Association Lists][Golfing Practice: Association Lists]]
  - [[Generalized Lifting][Generalized Lifting]]
  - [[Looking for Alternatives][Looking for Alternatives]]
    - [[The Name mplus Does Not Imply Addition][The Name mplus Does Not Imply Addition]]
    - [[Rules for Working with MonadPlus][Rules for Working with MonadPlus]]
    - [[Failing Safely with MonadPlus][Failing Safely with MonadPlus]]
  - [[Adventures in Hiding the Plumbing][Adventures in Hiding the Plumbing]]
    - [[Supplying Random Numbers][Supplying Random Numbers]]
    - [[Another Round of Golf][Another Round of Golf]]
  - [[Separating Interface from Implementation][Separating Interface from Implementation]]
    - [[Multiparameter Typeclasses][Multiparameter Typeclasses]]
    - [[Functional Dependencies][Functional Dependencies]]
    - [[Rounding Out Our Module][Rounding Out Our Module]]
    - [[Programming to a Monad’s Interface][Programming to a Monad’s Interface]]
  - [[The Reader Monad][The Reader Monad]]
  - [[A Return to Automated Deriving][A Return to Automated Deriving]]
  - [[Hiding the IO Monad][Hiding the IO Monad]]
    - [[Using a newtype][Using a newtype]]
    - [[Designing for Unexpected Uses][Designing for Unexpected Uses]]
    - [[Using Typeclasses][Using Typeclasses]]
    - [[Isolation and Testing][Isolation and Testing]]
    - [[The Writer Monad and Lists][The Writer Monad and Lists]]
    - [[Arbitrary I/O Revisited][Arbitrary I/O Revisited]]
- [[16 Using Parsec][16 Using Parsec]]
  - [[First Steps with Parsec: Simple CSV Parsing][First Steps with Parsec: Simple CSV Parsing]]
  - [[The sepBy and endBy Combinators][The sepBy and endBy Combinators]]
  - [[Choices and Errors][Choices and Errors]]
    - [[Lookahead][Lookahead]]
    - [[Error Handling][Error Handling]]
  - [[Extended Example: Full CSV Parser][Extended Example: Full CSV Parser]]
  - [[Parsec and MonadPlus][Parsec and MonadPlus]]
  - [[Parsing a URL-Encoded Query String][Parsing a URL-Encoded Query String]]
  - [[Supplanting Regular Expressions for Casual Parsing][Supplanting Regular Expressions for Casual Parsing]]
  - [[Parsing Without Variables][Parsing Without Variables]]
  - [[Applicative Functors for Parsing][Applicative Functors for Parsing]]
  - [[Applicative Parsing by Example][Applicative Parsing by Example]]
  - [[Parsing JSON Data][Parsing JSON Data]]
  - [[Parsing a HTTP Request][Parsing a HTTP Request]]
    - [[Backtracking and Its Discontents][Backtracking and Its Discontents]]
    - [[Parsing Headers][Parsing Headers]]
- [[17 Interfacing with C: The FFI][17 Interfacing with C: The FFI]]
  - [[Foreign Language Bindings: The Basics][Foreign Language Bindings: The Basics]]
    - [[Be Careful of Side Effects][Be Careful of Side Effects]]
    - [[A High-Level Wrapper][A High-Level Wrapper]]
  - [[Regular Expressions for Haskell: A Binding for PCRE][Regular Expressions for Haskell: A Binding for PCRE]]
    - [[Simple Tasks: Using the C Preprocessor][Simple Tasks: Using the C Preprocessor]]
    - [[Binding Haskell to C with hsc2hs][Binding Haskell to C with hsc2hs]]
    - [[Adding Type Safety to PCRE][Adding Type Safety to PCRE]]
    - [[Binding to Constants][Binding to Constants]]
    - [[Automating the Binding][Automating the Binding]]
  - [[Passing String Data Between Haskell and C][Passing String Data Between Haskell and C]]
    - [[Typed Pointers][Typed Pointers]]
    - [[Memory Management: Let the Garbage Collector Do the Work][Memory Management: Let the Garbage Collector Do the Work]]
    - [[A High-Level Interface: Marshaling Data][A High-Level Interface: Marshaling Data]]
    - [[Marshaling ByteStrings][Marshaling ByteStrings]]
    - [[Allocating Local C Data: The Storable Class][Allocating Local C Data: The Storable Class]]
    - [[Putting It All Together][Putting It All Together]]
  - [[Matching on Strings][Matching on Strings]]
    - [[Extracting Information About the Pattern][Extracting Information About the Pattern]]
    - [[Pattern Matching with Substrings][Pattern Matching with Substrings]]
    - [[The Real Deal: Compiling and Matching Regular Expressions][The Real Deal: Compiling and Matching Regular Expressions]]
- [[18 Monad Transformers][18 Monad Transformers]]
  - [[Motivation: Boilerplate Avoidance][Motivation: Boilerplate Avoidance]]
  - [[A Simple Monad Transformer Example][A Simple Monad Transformer Example]]
  - [[Common Patterns in Monads and Monad Transformers][Common Patterns in Monads and Monad Transformers]]
  - [[Stacking Multiple Monad Transformers][Stacking Multiple Monad Transformers]]
    - [[Hiding Our Work][Hiding Our Work]]
  - [[Moving Down the Stack][Moving Down the Stack]]
    - [[When Explicit Lifting Is Necessary][When Explicit Lifting Is Necessary]]
  - [[Understanding Monad Transformers by Building One][Understanding Monad Transformers by Building One]]
    - [[Creating a Monad Transformer][Creating a Monad Transformer]]
    - [[More Typeclass Instances][More Typeclass Instances]]
    - [[Replacing the Parse Type with a Monad Stack][Replacing the Parse Type with a Monad Stack]]
  - [[Transformer Stacking Order Is Important][Transformer Stacking Order Is Important]]
  - [[Putting Monads and Monad Transformers into Perspective][Putting Monads and Monad Transformers into Perspective]]
    - [[Interference with Pure Code][Interference with Pure Code]]
    - [[Overdetermined Ordering][Overdetermined Ordering]]
    - [[Runtime Overhead][Runtime Overhead]]
    - [[Unwieldy Interfaces][Unwieldy Interfaces]]
    - [[Pulling It All Together][Pulling It All Together]]
- [[19 Error Handling][19 Error Handling]]
  - [[Error Handling with Data Types][Error Handling with Data Types]]
    - [[Use of Maybe][Use of Maybe]]
    - [[Use of Either][Use of Either]]
  - [[Exceptions][Exceptions]]
    - [[First Steps with Exceptions][First Steps with Exceptions]]
    - [[Laziness and Exception Handling][Laziness and Exception Handling]]
    - [[Using handle][Using handle]]
    - [[Selective Handling of Exceptions][Selective Handling of Exceptions]]
    - [[I/O Exceptions][I/O Exceptions]]
    - [[Throwing Exceptions][Throwing Exceptions]]
    - [[Dynamic Exceptions][Dynamic Exceptions]]
  - [[Error Handling in Monads][Error Handling in Monads]]
    - [[A Tiny Parsing Framework][A Tiny Parsing Framework]]
- [[20 Systems Programming in Haskell][20 Systems Programming in Haskell]]
  - [[Running External Programs][Running External Programs]]
  - [[Directory and File Information][Directory and File Information]]
  - [[Program Termination][Program Termination]]
  - [[Dates and Times][Dates and Times]]
    - [[ClockTime and CalendarTime][ClockTime and CalendarTime]]
    - [[File Modification Times][File Modification Times]]
  - [[Extended Example: Piping][Extended Example: Piping]]
    - [[Using Pipes for Redirection][Using Pipes for Redirection]]
    - [[Better Piping][Better Piping]]
    - [[Final Words on Pipes][Final Words on Pipes]]
- [[21 Using Databases][21 Using Databases]]
  - [[Overview of HDBC][Overview of HDBC]]
  - [[Installing HDBC and Drivers][Installing HDBC and Drivers]]
  - [[Connecting to Databases][Connecting to Databases]]
  - [[Transactions][Transactions]]
  - [[Simple Queries][Simple Queries]]
  - [[SqlValue][SqlValue]]
  - [[Query Parameters][Query Parameters]]
  - [[Prepared Statements][Prepared Statements]]
  - [[Reading Results][Reading Results]]
    - [[Reading with Statements][Reading with Statements]]
    - [[Lazy Reading][Lazy Reading]]
  - [[Database Metadata][Database Metadata]]
  - [[Error Handling][Error Handling]]
- [[22 Extended Example: Web Client Programming][22 Extended Example: Web Client Programming]]
  - [[Basic Types][Basic Types]]
  - [[The Database][The Database]]
  - [[The Parser][The Parser]]
  - [[Downloading][Downloading]]
  - [[Main Program][Main Program]]
- [[23 GUI Programming with gtk2hs][23 GUI Programming with gtk2hs]]
  - [[Installing gtk2hs][Installing gtk2hs]]
  - [[Overview of the GTK+ Stack][Overview of the GTK+ Stack]]
  - [[User Interface Design with Glade][User Interface Design with Glade]]
    - [[Glade Concepts][Glade Concepts]]
  - [[Event-Driven Programming][Event-Driven Programming]]
  - [[Initializing the GUI][Initializing the GUI]]
  - [[The Add Podcast Window][The Add Podcast Window]]
  - [[Long-Running Tasks][Long-Running Tasks]]
  - [[Using Cabal][Using Cabal]]
- [[24 Concurrent and Multicore Programming][24 Concurrent and Multicore Programming]]
  - [[Defining Concurrency and Parallelism][Defining Concurrency and Parallelism]]
  - [[Concurrent Programming with Threads][Concurrent Programming with Threads]]
    - [[Threads Are Nondeterministic][Threads Are Nondeterministic]]
    - [[Hiding Latency][Hiding Latency]]
  - [[Simple Communication Between Threads][Simple Communication Between Threads]]
  - [[The Main Thread and Waiting for Other Threads][The Main Thread and Waiting for Other Threads]]
    - [[Safely Modifying an MVar][Safely Modifying an MVar]]
    - [[Safe Resource Management: A Good Idea, and Easy Besides][Safe Resource Management: A Good Idea, and Easy Besides]]
    - [[Finding the Status of a Thread][Finding the Status of a Thread]]
    - [[Writing Tighter Code][Writing Tighter Code]]
  - [[Communicating over Channels][Communicating over Channels]]
  - [[Useful Things to Know About][Useful Things to Know About]]
    - [[MVar and Chan Are Nonstrict][MVar and Chan Are Nonstrict]]
    - [[Chan Is Unbounded][Chan Is Unbounded]]
  - [[Shared-State Concurrency Is Still Hard][Shared-State Concurrency Is Still Hard]]
    - [[Deadlock][Deadlock]]
    - [[Starvation][Starvation]]
    - [[Is There Any Hope?][Is There Any Hope?]]
  - [[Using Multiple Cores with GHC][Using Multiple Cores with GHC]]
    - [[Runtime Options][Runtime Options]]
    - [[Finding the Number of Available Cores from Haskell][Finding the Number of Available Cores from Haskell]]
    - [[Choosing the Right Runtime][Choosing the Right Runtime]]
  - [[Parallel Programming in Haskell][Parallel Programming in Haskell]]
    - [[Normal Form and Head Normal Form][Normal Form and Head Normal Form]]
    - [[Sequential Sorting][Sequential Sorting]]
    - [[Transforming Our Code into Parallel Code][Transforming Our Code into Parallel Code]]
    - [[Knowing What to Evaluate in Parallel][Knowing What to Evaluate in Parallel]]
    - [[What Promises Does par Make?][What Promises Does par Make?]]
    - [[Running Our Code and Measuring Performance][Running Our Code and Measuring Performance]]
    - [[Tuning for Performance][Tuning for Performance]]
  - [[Parallel Strategies and MapReduce][Parallel Strategies and MapReduce]]
    - [[Separating Algorithm from Evaluation][Separating Algorithm from Evaluation]]
    - [[Separating Algorithm from Strategy][Separating Algorithm from Strategy]]
    - [[Writing a Simple MapReduce Definition][Writing a Simple MapReduce Definition]]
    - [[MapReduce and Strategies][MapReduce and Strategies]]
    - [[Sizing Work Appropriately][Sizing Work Appropriately]]
    - [[Efficiently Finding Line-Aligned Chunks][Efficiently Finding Line-Aligned Chunks]]
    - [[Counting Lines][Counting Lines]]
    - [[Finding the Most Popular URLs][Finding the Most Popular URLs]]
    - [[Conclusions][Conclusions]]
- [[25 Profiling and Optimization][25 Profiling and Optimization]]
  - [[Profiling Haskell Programs][Profiling Haskell Programs]]
    - [[Collecting Runtime Statistics][Collecting Runtime Statistics]]
    - [[Time Profiling][Time Profiling]]
    - [[Space Profiling][Space Profiling]]
  - [[Controlling Evaluation][Controlling Evaluation]]
    - [[Strictness and Tail Recursion][Strictness and Tail Recursion]]
    - [[Adding Strictness][Adding Strictness]]
  - [[Understanding Core][Understanding Core]]
  - [[Advanced Techniques: Fusion][Advanced Techniques: Fusion]]
    - [[Tuning the Generated Assembly][Tuning the Generated Assembly]]
  - [[Conclusions][Conclusions]]
- [[26 Advanced Library Design: Building a Bloom Filter][26 Advanced Library Design: Building a Bloom Filter]]
  - [[Introducing the Bloom Filter][Introducing the Bloom Filter]]
  - [[Use Cases and Package Layout][Use Cases and Package Layout]]
  - [[Basic Design][Basic Design]]
    - [[Unboxing, Lifting, and Bottom][Unboxing, Lifting, and Bottom]]
  - [[The ST Monad][The ST Monad]]
  - [[Designing an API for Qualified Import][Designing an API for Qualified Import]]
  - [[Creating a Mutable Bloom Filter][Creating a Mutable Bloom Filter]]
  - [[The Immutable API][The Immutable API]]
  - [[Creating a Friendly Interface][Creating a Friendly Interface]]
    - [[Re-Exporting Names for Convenience][Re-Exporting Names for Convenience]]
    - [[Hashing Values][Hashing Values]]
    - [[Turning Two Hashes into Many][Turning Two Hashes into Many]]
    - [[Implementing the Easy Creation Function][Implementing the Easy Creation Function]]
  - [[Creating a Cabal Package][Creating a Cabal Package]]
    - [[Dealing with Different Build Setups][Dealing with Different Build Setups]]
    - [[Compilation Options and Interfacing to C][Compilation Options and Interfacing to C]]
  - [[Testing with QuickCheck][Testing with QuickCheck]]
    - [[Polymorphic Testing][Polymorphic Testing]]
    - [[Writing Arbitrary Instances for ByteStrings][Writing Arbitrary Instances for ByteStrings]]
    - [[Are Suggested Sizes Correct?][Are Suggested Sizes Correct?]]
  - [[Performance Analysis and Tuning][Performance Analysis and Tuning]]
    - [[Profile-Driven Performance Tuning][Profile-Driven Performance Tuning]]
- [[27 Sockets and Syslog][27 Sockets and Syslog]]
  - [[Basic Networking][Basic Networking]]
  - [[Communicating with UDP][Communicating with UDP]]
    - [[UDP Client Example: syslog][UDP Client Example: syslog]]
    - [[UDP Syslog Server][UDP Syslog Server]]
  - [[Communicating with TCP][Communicating with TCP]]
    - [[Handling Multiple TCP Streams][Handling Multiple TCP Streams]]
    - [[TCP Syslog Server][TCP Syslog Server]]
    - [[TCP Syslog Client][TCP Syslog Client]]
- [[28 Software Transactional Memory][28 Software Transactional Memory]]
  - [[The Basics][The Basics]]
  - [[Some Simple Examples][Some Simple Examples]]
  - [[STM and Safety][STM and Safety]]
  - [[Retrying a Transaction][Retrying a Transaction]]
    - [[What Happens When We Retry?][What Happens When We Retry?]]
  - [[Choosing Between Alternatives][Choosing Between Alternatives]]
    - [[Using Higher Order Code with Transactions][Using Higher Order Code with Transactions]]
  - [[I/O and STM][I/O and STM]]
  - [[Communication Between Threads][Communication Between Threads]]
  - [[A Concurrent Web Link Checker][A Concurrent Web Link Checker]]
    - [[Checking a Link][Checking a Link]]
    - [[Worker Threads][Worker Threads]]
    - [[Finding Links][Finding Links]]
    - [[Command-Line Parsing][Command-Line Parsing]]
    - [[Pattern Guards][Pattern Guards]]
  - [[Practical Aspects of STM][Practical Aspects of STM]]
    - [[Getting Comfortable with Giving Up Control][Getting Comfortable with Giving Up Control]]
    - [[Using Invariants][Using Invariants]]
- [[A. Installing GHC and Haskell Libraries][A. Installing GHC and Haskell Libraries]]
  - [[Installing GHC][Installing GHC]]
    - [[Windows][Windows]]
    - [[Mac OS X][Mac OS X]]
    - [[Ubuntu and Debian Linux][Ubuntu and Debian Linux]]
    - [[Fedora Linux][Fedora Linux]]
    - [[FreeBSD][FreeBSD]]
  - [[Installing Haskell Software][Installing Haskell Software]]
    - [[Automated Download and Installation with /cabal/][Automated Download and Installation with /cabal/]]
      - [[Installing cabal][Installing cabal]]
      - [[Updating cabal's package list][Updating cabal's package list]]
      - [[Installing a library or program][Installing a library or program]]
    - [[Building Packages by Hand][Building Packages by Hand]]
- [[B. Characters, Strings, and Escaping Rules][B. Characters, Strings, and Escaping Rules]]
  - [[Writing Character and String Literals][Writing Character and String Literals]]
  - [[International Language Support][International Language Support]]
  - [[Escaping Text][Escaping Text]]
    - [[Single-Character Escape Codes][Single-Character Escape Codes]]
    - [[Multiline String Literals][Multiline String Literals]]
    - [[ASCII Control Codes][ASCII Control Codes]]
    - [[Control-with-Character Escapes][Control-with-Character Escapes]]
    - [[Numeric Escapes][Numeric Escapes]]
    - [[The Zero-Width Escape Sequence][The Zero-Width Escape Sequence]]
- [[Tips][Tips]]

* TODO Preface
* TODO 1 Getting Started
** Your Haskell Environment
** Getting Started with ghci, the Interpreter
** Basic Interaction: Using ghci as a Calculator
*** Simple Arithmetic
*** An Arithmetic Quirk: Writing Negative Numbers
*** Boolean Logic, Operators, and Value Comparisons
*** Operator Precedence and Associativity
*** Undefined Values, and Introducing Variables
*** Dealing with Precedence and Associativity Variables
** Command-Line Editing in ghci
** Lists
*** Operators on List
** Strings and Characters
** First Steps and Characters
** A Simple Program
* TODO 2 Types and Functions
** Why Care About Types?
** Haskell's Type System
*** Strong Types
*** Static Types
*** Type Inference
** What to Expect from the Type System
** Some Common Basic Types
** Function Application
** Useful Composite Data Types: Lists and Tuples
** Functions over Lists and Tuples
*** Passing an Expression to a Function
** Function Types and Purity
** Haskell Source Files, and Writing Simple Functions
*** Just What Is a Variable, Anyway?
*** Conditional Evaluation
** Understanding Evaluation by Example
*** Lazy Evaluation
*** A More Involved Example
*** Recursion
*** Ending the Recursion
*** Returning from the Recursion
*** What Have We Learned?
** Polymorphism in Haskell
*** Reasoning About Polymorphic Functions
*** Further Reading
** The Type of a Function of More Than One Argument
** Why the Fuss over Purity?
** Conclusion
* TODO 3 Defining Types, Streamlining Functions
** Defining a New Data Type
*** Naming Types and Values
** Type Synonyms
** Algebraic Data Types
*** Tuples, Algebraic Data Types, and When to Use Each
*** Analogues to Algebraic Data Types in Other Languages
** Pattern Matching
*** Construction and Deconstruction
*** Further Adventures
*** Variable Naming in Patterns
*** The Wild Card Pattern
*** Exhaustive Patterns and Wild Cards
** Record Syntax
** Parameterized Types
** Recursive Types
** Reporting Errors
*** A More Controlled Approach
** Introducing Local Variables
*** Shadowing
*** The where Clause
*** Local Functions, Global Variables
** The Offside Rule and Whitespace in an Expression
*** A Note About Tabs Versus Spaces
*** The Offside Rule Is Not Mandatory
** The case Expression
** Common Beginner Mistakes with Patterns
*** Incorrectly Matching Against a Variable
*** Incorrectly Trying to Compare for Equality
** Conditional Evaluation with Guards
* TODO 4 Functional Programming
** Thinking in Haskell
** A Simple Command-Line Framework
** Warming Up: Portably Splitting Lines of Text
*** A Line-Ending Conversion Program
** Infix Functions
** Working with Lists
*** Basic List Manipulation
*** Safely and Sanely Working with Crashy Functions
*** Partial and Total Functions
*** More Simple List Manipulations
*** Working with Sublists
*** Searching Lists
*** Working with Several Lists at Once
*** Special String-Handling Functions
** How to Think About Loops
*** Explicit Recursion
*** Transforming Every Piece of Input
*** Mapping over a List
*** Selecting Pieces of Input
*** Computing One Answer over a Collection
*** The Left Fold
*** Why Use Folds, Maps, and Filters?
*** Folding from the Right
*** Left Folds, Laziness, and Space Leaks
*** Further Reading
** Anonymous (lambda) Functions
** Partial Function Application and Currying
*** Sections
** As-patterns
** Code Reuse Through Composition
*** Use Your Head Wisely
** Tips for Writing Readable Code
** Space Leaks and Strict Evaluation
*** Avoiding Space Leaks with seq
*** Learning to Use seq
* TODO 5 Writing a Library: Working with JSON Data
** A Whirlwind Tour of JSON
** Representing JSON Data in Haskell
** The Anatomy of a Haskell Module
** Compiling Haskell Source
** Generating a Haskell Program and Importing Modules
** Printing JSON Data
** Type Inference Is a Double-Edged Sword
** A More General Look at Rendering
** Developing Haskell Code Without Going Nuts
** Pretty Printing a String
** Arrays and Objects, and the Module Header
** Writing a Module Header
** Fleshing Out the Pretty-Printing Library
*** Compact Rendering
*** True Pretty Printing
*** Following the Pretty Printer
** Creating a Package
*** Writing a Package Description
*** GHC’s Package Manager
*** Setting Up, Building, and Installing
** Practical Pointers and Further Reading
* TODO 6 Using Typeclasses
  _Page 135-164_
** The Need for Typeclasses
** What Are Typeclasses?
** Declaring Typeclass Instances
** Important Built-in Typeclasses
*** Show
*** Read
*** Serialization with read and show
*** Numeric Types
*** Equality, Ordering, and Comparisons
** Automatic Derivation
** Typeclasses at Work: Making JSON Easier to Use
*** More Helpful Errors
*** Making an Instance with a Type Synonym
** Living in an Open World
*** When Do Overlapping Instances Cause Problems?
*** Relaxing Some Restrictions on Typeclasses
*** How Does Show Work for Strings?
** How to Give a Type a New Identity
*** Differences Between Data and Newtype Declarations
*** Summary: The Three Ways of Naming Types
** JSON Typeclasses Without Overlapping Instances
** The Dreaded Monomorphism Restriction
** Conclusion
* TODO 7 I/O
  _Page 165-192_
** Classic I/O in Haskell
*** Pure Versus I/O
*** Why Purity Matters
** Working with Files and Handles
*** More on openFile
*** Closing Handles
*** Seek and Tell
*** Standard Input, Output, and Error
*** Deleting and Renaming Files
*** Temporary Files
** Extended Example: Functional I/O and Temporary Files
** Lazy I/O
*** hGetContents
*** readFile and writeFile
*** A Word on Lazy Output
*** interact
** The IO Monad
*** Actions
*** Sequencing
*** The True Nature of Return
** Is Haskell Really Imperative?
** Side Effects with Lazy I/O
** Buffering
*** Buffering Modes
*** Flushing The Buffer
** Reading Command-Line Arguments
** Environment Variables
* TODO 8 Efficient File Processing, Regular Expressions, and Filename Matching
  _Page 193-212_
** Efficient File Processing
*** Binary I/O and Qualified Imports
*** Text I/O
** Filename Matching
** Regular Expressions in Haskell
*** The Many Types of Result
** More About Regular Expressions
*** Mixing and Matching String Types
*** Other Things You Should Know
** Translating a glob Pattern into a Regular Expression
** An important Aside: Writing Lazy Functions
** Making Use of Our Pattern Matcher
** Handling Errors Through API Design
** Putting Our Code to Work
* TODO 9 I/O Case Study: A Library for Searching the Filesystem
  _Page 298-343_
** The find Command
** Starting Simple: Recursively Listing a Directory
*** Revisiting Anonymous and Named Functions
*** Why Provide Both mapM and forM?
** A Naive Finding Function
** Predicates: From Poverty to Riches, While Remaining Pure
** Sizing a File Safely
*** The Acquire-Use-Release Cycle
** A Domain-Specific Language for Predicates
*** Avoiding Boilerplate with Lifting
*** Gluing Predicates Together
*** Defining and Using New Operators
** Controlling Traversal
** Density, Readability, and the Learning Process
** Another Way of Looking at Traversal
** Useful Coding Guidelines
*** Common Layout Styles
* TODO 10 Code Case Study: Parsing a Binary Data Format
  _Page 235-254_
** Grayscale Files
** Parsing a Raw PGM File
** Getting Rid of Boilerplate Code
** Implicit State
*** The Identity Parser
*** Record Syntax, Updates, and Pattern Matching
*** A More Interesting Parser
*** Obtaining and Modifying the Parse State
*** Reporting Parse Errors
*** Chaining Parsers Together
** Introducing Functors
*** Constraints on Type Definitions Are Bad
*** Infix Use of fmap
*** Flexible Instances
*** Thinking More About Functors
** Writing a Functor Instance for Parse
** Using Functors for Parsing
** Rewriting Our PGM Parser
** Future Directions
* TODO 11 Testing and Quality Assurance
** QuickCheck: Type-Based Testing
*** Testing for Properties
*** Testing Against a Model
** Testing Case Study: Specifying a Pretty Printer
*** Generating Test Data
*** Testing Document Construction
*** Using Lists as a Model
*** Putting It All Together
** Measuring Test Coverage with HPC
* TODO 12 Barcode Recognition
  _Page 269-298_
** A Little Bit About Barcodes
*** EAN-13 Encoding
** Introducing Arrays
*** Arrays and Laziness
*** Folding over Arrays
*** Modifying Array Elements
** Encoding an EAN-13 Barcode
** Constraints on Our Decoder
** Divide and Conquer
** Turning a Color Image into Something Tractable
*** Parsing a Color Image
*** Grayscale Conversion
*** Grayscale to Binary and Type Safety
** What Have We Done to Our Image?
** Finding Matching Digits
*** Run Length Encoding
*** Scaling Run Lengths, and Finding Approximate Matches
*** List Comprehensions
*** Remembering a Match’s Parity
*** Chunking a List
*** Generating a List of Candidate Digits
** Life Without Arrays or Hash Tables
*** A Forest of Solutions
*** A Brief Introduction to Maps
*** Further Reading
** Turning Digit Soup into an Answer
*** Solving for Check Digits in Parallel
*** Completing the Solution Map with the First Digit
*** Finding the Correct Sequence
** Working with Row Data
** Pulling It All Together
** A Few Comments on Development Style
* TODO 13 Data Structures
** Association Lists
** Maps
** Functions Are Data, Too
** Extended Example: /etc/passwd
** Extended Example: Numeric Types
*** First Steps
*** Completed Code
** Taking Advantage of Functions as Data
*** Turning Difference Lists into a Proper Library
*** Lists, Difference Lists, and Monoids
** General-Purpose Sequences
* TODO 14 Monads
** Revisiting Earlier Code Examples
*** Maybe Chaining
*** Implicit State
** Looking for Shared Patterns
** The Monad Typeclass
** And Now, a Jargon Moment
** Using a New Monad: Show Your Work!
*** Information Hiding
*** Controlled Escape
*** Leaving a Trace
*** Using the Logger Monad
** Mixing Pure and Monadic Code
** Putting a Few Misconceptions to Rest
** Building the Logger Monad
*** Sequential Logging, Not Sequential Evaluation
*** The Writer Monad
** The Maybe Monad
*** Executing the Maybe Monad
*** Maybe at Work, and Good API Design
** The List Monad
*** Understanding the List Monad
*** Putting the List Monad to Work
** Desugaring of do Blocks
*** Monads as a Programmable Semicolon
*** Why Go Sugar-Free?
** The State Monad
*** Almost a State Monad
*** Reading and Modifying the State
*** Will the Real State Monad Please Stand Up?
*** Using the State Monad: Generating Random Values
*** A First Attempt at Purity
*** Random Values in the State Monad
*** Running the State Monad
*** What About a Bit More State?
** Monads and Functors
*** Another Way of Looking at Monads
** The Monad Laws and Good Coding Style
* TODO 15 Programming with Monads
** Golfing Practice: Association Lists
** Generalized Lifting
** Looking for Alternatives
*** The Name mplus Does Not Imply Addition
*** Rules for Working with MonadPlus
*** Failing Safely with MonadPlus
** Adventures in Hiding the Plumbing
*** Supplying Random Numbers
*** Another Round of Golf
** Separating Interface from Implementation
*** Multiparameter Typeclasses
*** Functional Dependencies
*** Rounding Out Our Module
*** Programming to a Monad’s Interface
** The Reader Monad
** A Return to Automated Deriving
** Hiding the IO Monad
*** Using a newtype
*** Designing for Unexpected Uses
*** Using Typeclasses
*** Isolation and Testing
*** The Writer Monad and Lists
*** Arbitrary I/O Revisited
* TODO 16 Using Parsec
** First Steps with Parsec: Simple CSV Parsing
** The sepBy and endBy Combinators
** Choices and Errors
*** Lookahead
*** Error Handling
** Extended Example: Full CSV Parser
** Parsec and MonadPlus
** Parsing a URL-Encoded Query String
** Supplanting Regular Expressions for Casual Parsing
** Parsing Without Variables
** Applicative Functors for Parsing
** Applicative Parsing by Example
** Parsing JSON Data
** Parsing a HTTP Request
*** Backtracking and Its Discontents
*** Parsing Headers

* TODO 17 Interfacing with C: The FFI
** Foreign Language Bindings: The Basics
*** Be Careful of Side Effects
*** A High-Level Wrapper
** Regular Expressions for Haskell: A Binding for PCRE
*** Simple Tasks: Using the C Preprocessor
*** Binding Haskell to C with hsc2hs
*** Adding Type Safety to PCRE
*** Binding to Constants
*** Automating the Binding
** Passing String Data Between Haskell and C
*** Typed Pointers
*** Memory Management: Let the Garbage Collector Do the Work
*** A High-Level Interface: Marshaling Data
*** Marshaling ByteStrings
*** Allocating Local C Data: The Storable Class
*** Putting It All Together
** Matching on Strings
*** Extracting Information About the Pattern
*** Pattern Matching with Substrings
*** The Real Deal: Compiling and Matching Regular Expressions
* TODO 18 Monad Transformers
** Motivation: Boilerplate Avoidance
** A Simple Monad Transformer Example
** Common Patterns in Monads and Monad Transformers
** Stacking Multiple Monad Transformers
*** Hiding Our Work
** Moving Down the Stack
*** When Explicit Lifting Is Necessary
** Understanding Monad Transformers by Building One
*** Creating a Monad Transformer
*** More Typeclass Instances
*** Replacing the Parse Type with a Monad Stack
** Transformer Stacking Order Is Important
** Putting Monads and Monad Transformers into Perspective
*** Interference with Pure Code
*** Overdetermined Ordering
*** Runtime Overhead
*** Unwieldy Interfaces
*** Pulling It All Together

* TODO 19 Error Handling
** Error Handling with Data Types
*** Use of Maybe
*** Use of Either
** Exceptions
*** First Steps with Exceptions
*** Laziness and Exception Handling
*** Using handle
*** Selective Handling of Exceptions
*** I/O Exceptions
*** Throwing Exceptions
*** Dynamic Exceptions
** Error Handling in Monads
*** A Tiny Parsing Framework
* TODO 20 Systems Programming in Haskell
** Running External Programs
** Directory and File Information
** Program Termination
** Dates and Times
*** ClockTime and CalendarTime
*** File Modification Times
** Extended Example: Piping
*** Using Pipes for Redirection
*** Better Piping
*** Final Words on Pipes

* TODO 21 Using Databases
** Overview of HDBC
** Installing HDBC and Drivers
** Connecting to Databases
** Transactions
** Simple Queries
** SqlValue
** Query Parameters
** Prepared Statements
** Reading Results
*** Reading with Statements
*** Lazy Reading
** Database Metadata
** Error Handling
* TODO 22 Extended Example: Web Client Programming
** Basic Types
** The Database
** The Parser
** Downloading
** Main Program
* TODO 23 GUI Programming with gtk2hs
** Installing gtk2hs
** Overview of the GTK+ Stack
** User Interface Design with Glade
*** Glade Concepts
** Event-Driven Programming
** Initializing the GUI
** The Add Podcast Window
** Long-Running Tasks
** Using Cabal
* TODO 24 Concurrent and Multicore Programming
** Defining Concurrency and Parallelism
** Concurrent Programming with Threads
*** Threads Are Nondeterministic
*** Hiding Latency
** Simple Communication Between Threads
** The Main Thread and Waiting for Other Threads
*** Safely Modifying an MVar
*** Safe Resource Management: A Good Idea, and Easy Besides
*** Finding the Status of a Thread
*** Writing Tighter Code
** Communicating over Channels
** Useful Things to Know About
*** MVar and Chan Are Nonstrict
*** Chan Is Unbounded
** Shared-State Concurrency Is Still Hard
*** Deadlock
*** Starvation
*** Is There Any Hope?
** Using Multiple Cores with GHC
*** Runtime Options
*** Finding the Number of Available Cores from Haskell
*** Choosing the Right Runtime
** Parallel Programming in Haskell
*** Normal Form and Head Normal Form
*** Sequential Sorting
*** Transforming Our Code into Parallel Code
*** Knowing What to Evaluate in Parallel
*** What Promises Does par Make?
*** Running Our Code and Measuring Performance
*** Tuning for Performance
** Parallel Strategies and MapReduce
*** Separating Algorithm from Evaluation
*** Separating Algorithm from Strategy
*** Writing a Simple MapReduce Definition
*** MapReduce and Strategies
*** Sizing Work Appropriately
*** Efficiently Finding Line-Aligned Chunks
*** Counting Lines
*** Finding the Most Popular URLs
*** Conclusions
* TODO 25 Profiling and Optimization
** Profiling Haskell Programs
*** Collecting Runtime Statistics
*** Time Profiling
*** Space Profiling
** Controlling Evaluation
*** Strictness and Tail Recursion
*** Adding Strictness
** Understanding Core
** Advanced Techniques: Fusion
*** Tuning the Generated Assembly
** Conclusions
* TODO 26 Advanced Library Design: Building a Bloom Filter
** Introducing the Bloom Filter
** Use Cases and Package Layout
** Basic Design
*** Unboxing, Lifting, and Bottom
** The ST Monad
** Designing an API for Qualified Import
** Creating a Mutable Bloom Filter
** The Immutable API
** Creating a Friendly Interface
*** Re-Exporting Names for Convenience
*** Hashing Values
*** Turning Two Hashes into Many
*** Implementing the Easy Creation Function
** Creating a Cabal Package
*** Dealing with Different Build Setups
*** Compilation Options and Interfacing to C
** Testing with QuickCheck
*** Polymorphic Testing
*** Writing Arbitrary Instances for ByteStrings
*** Are Suggested Sizes Correct?
** Performance Analysis and Tuning
*** Profile-Driven Performance Tuning
* TODO 27 Sockets and Syslog
** Basic Networking
** Communicating with UDP
*** UDP Client Example: syslog
*** UDP Syslog Server
** Communicating with TCP
*** Handling Multiple TCP Streams
*** TCP Syslog Server
*** TCP Syslog Client

* TODO 28 Software Transactional Memory
** The Basics
** Some Simple Examples
** STM and Safety
** Retrying a Transaction
*** What Happens When We Retry?
** Choosing Between Alternatives
*** Using Higher Order Code with Transactions
** I/O and STM
** Communication Between Threads
** A Concurrent Web Link Checker
*** Checking a Link
*** Worker Threads
*** Finding Links
*** Command-Line Parsing
*** Pattern Guards
** Practical Aspects of STM
*** Getting Comfortable with Giving Up Control
*** Using Invariants
* TODO A. Installing GHC and Haskell Libraries
** Installing GHC
*** Windows
*** Mac OS X
*** Ubuntu and Debian Linux
*** Fedora Linux
*** FreeBSD
** TODO Installing Haskell Software
*** Automated Download and Installation with /cabal/
**** Installing cabal
**** Updating cabal's package list
**** Installing a library or program
    
*** Building Packages by Hand
* TODO B. Characters, Strings, and Escaping Rules
** Writing Character and String Literals
** International Language Support
** Escaping Text
*** Single-Character Escape Codes
*** Multiline String Literals
*** ASCII Control Codes
*** Control-with-Character Escapes
*** Numeric Escapes
*** The Zero-Width Escape Sequence
* Tips
