#+TITLE: Algorithms
#+VERSION: 4th
#+AUTHOR: Robert Sedgewick, Kevin Wayne
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Preface - viii][Preface - viii]]
- [[1 Fundamentals - 3][1 Fundamentals - 3]]
    - [[Algorithms - 4][Algorithms - 4]]
  - [[1.1 Basic Programming Model - 8][1.1 Basic Programming Model - 8]]
  - [[1.2 Data Abstraction - 64][1.2 Data Abstraction - 64]]
    - [[Using abstract data types. - 65][Using abstract data types. - 65]]
    - [[Examples of abstract data types. - 74][Examples of abstract data types. - 74]]
      - [[Geometric objects - 76][Geometric objects - 76]]
      - [[Information processing - 78][Information processing - 78]]
      - [[Strings - 80][Strings - 80]]
      - [[Input and output revisited. - 82][Input and output revisited. - 82]]
    - [[Implementing an abstract data type. - 84][Implementing an abstract data type. - 84]]
      - [[Instance variables - 84][Instance variables - 84]]
      - [[Constructors - 84][Constructors - 84]]
      - [[Instance methods - 86][Instance methods - 86]]
      - [[Slope - 87][Slope - 87]]
      - [[API, clients, and implementations. - 88][API, clients, and implementations. - 88]]
    - [[More ADT implementations. - 90][More ADT implementations. - 90]]
      - [[Date. - 90][Date. - 90]]
      - [[Maintaining multiple implementations. - 90][Maintaining multiple implementations. - 90]]
      - [[Accumulator. - 92][Accumulator. - 92]]
      - [[Visual accumulator. - 94][Visual accumulator. - 94]]
    - [[Data-type design - 96][Data-type design - 96]]
      - [[Encapsulation. - 96][Encapsulation. - 96]]
      - [[Designing APIs. - 97][Designing APIs. - 97]]
      - [[Algorithms and abstract data types. - 98][Algorithms and abstract data types. - 98]]
      - [[Interface inheritance. - 100][Interface inheritance. - 100]]
      - [[Implementation inheritance. - 101][Implementation inheritance. - 101]]
      - [[String conversion. - 102][String conversion. - 102]]
      - [[Wrapper types. - 102][Wrapper types. - 102]]
      - [[Equality. - 102][Equality. - 102]]
      - [[Memory management. - 104][Memory management. - 104]]
      - [[Immutability. - 105][Immutability. - 105]]
      - [[Design by contract. - 107][Design by contract. - 107]]
      - [[Exceptions and errors. - 107][Exceptions and errors. - 107]]
      - [[Assertions. - 107][Assertions. - 107]]
      - [[Summary. - 108][Summary. - 108]]
  - [[1.3 Bags, Queues, and Stacks - 120][1.3 Bags, Queues, and Stacks - 120]]
    - [[APIs - 121][APIs - 121]]
      - [[Generics - 122][Generics - 122]]
      - [[Iterable collections - 123][Iterable collections - 123]]
      - [[Bags - 124][Bags - 124]]
      - [[FIFO queues - 126][FIFO queues - 126]]
      - [[Pushdown stacks - 127][Pushdown stacks - 127]]
      - [[Arithmetic expression evaluation - 128][Arithmetic expression evaluation - 128]]
    - [[Implementing collections - 132][Implementing collections - 132]]
      - [[Fixed-capacity stack - 132][Fixed-capacity stack - 132]]
      - [[Generics - 134][Generics - 134]]
      - [[Array resizing - 136][Array resizing - 136]]
      - [[Loitering - 137][Loitering - 137]]
      - [[Iteration - 138][Iteration - 138]]
    - [[Linked lists - 142][Linked lists - 142]]
      - [[Node record - 142][Node record - 142]]
      - [[Building a linked list - 143][Building a linked list - 143]]
      - [[Insert at the beginning - 144][Insert at the beginning - 144]]
      - [[Remove from the beginning - 145][Remove from the beginning - 145]]
      - [[Insert at the end - 145][Insert at the end - 145]]
      - [[Insert/remove at other positions - 145][Insert/remove at other positions - 145]]
      - [[Traversal - 146][Traversal - 146]]
      - [[Stack implementation - 147][Stack implementation - 147]]
      - [[Queue implementation - 150][Queue implementation - 150]]
      - [[Bag implementation - 154][Bag implementation - 154]]
    - [[Overview - 156][Overview - 156]]
      - [[Data structures - 156][Data structures - 156]]
  - [[1.4 Analysis of Algorithms - 172][1.4 Analysis of Algorithms - 172]]
    - [[Scientific method - 172][Scientific method - 172]]
    - [[Observations - 173][Observations - 173]]
      - [[Example - 173][Example - 173]]
      - [[Stopwatch - 174][Stopwatch - 174]]
      - [[Analysis of experimental data - 176][Analysis of experimental data - 176]]
    - [[Mathematical models - 178][Mathematical models - 178]]
      - [[Tilde approximations.][Tilde approximations.]]
  - [[1.5 Case Study: Union-Find - 216][1.5 Case Study: Union-Find - 216]]
- [[2 Sorting - 243][2 Sorting - 243]]
  - [[2.1 Elementary Sorts - 244][2.1 Elementary Sorts - 244]]
  - [[2.2 Mergesort - 270][2.2 Mergesort - 270]]
  - [[2.3 Quicksort - 288][2.3 Quicksort - 288]]
  - [[2.4 Priority Queues - 308][2.4 Priority Queues - 308]]
  - [[2.5 Applications - 336][2.5 Applications - 336]]
- [[3 Searching - 361][3 Searching - 361]]
  - [[3.1 Symbol Tables - 362][3.1 Symbol Tables - 362]]
  - [[3.2 Binary Search Trees - 396][3.2 Binary Search Trees - 396]]
  - [[3.3 Balanced Search Trees - 424][3.3 Balanced Search Trees - 424]]
  - [[3.4 Hash Tables - 458][3.4 Hash Tables - 458]]
  - [[3.5 Applications - 486][3.5 Applications - 486]]
- [[4 Graphs - 515][4 Graphs - 515]]
  - [[4.1 Undirected Graphs - 518][4.1 Undirected Graphs - 518]]
  - [[4.2 Directed Graphs - 566][4.2 Directed Graphs - 566]]
  - [[4.3 Minimum Spanning Trees - 604][4.3 Minimum Spanning Trees - 604]]
  - [[4.4 Shortest Paths - 638][4.4 Shortest Paths - 638]]
- [[5 Strings - 695][5 Strings - 695]]
  - [[5.1 String Sorts - 702][5.1 String Sorts - 702]]
  - [[5.2 Tries - 730][5.2 Tries - 730]]
  - [[5.3 Substring Search - 758][5.3 Substring Search - 758]]
  - [[5.4 Regular Expressions - 788][5.4 Regular Expressions - 788]]
  - [[5.5 Data Compression - 810][5.5 Data Compression - 810]]
- [[6 Context - 853][6 Context - 853]]
- [[Index - 933][Index - 933]]
- [[Algorithms - 954][Algorithms - 954]]
- [[Clients - 955][Clients - 955]]

* Preface - viii
* 1 Fundamentals - 3
  - =EN=
    amenable

*** TODO Algorithms - 4
    - Algorithm :: used in computer science to describe a _finite_, _deterministic_,
                   and _effective_ problem-solving method suitable for implementation
                   as a computer program.

    - =TODO= Note

** TODO 1.1 Basic Programming Model - 8
  - =EN=
    mitigate - 缓和

** TODO 1.2 Data Abstraction - 64
*** Using abstract data types. - 65
*** Examples of abstract data types. - 74
**** Geometric objects - 76
**** Information processing - 78
**** Strings - 80
**** Input and output revisited. - 82

*** Implementing an abstract data type. - 84
**** Instance variables - 84
**** Constructors - 84
**** Instance methods - 86
**** Slope - 87
**** API, clients, and implementations. - 88

*** More ADT implementations. - 90
**** Date. - 90
**** Maintaining multiple implementations. - 90
**** Accumulator. - 92
**** Visual accumulator. - 94

*** Data-type design - 96
**** Encapsulation. - 96
**** Designing APIs. - 97
**** Algorithms and abstract data types. - 98
**** Interface inheritance. - 100
**** Implementation inheritance. - 101
**** String conversion. - 102
**** Wrapper types. - 102
**** Equality. - 102
**** Memory management. - 104
**** Immutability. - 105
**** Design by contract. - 107
**** Exceptions and errors. - 107
**** Assertions. - 107
**** Summary. - 108

** TODO 1.3 Bags, Queues, and Stacks - 120
*** APIs - 121
**** Generics - 122
***** Autoboxing - 122

**** Iterable collections - 123
**** Bags - 124
**** FIFO queues - 126
**** Pushdown stacks - 127
**** Arithmetic expression evaluation - 128

*** Implementing collections - 132
**** Fixed-capacity stack - 132
**** Generics - 134
**** Array resizing - 136
**** Loitering - 137
**** Iteration - 138

*** Linked lists - 142
**** Node record - 142
**** Building a linked list - 143
**** Insert at the beginning - 144
**** Remove from the beginning - 145
**** Insert at the end - 145
**** Insert/remove at other positions - 145
**** Traversal - 146
**** Stack implementation - 147
**** Queue implementation - 150
**** Bag implementation - 154

*** Overview - 156
**** Data structures - 156

** TODO 1.4 Analysis of Algorithms - 172
*** Scientific method - 172
*** Observations - 173
**** Example - 173
**** Stopwatch - 174
**** Analysis of experimental data - 176

*** Mathematical models - 178
**** Tilde approximations.
** TODO 1.5 Case Study: Union-Find - 216

* 2 Sorting - 243
  - In this chapter,
    + we consider
      1. SEVERAL classical /sorting/ methods

      2. an efficient implementation of a fundamental data type known as the
         /priority queue/.

    + we discuss
      1. the theoretical basis for comparing sorting algorithms

      2. conclude the chapter with a _survey_ of applications of /sorting/ and
         /priority queues/.

  - =EN=
    excursion - 短途旅行

  - *Rules of the game*

  - Template for sort classes:
    #+BEGIN_SRC java
      public class Example
      {
          public static void sort(Comparable[] a)
          { /* See Algorithms 2.1, 2.2, 2.3, 2.4, 2.5, or 2.7. */
          }

          private static boolean less(Comparable v, Comparable w)
          { return v.compareTo(w) < 0; }

          private static void exch(Comparable[] a, int i, int j)
          { Comparable t = a[i]; a[i] = a[j]; a[j] = t; }

          private static void show(Comparable[] a)
          { // Print the array, on a single line.
              for (int i = 0; i < a.length; i++)
                  StdOut.print(a[i] + " ");
              StdOut.println();
          }

          public static boolean isSorted(Comparable[] a)
          { // Test whether the array entries are in order.
              for (int i = 1; i < a.length; i++)
                  if (less(a[i], a[i-1])) return false;
              return true;
          }

          public static void main(String[] args)
          { // Read strings from standard input, sort them, and print.
              String[] a = In.readStrings();
              sort(a);
              assert isSorted(a);
              show(a);
          }
      }
    #+END_SRC

    + Scala version:
      * Translation (imperative):
        #+BEGIN_SRC scala
          object SortingTemplate
          {
            def sort(a: Array[Comparable]): Unit =
            { /* See Algorithms 2.1, 2.2, 2.3, 2.4, 2.5, or 2.7. */
            }
  
            private def less(v: Comparable, w: Comparable): Boolean =
              v.compareTo(w) < 0
  
            private def exch(a: Array[Comparable], i: Int, j: Int): Unit =
            {
              val t = a(i)
              a(i) = a(j)
              a(j) = t
            }
  
            private def show(a: Array[Comparable]): Unit =
            { // Print the array, on a single line.
                println("Array(" + a.mkString(", ") + ")")
            }
  
            def isSortedAscending(a: Array[Comparable]): Boolean = 
              a.indices.sliding(2) forall {
                case Vector(a)    => true
                case Vecoor(a, b) => less(a, b)
              }
  
  
            def isSorted(a: Array[Comparable]): Boolean =
              isSortedAscending _
  
            def main(args: Array[String]): Unit =
            { // Read strings from standard input, sort them, and print.
                val a: Array[String] = In.readStrings()
                sort(a)
                assert(isSorted(a))
                show(a)
            }
          }
        #+END_SRC

      * Translation:
        #+BEGIN_SRC scala
          object SortingTemplate {
            /* See Algorithms 2.1, 2.2, 2.3, 2.4, 2.5, or 2.7. */
            def sort[T](a: Vector[T])(implicit ord: Ordering[T]): Vector[T] =
              ???

            private def less[T](v: T, w: T)(implicit ord: Ordering[T]): Boolean =
              v.compareTo(w) < 0

            private def exch[T](a: Vector[T], i: Int, j: Int): Vector[T] =
              a.updated(i, a(j)).updated(j, a(i))

            private def show[T](a: Vector[T]): Unit =
              println("Array(" + a.mkString(", ") + ")")

            def isSortedAscending[T](a: Vector[T]): Boolean =
              a.indices.sliding(2) forall {
                case Vector(a)    => true
                case Vector(a, b) => less(a, b)
              }

            def isSorted[T](a: Vector[T]): Boolean =
              isSortedAscending _

            def main(args: Array[String]): Unit = {
              val a: Vector[String] = In.readStrings()
              val sortedA = sort(a)
              assert(isSorted(sortedA))
              show(sortedA)
            }
          }
        #+END_SRC

** 2.1 Elementary Sorts - 244
** 2.2 Mergesort - 270
** 2.3 Quicksort - 288
** 2.4 Priority Queues - 308
** 2.5 Applications - 336

* 3 Searching - 361
** 3.1 Symbol Tables - 362
** 3.2 Binary Search Trees - 396
** 3.3 Balanced Search Trees - 424
** 3.4 Hash Tables - 458
** 3.5 Applications - 486

* 4 Graphs - 515
** 4.1 Undirected Graphs - 518
** 4.2 Directed Graphs - 566
** 4.3 Minimum Spanning Trees - 604
** 4.4 Shortest Paths - 638

* 5 Strings - 695
** 5.1 String Sorts - 702
** 5.2 Tries - 730
** 5.3 Substring Search - 758
** 5.4 Regular Expressions - 788
** 5.5 Data Compression - 810

* 6 Context - 853
* Index - 933
* Algorithms - 954
* Clients - 955
