#+TITLE: Learning Python
#+SUBTITLE: Powerful Object-Oriented Programming
#+VERSION: 5th (Updated for 3.3 and 2.7)
#+USE: 3.8
#+AUTHOR: Mark Lutz
#+STARTUP: overview
#+STARTUP: entitiespretty

* Preface - xxxiii
* Part I. Getting Started
** 1. A Python Q&A Session - 3
*** Why Do People Use Python? - 3
**** Software Quality 4
**** Developer Productivity 5

*** Is Python a “Scripting Language”? - 5
*** OK, but What’s the Downside? - 7
*** Who Uses Python Today? - 9
*** What Can I Do with Python? - 10
**** Systems Programming 11
**** GUIs 11
**** Internet Scripting 11
**** Component Integration 12
**** Database Programming 12
**** Rapid Prototyping 13
**** Numeric and Scientific Programming 13
**** And More: Gaming, Images, Data Mining, Robots, Excel... 14

*** How Is Python Developed and Supported? - 15
**** Open Source Tradeoffs 15

*** What Are Python’s Technical Strengths? - 16
**** It’s Object-Oriented and Functional 16
**** It’s Free 17
**** It’s Portable 17
**** It’s Powerful 18
**** It’s Mixable 19
**** It’s Relatively Easy to Use 19
**** It’s Relatively Easy to Learn 20
**** It’s Named After Monty Python 20

*** How Does Python Stack Up to Language X? - 21
*** Chapter Summary - 22
*** Test Your Knowledge: Quiz - 23
*** Test Your Knowledge: Answers - 23

** 2. How Python Runs Programs - 27
*** Introducing the Python Interpreter - 27
*** Program Execution - 28
**** The Programmer’s View 28
**** Python’s View 30

*** Execution Model Variations - 33
**** Python Implementation Alternatives - 33
**** Execution Optimization Tools - 37
**** Frozen Binaries - 39
**** Future Possibilities? - 40

*** Chapter Summary - 40
*** Test Your Knowledge: Quiz - 41
*** Test Your Knowledge: Answers - 41

** 3. How You Run Programs - 43
*** The Interactive Prompt 43
**** Starting an Interactive Session 44
**** The System Path 45
**** New Windows Options in 3.3: PATH, Launcher 46
**** Where to Run: Code Directories 47
**** What Not to Type: Prompts and Comments 48
**** Running Code Interactively 49
**** Why the Interactive Prompt? 50
**** Usage Notes: The Interactive Prompt 52

*** System Command Lines and Files 54
**** A First Script 55
**** Running Files with Command Lines 56
**** Command-Line Usage Variations 57
**** Usage Notes: Command Lines and Files 58

*** Unix-Style Executable Scripts: #! 59
**** Unix Script Basics 59
**** The Unix env Lookup Trick 60
**** The Python 3.3 Windows Launcher: #! Comes to Windows 60

*** Clicking File Icons 62
**** Icon-Click Basics 62
**** Clicking Icons on Windows 63
**** The input Trick on Windows 63
**** Other Icon-Click Limitations 66

*** Module Imports and Reloads 66
**** Import and Reload Basics 66
**** The Grander Module Story: Attributes 68
**** Usage Notes: import and reload 71

*** Using exec to Run Module Files 72
*** The IDLE User Interface 73
**** IDLE Startup Details 74
**** IDLE Basic Usage 75
**** IDLE Usability Features 76
**** Advanced IDLE Tools 77
**** Usage Notes: IDLE 78

*** Other IDEs 79
*** Other Launch Options 81
**** Embedding Calls 81
**** Frozen Binary Executables 82
**** Text Editor Launch Options 82
**** Still Other Launch Options 82
**** Future Possibilities? 83

*** Which Option Should I Use? 83
*** Chapter Summary 85
*** Test Your Knowledge: Quiz 85
*** Test Your Knowledge: Answers 86
*** Test Your Knowledge: Part I Exercises 87

* Part II. Types and Operations
** 4. Introducing Python Object Types - 93
*** The Python Conceptual Hierarchy 93
*** Why Use Built-in Types? 94
*** Python’s Core Data Types 95
*** Numbers 97
*** Strings 99
**** Sequence Operations 99
**** Immutability 101
**** Type-Specific Methods 102
**** Getting Help 104
**** Other Ways to Code Strings 105
**** Unicode Strings 106
**** Pattern Matching 108

*** Lists 109
**** Sequence Operations 109
**** Type-Specific Operations 109
**** Bounds Checking 110
**** Nesting 110
**** Comprehensions 111

*** Dictionaries 113
**** Mapping Operations 114
**** Nesting Revisited 115
**** Missing Keys: if Tests 116
**** Sorting Keys: for Loops 118
**** Iteration and Optimization 120

*** Tuples 121
**** Why Tuples? 122

*** Files 122
**** Binary Bytes Files 123
**** Unicode Text Files 124
**** Other File-Like Tools 126

*** Other Core Types 126
**** How to Break Your Code’s Flexibility 128
**** User-Defined Classes 129
**** And Everything Else 130

*** Chapter Summary 130
*** Test Your Knowledge: Quiz 131
*** Test Your Knowledge: Answers 131

** 5. Numeric Types - 133
*** Numeric Type Basics 133
**** Numeric Literals 134
**** Built-in Numeric Tools 136
**** Python Expression Operators 136

*** Numbers in Action 141
**** Variables and Basic Expressions 141
**** Numeric Display Formats 143
**** Comparisons: Normal and Chained 144
**** Division: Classic, Floor, and True 146
**** Integer Precision 150
**** Complex Numbers 151
**** Hex, Octal, Binary: Literals and Conversions 151
**** Bitwise Operations 153
**** Other Built-in Numeric Tools 155

*** Other Numeric Types 157
**** Decimal Type 157
**** Fraction Type 160
**** Sets 163
**** Booleans 171

*** Numeric Extensions 172
*** Chapter Summary 172
*** Test Your Knowledge: Quiz 173
*** Test Your Knowledge: Answers 173

** 6. The Dynamic Typing Interlude - 175
*** The Case of the Missing Declaration Statements 175
**** Variables, Objects, and References 176
**** Types Live with Objects, Not Variables 177
**** Objects Are Garbage-Collected 178

*** Shared References 180
**** Shared References and In-Place Changes 181
**** Shared References and Equality 183

*** Dynamic Typing Is Everywhere 185
*** Chapter Summary 186
*** Test Your Knowledge: Quiz 186
*** Test Your Knowledge: Answers 186

** 7. String Fundamentals - 189
*** This Chapter’s Scope 189
**** Unicode: The Short Story 189

*** String Basics 190
*** String Literals 192
**** Single- and Double-Quoted Strings Are the Same 193
**** Escape Sequences Represent Special Characters 193
**** Raw Strings Suppress Escapes 196
**** Triple Quotes Code Multiline Block Strings 198

*** Strings in Action 200
**** Basic Operations 200
**** Indexing and Slicing 201
**** String Conversion Tools 205
**** Changing Strings I 208

*** String Methods 209
**** Method Call Syntax 209
**** Methods of Strings 210
**** String Method Examples: Changing Strings II 211
**** String Method Examples: Parsing Text 213
**** Other Common String Methods in Action 214
**** The Original string Module’s Functions (Gone in 3.X) 215

*** String Formatting Expressions 216
**** Formatting Expression Basics 217
**** Advanced Formatting Expression Syntax 218
**** Advanced Formatting Expression Examples 220
**** Dictionary-Based Formatting Expressions 221

*** String Formatting Method Calls 222
**** Formatting Method Basics 222
**** Adding Keys, Attributes, and Offsets 223
**** Advanced Formatting Method Syntax 224
**** Advanced Formatting Method Examples 225
**** Comparison to the % Formatting Expression 227
**** Why the Format Method? 230

*** General Type Categories 235
**** Types Share Operation Sets by Categories 235
**** Mutable Types Can Be Changed in Place 236

*** Chapter Summary 237
*** Test Your Knowledge: Quiz 237
*** Test Your Knowledge: Answers 237

** 8. Lists and Dictionaries - 239
*** Lists 239
*** Lists in Action 242
**** Basic List Operations 242
**** List Iteration and Comprehensions 242
**** Indexing, Slicing, and Matrixes 243
**** Changing Lists in Place 244

*** Dictionaries 250
*** Dictionaries in Action 252
**** Basic Dictionary Operations 253
**** Changing Dictionaries in Place 254
**** More Dictionary Methods 254
**** Example: Movie Database 256
**** Dictionary Usage Notes 258
**** Other Ways to Make Dictionaries 262
**** Dictionary Changes in Python 3.X and 2.7 264

*** Chapter Summary 271
*** Test Your Knowledge: Quiz 272
*** Test Your Knowledge: Answers 272

** 9. Tuples, Files, and Everything Else - 275
*** Tuples 276
**** Tuples in Action 277
**** Why Lists and Tuples? 279
**** Records Revisited: Named Tuples 280

*** Files 282
**** Opening Files 283
**** Using Files 284
**** Files in Action 285
**** Text and Binary Files: The Short Story 287
**** Storing Python Objects in Files: Conversions 288
**** Storing Native Python Objects: pickle 290
**** Storing Python Objects in JSON Format 291
**** Storing Packed Binary Data: struct 293
**** File Context Managers 294
**** Other File Tools 294

*** Core Types Review and Summary 295
**** Object Flexibility 297
**** References Versus Copies 297
**** Comparisons, Equality, and Truth 300
**** The Meaning of True and False in Python 304
**** Python’s Type Hierarchies 306
**** Type Objects 306
**** Other Types in Python 308

*** Built-in Type Gotchas 308
**** Assignment Creates References, Not Copies 308
**** Repetition Adds One Level Deep 309
**** Beware of Cyclic Data Structures 310
**** Immutable Types Can’t Be Changed in Place 311

*** Chapter Summary 311
*** Test Your Knowledge: Quiz 311
*** Test Your Knowledge: Answers 312
*** Test Your Knowledge: Part II Exercises 313

* Part III. Statements and Syntax
** 10. Introducing Python Statements - 319
*** The Python Conceptual Hierarchy Revisited 319
*** Python’s Statements 320
*** A Tale of Two ifs 322
**** What Python Adds 322
**** What Python Removes 323
**** Why Indentation Syntax? 324
**** A Few Special Cases 327

*** A Quick Example: Interactive Loops 329
**** A Simple Interactive Loop 329
**** Doing Math on User Inputs 331
**** Handling Errors by Testing Inputs 332
**** Handling Errors with try Statements 333
**** Nesting Code Three Levels Deep 335

*** Chapter Summary 336
*** Test Your Knowledge: Quiz 336
*** Test Your Knowledge: Answers 336

** 11. Assignments, Expressions, and Prints - 339
*** Assignment Statements 339
**** Assignment Statement Forms 340
**** Sequence Assignments 341
**** Extended Sequence Unpacking in Python 3.X 344
**** Multiple-Target Assignments 348
**** Augmented Assignments 350
**** Variable Name Rules 352

*** Expression Statements 356
**** Expression Statements and In-Place Changes 357

*** Print Operations 358
**** The Python 3.X print Function 359
**** The Python 2.X print Statement 361
**** Print Stream Redirection 363
**** Version-Neutral Printing 366

*** Chapter Summary 369
*** Test Your Knowledge: Quiz 370
*** Test Your Knowledge: Answers 370

** 12. if Tests and Syntax Rules - 371
*** if Statements 371
**** General Format 371
**** Basic Examples 372
**** Multiway Branching 372

*** Python Syntax Revisited 375
**** Block Delimiters: Indentation Rules 376
**** Statement Delimiters: Lines and Continuations 378
**** A Few Special Cases 379

*** Truth Values and Boolean Tests 380
*** The if/else Ternary Expression 382
*** Chapter Summary 385
*** Test Your Knowledge: Quiz 385
*** Test Your Knowledge: Answers 386

** 13. while and for Loops - 387
*** while Loops 387
**** General Format 388
**** Examples 388

*** break, continue, pass, and the Loop else 389
**** General Loop Format 389
**** pass 390
**** continue 391
**** break 391
**** Loop else 392

*** for Loops 395
**** General Format 395
**** Examples 395

*** Loop Coding Techniques 402
**** Counter Loops: range 402
**** Sequence Scans: while and range Versus for 403
**** Sequence Shufflers: range and len 404
**** Nonexhaustive Traversals: range Versus Slices 405
**** Changing Lists: range Versus Comprehensions 406
**** Parallel Traversals: zip and map 407
**** Generating Both Offsets and Items: enumerate 410

*** Chapter Summary 413
*** Test Your Knowledge: Quiz 414
*** Test Your Knowledge: Answers 414

** 14. Iterations and Comprehensions - 415
*** Iterations: A First Look 416
**** The Iteration Protocol: File Iterators 416
**** Manual Iteration: iter and next 419
**** Other Built-in Type Iterables 422

*** List Comprehensions: A First Detailed Look 424
**** List Comprehension Basics 425
**** Using List Comprehensions on Files 426
**** Extended List Comprehension Syntax 427

*** Other Iteration Contexts 429
*** New Iterables in Python 3.X 434
**** Impacts on 2.X Code: Pros and Cons 434
**** The range Iterable 435
**** The map, zip, and filter Iterables 436
**** Multiple Versus Single Pass Iterators 438
**** Dictionary View Iterables 439

*** Other Iteration Topics 440
*** Chapter Summary 441
*** Test Your Knowledge: Quiz 441
*** Test Your Knowledge: Answers 441

** 15. The Documentation Interlude - 443
*** Python Documentation Sources 443
**** # Comments 444
**** The dir Function 444
**** Docstrings: __doc__ 446
**** PyDoc: The help Function 449
**** PyDoc: HTML Reports 452
**** Beyond docstrings: Sphinx 461
**** The Standard Manual Set 461
**** Web Resources 462
**** Published Books 463

*** Common Coding Gotchas 463
*** Chapter Summary 465
*** Test Your Knowledge: Quiz 466
*** Test Your Knowledge: Answers 466
*** Test Your Knowledge: Part III Exercises 467

* Part IV. Functions and Generators
** 16 Function Basics - 473
*** Why Use Functions? 474
*** Coding Functions 475
**** def Statements 476
**** def Executes at Runtime 477

*** A First Example: Definitions and Calls 478
**** Definition 478
**** Calls 478
**** Polymorphism in Python 479

*** A Second Example: Intersecting Sequences 480
**** Definition 481
**** Calls 481
**** Polymorphism Revisited 482
**** Local Variables 483

*** Chapter Summary 483
*** Test Your Knowledge: Quiz 483
*** Test Your Knowledge: Answers 484

** 17 Scopes - 485
*** Python Scope Basics 485
**** Scope Details 486
**** Name Resolution: The LEGB Rule 488
**** Scope Example 490
**** The Built-in Scope 491

*** The global Statement 494
**** Program Design: Minimize Global Variables 495
**** Program Design: Minimize Cross-File Changes 497
**** Other Ways to Access Globals 498

*** Scopes and Nested Functions 499
**** Nested Scope Details 500
**** Nested Scope Examples 500
**** Factory Functions: Closures 501
**** Retaining Enclosing Scope State with Defaults 504

*** The nonlocal Statement in 3.X 508
**** nonlocal Basics 508
**** nonlocal in Action 509

*** Why nonlocal? State Retention Options 512
**** State with nonlocal: 3.X only 512
**** State with Globals: A Single Copy Only 513
**** State with Classes: Explicit Attributes (Preview) 513
**** State with Function Attributes: 3.X and 2.X 515

*** Chapter Summary 519
*** Test Your Knowledge: Quiz 519
*** Test Your Knowledge: Answers 520

** 18 Arguments - 523
*** Argument-Passing Basics 523
**** Arguments and Shared References 524
**** Avoiding Mutable Argument Changes 526
**** Simulating Output Parameters and Multiple Results 527

*** Special Argument-Matching Modes 528
**** Argument Matching Basics 529
**** Argument Matching Syntax 530
**** The Gritty Details 531
**** Keyword and Default Examples 532
**** Arbitrary Arguments Examples 534
**** Python 3.X Keyword-Only Arguments 539

*** The min Wakeup Call! 542
**** Full Credit 542
**** Bonus Points 544
**** The Punch Line... 544

*** Generalized Set Functions 545
*** Emulating the Python 3.X print Function 547
**** Using Keyword-Only Arguments 548

*** Chapter Summary 550
*** Test Your Knowledge: Quiz 551
*** Test Your Knowledge: Answers 552

** 19 Advanced Function Topics - 553
*** Function Design Concepts 553
*** Recursive Functions 555
**** Summation with Recursion 555
**** Coding Alternatives 556
**** Loop Statements Versus Recursion 557
**** Handling Arbitrary Structures 558

*** Function Objects: Attributes and Annotations 562
**** Indirect Function Calls: “First Class” Objects 562
**** Function Introspection 563
**** Function Attributes 564
**** Function Annotations in 3.X 565

*** Anonymous Functions: lambda 567
**** lambda Basics 568
**** Why Use lambda? 569
**** How (Not) to Obfuscate Your Python Code 571
**** Scopes: lambdas Can Be Nested Too 572

*** Functional Programming Tools 574
**** Mapping Functions over Iterables: map 574
**** Selecting Items in Iterables: filter 576
**** Combining Items in Iterables: reduce 576

*** Chapter Summary 578
*** Test Your Knowledge: Quiz 578
*** Test Your Knowledge: Answers 578

** 20 Comprehensions and Generations - 581
*** List Comprehensions and Functional Tools 581
**** List Comprehensions Versus map 582
**** Adding Tests and Nested Loops: filter 583
**** Example: List Comprehensions and Matrixes 586
**** Don’t Abuse List Comprehensions: KISS 588

*** Generator Functions and Expressions 591
**** Generator Functions: yield Versus return 592
**** Generator Expressions: Iterables Meet Comprehensions 597
**** Generator Functions Versus Generator Expressions 602
**** Generators Are Single-Iteration Objects 604
**** Generation in Built-in Types, Tools, and Classes 606
**** Example: Generating Scrambled Sequences 609
**** Don’t Abuse Generators: EIBTI 614
**** Example: Emulating zip and map with Iteration Tools 617

*** Comprehension Syntax Summary 622
**** Scopes and Comprehension Variables 623
**** Comprehending Set and Dictionary Comprehensions 624
**** Extended Comprehension Syntax for Sets and Dictionaries 625

*** Chapter Summary 626
*** Test Your Knowledge: Quiz 626
*** Test Your Knowledge: Answers 626

** 21 The Benchmarking Interlude - 629
*** Timing Iteration Alternatives 629
**** Timing Module: Homegrown 630
**** Timing Script 634
**** Timing Results 635
**** Timing Module Alternatives 638
**** Other Suggestions 642

*** Timing Iterations and Pythons with timeit 642
**** Basic timeit Usage 643
**** Benchmark Module and Script: timeit 647
**** Benchmark Script Results 649
**** More Fun with Benchmarks 651

*** Other Benchmarking Topics: pystones 656
*** Function Gotchas 656
**** Local Names Are Detected Statically 657
**** Defaults and Mutable Objects 658
**** Functions Without returns 660
**** Miscellaneous Function Gotchas 661

*** Chapter Summary 661
*** Test Your Knowledge: Quiz 662
*** Test Your Knowledge: Answers 662
*** Test Your Knowledge: Part IV Exercises 663

* Part V. Modules and Packages
** 22. Modules: The Big Picture - 669
*** Why Use Modules? - 669
*** Python Program Architecture 670
**** How to Structure a Program 671
**** Imports and Attributes 671
**** Standard Library Modules 673

*** How Imports Work 674
**** 1. Find It 674
**** 2. Compile It (Maybe) 675
**** 3. Run It 675

*** Byte Code Files: ~__pycache__~ in Python 3.2+ 676
**** Byte Code File Models in Action 677

*** The Module Search Path 678
**** Configuring the Search Path 681
**** Search Path Variations 681
**** The sys.path List 681
**** Module File Selection 682

*** Chapter Summary 685
*** Test Your Knowledge: Quiz 685
*** Test Your Knowledge: Answers 685

** 23. Module Coding Basics - 687
*** Module Creation 687
**** Module Filenames 687
**** Other Kinds of Modules 688

*** Module Usage 688
**** The import Statement 689
**** The from Statement 689
**** The from * Statement 689
**** Imports Happen Only Once 690
**** import and from Are Assignments 691
**** import and from Equivalence 692
**** Potential Pitfalls of the from Statement 693

*** Module Namespaces 694
**** Files Generate Namespaces 695
**** Namespace Dictionaries: ~__dict__~ 696
**** Attribute Name Qualification 697
**** Imports Versus Scopes 698
**** Namespace Nesting 699

*** Reloading Modules 700
**** reload Basics 701
**** reload Example 702

*** Chapter Summary 703
*** Test Your Knowledge: Quiz 704
*** Test Your Knowledge: Answers 704

** 24. Module Packages - 707
*** Package Import Basics 708
**** Packages and Search Path Settings 708
**** Package =__init__.py= Files 709

*** Package Import Example 711
**** from Versus import with Packages 713

*** Why Use Package Imports? 713
**** A Tale of Three Systems 714

*** Package Relative Imports 717
**** Changes in Python 3.X 718
**** Relative Import Basics 718
**** Why Relative Imports? 720
**** The Scope of Relative Imports 722
**** Module Lookup Rules Summary 723
**** Relative Imports in Action 723
**** Pitfalls of Package-Relative Imports: Mixed Use 729

*** Python 3.3 Namespace Packages 734
**** Namespace Package Semantics 735
**** Impacts on Regular Packages: Optional =__init__.py= 736
**** Namespace Packages in Action 737
**** Namespace Package Nesting 738
**** Files Still Have Precedence over Directories 740

*** Chapter Summary 742
*** Test Your Knowledge: Quiz 742
*** Test Your Knowledge: Answers 742

** 25. Advanced Module Topics - 745
*** Module Design Concepts 745
*** Data Hiding in Modules 747
**** Minimizing from * Damage: ~_X~ and ~__all__~ 747

*** Enabling Future Language Features: ~__future_~ 748
*** Mixed Usage Modes: ~__name__~ and ~__main__~ 749
**** Unit Tests with ~__name__~ 750

*** Example: Dual Mode Code 751
**** Currency Symbols: Unicode in Action 754
**** Docstrings: Module Documentation at Work 756

*** Changing the Module Search Path 756
*** The as Extension for import and from 758
*** Example: Modules Are Objects 759
*** Importing Modules by Name String 761
**** Running Code Strings 762
**** Direct Calls: Two Options 762

*** Example: Transitive Module Reloads 763
**** A Recursive Reloader 764
**** Alternative Codings 767

*** Module Gotchas 770
**** Module Name Clashes: Package and Package-Relative Imports 771
**** Statement Order Matters in Top-Level Code 771
**** from Copies Names but Doesn’t Link 772
**** from * Can Obscure the Meaning of Variables 773
**** reload May Not Impact from Imports 773
**** reload, from, and Interactive Testing 774
**** Recursive from Imports May Not Work 775

*** Chapter Summary 776
*** Test Your Knowledge: Quiz 777
*** Test Your Knowledge: Answers 777
*** Test Your Knowledge: Part V Exercises 778

* Part VI. Classes and OOP
** 26. OOP: The Big Picture - 783
*** Why Use Classes? 784
*** OOP from 30,000 Feet 785
**** Attribute Inheritance Search 785
**** Classes and Instances 788
**** Method Calls 788
**** Coding Class Trees 789
**** Operator Overloading 791
**** OOP Is About Code Reuse 792

*** Chapter Summary 795
*** Test Your Knowledge: Quiz 795
*** Test Your Knowledge: Answers 795

** 27. Class Coding Basics - 797
*** Classes Generate Multiple Instance Objects 797
**** Class Objects Provide Default Behavior 798
**** Instance Objects Are Concrete Items 798
**** A First Example 799

*** Classes Are Customized by Inheritance 801
**** A Second Example 802
**** Classes Are Attributes in Modules 804

*** Classes Can Intercept Python Operators 805
**** A Third Example 806
**** Why Use Operator Overloading? 808

*** The World’s Simplest Python Class 809
**** Records Revisited: Classes Versus Dictionaries 812

*** Chapter Summary 814
*** Test Your Knowledge: Quiz 815
*** Test Your Knowledge: Answers 815

** 28. A More Realistic Example - 817
*** Step 1: Making Instances 818
**** Coding Constructors 818
**** Testing As You Go 819
**** Using Code Two Ways 820

*** Step 2: Adding Behavior Methods 822
**** Coding Methods 824

*** Step 3: Operator Overloading 826
**** Providing Print Displays 826

*** Step 4: Customizing Behavior by Subclassing 828
**** Coding Subclasses 828
**** Augmenting Methods: The Bad Way 829
**** Augmenting Methods: The Good Way 829
**** Polymorphism in Action 832
**** Inherit, Customize, and Extend 833
**** OOP: The Big Idea 833

*** Step 5: Customizing Constructors, Too 834
**** OOP Is Simpler Than You May Think 836
**** Other Ways to Combine Classes 836

*** Step 6: Using Introspection Tools 840
**** Special Class Attributes 840
**** A Generic Display Tool 842
**** Instance Versus Class Attributes 843
**** Name Considerations in Tool Classes 844
**** Our Classes’ Final Form 845

*** Step 7 (Final): Storing Objects in a Database 847
**** Pickles and Shelves 847
**** Storing Objects on a Shelve Database 848
**** Exploring Shelves Interactively 849
**** Updating Objects on a Shelve 851

*** Future Directions 853
*** Chapter Summary 855
*** Test Your Knowledge: Quiz 855
*** Test Your Knowledge: Answers 856

** 29. Class Coding Details - 859
*** The class Statement 859
**** General Form 860
**** Example 860

*** Methods 862
**** Method Example 863
**** Calling Superclass Constructors 864
**** Other Method Call Possibilities 864

*** Inheritance 865
**** Attribute Tree Construction 865
**** Specializing Inherited Methods 866
**** Class Interface Techniques 867
**** Abstract Superclasses 869

*** Namespaces: The Conclusion 872
**** Simple Names: Global Unless Assigned 872
**** Attribute Names: Object Namespaces 872
**** The “Zen” of Namespaces: Assignments Classify Names 873
**** Nested Classes: The LEGB Scopes Rule Revisited 875
**** Namespace Dictionaries: Review 878
**** Namespace Links: A Tree Climber 880

*** Documentation Strings Revisited 882
*** Classes Versus Modules 884
*** Chapter Summary 884
*** Test Your Knowledge: Quiz 884
*** Test Your Knowledge: Answers 885

** TODO 30. Operator Overloading - 887
*** The Basics - 887
**** Constructors and Expressions: =__init__= and =__sub__= - 888
**** Common Operator Overloading Methods - 888

*** Indexing and Slicing: ~__getitem__~ and ~__setitem__~ - 890
**** Intercepting Slices - 891
**** Slicing and Indexing in Python 2.X - 893
**** But 3.X’s ~__index__~ Is Not Indexing! - 894

*** Index Iteration: ~__getitem__~ - 894
*** Iterable Objects: ~__iter__~ and ~__next__~ - 895
**** User-Defined Iterables - 896
**** Multiple Iterators on One Object - 899
**** Coding Alternative: ~__iter__~ plus yield - 902

*** Membership: ~__contains__~, ~__iter__~, and ~__getitem__~ - 906
*** Attribute Access: ~__getattr__~ and ~__setattr__~ - 909
**** Attribute Reference - 909
**** Attribute Assignment and Deletion - 910
**** Other Attribute Management Tools - 912
**** Emulating Privacy for Instance Attributes: Part 1 - 912

*** DONE String Representation: ~__repr__~ and ~__str__~ - 913
    CLOSED: [2020-11-04 Wed 02:00]
    As we've learned, the _DEFAULT display_ of /instance objects/ for a /class/
    like this is _NEITHER generally useful_ _NOR aesthetically pretty_:

**** DONE Why Two Display Methods? - 914
     CLOSED: [2020-11-04 Wed 01:37]
     - Python provides _TWO_ /display methods/ to support alternative displays *for
       DIFFERENT audiences*:
       1. ~__str__~
          + The *first choice* of (~__repr__~ is the fallback)
            * the ~print~ function
            * the built-in ~str~ function (the internal equivalent of which ~print~ runs)

          + It generally should return a *user-friendly display*.

       2. ~__repr__~
          + *Be used in ALL OTHER contexts*:
            * for interactive echoes,
            * the built-in ~repr~ function,
            * nested appearances,
            * by ~print~ and ~str~ *if NO* ~__str__~ is present.

          + It should generally return an *as-code string* that
            * could be used to *re-create the object*,
              OR
            * a *detailed display for developers*.
     
     - ~__repr__~ is the fallback of ~__str__~,
       and the INVERSE is *NOT* true.

     - That is, ~__repr__~ is used *EVERYWHERE*,
       *EXCEPT* by ~print~ and ~str~ when a ~__str__~ is defined.

     - _If you code either, the other is available for an additional display_:
       + As noted in Chapter 28, 
         (In practice) general tools may also *prefer* ~__str__~ to leave other
         /classes/ the option of adding an alternative ~__repr__~ display for use in
         other contexts, as long as ~print~ and ~str~ displays suffice for the tool.
       
       + Conversely, a general tool that codes a ~__repr__~ still leaves clients the
         option of adding alternative displays with a ~__str__~ for ~print~ and ~str~.

     - Because of this, ~__repr__~ may be best if you want a single display for
       all contexts. 
       
     - Example:
       #+begin_src python
         class addboth(adder):
             def __str__(self):  # User-friendly string
                 return f"[Value: {self.data}]"

             def __repr__(self):  # As-code string
                 return f"addboth({self.data})"


         x = addboth(4)
         x + 1

         x
         # addboth(5)

         print(x)
         # [Value: 5]

         str(x), repr(x)
         # ('[Value: 5]', 'addboth(5)')
       #+end_src
     
**** DONE Display Usage Notes - 916
     CLOSED: [2020-11-04 Wed 01:59]
     - Though generally simple to use, there are
       _THREE usage notes_ regarding these methods here:

       1. ~__str__~ and ~__repr__~ *must* both return /strings/;
          other result types are not converted and raise errors,
          + so be sure to run them through a _to-string converter_
            if the the initial value you construct is not a string.

       2. Depending on a container's string-conversion logic,
          #+begin_src python
            class Printer:
                def __init__(self, val):
                    self.val = val

                def __str__(self):
                    return str(self.val)

            objs = [Printer(2), Printer(3)]
            for x in objs:
                print(x)
            # 2
            # 3

            print(objs)
            # [<__main__.Printer object at 0x000000000297AB38>, <__main__.Printer obj...etc...>]

            objs
            # [<__main__.Printer object at 0x000000000297AB38>, <__main__.Printer obj...etc...>]
          #+end_src
          + the ~__str__~ might ONLY apply
            when /objects/ appear *at the top level* of a print operation;

          + _objects nested in larger objects_ might still print with their ~__repr__~
            or its default. The following illustrates both of these points:

          + To ensure that a custom display is run in all contexts regardless of the
            container, code ~__repr__~, *not* ~__str__~:
            #+begin_src python
              class Printer:
                  def __init__(self, val):
                      self.val = val

                  def __repr__(self):       # `__repr__` used by print if no `__str__`
                      return str(self.val)  # `__repr__` used if echoed or nested


              objs = [Printer(2), Printer(3)]
              for x in objs:
                  print(x)  # No `__str__`; runs `__repr__`
              # 2
              # 3


              print(objs)  # Runs `__repr__`, not `__str__`
              # [2, 3]

              objs
              # [2, 3]
            #+end_src

       3. *CAUTION* (perhaps *most SUBTLE*):
          *the /display methods/ also have the potential to trigger infinite recursion
          loops in rare contexts* -- because some objects' displays include displays
          of other objects, it's not impossible that a display may trigger a display
          of an object being displayed, and thus loop. This is rare and obscure enough
          to skip here, but watch for an example of this looping potential to
          appear for these methods in a note near the end of the next chapter in
          its =listinherited.py= example’s class, where ~__repr__~ can loop.
          =TODO= =TODO= =TODO= =TODO= =TODO= =TODO= =TODO=

     - Summary:
       In practice,
       + ~__str__~, and its more inclusive relative ~__repr__~, seem to be the second
         most commonly used operator overloading methods in Python scripts, behind
         ~__init__~.
       
       + For additional examples of these tools at work and the design tradeoffs
         they imply, see
         * Chapter 28’s case study,

         * Chapter 31’s class lister mix-ins,

         * their role in Chapter 35’s exception classes,
           where ~__str__~ is required over ~__repr__~.
     
*** Right-Side and In-Place Uses: ~__radd__~ and ~__iadd__~ - 917
**** Right-Side Addition 917
**** In-Place Addition 920

*** TODO Call Expressions: ~__call__~ - 921
**** Function Interfaces and Callback-Based Code - 923

*** TODO Comparisons: ~__lt__~, ~__gt__~, and Others - 925
**** The ~__cmp__~ Method in Python 2.X - 926

*** Boolean Tests: ~__bool__~ and ~__len__~ - 927
**** Boolean Methods in Python 2.X 928

*** Object Destruction: ~__del__~ - 929
**** Destructor Usage Notes 930

*** Chapter Summary - 931
*** Test Your Knowledge: Quiz - 931
*** Test Your Knowledge: Answers - 931

** 31. Designing with Classes - 933
*** Python and OOP 933
**** Polymorphism Means Interfaces, Not Call Signatures 934

*** OOP and Inheritance: “Is-a” Relationships 935
*** OOP and Composition: “Has-a” Relationships 937
**** Stream Processors Revisited 938

*** OOP and Delegation: “Wrapper” Proxy Objects 942
*** Pseudoprivate Class Attributes 944
**** Name Mangling Overview 945
**** Why Use Pseudoprivate Attributes? 945

*** Methods Are Objects: Bound or Unbound 948
**** Unbound Methods Are Functions in 3.X 950
**** Bound Methods and Other Callable Objects 951

*** Classes Are Objects: Generic Object Factories 954
**** Why Factories? 955

*** Multiple Inheritance: “Mix-in” Classes 956
**** Coding Mix-in Display Classes 957

*** Other Design-Related Topics 977
*** Chapter Summary 977
*** Test Your Knowledge: Quiz 978
*** Test Your Knowledge: Answers 978

** 32. Advanced Class Topics - 979
*** Extending Built-in Types 980
**** Extending Types by Embedding 980
**** Extending Types by Subclassing 981

*** The “New Style” Class Model 983
**** Just How New Is New-Style? 984

*** New-Style Class Changes 985
**** Attribute Fetch for Built-ins Skips Instances 987
**** Type Model Changes 992
**** All Classes Derive from “object” 995
**** Diamond Inheritance Change 997
**** More on the MRO: Method Resolution Order 1001
**** Example: Mapping Attributes to Inheritance Sources 1004

*** New-Style Class Extensions 1010
**** Slots: Attribute Declarations 1010
**** Properties: Attribute Accessors 1020
**** ~__getattribute__~ and Descriptors: Attribute Tools 1023
**** Other Class Changes and Extensions 1023

*** Static and Class Methods 1024
**** Why the Special Methods? 1024
**** Static Methods in 2.X and 3.X 1025
**** Static Method Alternatives 1027
**** Using Static and Class Methods 1028
**** Counting Instances with Static Methods 1030
**** Counting Instances with Class Methods 1031

*** Decorators and Metaclasses: Part 1 1034
**** Function Decorator Basics 1035
**** A First Look at User-Defined Function Decorators 1037
**** A First Look at Class Decorators and Metaclasses 1038
**** For More Details 1040

*** The super Built-in Function: For Better or Worse? 1041
**** The Great super Debate 1041
**** Traditional Superclass Call Form: Portable, General 1042
**** Basic super Usage and Its Tradeoffs 1043
**** The super Upsides: Tree Changes and Dispatch 1049
**** Runtime Class Changes and super 1049
**** Cooperative Multiple Inheritance Method Dispatch 1050
**** The super Summary 1062

*** Class Gotchas 1064
**** Changing Class Attributes Can Have Side Effects 1064
**** Changing Mutable Class Attributes Can Have Side Effects, Too 1065
**** Multiple Inheritance: Order Matters 1066
**** Scopes in Methods and Classes 1068
**** Miscellaneous Class Gotchas 1069
**** KISS Revisited: “Overwrapping-itis” 1070

*** Chapter Summary 1070
*** Test Your Knowledge: Quiz 1071
*** Test Your Knowledge: Answers 1071
*** Test Your Knowledge: Part VI Exercises 1072
    
* Part VII. Exceptions and Tools
** 33. Exception Basics - 1081
*** Why Use Exceptions? - 1081
**** Exception Roles - 1082

*** Exceptions: The Short Story - 1083
**** Default Exception Handler - 1083
**** Catching Exceptions - 1084
**** Raising Exceptions - 1085
**** User-Defined Exceptions - 1086
**** Termination Actions - 1087

*** Chapter Summary - 1089
*** Test Your Knowledge: Quiz - 1090
*** Test Your Knowledge: Answers - 1090

** 34. Exception Coding Details - 1093
*** The ~try~ / ~except~ / ~else~ Statement - 1093
**** How ~try~ Statements Work - 1094
**** try Statement Clauses - 1095
**** The try else Clause - 1098
**** Example: Default Behavior - 1098
**** Example: Catching Built-in Exceptions - 1100

*** The ~try~ / ~finally~ Statement - 1100
**** Example: Coding Termination Actions with ~try~ / ~finally~ - 1101

*** Unified ~try~ / ~except~ / ~finally~ - 1102
**** Unified ~try~ Statement Syntax - 1104
**** Combining ~finally~ and ~except~ by Nesting - 1104
**** Unified ~try~ Example - 1105

*** The ~raise~ Statement - 1106
**** Raising Exceptions - 1107
**** Scopes and ~try~ ~except~ Variables - 1108
**** Propagating Exceptions with ~raise~ - 1110
**** Python 3.X Exception Chaining: ~raise from~ - 1110

*** The ~assert~ Statement - 1112
**** Example: Trapping Constraints (but Not Errors!) - 1113

*** ~with~ / ~as~ Context Managers - 1114
**** Basic Usage - 1114
**** The Context Management Protocol - 1116
**** Multiple Context Managers in 3.1, 2.7, and Later - 1118

*** Chapter Summary - 1119
*** Test Your Knowledge: Quiz - 1120
*** Test Your Knowledge: Answers - 1120

** 35. Exception Objects - 1123
*** Exceptions: Back to the Future 1124
**** String Exceptions Are Right Out! 1124
**** Class-Based Exceptions 1125
**** Coding Exceptions Classes 1126

*** Why Exception Hierarchies? 1128
*** Built-in Exception Classes 1131
**** Built-in Exception Categories 1132
**** Default Printing and State 1133

*** Custom Print Displays 1135
*** Custom Data and Behavior 1136
**** Providing Exception Details 1136
**** Providing Exception Methods 1137

*** Chapter Summary 1139
*** Test Your Knowledge: Quiz 1139
*** Test Your Knowledge: Answers 1139

** 36. Designing with Exceptions - 1141
*** Nesting Exception Handlers 1141
**** Example: Control-Flow Nesting 1143
**** Example: Syntactic Nesting 1143

*** Exception Idioms 1145
**** Breaking Out of Multiple Nested Loops: “go to” 1145
**** Exceptions Aren’t Always Errors 1146
**** Functions Can Signal Conditions with raise 1147
**** Closing Files and Server Connections 1148
**** Debugging with Outer try Statements 1149
**** Running In-Process Tests 1149
**** More on ~sys.exc_info~ 1150
**** Displaying Errors and Tracebacks 1151

*** Exception Design Tips and Gotchas 1152
**** What Should Be Wrapped 1152
**** Catching Too Much: Avoid Empty except and Exception 1153
**** Catching Too Little: Use Class-Based Categories 1155

*** Core Language Summary 1155
**** The Python Toolset 1156
**** Development Tools for Larger Projects 1157

*** Chapter Summary 1160
*** Test Your Knowledge: Quiz 1161
*** Test Your Knowledge: Answers 1161
*** Test Your Knowledge: Part VII Exercises 1161

* Part VIII. Advanced Topics
** 37. Unicode and Byte Strings - 1165
*** String Changes in 3.X 1166
*** String Basics 1167
**** Character Encoding Schemes 1167
**** How Python Stores Strings in Memory 1170
**** Python’s String Types 1171
**** Text and Binary Files 1173

*** Coding Basic Strings 1174
**** Python 3.X String Literals 1175
**** Python 2.X String Literals 1176
**** String Type Conversions 1177

*** Coding Unicode Strings 1178
**** Coding ASCII Text 1178
**** Coding Non-ASCII Text 1179
**** Encoding and Decoding Non-ASCII text 1180
**** Other Encoding Schemes 1181
**** Byte String Literals: Encoded Text 1183
**** Converting Encodings 1184
**** Coding Unicode Strings in Python 2.X 1185
**** Source File Character Set Encoding Declarations 1187

*** Using 3.X bytes Objects 1189
**** Method Calls 1189
**** Sequence Operations 1190
**** Other Ways to Make bytes Objects 1191
**** Mixing String Types 1192

*** Using 3.X/2.6+ bytearray Objects 1192
**** bytearrays in Action 1193
**** Python 3.X String Types Summary 1195

*** Using Text and Binary Files 1195
**** Text File Basics 1196
**** Text and Binary Modes in 2.X and 3.X 1197
**** Type and Content Mismatches in 3.X 1198

*** Using Unicode Files 1199
**** Reading and Writing Unicode in 3.X 1199
**** Handling the BOM in 3.X 1201
**** Unicode Files in 2.X 1204
**** Unicode Filenames and Streams 1205

*** Other String Tool Changes in 3.X 1206
**** The re Pattern-Matching Module 1206
**** The struct Binary Data Module 1207
**** The pickle Object Serialization Module 1209
**** XML Parsing Tools 1211

*** Chapter Summary 1215
*** Test Your Knowledge: Quiz 1215
*** Test Your Knowledge: Answers 1216

** TODO 38. Managed Attributes - 1219
   - attribute interception :: TODO

   - For tools builders, _managing attribute access_ can be an important part of
     flexible APIs.

   - =TODO= Moreover, an understanding of the /descriptor model/ covered here can
     make related tools such as /slots/ and /properties/ more tangible.

*** DONE Why Manage Attributes? - 1219
    CLOSED: [2020-10-28 Wed 21:20]
    - Q :: Why do we need to manage attributes?

    - A :: Explain this with an example:
           Suppose we have an attribute ~name~ for a project ~person~ of the class
           ~Person~.
      1. First, we access the attribute directly, which is natural with the first
         glance: ~person.name~ and ~person.name = value~

      2. Later, you want to add some logic to this attribute, for example:
         do something when set or mutate it, or provide a default value when no
         valid value ("uninitialized" is a common cause, though not the only one)
         #+BEGIN_SRC python
           class Person:
               def getName(self):
                   if not valid():
                       raise TypeError('cannot fetch name')
                   else:
                       return self.name.transform()

               def setName(self, value):
                   if not valid(value):
                       raise TypeError('cannot change name')
                   else:
                       self.name = transform(value)

           person = Person()
           person.getName()
           person.setName('value')
         #+END_SRC

       From 1 to 2, there is an API change, which is NOT what we want.
       
    - Conclusion ::
      + If you begin with a /method-based interface/ to data, clients are immune to
        changes;
      + if you do NOT, they can become *PROBLEMATIC*.
        =from Jian=
        * As an end client, not use /method-based interface/ is not a big problem,
          though you may need to change your code when you change some API in the
          future, at least this won't affect other people.
          - Don't forget how hard to refactor a dynamic programming language code!
            With type info, the IDE can't help you much. Even if keep using /type
            hints/ in Python 3.5+ and you do type well (this means theoretically
            your type hints is enough for type checker to infer all required
            info), since the Python type-checkers now (2020) is not strong enough, 
            you still can make mistakes when refactoring with the help of
            type-checker equiped IDE/LSP.

        * As a tool maker, _change API_ can be a *disaster* to end clients.

**** DONE Inserting Code to Run on Attribute Access - 1220 =RE-READ=
     CLOSED: [2020-10-28 Wed 22:16]
     - /attribute accessor/ method can help fix the API even in the future in
       most cases.

     - This chapter presents _FOUR_ accessor techniques:
       + The ~__getattr__~ and ~__setattr__~ /methods/, for *routing*
         _undefined attribute fetches_ and _all attribute assignments_ *to*
         /generic handler methods/.

       + The ~__getattribute__~ /method/, for
         *routing* _all attribute fetches_
         *to* a /generic handler method/.

       + The ~property~ /built-in/, for
         *routing* _specific attribute access_
         *to* /GET and SET handler functions/.

       + The /descriptor protocol/, for
         *routing* _specific attribute accesses_
         *to* /instances of classes with *arbitrary* GET and SET handler
         methods/, and the basis for other tools such as /properties/ and
         /slots/. =TODO= =TODO= =TODO=

     - _VERSIONS_: =IMPORTANT=
       + The tools in the _FIRST_ of these above bullets are available in _ALL_
         Pythons.

       + The last _THREE_ bullets' tools are available
         * in Python _3.X_ and _new-style classes_ in 2.2+ --
           - they _first appeared_ in Python 2.2, along with many of the other
             advanced tools of Chapter 32 such as /slots/ and /super/.
             =TODO= =TODO= =TODO= Chapter 32

       + We briefly met the _FIRST_ and _THIRD_ of these in Chapter 30 and Chapter
         32, respectively;
         the _SECOND_ and _FOURTH_ are largely new topics we'll explore in full
         here. =TODO=

     - Four methods do differ in some imporant ways. =TODO=
       For example,
       + the _LAST TWO_ techniques listed here apply to /SPECIFIC attributes/,

       + the _FIRST TWO_ are *GENERIC* enough to be used by /delegation-based
         proxy classes/ that *MUST route* ARBITRARY attributes *to* wrapped
         objects.

       + _We'll see_ all four schemes also differ in BOTH _complexity_ and
         _aesthetics_, in ways you must see in action to judge for yourself.

*** DONE Properties - 1221
    CLOSED: [2020-10-28 Wed 22:43]
    - The /property protocol/ allows us to:
      + *route* a specific attribute's ~get~, ~set~, and ~delete~ operations
        *to* /functions/ or /methods/ we provide

      + ENABLING us to insert code to be _run AUTOMATICALLY_ *on* /attribute access/

      + INTERCEPT /attribute deletions/

      + PROVIDE /documentation/ for the attributes if desired

    - Properties are created with the ~property~ /built-in/ and are assigned to
      /class attributes/, just LIKE /method functions/.

    - *A* /property/ manages *a* _SINGLE_, _SPECIFIC_ /attribute/; =IMPORTANT=
      It allows us to control BOTH /fetch/ and /assignment/ freely, without
      breaking existing code.

    - As we'll see, properties are strongly related to /descriptors/;
      in fact, they are essentially a restricted form of them.
      =IMPORANT=
      =TODO=

**** DONE The Basics - 1222
     CLOSED: [2020-10-28 Wed 22:25]
     A /property/ is created by assigning the result of a /built-in function/ to
     a /class attribute/
     #+begin_src python
       attribute = property(fget, fset, fdel, doc)
     #+end_src
     - *None* of this built-in's arguments *are required*, and
       ALL _DEFAULT to_ ~None~.

     - Suppose you didn't set ~fget~, and then when you call it,
       it will ~raise~ an ~AttributeError~.

     - =TODO= =IMPORTANT=
       Technically, all three of the first three arguments accept *any* /callable/,
       including
       + a /class's method/, having a first argument to receive the instance being
         qualified.
         =TODO= give a NOT method example.

     - This /built-in/ ~property~ call *returns* a /property object/, which we
       assign to the name of the /attribute/ to be managed _in the class scope_,
       where it *will be inherited by* EVERY /instance/.

**** DONE A First Example - 1222
     CLOSED: [2020-10-28 Wed 22:27]
     A trivial, which only is used to illustrate how does a /property/ works.
     #+BEGIN_SRC python
       class Person:                            # Add (object) in 2.X
           def __init__(self, name):
               self._name = name

           def getName(self):
               print('fetch...')
               return self._name

           def setName(self, value):
               print('change...')
               self._name = value

           def delName(self):
               print('remove...')
               del self._name

           name = property(getName, setName, delName, "name property docs")

       bob = Person('Bob Smith')                # bob has a managed attribute
       print(bob.name)                          # Runs getName
       bob.name = 'Robert Smith'                # Runs setName
       print(bob.name)
       del bob.name                             # Runs delName

       print('-'*20)

       sue = Person('Sue Jones')                # sue inherits property too
       print(sue.name)
       print(Person.name.__doc__)               # Or help(Person.name)
     #+END_SRC

     - Store data into ~self._name~ so it *does NOT clash* with the  ~name~
       /property/.

     - Like all /class attributes/, /properties/ are inherited by its /subclasses/.
       + Here is a example whoes behavior is the same as the example code above:
         #+begin_src python
           class Super:
               # ... the original `Person` class code ...
               name = property(getName, setName, delName, 'name property docs')

           class Person(Super):
               pass
         #+end_src

**** DONE Computed Attributes - 1224
     CLOSED: [2020-10-28 Wed 22:37]
     #+BEGIN_SRC python
       class PropSquare:                     # Add (object) in 2.X
           def __init__(self, start):
               self.value = start

           def getX(self):
               return self.value ** 2

           def setX(self, value):
               self.value = value

           x = property(getX, setX)

       p = PropSquare(3)
       q = PropSquare(32)

       print(p.x)    # 3**2
       p.X = 4
       print(p.x)    # 4**2
       print(q.x)    # 32 ** 2
     #+END_SRC

     - The ~property~ methods automatically receive a ~self~ argument, they have
       access to the state information stored in /instances/.
       
**** DONE Coding Properties with Decorators - 1224
     CLOSED: [2020-10-28 Wed 22:43]
     The ~property~ built-in can serve as a /decorator/.
     #+BEGIN_SRC python
       class Person:
           @property
           def name(self): ...

       # is the same as

       class Person:
           def name(self): ...
           name = property(name)
     #+END_SRC

***** DONE Setter and deleter decorators
      CLOSED: [2020-10-28 Wed 22:42]
      - As of Python 2.6 and 3.0,
        /property/ objects also have ~getter~, ~setter~, and ~deleter~ /methods/
        that
        + *assign* the corresponding /property accessor methods/ and
        + *return* a copy of the /property/ itself.
      
      #+BEGIN_SRC python
        class Person:
            def __init__(self, name):
            self._name = name

            @property
            def name(self): # name = property(name)
                "name property docs"
                print('fetch...')
                return self._name

            @name.setter
            def name(self, value):   # name = name.setter(name)
                print('change...')
                self._name = value

            @name.deleter
            def name(self):    # name = name.deleter(name)
                print('remove...')
                del self._name

        bob = Person('Bob Smith')  # bob has a managed attribute
        print(bob.name)            # Runs name getter (name 1)
        bob.name = 'Robert Smith'  # Runs name setter (name 2)
        print(bob.name)
        del bob.name               # Runs name deleter (name 3)

        print('-'*20)

        sue = Person('Sue Jones')  # sue inherits property too
        print(sue.name)
        print(Person.name.__doc__) # Or help(Person.name)
      #+END_SRC

*** TODO Descriptors - 1226
    /descriptors/ provide an _alternative_ way to *intercept* /attribute access/;
    they are _STRONGLY RELATED TO_ the /properties/ discussed in the prior section.
    
    - A /property/ is a kind of /descriptor/.

    - /Descriptors/ are the _underlying implementation mechanism_ for a variety
      of class tools, including both:
      + /properties/
      + /slots/
      + etc.

    - Functionally speaking, the descriptor protocol allows us to route a specific
      attribute’s get, set, and delete operations to methods of a separate
      class’s instance object that we provide. This allows us to insert code to
      be run automatically on attribute fetches and assignments, intercept
      attribute deletions, and provide documentation for the attributes if
      desired.
      =TODO= =TODO= =TODO=

    - /Descriptors/:
      + They are created as *INDEPENDENT* /classes/, and
        they *are assigned to* /class attributes/ just like /method functions/.

      + Like any other /class attribute/, they are *inherited by* /subclasses/ and
        /instances/.

      + Their /access-interception methods/ are provided with BOTH
        * a ~self~ for the /descriptor instance/ ITSELF, as well as
        * the /instance/ of the /client class/ whose /attribute/ *references* the
          /descriptor object/.

      Because of this,
      they can *retain* and *use* state information of their own,
      as well as /state/ information of the subject /instance/.
      
        For example, a /descriptor/ may call /methods/ *available* in the /client
      class/, as well as /descriptor specific methods/ *it defines*.
      
**** DONE The Basics - 1227
     CLOSED: [2020-10-29 Thu 00:39]
     /descriptors/ are coded as *separate* /classes/ and provide *specially named*
     /accessor methods/ for the /attribute access operations/ they wish to _INTERCEPT_
     -- *get*, *set*, and *deletion* methods in the /descriptor class/ are
     AUTOMATICALLY run when the attribute assigned to the /descriptor class
     instance/ is accessed in the corresponding way:
     #+begin_src python
       class Descriptor:
           "docstring goes here"
           def __get__(self, instance, owner): ...  # Return attr value
           def __set__(self, instance, value): ...  # Return nothing (None)
           def __delete__(self, instance): ...      # Return nothing (None)
     #+end_src

     - /Classes/ with _ANY_ of these /methods/ are CONSIDERED /descriptors/,
       + their /methods/ are special when one of their instances is assigned to
         another class’s attribute -- when the attribute is accessed, they are
         automatically invoked.

       + If any of these /methods/ are _ABSENT_, it generally means that the
         corresponding type of access is *not supported*.

       + *Unlike /properties/,* however, omitting a ~__set__~ allows the /descriptor
         attribute's name/ to be assigned and thus _redefined_ in an instance,
         thereby *hiding* the /descriptor/ --
         _to make an attribute *read-only*,_ you *must* define ~__set__~ to
         _CATCH assignments_ and _RAISE an exception_.

     - /Descriptors/ with ~__set__~ methods also have some special-case implications
       for inheritance that we'll largely defer until Chapter 40's coverage of
       /metaclasses/ and the _COMPLETE_ /inheritance specification/.
       =TODO= =TODO= =TODO= 
       + In short, a /descriptor/ with a ~__set__~ is known formally as
         /data descriptor/, and is given *precedence OVER* other names located
         by /normal inheritance rules/.

       + The /inherited descriptor/ for name ~__class__~, for example, *overrides*
         the SAME name IN an /instance's namespace dictionary/.
         * This also works to ensure that /data descriptors/ you code in your own
           /classes/ *take precedence over* others.

***** DONE Descriptor method arguments - 1227
      CLOSED: [2020-10-29 Thu 00:39]
      Before we code anything realistic, let's take a brief look at some
      _FUNDAMENTALS_.

      - *All three* /descriptor methods/ outlined in the prior section are passed
        both
        + the /descriptor class instance (~self~)/, and
        + the /instance/ of the /client class/ to which the /descriptor instance/
          is attached (~instance~).

      - The ~__get__~ /access method/ ADDITIONALLY receives an ~owner~ argument,
        specifying the /class/ to which the /descriptor instance/ is attached.
        + Its ~instance~ argument is
          * EITHER the /instance/ through which the attribute was accessed (for
            ~instance.attr~),

          * OR ~None~ when the attribute is accessed through the /owner class/ directly
            (for ~Class.attr~).

        + The _FORMER_ of these generally _computes a value_ for /instance access/,

        + The _LATTER_ usually returns ~self~
          IF /descriptor object ACCESS/ is *supported*.
          =TODO= =???= =TODO=

      - For example:
        #+begin_src python
          class Descriptor:
              def __get__(self, instance, owner):
                  print(self, instance, owner, sep='\n')

          class Subject:
              attr = Descriptor()

          Subject.attr
          ## <__main__.Descriptor object at 0x0281E690>
          ## None
          ## <class '__main__.Subject'>


          x = Subject()
          x.attr
          ## <__main__.Descriptor object at 0x0281E690>
          ## <__main__.Subject object at 0x028289B0>
          ## <class '__main__.Subject'>
        #+end_src
        + Notice the arguments *AUTOMATICALLY passed into* the ~__get__~ method
          in the first attribute fetch -- when ~x.attr~ is fetched, it's as
          though the following translation occurs (though the ~Subject.attr~
          here doesn't invoke ~__get__~ again):
          ~X.attr~ -> ~Descriptor.__get__(Subject.attr, X, Subject)~

        + The /descriptor/ knows it is being accessed directly when its /instance
          argument/ is ~None~.
          
        + =from Jian=
          I don't quite understand how to use ~Subject.attr~, which *seems USELESS*!
      
***** DONE Read-only descriptor - 1228
      CLOSED: [2020-10-29 Thu 00:17]
      - Example:
        #+begin_src python
          class D:
              def __get__(*args): print('get')

          class C:
              a = D()  ## Attribute `a` is a descriptor instance

          x = C()
          x.a          ## Run inherited descriptor `__get__`
          # get

          C.a
          # get

          list(X.__dict__.keys())
          # []


          x.a = 99     ## Stored on `x`, hiding `C.a`!
          x.a
          # 99

          list(X.__dict__.keys())
          # ['a']
        #+end_src
        + Can't be ignored if /read-only descriptor/ is required:
          #+begin_src python
            # defined in `D`
            def __set__(*args):
                raise AttributeError('cannot set')
          #+end_src

        + If not /read-only descriptor/, the assignment can happen, and the
          /descriptor/ will be hided. The lines from ~x.a = 99~ to the end in
          the above example can show this.

        + =IMPORTANT= =from Jian=
          This example can prove that /no ~__set__~ descriptor/ is never the
          /descriptor/ you want if you want to write reasonable code!!!

      - Don't confuse the /descriptor ~__delete__~ method/ with the GENERAL
        ~__del__~ /method/:
        + ~__delete__~ attempts to *delete* the /managed attribute name/ on an
          /instance/ of the /owner class/;
          * It is more closely related to the ~__delattr__~ /generic attribute
            deletion method/ =TOOD= LATER IN THIS CHAPTER.

        + ~__del__~ is an /instance destructor method/, which is called when an
          /instance/ of any kind of /class/ is about to be *garbage-collected*.
          =TODO= =LEARN MORE!!!= =TODO=

**** DONE A First Example - 1229
     CLOSED: [2020-10-28 Wed 23:03]
     #+BEGIN_SRC python
       class Name:                                 # Use (object) in 2.X
           "name descriptor docs"
           def __get__(self, instance, owner):
               print('fetch...')
               return instance._name

           def __set__(self, instance, value):
               print('change...')
               instance._name = value

           def __delete__(self, instance):
               print('remove...')
               del instance._name


       class Person:                               # Use (object) in 2.X
           def __init__(self, name):
               self._name = name

           name = Name()                           # Assign descriptor to attr


       bob = Person('Bob Smith')  ## bob has a managed attribute
       print(bob.name)            ## Runs Name.__get__
       # fetch...
       # Bob Smith

       bob.name = 'Robert Smith'  ## Runs Name.__set__
       print(bob.name)
       # fetch...
       # Robert Smith

       del bob.name               ## Runs Name.__delete__

       print('-'*20)
       # --------------------

       sue = Person('Sue Jones')  ## sue inherits descriptor too
       print(sue.name)
       # fetch...
       # Sue Jones

       print(Name.__doc__)        ## Or help(Name)
       # name descriptor docs
     #+END_SRC

     - we must assign the /descriptor/ to a class attribute like this — it won’t
       work if assigned to a ~self~ instance attribute instead.

     - When the descriptor's ~__get__~ method is run, it is passed three objects
       to define its context:
       + ~self~ is the ~Name~ class instance.
       + ~instance~ is the ~Person~ class instance.
       + ~owner~ is the ~Person~ class.

     - If a descriptor class is ONLY used in one class, just embed it into this
       class.
       #+BEGIN_SRC python
         class Person:
             def __init__(self, name):
                 self._name = name

             class Name:
                 """name descriptor docs"""
                 def __get__(self, instance, owner):
                     print('fetch...')
                     return instance._name

                 def __set__(self, instance, value):
                     print('change...')
                     instance._name = value

                 def __delete__(self, instance):
                     print('remove...')
                     del instance._name

             name = Name()
       #+END_SRC

**** DONE Computed Attributes - 1231
     CLOSED: [2020-10-28 Wed 23:08]
     Re-implement the example in the subsection "Computed Attributes" of the
     section "Properties"
     #+BEGIN_SRC python
       class DescSquare:
           def __init__(self, start):           # Each desc has own state
               self.value = start

           def __get__(self, instance, owner):  # On attr fetch
               return self.value**2

           def __set__(self, instance, value):  # On attr assign
               self.value = value               # No delete or docs

       class Client1:
           x = DescSquare(3)                    # Assign descriptor instance to class attr

       class Client2:
           x = DescSquare(32)                   # Assign descriptor instance to class attr

       c1 = Client1()
       c2 = Client2()

       print(c1.x)                              # 3 ** 2
       c1.x = 4
       print(c1.x)                              # 4 ** 2
       print(c2.x)                              # 32 ** 2 (1024)
     #+END_SRC

**** TODO Using State Information in Descriptors - 1232
**** TODO How Properties and Descriptors Relate - 1236
     _NOT from this book_
     From https://docs.python.org/3.6/howto/descriptor.html#properties
     #+BEGIN_SRC python
       class Property(object):
           """Emulate PyProperty_Type() in Objects/descrobject.c"""

           def __init__(self, fget=None, fset=None, fdel=None, doc=None):
               self.fget = fget
               self.fset = fset
               self.fdel = fdel
               if doc is None and fget is not None:
                   doc = fget.__doc__
               self.__doc__ = doc

           def __get__(self, obj, objtype=None):
               if obj is None:
                   return self
               if self.fget is None:
                   raise AttributeError("unreadable attribute")
               return self.fget(obj)

           def __set__(self, obj, value):
               if self.fset is None:
                   raise AttributeError("can't set attribute")
               self.fset(obj, value)

           def __delete__(self, obj):
               if self.fdel is None:
                   raise AttributeError("can't delete attribute")
               self.fdel(obj)

           def getter(self, fget):
               return type(self)(fget, self.fset, self.fdel, self.__doc__)

           def setter(self, fset):
               return type(self)(self.fget, fset, self.fdel, self.__doc__)

           def deleter(self, fdel):
               return type(self)(self.fget, self.fset, fdel, self.__doc__)
     #+END_SRC
     - Without the ~getter~, ~setter~, and ~deleter~, this cannot be used as a
       decorator.

***** TODO Descriptors and slots and more
      =TODO=

*** TODO ~__getattr__~ and ~__getattribute__~ - 1237
    We have learned /properties/ and /descriptors/, which are used to
    *manage* _SPECIFIC_ /attributes/.
      The ~__getattr__~ and ~__getattribute__~ operator *overloading* /methods/
    provide still OTHER WAYS to *intercept* attribute fetches for /class
    instances/.

    - Like /properties/ and /descriptors/,
      they allow us to insert code to be run automatically when attributes are
      accessed.

      + As we'll see, though, these two methods can also be used in _more general
        ways_. =TODO=

      + Because they *intercept* _ARBITRARY_ names, they apply in _BROADER_ roles
        such as /delegation/ =TODO=, =???=
        but may also _incur extra calls_ in some contexts, and are *too dynamic* to
        register in ~dir~ results =TODO=. =???=

    - _Attribute fetch_ *interception* comes in _TWO_ flavors, coded with _TWO_
      DIFFERENT /methods/:
      + ~__getattr__~ is run _for UNDEFINED attributes_ -- its use is STRAIGHTFORWARD,
        because it is run ONLY for /attributes/ *NOT*
        * stored on an /instance/
          OR
        * inherited from one of its /classes/, 

      + ~__getattribute__~ is run _for EVERY attribute_ --
        because it is *all-inclusive*,
        you *must be cautious* when using this /method/ *to*
        *AVOID recursive loops* _by PASSING /attribute accesses/ TO a /superclass/._
        * for example,
          if you use ~__getattribute__~ to get ~self.name~, and you use
          ~self.name~ inside ~__getattribute__~, there is a recursive loops!!!

    - These _TWO_ /methods/ are representatives of a set of /attribute interception/
      /methods/ that also includes ~__setattr__~ and ~__delattr_~.
        Because these methods have _SIMILAR_ roles, though, we will generally
      treat them all as a single topic here.

    - *UNLIKE* /properties/ and /descriptors/,
      these /methods/ are part of /Python's GENERAL operator overloading protocol/.

    - The ~__getattr__~ and ~__getattribute__~ methods are also more _generic_ in
      the sense of *intercepting* access to ANY (or even ALL) instance attribute
      fetches, NOT just a single specific name.
      =TODO= =???=
        Because of this, these two methods are well suited to general
      delegation-based coding patterns - they can be used to implement wrapper
      (a.k.a. /proxy/) objects that manage all attribute accesses for an embedded
      object.

    - These two methods are more _narrowly focused_ -- they do fetch only, NO
      assignments.

      + ~__setattr__~ and ~__delattr__~ must be set to do /assignment/ and /deletion/.

      + You must avoid _recursive loops_ when use ~__setattr__~.

    - By contrast, /properties/ and /descriptors/ catch /get/, /set/, and /delete/
      operations by design.

**** DONE The Basics - 1238
     CLOSED: [2020-10-30 Fri 18:32]
     - Functionalities of /methods/:
       #+begin_src python
         def __getattr__(self, name):        # On undefined attribute fetch [obj.name]
         def __getattribute__(self, name):   # On all attribute fetch [obj.name]
         def __setattr__(self, name, value): # On all attribute assignment [obj.name=value]
         def __delattr__(self, name):        # On all attribute deletion [del obj.name]
       #+end_src
       + ~__getattr__~ and ~__getattribute__~ normally return an _attribute value_.
       + ~__setattr__~ and ~__delattr__~ return ~None~
       + They all can _raise exceptions_ to signal prohibited access.

     - Example 1:
       #+BEGIN_SRC python
         # both Python 2.X and 3.X
         class Catcher:
             def __getattr__(self, name):
                 print('Get: %s' % name)

             def __setattr__(self, name, value):
                 print('Set: %s %s' % (name, value))

         x = Catcher()
         x.job # Prints "Get: job"
         x.pay # Prints "Get: pay"
         x.pay = 99 # Prints "Set: pay 99"
       #+END_SRC

     - Example 2:
       #+BEGIN_SRC python
         # new style class required in Python 2.X
         class Catcher(object):
             def __getattribute__(self, name):
                 print('Get: %s' % name)

             def __setattr__(self, name, value):
                 print('Set: %s %s' % (name, value))
       #+END_SRC

     - Example 3 (delegation):
       #+BEGIN_SRC python
         # from Chapter 31
         class Wrapper:
             def __init__(self, object):
                 self.wrapped = object                    # Save object

             def __getattr__(self, attrname):
                 print('Trace: ' + attrname)              # Trace fetch
                 return getattr(self.wrapped, attrname)   # Delegate fetch

         x = Wrapper([1, 2, 3])
         x.append(4)                                      # Prints "Trace: append"
         print(x.wrapped)                                 # Prints "[1, 2, 3, 4]"
       #+END_SRC

       There is no analog of this for /properties/ and /descriptors/.

***** Avoiding loops in attribute interception methods
      - ~__getattribute__~
        Resolve the loops through fetching the attributes from a higher super class.
        #+BEGIN_SRC python
          def __getattribute__(self, name):
              """Wrong! LOOP!"""
              x = self.other                     # LOOPS!

          # self.name
          # self.other
          # self.other
          # ...


          def __getattribute__(self, name):
              """Right!"""
              x = object.__getattribute__(self, 'other')  # Force higher to avoid loops.
        #+END_SRC

      - ~__setattr__~
        #+BEGIN_SRC python
          def __setattr__(self, name, value):
              "Wrong"
              self.other = value                             # Recurs (and might LOOP!)


          def __setattr__(self, name, value):
              "Right"
              self.__dict__['other'] = value                 # Use attr dict to avoid Recurs


          def __setattr__(self, name, value):
              "Right"
              object.__setattr__(self, 'other', value)       # Force higher to aovid Recurs
        #+END_SRC

      - You mustn't use the ~__dict__~ method to resolve the recurs problem of
        ~__getattribute__~: it will trigger ~__getattribute__~!!!

      - Tips:
        For ~__setattr__~, the ~object.__setattr__~ is more general than the
        ~self.__dict__~ method -- ~object.__setattr__~ can work with /slots/ and
        /properties/ that are NOT physically stored in the instance's ~__dict__~
        namespace dictionary.

**** DONE A First Example - 1241
     CLOSED: [2020-10-31 Sat 00:50]
     #+BEGIN_SRC python
       class Person:                            # Portable: 2.X or 3.X
           def __init__(self, name):            # On [Person()]
               self._name = name                # Triggers __setattr__!

           def __getattr__(self, attr):         # On [obj.undefined_attr]
               print('get: ' + attr)
               if attr == 'name':               # Intercept name: not stored
                   return self._name            # Does not loop: real attr
               else: # Others are errors
                   raise AttributeError(attr)

           def __setattr__(self, attr, value):  # On [obj.any_attr = value]
               print('set: ' + attr)
               if attr == 'name':
                   attr = '_name'               # Set internal name
               self.__dict__[attr] = value      # Avoid looping here

           def __delattr__(self, attr):         # On [del obj.any_attr]
               print('del: ' + attr)
               if attr == 'name':
                   attr = '_name'               # Avoid looping here too
               del self.__dict__[attr]          # but much less common


       bob = Person('Bob Smith')                # bob has a managed attribute
       ## set: _name

       print(bob.name)                          # Runs __getattr__
       ## get: name
       ## Bob Smith

       bob.name = 'Robert Smith'                # Runs __setattr__
       ## set: name

       print(bob.name)                          # Runs __getattr__
       ## get: name
       ## Robert Smith

       del bob.name                             # Runs __delattr__
       ## del: name

       print('-'*20)

       sue = Person('Sue Jones') # sue inherits property too
       ## set: _name

       print(sue.name)
       ## get: name
       ## Sue Jones

       # print(Person.name.__doc__) # No equivalent here
     #+END_SRC
     - The /attribute assignment/ in the ~__init__~ /constructor/
       TRIGGERS
       ~__setattr__~ too -- this method catches *every* /attribute assignment/,
       even those anywhere within the class itself.

     - (To compare with /properties/ and /descriptors/, we have the last commented
       line in the above example code)
       *UNLIKE* with /properties/ and /descriptors/,
       there's NO direct notion of specifying _documentation_ for our attribute here;
       + /managed attributes/ exist *within* the code of our /interception methods/,
         not as DISTINCT /objects/.

***** Using ~__getattribute__~
      To achieve exactly the same results with ~__getattribute__~, replace the
      ~__getattr__~ in the example with
      #+begin_src python
        def __getattribute__(self, attr):               # On [obj.any]
            print(f"get: {attr}"
            if attr == 'name':                          # Intercept all names
                attr = '_name'                          # Map to internal name
            return object.__getattribute__(self, attr)  # Avoid looping here!!!!!!!!!!!
      #+end_src

      - *CAUTION*:
        Because ~__getattribute__~ catches _ALL_ /attributes fetches/,
        + this version must be careful to
          *AVOID* LOOPING *BY* passing new fetches to /superclass/,
          AND
        + it _CAN'T_ generally assume UNKNOWN names are errors.

      - Try with this new version ~Person~:
        #+begin_src python
          bob = Person('Bob Smith')                # bob has a managed attribute
          ## set: _name
          ## get: __dict__

          print(bob.name)                          # Runs __getattr__
          ## get: name
          ## Bob Smith

          bob.name = 'Robert Smith'                # Runs __setattr__
          ## set: name
          ## get: __dict__

          print(bob.name)                          # Runs __getattr__
          ## get: name
          ## Robert Smith

          del bob.name                             # Runs __delattr__
          ## del: name
          ## get: __dict__

          print('-'*20)

          sue = Person('Sue Jones')
          ## set: _name
          ## get: __dict__

          print(sue.name)
          ## get: name
          ## Sue Jones
        #+end_src
        
**** DONE Computed Attributes - 1243
     CLOSED: [2020-10-31 Sat 02:08]
     Nothing special than /properties/ and /descriptors/:
     #+begin_src python
       class AttrSquare:
           def __init__(self, start):
               self.value = start                  # Triggers __setattr__!

           def __getattr__(self, attr):            # On undefined attr fetch
               if attr == 'X':
                   return self.value ** 2
               else:                               # value is not undefined
                   raise AttributeError(attr)

           def __setattr_(self, attr, value):      # On all attr assignments
               if attr == 'X':
                   attr = 'value'
               self.__dict__[attr] = value
     #+end_src
     
***** Using ~__getattribute__~ - 1244
      To use ~__getattribute__~, besides replace ~__getattr__~ with ~__getattribute__~,
      changes the ~__setattr__~ assignment method to *avoid looping* _BY_ using /direct
      superclass method/ calls instead of ~__dict__~ keys:
      #+begin_src python
        class AttrSquare:                           # Add (object) for 2.X
            def __init__(self, start):
                self.value = start                  # Triggers __setattr__!

            def __getattribute__(self, attr):       # On all attr fetches
                if attr == 'X':
                    return self.value ** 2          # Triggers __getattribute__ again!
                else:
                    return object.__getattribute__(self, attr)

            def __setattr__(self, attr, value):     # On all attr assignments
                if attr == 'X':
                    attr = 'value'
                object.__setattr__(self, attr, value)
      #+end_src
      - Notice, the implicit *routing* going on inside this class's methods:
        + ~self.vlaue = start~ inside the /constructor/ TRIGGERS ~__setattr__~
        + ~self.vlaue~ inside ~_getattribute_~ TRIGGERS ~__getattribute__~ again

      - In fact, ~__getattribute__~ is run *twice* each time we fetch /attribute/ ~X~.
        + This does *NOT happen* in the ~__getattr__~ version, because the ~value~
          attribute is _not undefined_.

        + If you care about speed and want to avoid this, change ~__getattribute__~
          to use the /superlcass/ to fetch ~value~ as well:
          #+begin_src python
            def __getattribute__(self, attr):
                if attr == 'X':
                    return object.__getattribute__(self, 'value') ** 2
          #+end_src
          This *STILL* incurs a call to the /superclass method/,
          BUT *NOT* an additional recursive call before we get there.
          Add ~print~ calls to these methods to trace how and when they run.
     
**** DONE ~__getattr__~ and ~__getattribute__~ Compared - 1245
     CLOSED: [2020-10-31 Sat 02:26]
     #+begin_src python
       class GetAttr:
           attr1 = 1

           def __init__(self):
               self.attr2 = 2

           def __getattr__(self, attr):  # On undefined attrs only
               print(f"get: {attr}")     # Not on attr1: inherited from class
               if attr == 'attr3':       # Not on attr2: stored on instance
                   return 3
               else:
                   raise AttributeError(attr)


       x = GetAttr()

       print(x.attr1)
       ## 1

       print(x.attr2)
       ## 2

       print(x.attr3)
       ## 3


       class GetAttribute:
           attr1 = 1

           def __init__(self):
               self.attr2 = 2

           def __getattribute__(self, attr):  # On all attr fetches
               print(f"get: {attr}")          # Use superclass to avoid looping here
               if attr == 'attr3':
                   return 3
               else:
                   return object.__getattribute__(self, attr)

       y = GetAttr()

       print(y.attr1)
       ## get: attr1
       ## 1

       print(y.attr2)
       ## get: attr2
       ## 2

       print(y.attr3)
       ## get: attr3
       ## 3
     #+end_src
     - To summarize the coding differences between ~__getattr__~ and ~__getattribute__~,
       the following example uses both to implement _THREE_ /attributes/:
       + ~attr1~: a /class attribute/
       + ~attr2~: an /instance attribute/
       + ~attr3~: a VIRTUAL /managed attribute/ computed when fetched.

     - Although ~__getattribute__~ can catch *MORE* /attribute fetches/ *than*
       ~__getattr__~, in practice they are often just variations on a theme --
       if /attributes/ are *NOT* _physically stored_,
       the two have the *same* effect.
     
**** TODO Management Techniques Compared - 1246
**** TODO Intercepting Built-in Operation Attributes - 1249
***** Delegation-based managers revisited - 1253

*** TODO Example: Attribute Validations 1256
**** TODO Using Properties to Validate - 1256
***** TODO Testing code - 1258
      
**** TODO Using Descriptors to Validate - 1259
***** Option 1: Validating with shared descriptor instance state - 1259
***** Option 2: Validating with per-client-instance state - 1261
      
**** TODO Using ~__getattr__~ to Validate - 1263
**** TODO Using ~__getattribute__~ to Validate - 1265

*** TODO Chapter Summary - 1266
*** TODO Test Your Knowledge: Quiz - 1266
*** TODO Test Your Knowledge: Answers - 1267

** TODO 39. Decorators - 1269
*** DONE What's a Decorator? - 1269
    CLOSED: [2020-04-04 Sat 16:41]
    - /Decoration/ is a way to specify *management* or *augmentation* code for
      /functions/ and /classes/.

    - /Decorators/ themselves take _the form of /callable objects/ (e.g., functions)
      that process other /callable objects/._

    - _TWO_ flavors of Python decorators:
      + /Function decorators/
        * Added in Python 2.4

        * Do name rebinding at function definition time, providing a layer of logic
          that can _manage /functions/ and /methods/, or later calls to them_.

      + Class decorators
        * Added in Python 2.6 and 3.0

        * Do name rebinding at class definition time, providing a layer of logic
          that can _manage /classes/, or the /instances/ created by later calls
          to them._

**** DONE Managing Calls and Instances - 1270
     CLOSED: [2020-04-04 Sat 15:20]
     - Wrapper (a.k.a. proxy):
       + Call proxies (=from Jian= for /functions/)
       + Interface proxies (=from Jian= for /classes/)

     - Decorators achieve these effects by _automatically *rebinding* /function/
       and /class/ names to other callables_, at the end of ~def~ and ~class~
       statements.

**** TODO Managing Functions and Classes - 1270
     - xx
       + /Function managers/
       + /Class managers/

     - xx

**** TODO Using and Defining Decorators - 1271
**** DONE Why Decorators? - 1271
     CLOSED: [2020-04-04 Sat 16:41]
     - /Decorators/ are *NEVER strictly REQUIRED*.
       However, it can help
       + making intent clearer
         A very explicit syntax makes /decorators/ easier to spot than helper
         function calls, which can be arbitrarily far-removed.

       + minimizing augmentation code redundancy
         /decorators/ are applied once at their definition sites.
           Not like helper functions that need to be called everytime there is a
         call to the _decorated objects_.

       + ensuring correct API usage
         For a /decorated objects/, when use them, there is no way to forget related
         helper functions.

     - In other words, beyond their technical model, decorators offer some advantages
       in terms of both code maintenance and consistency. Moreover, as structuring
       tools, decorators naturally foster encapsulation of code, which reduces
       redundancy and makes future changes easier.
       TODO RE-PHRASE

     - Drawbacks: TODO Explore these in code later in this chapter TODO
       Because of insert wrapper logic,
       + Alter the types of the decorated objects;
       + Incur extra calls when used as call proxies or interface proxies.

     - On the other hand, the same considerations apply to any technique that adds
       wrapping logic to objects.

     - *Decorators versus macros*:
       + /Python's decorators/ bear _similarities_ to what some call /aspect-oriented
         programming/ in other languages.

       + /Python's decorator syntax/ also very _closely resembles_ /Java's annotations/,
         though Python's model is usually considered more flexible and general.
         TODO ??? TODO ??? TODO

       + /Decorators/ are a /runtime/ operation, based upon name rebinding.
         Not like /macros/ in other languages that typically associated with
         code generation in /compile time/.
           They are fundamentally different in scope, implementation, and coding
         pattern.

       + /Decorators/ are about /callable objects/ *managing* /callable objects/.

*** TODO The Basics - 1273
    Most of the magic of /decorators/ boils down to an *automatic rebinding*
    operation

**** DONE Function Decorators - 1273
     CLOSED: [2020-10-31 Sat 03:36]
     - /Function decorators/ have been available in Python *since version 2.4.*

     - /Function decorators/ are largely just /syntactic sugar/ that
       1. _runs one /function/ through another_ at the end of a ~def~ statement, and
       2. *rebinds* the _ORIGINAL function name_ to the result.

***** DONE Usage - 1273
      CLOSED: [2020-10-31 Sat 03:37]
      - A /function decorator/ is a kind of /runtime declaration/ about the function
        whose definition follows.

      - The /decorator/ is coded on _a line *just before* the ~def~ statement_ that
        defines a /function/ or /method/, and it consists of
        1. the ~@~ symbol
           followed by
        2. a reference to a /metafunction/ -- a function (or other /callable object/)
           that *manages another function*.

      - Example:
        #+begin_src python
          @decorator  # Decorate function
          def f(arg):
              ...

          f(99)       # Call function
        #+end_src
        
        This is EQUIVALENT TO
        
        #+begin_src python
          def f(arg):
              ...

          f = decorator(f)  # Rebind function name to decorator result

          f(99)             # Essentially calls `decorator(F)(99)`
        #+end_src

      - This *AUTOMATIC name rebinding* works on any ~def~ statement, whether it's for
        a simple /function/ or a /method within a class/.

      - This *AUTOMATIC name rebinding* accounts for the /static method/ and
        /property decoration/ syntax we met earlier in the book:
        #+begin_src python
          class C:
              @staticmethod
              def meth(...): ...   # meth = staticmethod(meth)


          class C:
              @property
              def name(self): ...  # name = property(name)
        #+end_src

***** DONE Implementation - 1274
      CLOSED: [2020-10-31 Sat 20:23]
      - A /decorator/ itself is a *callable* that returns a *callable*.

      - That is, it returns the object to be called later when the /decorated
        function/ is invoked through its _ORIGINAL name_:
        + EITHER a /wrapper object/ to intercept later calls,
        + OR the _ORIGINAL function augmented_ in some way.
        
      - In fact, /decorators/
        1. _CAN BE_
           *ANY type* of /callable/
           AND
        2. _RETURN_
           *ANY type* of /callable/:

      - *ANY COMBINATION* of /functions/ and /classes/ may be used,
        though some are better suited to certain contexts.

      - For example,
        to tap into the /decoration protocol/ in order to manage a function just
        after it is created, we might code a decorator of this form:
        #+begin_src python
          def decorator(f):
              # Process function `f`
              return f

          @decorator
          def func():  # func = decorator(func)
              ...
        #+end_src
        + Because the _ORIGINAL decorated function_ is *ASSIGNED BACK* to its name,
          this simply _ADDS *a post-creation step* TO function definition._
          * Such a structure might be used to
            - *register* a /function/ *to an API*,
            - *assign* /function attributes/,  =TODO= =???= /function attributes/???
            - and so on.

      - In more typical use, to insert logic that intercepts later calls to a
        function, we might code a /decorator/ to return a different object than
        the original function -- a proxy for later calls:
        #+begin_src python
          def decorator(f):
              # Save or use function `f`
              # Return a different callable: nested `def`, `class` with `__call__`, etc.

          @decorator
          def func(): # func = decorator(func)
              ...
        #+end_src
        + This /decorator/ is invoked AT DECORATION TIME, and the /callable/ it
          returns is invoked when the _ORIGINAL function name_ is later called.

        + The /decorator/ itself RECEIVES the /decorated function/;

        + _the /callable/ returned_ receives *whatever arguments are later passed
          to* _the decorated function's name_.

        + When coded properly, this works the same for /class-level methods/:
          the implied /instance object/ simply shows up in the first argument of
          the returned /callable/.
          =TODO= =Can be improper???= =TODO=

      - In skeleton terms, here's one common coding pattern that captures this
        idea -- the /decorator/ returns a /wrapper/ that retains the _ORIGINAL
        function_ in an enclosing scope:
        #+begin_src python
          def decorator(f):        # On @ decoration
              def wrapper(*args):  # On wrapped function call
                  # Use `f` and args
                  # F(*args) calls original function

              return wrapper

          @decorator       # `func = decorator(func)`
          def func(x, y):  # `func` is passed to decorator's `f`
              ...

          func(6, 7)  # 6, 7 are passed to wrapper's *args
        #+end_src
        + When the name ~func~ is later called, it really invokes the ~wrapper~
          function returned by ~decorator~; the ~wrapper~ function can then run
          the ORIGINAL ~func~ because it is still available in an /enclosing scope/.
          * When coded this way, each decorated function produces a new scope to
            retain state.

        + To do the same with /classes/, we can overload ~__call__~ and use /instance
          attributes/ instead of /enclosing scopes/:
          #+begin_src python
            class decorator:
                def __init__(self, func):  # On @ decoration
                    self.func = func

                def __call__(self, *args):  # On wrapped function call
                    # Use `self.func` and `args`
                    # `self.func(*args)` calls original function


            @decorator
            def func(x, y):  # `func = decorator(func)`
                ...          # `func` is passed to `_init_`

            func(6, 7)
          #+end_src
          * Call ~func~ will actually invokes the ~__call__~ /method/ of the
            /instance/ created by ~decorator~; the ~__call__~ /method/ can then
            run the ORIGINAL ~func~ because it is still available in an /instance
            attribute/.

          * When coded this way, each /decorated function/ produces a *NEW*
            /instance/ to *retain state*.

***** DONE Supporting method decoration - 1275
      CLOSED: [2020-10-31 Sat 20:39]
      One subtle point about the prior class-based coding is that while it works
      to intercept simple function calls, it does not quite work when applied to
      class-level method functions:
      #+begin_src python
        class decorator:
            def __init__(self, func):          # `func` is method without instance
                self.func = func

            def __call__(self, *args):         # `self` is decorator instance
                # `self.func(*args)` fails!    # C instance not in args!


        class C:
            @decorator
            def method(self, x, y):  # `method = decorator(method)`
                ...                  # Rebound to decorator instance
      #+end_src
      When coded this way, the /decorated method/ is *rebound* to /an instance of the
      decorator class/, *instead of* a simple function -- =TODO= not as usual
      expectation, though this is NOT a reasonable expectation as explained below.

      - The problem with this is that the ~self~ in the decorator's ~__call__~ receives
        /the ~decorator~ class instance/ when the /method/ is later run, and the
        /instance/ of /class/ ~C~ is never included in ~*args~. This makes it
        impossible to dispatch the call to the ORIGINAL /method/ -- the /decorator
        object/ retains the original method function, but it has no instance to
        pass to it.

      - To support _BOTH_ /functions/ and /methods/, the /nested function/ alternative
        works better:
        #+begin_src python
          def decorator(f):        # `f` is function or method without instance
              def wrapper(*args):  # class instance in `args[0]` for method
                  ...              # `f(*args)` runs function or method

              return wrapper


          @decorator
          def func(x, y):  # `func = decorator(func)`
              ...

          func(6, 7)       # Really calls `wrapper(6, 7)`


          class C:
              @decorator
              def method(self, x, y):  # `method = decorator(method)`
                  ...                  # Rebound to simple function


          x = C()
          x.method(6, 7)               # Really calls wrapper(x, 6, 7)
        #+end_src
        When coded this way ~wrapper~ receives the ~C~ /class instance/ in its first
        argument, so it can dispatch to the ORGINAL /method/ and *access state
        information*.

        + Technically, this /nested-function/ version works because
          * Python creates a /bound method object/ and thus passes the /subject
            class instance/ to the ~self~ argument only when a method attribute
            references a simple function;

          * when it references an instance of a /callable class/ instead, the /callable
            class's instance/ is passed to ~self~ to give the /callable class/ access
            to its own state information. We'll see how this subtle difference
            can matter in more realistic examples later in this chapter.

      - Also *NOTE* that
        1. /nested functions/ are perhaps the *most straightforward way* to SUPPORT
           /decoration/ of *both* /functions/ and /methods/,

        2. BUT *NOT necessarily the ONLY way*.
           The prior chapter's /descriptors/, for example, receive _BOTH_ the
           /descriptor/ and /subject class instance/ when called.
           =TODO= =TODO= =TODO=
           Though more complex, later in this chapter we'll see how this tool
           can be leveraged in this context as well.

**** TODO Class Decorators - 1277
     - /Function decorators/ proved so useful that the model was extended to allow
       /class decoration/ as of _Python 2.6 and 3.0_.
       1. They were *initially resisted*
          BECAUSE of *role overlap* with /metaclasses/;

       2. In the end, though, they were adopted
          BECAUSE they provide a *SIMPLER* way to achieve many of the same goals.

     - /Class decorators/ are strongly related to /function decorators/:
       + same syntax
       + very similar coding patterns.

     - _RATHER THAN_ wrapping INDIVIDUAL /functions/ or /methods/, though,
       /class decorators/ are a way to
       + manage /classes/, or
       + wrap up /instance construction calls/ with _extra logic_ that
         _MANAGES_ or _AUGMENTS_ instances created from a class.

     - In the latter role above, they may manage *FULL* object interfaces.
       
***** DONE Usage - 1277
      CLOSED: [2020-11-01 Sun 19:21]
      Syntactically, /class decorators/ appear just before _class definition_, in
      the same way that /function decorators/ appear just before _funciton/method
      definition_.
      
      - In symbolic terms, for a /decorator/ that *MUST be* a /one-argument callable/
        that returns a /callable/.
        + The net effect:
          calling the _class name_ later to create an /instance/ winds up triggering
          the callable returned by the /decorator/, which may or may NOT call the
          _ORIGINAL class_ itself.

***** DONE Implementation - 1277
      CLOSED: [2020-11-01 Sun 19:51]
      - New /class decorators/ are coded with many of the same techniques used for
        /function decorators/, though some may involve *two levels of augmentation*
        -- to manage both /instance construction/ calls, as well as /instance
        interface access/. Because a /class decorator/ is also a /callable/ that
        returns a /callable/, most combinations of /functions/ and /classes/
        suffice.

      - Usages:
        + Simply MANAGE a /class/ just after it is created, return the _ORIGINAL
          class_ itself:
          #+begin_src python
            def decorator(C):
                # Process class C
                return C

            @decorator
            class C:  # `C = decorator(C)`
                ...
          #+end_src

        + Do more works, and return a *different* callable object:
          #+begin_src python
            def decorator(C):
                # Save or use class C
                # Return a different callable: nested `def`, class with `__call__`, etc.

            @decorator
            class C:  # `C = decorator(C)`
                ...
          #+end_src
          * For example,
            the following inserts an /object/ that intercepts *UNDEFINED* /attributes/
            of a /class instance/:
            #+begin_src python
              def decorator(cls):                   # On @ decoration
                  class Wrapper:
                      def __init__(self, *args):    # On instance creation
                          self.wrapped = cls(*args)

                      def __getattr__(self, name):  # On attribute fetch
                          return getattr(self.wrapped, name)

                  return Wrapper

              @decorator
              class C:                       # C = decorator(C)
                  def __init__(self, x, y):  # Run by Wrapper.__init__
                      self.attr = 'spam'

              x = C(6, 7)    # Really calls Wrapper(6, 7)
              print(x.attr)  # Runs Wrapper.__getattr__, prints "spam"
            #+end_src
            In this example, the decorator rebinds the class name to another
            class, which retains the original class in an enclosing scope and
            creates and embeds an instance of the original class when it’s
            called. When an attribute is later fetched from the instance, it is
            intercepted by the wrapper’s ~__getattr__~ and delegated to the
            embedded instance of the original class. Moreover, each decorated
            class creates a new scope, which remembers the original class. We’ll
            flesh out this example into some more useful code later in this
            chapter. =TODO= =???= =TODO= =???= =TODO=

      - Like /function decorators/, /class decorators/ are commonly coded as either
        _"factory" functions_ that *create* and *return* /callables/, /classes/
        that use ~__init__~ or ~__call__~ /methods/ to *intercept* _call operations_,
        or some combination thereof.
        + /Factory functions/ typically retain /state/ in
          * _enclosing scope references_, and
          * _classes in attributes_.
        
***** TODO Supporting method decoration - 1279
      As for /function decorators/, some /callable type/ COMBINATIONS work better
      for /class decorators/ than others. Consider the following invalid
      alternative to the /class decorator/ of the prior example:
      #+begin_src python
        class Decorator:                      # On `@` decoration
            def __init__(self, C):
                self.C = C

            def __call__(self, *args):        # On instance creation
                self.wrapped = self.C(*args)
                return self

            def __getattr__(self, attrname):  # On attribute fetch
                return getattr(self.wrapped, attrname)


        @Decorator
        class C:     # `C = Decorator(C)`
            ...

        x = C()
        y = C()      # Overwrites `x`!
      #+end_src
      
      - This code handles MULTIPLE /decorated classes/ (each makes a new ~Decorator~
        instance) and will *intercept* _instance creation calls_ (each runs ~__call__~).
        
      - UNLIKE the prior version, however, this version *FAILS to* handle _MULTIPLE
        instances_ of a given /class/ -- each _instance creation call_ *overwrites*
        the prior saved /instance/.
          The original version does support multiple instances, because each
        _instance creation call_ makes a new *independent wrapper object*. More
        generally, either of the following patterns supports multiple wrapped
        instances:
        #+begin_src python
          def decorator(C):                    # On @ decoration
              class Wrapper:
                  def __init__(self, *args):   # On instance creation: new Wrapper
                      self.wrapped = C(*args)  # Embed instance in instance

              return Wrapper


          class Wrapper:
              ...


          def decorator(C):                 # On `@` decoration
              def onCall(*args):            # On instance creation: new `Wrapper`
                  return Wrapper(C(*args))  # Embed instance in instance

              return onCall
        #+end_src

      - We'll study this phenomenon in a more realistic context later in the chapter
        too; in practice, though, we must be careful to combine callable types properly
        to support our intent, and choose state policies wisely.

**** TODO Decorator Nesting - 1279
     Sometimes ONE /decorator/ isn't enough.
     A combination of multiple /decorators/ is required.
     
     - /Decorator/ syntax allows you to add multiple layers of wrapper logic to a
       decorated function or method.
       + When this feature is used, *EACH /decorator/ must appear on a line of its
         own*:
         #+begin_src python
           @A
           @B
           @C
           def f(...):
               ...
         #+end_src
         runs the same as the following:
         #+begin_src python
           def f(...):
               ...


           f = A(B(C(f)))
         #+end_src

     - If all the decorators insert wrappers, the net effect is that when the
       original function name is called, three different layers of wrapping
       object logic will be invoked, to augment the original function in three
       different ways. The last decorator listed is the first applied, and is
       the most deeply nested when the original function name is later called
       (insert joke about Python “interior decorators” here).

     - Just as for functions, multiple class decorators result in multiple nested
       function calls, and possibly multiple levels and steps of wrapper logic
       around instance creation calls. For example, the following code:
       #+begin_src python
         @spam
         @eggs
         class C:
             ...


         x = C()
       #+end_src

     - Again, each decorator is free to return either the original class or an
       inserted wrapper object. With wrappers, when an instance of the original
       C class is finally requested, the call is redirected to the wrapping
       layer objects provided by both the spam and eggs decorators, which may
       have arbitrarily different roles—they might trace and validate attribute
       access, for example, and both steps would be run on later requests.
       + For instance, the following do-nothing decorators simply return the
         /decorated function/:
         #+begin_src python
           def d1(F): return F
           def d2(F): return F
           def d3(F): return F

           @d1
           @d2
           @d3
           def func(): # func = d1(d2(d3(func)))
               print('spam')


           func() # Prints "spam"
         #+end_src

     - The same syntax works on classes, as do these same do-nothing decorators.

     - When decorators insert wrapper function objects, though, they may augment
       the original function when called—the following concatenates to its
       result in the decorator layers, as it runs the layers from inner to
       outer:
       #+begin_src python
         def d1(F): return lambda: 'X' + F()
         def d2(F): return lambda: 'Y' + F()
         def d3(F): return lambda: 'Z' + F()

         @d1
         @d2
         @d3
         def func(): # func = d1(d2(d3(func)))
             return 'spam'


         print(func()) # Prints "XYZspam"
       #+end_src
       We use lambda functions to implement wrapper layers here (each retains
       the wrapped function in an enclosing scope); in practice, wrappers can
       take the form of functions, callable classes, and more. When designed
       well, decorator nesting allows us to combine augmentation steps in a wide
       variety of ways.

**** TODO Decorator Arguments - 1281
**** TODO Decorators Manage Functions and Classes, Too - 1282

*** TODO Coding Function Decorators - 1283
**** TODO Tracing Calls - 1283
**** TODO Decorator State Retention Options - 1285
***** Class instance attributes - 1285
***** Enclosing scopes and globals - 1286
***** Enclosing scopes and nonlocals - 1287
***** Function attributes

**** TODO Class Blunders I: Decorating Methods - 1289
***** Using nested functions to decorate methods - 1291
***** Using descriptors to decorate methods - 1292

**** TODO Timing Calls - 1295
***** Decorators versus per-call timing - 1297
***** Testing subtleties - 1297

**** TODO Adding Decorator Arguments - 1298
***** Timing with decorator arguments - 1299

*** TODO Coding Class Decorators - 1301
**** TODO Singleton Classes - 1301
***** Coding alternatives - 1302

**** TODO Tracing Object Interfaces - 1303
***** Tracing interfaces with class decorators - 1304
***** Applying class decorators to built-in types - 1306

**** TODO Class Blunders II: Retaining Multiple Instances - 1308
**** TODO Decorators Versus Manager Functions - 1309
**** TODO Why Decorators? (Revisited) - 1310

*** TODO Managing Functions and Classes Directly - 1312
*** TODO Example: "Private" and "Public" Attributes - 1314
**** TODO Implementing Private Attributes - 1314
**** TODO Implementation Details I - 1317
***** Inheritance versus delegation - 1317
***** Decorator arguments - 1317
***** State retention and enclosing scopes - 1317
***** Using ~_dict_~ and ~__slot__~ (and other virtual names) - 1318

**** TODO Generalizing for Public Declarations, Too - 1318
**** TODO Implementation Details II - 1320
***** Using ~__X~ pseudoprivate names - 1321
***** Breaking privacy - 1321
***** Decorator tradeoffs - 1321

**** TODO Open Issues - 1321
***** Caveat: Implicitly run operator overloading methods fail to delegate under 3.X - 1322
***** Approaches to redefining operator overloading methods for 3.X - 1324
****** Inline definition - 1324
****** Mix-in superclasses - 1325
****** Coding variations: Routers, descriptors, automation - 1326

***** Should operator methods be validated? - 1327
****** Implementation alternatives: ~__getattribute__~ inserts, call stack inspection - 1328

**** TODO Python Isn't About Control - 1329

*** TODO Example: Validating Function Arguments - 1330
**** TODO The Goal - 1330
**** TODO A Basic Range-Testing Decorator for Positional Arguments - 1331
**** TODO Generalizing for Keywords and Defaults, Too - 1333
**** TODO Implementation Details - 1336
***** Function introspection - 1336
***** Argument assumptions - 1337
***** Matching algorithm - 1338

**** TODO Open Issues - 1338
***** Invalid calls - 1338
***** Arbitrary arguments - 1339
***** Decorator nesting - 1340

**** TODO Decorator Arguments Versus Function Annotations - 1340
**** TODO Other Applications: Type Testing (If You Insist!) - 1342

*** TODO Chapter Summary - 1343
**** TODO Test Your Knowledge: Quiz - 1344
**** TODO Test Your Knowledge: Answers - 1345

** 40. Metaclasses - 1355
   - In a sense, /metaclasses/ simply *extend* the _code-insertion model of
     /decorators/._
     + As we learned, /function decorators/ and /class decorators/ allow us to
       *intercept and augment*
       /function calls/ and /class instance creation calls/.

     + In a similar spirit, /metaclasses/ allow us to *intercept and augment*
       _class creation_ -- they provide an API for inserting extra logic to be
       run at the conclusion of a class statement, albeit _in different ways than
       /decorators/._
       * Accordingly, they provide a _general protocol_ for managing /class objects/
         in a program.

   - In practice, /metaclasses/ allow us to gain a high level of control over how
     a set of /classes/ works.

   - On the other hand, /metaclasses/ open the door to a variety of coding patterns
     that may be difficult or impossible to achieve otherwise, and they are
     especially of interest to programmers seeking to write _flexible APIs_ or
     programming tools for others to use.
   
   - Also /metaclasses/ can teach you much about /Python's class model/ in general
     (as we'll see, they even impact inheritance), and are prerequisite to
     understanding code that employs them.

*** TODO To Metaclass or Not to Metaclass - 1356
**** Increasing Levels of "Magic" - 1357
     Most of this book has focused on straightforward application-coding techniques—the
     modules, functions, and classes that most programmers spend their time writing to
     achieve real-world goals. The majority of Python’s users may use classes and make
     instances, and might even do a bit of operator overloading, but they probably won’t
     get too deep into the details of how their classes actually work.

     However, in this book we’ve also seen a variety of tools that allow us to control Python’s
     behavior in generic ways, and that often have more to do with Python internals or tool
     building than with application-programming domains. As a review, and to help us place
     metaclasses in the tools spectrum:

     - Introspection attributes and tools
       ~__class__~ and ~__dict__~
       ~dir~ and ~getattr~

     - Operator overloading methods
       ~__str__~ and ~__add__~

     - Attribute interception methods
       ~__getattr__~, ~__setattr__~, ~__delattr__~, and ~__getattribute__~

     - Class properties
       ~property~

     - Class attribute descriptors
       ~property~
       ~__get__~, ~__set__~, and ~__delete__~

     - Function and class decorators
       ~@callable~

     - Metaclass
       
**** A Language of Hooks - 1358
**** The Downside of "Helper" Functions - 1359
**** Metaclasses Versus Class Decorators: Round 1 - 1361

*** TODO The Metaclass Model - 1364
    Pre-knowledge of understanding /metaclasses/:
    - Python's type model
    - What happens at the end of a ~class~ statement
    
**** TODO Classes Are Instances of type - 1364
     - As we've seen, /instances/ of /classes/
       + have some _state information attributes_ of their own,
       + but they also _inherit behavioral attributes_ from the /classes/ from
         which they are made.

     - While we can get a lot done with such /instance objects/, /Python's type
       model/ turns out to be a bit richer than I've formally described.

       + Really, there's a hole in the model we've seen thus far:
         * Q :: if /instances/ are created from /classes/, what is it that creates
           our /classes/?

         * A :: It turns out that /classes/ are /instances/ of something, too:
           - In Python 3.X,
             /user-defined class objects/ are /instances/ of the object named ~type~,
             which is itself a /class/.

           - In Python 2.X,
             * /new-style classes/ inherit from ~object~, which is a /subclass/ of ~type~;

             * /classic classes/
               + are /instances/ of ~type~ and
               + are NOT created from a /class/.

     - =TODO=
     - =TODO=
     - =TODO=
     - =TODO=
     - =TODO=
     - =TODO=
     - =TODO=
     - =TODO=

**** TODO Metaclasses Are Subclasses of Type - 1366
**** TODO Class Statement Protocol - 1367

*** TODO Declaring Metaclasses - 1368
**** Declaration in 3.X - 1369
**** Declaration in 2.X - 1369
**** Metaclass Dispatch in Both 3.X and 2.X - 1370

*** TODO Coding Metaclasses - 1370
**** A Basic Metaclass - 1371
**** Customizing Construction and Initialization - 1372
**** Other Metaclass Coding Techniques - 1373

*** TODO Inheritance and Instance - 1378
**** Metaclass Versus Superclass - 1381
**** Inheritance: The Full Story - 1382

*** TODO Metaclass Methods - 1388
**** Metaclass Methods Versus Class Methods - 1389
**** Operator Overloading in Metaclass Methods - 1390

*** TODO Example: Adding Methods to Classes - 1391
**** Manual Augmentation - 1391
**** Metaclass-Based Augmentation - 1393
**** Metaclasses Versus Class Decorators: Round 2 - 1394

*** TODO Example: Applying Decorators to Methods - 1400
**** Tracing with Decoration Manually - 1400
**** Tracing with Metaclasses and Decorators - 1401
**** Applying Any Decorator to Methods - 1403
**** Metaclasses Versus Class Decorators: Round 3 (and Last) - 1404

*** TODO Chapter Summary - 1407
*** TODO Test Your Knowledge: Quiz - 1407
*** TODO Test Your Knowledge: Answers - 1408

** 41. All Good Things - 1409
*** The Python Paradox - 1409
**** On "Optional" Language Features - 1410
**** Against Disquieting Improvements - 1411
**** Complexity Versus Power - 1412
**** Simplicity Versus Elitism - 1412
**** Closing Thoughts - 1413

*** Where to Go From Here - 1414
*** Encore: Print Your Own Completion Certificate! - 1414

* Part IX. Appendixes
** A. Installation and Configuration - 1421
*** Installing the Python Interpreter 1421
**** Is Python Already Present? 1421
**** Where to Get Python 1422
**** Installation Steps 1423

*** Configuring Python 1427
**** Python Environment Variables 1427
**** How to Set Configuration Options 1429
**** Python Command-Line Arguments 1432
**** Python 3.3 Windows Launcher Command Lines 1435

*** For More Help 1436

** B. The Python 3.3 Windows Launcher - 1437
*** The Unix Legacy 1437
*** The Windows Legacy 1438
*** Introducing the New Windows Launcher 1439
*** A Windows Launcher Tutorial 1441
**** Step 1: Using Version Directives in Files 1441
**** Step 2: Using Command-Line Version Switches 1444
**** Step 3: Using and Changing Defaults 1445

*** Pitfalls of the New Windows Launcher 1447
**** Pitfall 1: Unrecognized Unix ~!#~ Lines Fail 1447
**** Pitfall 2: The Launcher Defaults to 2.X 1448
**** Pitfall 3: The New PATH Extension Option 1449

*** Conclusions: A Net Win for Windows 1450

** C. Python Changes and This Book - 1451
*** Major 2.X/3.X Differences 1451
**** 3.X Differences 1452
**** 3.X-Only Extensions 1453

*** General Remarks: 3.X Changes 1454
**** Changes in Libraries and Tools 1454
**** Migrating to 3.X 1455

*** Fifth Edition Python Changes: 2.7, 3.2, 3.3 1456
**** Changes in Python 2.7 1456
**** Changes in Python 3.3 1457
**** Changes in Python 3.2 1458

*** Fourth Edition Python Changes: 2.6, 3.0, 3.1 1458
**** Changes in Python 3.1 1458
**** Changes in Python 3.0 and 2.6 1459
**** Specific Language Removals in 3.0 1460

*** Third Edition Python Changes: 2.3, 2.4, 2.5 1462
*** Earlier and Later Python Changes 1463

** D. Solutions to End-of-Part Exercises - 1465
*** Part I, Getting Started 1465
*** Part II, Types and Operations 1467
*** Part III, Statements and Syntax 1473
*** Part IV, Functions and Generators 1475
*** Part V, Modules and Packages 1485
*** Part VI, Classes and OOP 1489
*** Part VII, Exceptions and Tools 1497

* Index
