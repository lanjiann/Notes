#+TITLE: Programming Erlang
#+SUBTITLE: Software for a Concurrent World
#+VERSION: 2nd
#+AUTHOR: Joe Armstrong
#+EDITED by: Susannah Davidson Pfalzer
#+STARTUP: overview
#+STARTUP: entitiespretty

* Introduction - xiii
** What's This Book About? - xiv
** Who Is This Book For? - xiv
** New In This Edition - xv
** Road Map - xv
** The Code in This Book - xvi
** Help! It Doesn't Work - xvi
** Acknowledgments - xvii
*** First Edition - xvii
*** Second Edition - xvii
   
* Part I — Why Erlang?
** TODO 1. Introducing Concurrency - 3
*** 1.1 Modeling Concurrency - 3
*** 1.2 Benefits of Concurrency - 6
*** 1.3 Concurrent Programs and Parallel Computers - 8
*** 1.4 Sequential vs. Concurrent Programming Languages - 9

** DONE 2. A Whirlwind Tour of Erlang - 11
   CLOSED: [2021-01-31 Sun 04:38]
*** DONE 2.1 The Shell - 11
    CLOSED: [2021-01-30 Sat 22:44]
    User commdnad ~erl~
    
    - Each expression must be ended with a ~.~ followed by a /whitespace character/.

    - whitespace character :: space, tab, or carriage return character.

    - /Rebind variables/ is *NOT allowed* in Erlang. 
      #+begin_src erlang
        X = 123.
        X * 2.
        X = 999.  % ** exception error: no match of right hand side value 999
      #+end_src
      
**** DONE The ~=~ operator - 12
     CLOSED: [2021-01-30 Sat 22:41]
     ~=~ is not assignment, and it is used for /pattern matching/.
     
**** DONE Syntax of Variables and Atoms - 13
     CLOSED: [2021-01-30 Sat 22:43]
     - /Erlang variables/ start with _uppercase characters_.

     - Identifiers that start with _lowercase characters_ are /atoms/.
       #+begin_src erlang
         abc = 123.
         % ** exception error: no match of right hand side value 123
       #+end_src
    
*** DONE 2.2 Processes, Modules, and Compilation - 13
    CLOSED: [2021-01-31 Sun 03:16]
    - /Erlang programs/ are built from a number of parallel /processes/.

    - /Processes/ evaluate /functions/ that are defined in /modules/.
      
    - /Modules/ are files with the _extension_ =.erl=
      and must be compiled _before_ they can be run.

    - Having compiled a /module/,
      we can evaluate the /functions/ in the /module/
      from the _shell_ OR _directly from the command line in an OS enviroment_.

**** DONE Compiling and Running "Hello World" in the Shell - 13
     CLOSED: [2021-01-30 Sat 23:23]
     #+begin_src erlang
       % hello.erl

       -module(hello).
       -export([start/0]).

       start() ->
           io.format("Hello world~n").
     #+end_src
     - Start the /Erlang shell/ in the directory where we stored =hello.erl= and run:
       1. ~c(hello).~
          * Output: ~{ok,hello}~

       2. ~hello:start().~
          * Output:
            Hello world
            ok

       3. ~halt().~
          Stop the /Erlang shell/.
     
     - The above way of compiling and running in /Erlang shell/ _works identically
       on all platforms._
       
**** DONE Compiling Outside the Erlang Shell - 14
     CLOSED: [2021-01-31 Sun 03:16]
     #+begin_src shell
       erlc hello.erl
       erl -noshell -s hello start -s init stop
       # Hello world
     #+end_src
     
     - The ~erlc~ command will produce an object code file called =hello.beam=.

     - The second command
       1. loads the module ~hello~;
       2. evaluates the function ~hello:start()~;
       3. evaluates the expression ~init:stop()~;
    
     - The advantage of using ~erlc~ is automation.
       We can
       * run ~erlc~ inside _rakefile_ or _makefiles_
         and
       * automate the build /process/.
       
*** DONE 2.3 Hello, Concurrency - 15
    CLOSED: [2021-01-31 Sun 04:38]
    A /process/ is a *lightweight virtual machine* that can _COMMUNICATE_ with other
    /processes/ _ONLY_ by SENDING and RECEIVING /messages/.

    - The first concurrent program we'll write is a _file server_.
      To transfer files between two machines, we need _TWO_ programs:
      * a _client_ that runs on one machine;
      * a _server_ that runs on a second machine.
        
      We'll make _TWO_ /modules/ called ~afile_client~ and ~afile_server~.
      
**** DONE The File Server Process - 15
     CLOSED: [2021-01-31 Sun 04:10]
     To create a /process/, call the primitive ~spawn(...)~.
     
     #+begin_src erlang
       -module(afile_server).
       -export([start/1, loop/1]).

       start(Dir) -> spawn(afile_server, loop [Dir]).

       loop(Dir) ->
           receive
               {Client, list_dir} ->
                   Client ! {self(), file:list_dir(Dir)};
               {Client, {get_file, File}} ->
                   Full = filename:join(Dir, File),
                   Client ! {self(), file:read_file(Full)};
           end,
           loop(Dir).
     #+end_src

     - In a sequential programming language, we have to be extremely careful to
       avoid _infinite loops_; we have *only ONE* /thread/ of control, and if this
       /thread/ gets stuck in a loop, we're in trouble.
         In Erlang, there is no such problem. A _server_ is just a program that
       services requests in an _infinite loop_ and that runs in parallel with any
       other tasks that we want to perform.

     - Test the code above:
       #+begin_src erlang
         c(afile_server).
         {ok,afile_server}

         FileServer = afile_server:start(".").
         % <0.47.0>

         FileServer ! {self(), list_dir}.
         % {<0.31.0>, list_dir}

         receive X -> X end.
         % {<0.47.0>,
         %  {ok,["afile_server.beam","processes.erl","attrs.erl","lib_find.erl",
         %      "dist_demo.erl","data1.dat","scavenge_urls.erl","test1.erl",
         %      ...]}}
       #+end_src

**** DONE The Client Code - 18
     CLOSED: [2021-01-31 Sun 04:26]
     #+begin_src erlang
       % afile_client.erl

       -module(afile_client).
       -export([ls/1, get_file/2]).

       ls(Server) ->
           Server ! {self(), list_dir},
           receive
               {Server, FileList} ->
                   FileList
           end.

       get_file(Server, File) ->
           Server ! {self(), {get_file, File}},
           receive
               {Server, Content} ->
                   Content
           end.
     #+end_src

     - Test the _client_ with the _server_ written in the previous section:
       #+begin_src erlang
         c(afile_server).
         c(afile_client).

         FileServer = afile_server:start(".").
         % <0.43.0>

         afile_client:get_file(FileServer, "missing").
         % {error,enoent}

         afile_client:get_file(FileServer, "afile_server.erl")
         % {ok,<<"-module(afile_server).\n-export([start/1])...."}
       #+end_src
       
     - =TODO=
       What you've seen so far is the basis of a FULLY BLOWN file server, but it
       is *not yet complete*. There are a lot of details associated with
       * *starting* and *stopping* the /server/,
       * *connecting* to a /socket/,
       * and so on.
         
       These will not be covered here.
     
**** DONE Improving the File Server - 20
     CLOSED: [2021-01-31 Sun 04:35]
     - In a real _server_, the _client_ and _server_ would run on DIFFERENT
       machines, so somehow we have to arrange that interprocess messages can
       pass
       * _NOT ONLY_ between /processes/ in the _SAME Erlang node_
       * _BUT_ between /Erlang processes/ located on _physically SEPARATED machines_.
     
     - =TODO= =NEXT=
       In _Chapter 17, Programming with Sockets, on page 263_,
       we'll see how to use a /TCP transport layer/ for /process communication/,
       and in _The File Server Revisited, on page 221_, we'll see how to implement
       the _file server_ directly in /distributed Erlang/.

*** DONE Exercises - 20
    CLOSED: [2021-01-31 Sun 04:38]
    1. Answer: ~erl~ and ~halt().~

    2. ...

    3. ...

    4. =TODO=
    
* TODO Part II — Sequential Programming
** TODO 3. Basic Concepts - 25
*** 3.1 Starting and Stopping the Erlang Shell - 25
**** Evaluating Commands in the Shell - 26
**** Things That Can Go Wrong - 26
**** Command Editing in the Erlang Shell - 27
     
*** 3.2 Simple Integer Arithmetic - 27
*** 3.3 Variables - 28
**** Erlang Variables Do Not Vary - 29
**** Variable Bindings and Pattern Matching - 30
**** Why Single Assignment Improves Our Programs - 32
     
*** 3.4 Floating-Point Numbers - 32
*** 3.5 Atoms - 33
*** 3.6 Tuples - 34
**** Creating Tuples - 35
**** Extracting Values from Tuples - 36
    
*** 3.7 Lists - 37
**** Terminology - 38
**** Defining Lists - 38
**** Extracting Elements from a Lists - 39
    
*** 3.8 Strings - 39
*** 3.9 Pattern Matching Again - 41
*** Exercises - 42

** TODO 4. Modules and Functions - 43
*** TODO 4.1 Modules Are Where We Store Code - 43
**** Common Errors - 45
**** Directories and Code Paths - 46
**** Adding Tests to Your Code - 46
**** Extending the Program - 47
**** Where to Put the Semicolons - 49
     
*** TODO 4.2 Back to Shopping - 50
*** TODO 4.3 Funs: The Basic Unit of Abstraction - 52
**** Functions That Have Funs As Their Arguments - 54
**** Functions That Return Funs - 55
**** Defining Your Own Control Abstractions - 56
     
*** TODO 4.4 Simple List Processing - 57
*** TODO 4.5 List Comprehensions - 59
**** Quicksort - 61
**** Pythagorean Triplets - 62
**** Anagrams - 63
     
*** TODO 4.6 BIFs - 63
*** TODO 4.7 Guards - 64
**** Guard Sequences - 64
**** Guard Examples - 65
**** Use of the true Guard - 67
    
*** TODO 4.8 case and if Expressions - 68
**** case Expressions - 68
**** if Expressions - 69
    
*** TODO 4.9 Building Lists in Natural Order - 70
*** TODO 4.10 Accumulators - 71
*** TODO Exercises - 72

** TODO 5. Records and Maps - 75
*** TODO 5.1 When to Use Maps or Records - 75
*** TODO 5.2 Naming Tuple Items with Records - 76
**** Creating and Updating Records - 77
**** Extracting the Fields of a Record - 77
**** Pattern Matching Records in Functions - 78
**** Records Are Tuples in Disguise - 78
    
*** TODO 5.3 Maps: Associative Key-Value Stores - 79
**** The Semantics of Maps - 79
**** Pattern Matching the Fields of a Map - 80
**** BIFs That Operate on Maps - 82
**** Ordering of Maps - 83
**** The JSON Bridge - 84
     
*** TODO Exercises - 85
     
** TODO 6. Error Handling in Sequential Programs - 87
*** 6.1 Handling Errors in Sequential Code - 88
*** 6.2 Trapping an Exception with ~try...catch~ - 89
**** ~try...catch~ Has a Value - 90
**** Shortcuts - 91
**** Programming Idioms with ~try...catch~ - 92
    
*** 6.3 Trapping an Exception with catch - 92
*** 6.4 Programming Style with Exceptions - 93
**** Improving Error Messages - 93
**** Code Where Error Returns Are Common - 94
**** Code Where Errors Are Possible but Rare - 94
**** Catching Every Possible Exception - 95
    
*** 6.5 Stack Traces - 95
*** 6.6 Fail Fast and Noisily, Fail Politely - 96
*** Exercises - 97

** TODO 7. Binaries and the Bit Syntax - 99
*** 7.1 Binaries - 99
**** Working with Binaries - 100
    
*** 7.2 The Bit Syntax - 101
**** Packing and Unpacking 16-Bits Color - 102
**** Bit Syntax Expressions - 103
**** Real-World Bit Syntax Examples - 105
***** Finding the Synchronization Frame in MPEG Data - 105
***** Unpacking COFF Data - 108
***** Unpacking the Header of an IPv4 Datagram - 110
     
*** 7.3 Bitstrings: Processing Bit-Level Data - 110
*** Exercises - 112

** TODO 8. The Rest of Sequential Erlang - 113
*** 8.1 apply - 115
*** 8.2 Arithmetic Expressions - 116
*** 8.3 Arity - 116
*** 8.4 Attributes - 117
**** Predefined Module Attributes - 117
**** User-Defined Attributes - 119
    
*** 8.5 Block Expressions - 120
*** 8.6 Booleans - 120
*** 8.7 Boolean Expressions - 121
*** 8.8 Character Set - 122
*** 8.9 Comments - 122
*** 8.10 Dynamic Code Loading - 122
*** 8.11 Erlang Preprocessor - 126
*** 8.12 Escape Sequences - 126
*** 8.13 Expressions and Expression Sequences - 127
*** 8.14 Function References - 128
*** 8.15 Include Files - 128
*** 8.16 List Operations ++ and - - - 129
*** 8.17 Macros - 129
**** Control Flow in Macros - 130
    
*** 8.18 Match Operator in Patterns - 131
*** 8.19 Numbers - 132
**** Integers - 132
**** Floats - 133
     
*** 8.20 Operator Precedence - 133
*** 8.21 The Process Dictionary - 134
*** 8.22 References - 135
*** 8.23 Short-Circuit Boolean Expressions - 135
*** 8.24 Term Comparisons - 136
*** 8.25 Tuple Modules - 137
*** 8.26 Underscore Variables - 137
*** Exercises - 138
- 
** TODO 9. Types - 141
*** 9.1 Specifying Data and Function Types - 141
*** 9.2 Erlang Type Notation - 143
**** The Grammar of Types - 143
**** Predefined Types - 144
**** Specifying the Input and Output Types of a Function - 145
**** Exported and Local Types - 146
**** Opaque Types - 147
    
*** 9.3 A Session with the Dialyzer - 148
**** Incorrect Use of a BIF Return Value - 149
**** Incorrect Arguments to a BIF - 150
**** Incorrect Program Logic - 150
**** Working with the Dialyzer - 151
**** Things That Confuse the Dialyzer - 151
    
*** 9.4 Type Inference and Success Typing - 152
*** 9.5 Limitations of the Type System - 155
*** Exercises - 157
- 
** TODO 10. Compiling and Running Your Program - 159
*** 10.1 Modifying the Development Environment - 159
**** Setting the Search Paths for Loading Code - 159
**** Executing a Set of Commands When the System Is Started - 161
    
*** 10.2 Different Ways to Run Your Program - 161
**** Compile and Run in the Eralng Shell - 162
**** Compile and Run from the Command Prompt - 162
**** Run As an Escript - 164
**** Programs with Command-Line Arguments - 165
     
*** 10.3 Automating Compilation with Makefiles - 166
**** A Makefile Template - 166
***** Specializing the Makefile Template - 168
    
*** 10.4 When Things Go Wrong - 169
**** Stopping Erlang - 169
**** Undefined (Missing) Code - 170
**** The Shell Isn't Responding - 170
**** My Makefile Doesn't Make - 172
**** Erlang Has Crashed and You Want to Read the Crash Dump - 172
    
*** 10.5 Getting Help - 172
*** 10.6 Tweaking the Environment - 173
*** Exercises - 174
- 
* TODO Part III — Concurrent and Distributed Programs
** 11. Real-World Concurrency - 177
** 12. Concurrent Programming - 181
*** 12.1 The Concurrency Primitives - 182
*** 12.2 Introducing Client-Server - 184
*** 12.3 Processes Are Cheap - 189
*** 12.4 Receive with a Timeout - 191
**** Receive with Timeout Value of Zero - 192
***** receive with Timeout Value of Infinity - 192
      
**** Implementation a Timer - 193
    
*** 12.5 Selective Receive - 193
*** 12.6 Registered Processes - 194
*** 12.7 A Word About Tail Recursion - 196
*** 12.8 Spawning with MFAs or Funs - 197
*** Exercises - 198

** 13. Errors in Concurrent Programs - 199
*** 13.1 Error Handling Philosophy - 199
**** Let Some Other Process Fix the Error - 200
**** Let It Crash - 200
**** Why Crash? - 201
    
*** 13.2 Error Handling Semantics - 202
*** 13.3 Creating Links - 203
*** 13.4 Groups of Processes That All Die Together - 204
*** 13.5 Setting Up a Firewall - 205
*** 13.6 Monitors - 205
*** 13.7 Error Handling Primitives - 206
*** 13.8 Programming for Fault Tolerance - 207
**** Performing an Action When a Process Dies - 207
**** Making a Set of Processes That All Die Together - 208
**** Making a Process That Never Die - 209
     
*** Exercises - 210

** 14. Distributed Programming - 211
*** 14.1 Two Models for Distribution - 212
*** 14.2 Writing a Distributed Program - 213
*** 14.3 Building the Name Server - 213
**** Stage 1: A Simple Name Server - 214
**** Stage 2: Client on One Node, Server on Second Node but Same Host - 215
**** Stage 3: Client and Server on Different Machines on the Same LAN - 216
**** Stage 4: Client and Server on Different Hosts in the Internet - 218
    
*** 14.4 Libraries and BIFS for Distributed Programming - 219
**** An Example of Remote Spawning - 220
**** The File Server Revisited - 221
    
*** 14.5 The Cookie Protection System - 222
*** 14.6 Socket-Based Distribution - 224
**** Controlling Processes with ~lib_chan~ - 224
**** The Server Code - 225
     
*** Exercises - 227

* TODO Part IV — Programming Libraries and Frameworks
** 15. Interfacing Techniques - 231
*** 15.1 How Erlang Communicates with External Programs - 232
*** 15.2 Interfacing an External C Program with a Port - 234
**** The C Program - 235
***** =example1_driver.c= - 236
***** =er1_comm.c= - 236
    
**** The Erlang Program - 238
**** Compiling and Linking the Post Program - 239
**** Run the Program - 239
     
*** 15.3 Calling a Shell Script from Erlang - 240
*** 15.4 Advanced Interfacing Techniques - 240
*** Exercises - 241
- 
** 16. Programming with Files - 243
*** 16.1 Modules for Manipulating Files - 243
*** 16.2 Ways to Read a File - 244
**** Reading All the Terms in the File - 244
**** Reading the Terms in the File One at a Time - 246
**** Reading the Lines in a File One at a Time - 247
**** Reading the Entire File into a Binary - 248
**** Reading a File with Random Access - 248
**** Reading MP3 Metadata - 249
     
*** 16.3 Ways to Write a File - 251
**** Writing a List of Terms to a File - 251
***** Aside - 252
      
**** Writing Lines to a File - 253
**** Writing an Entire File in One Operation - 253
***** Listing URLs from a File - 253
    
**** Writing to a Random-Access File - 255
     
*** 16.4 Directory and File Operations - 255
**** Finding Information About a File - 256
**** Copying and Deleting Files - 257
    
*** 16.5 Bits and Pieces - 258
*** 16.6 A Find Utility - 258
*** Exercises - 261
- 
** 17. Programming with Sockets - 263
*** 17.1 Using TCP - 263
**** Fetching Data from a Server - 264
**** A Simple TCP Server - 267
**** Sequential and Parallel Servers - 270
***** A Sequential Server - 271
***** A Parallel Server - 271
***** Notes - 272
     
*** 17.2 Active and Passive Sockets - 272
**** Active Message Reception (Nonblocking) - 273
**** Passive Message Reception (Blocking) - 274
**** The Hybrid Approach (Partial Blocking) - 274
    
*** 17.3 Error Handling with Sockets - 275
*** 17.4 UDP - 276
**** The Simplest UDP Server and Client - 277
**** A UDP Factorial Server - 278
**** UDP Packet Gotchas - 279
     
*** 17.5 Broadcasting to Multiple Machines - 280
*** 17.6 A SHOUTcast Server - 281
**** The SHOUTcast Protocol - 281
**** How the SHOUTcast Server Works - 282
**** Pseudocode for the SHOUTcast Server - 283
**** Running the SHOUTcast Server - 284
     
*** Exercises - 285

** 18. Browsing with Websockets and Erlang - 287
*** 18.1 Creating a Digital Clock - 288
*** 18.2 Basic Interaction - 291
*** 18.3 An Erlang Shell in the Browser - 292
*** 18.4 Creating a Chat Widget - 293
*** 18.5 IRC Lite - 295
*** 18.6 Graphics in the Browser - 299
*** 18.7 The Browser Server Protocol - 301
**** Sending a Message from Erlang to the Browser - 301
**** Messages from the Browser to Erlang - 302
     
*** Exercises - 303

** 19. Storing Data with ETS and DETS - 305
*** 19.1 Types of Table - 306
*** 19.2 ETS Table Efficiency Considerations - 308
*** 19.3 Creating an ETS Table - 309
*** 19.4 Example Programs with ETS - 310
**** The Trigram Iterator - 311
**** Build the Tables - 312
**** Table-Building Time - 312
**** Table Access Times - 313
**** And the Winners Is - 314
    
*** 19.5 Storing Tuples on Disk - 315
**** Example: A Filename Index - 315
    
*** 19.6 What Haven’t We Talked About? - 318
*** Exercises - 318

** 20. Mnesia: The Erlang Database - 321
*** 20.1 Creating the Initial Database - 321
*** 20.2 Database Queries - 322
**** Selecting All Data in a Table - 323
**** Choosing Data from a Table - 325
**** Conditionally Selecting Data from a Table - 325
**** Selecting Data from Two Tables (Joins) - 326
     
*** 20.3 Adding and Removing Data in the Database - 326
**** Adding a Row - 326
**** Removing a Row - 327
     
*** 20.4 Mnesia Transactions - 328
**** Aborting a Transaction - 329
**** Loading the Test Data - 331
**** The ~do()~ Function - 331
    
*** 20.5 Storing Complex Data in Tables - 332
*** 20.6 Table Types and Location - 333
**** Creating Tables - 334
**** Common Combinations of Table Attributes - 335
**** Table Behavior - 336
    
*** 20.7 The Table Viewer - 336
*** 20.8 Digging Deeper - 337
*** Exercises - 338

** 21. Profiling, Debugging, and Tracing - 339
*** 21.1 Tools for Profiling Erlang Code - 340
*** 21.2 Testing Code Coverage - 341
*** 21.3 Generating Cross-References - 342
*** 21.4 Compiler Diagnostics - 343
**** Head Mismatch - 343
**** Unbound Variables - 344
**** Unterminated String - 344
**** Unsafe Variables - 344
**** Shadowed Variables - 345
    
*** 21.5 Runtime Diagnostics - 346
**** The Stack Trace - 346
    
*** 21.6 Debugging Techniques - 347
**** ~io:format~ Debugging - 348
**** Dumping to a File - 349
**** Using the Error Logger - 349
     
*** 21.7 The Erlang Debugger - 350
*** 21.8 Tracing Messages and Process Execution - 352
**** Using the Trace Libraries - 354
    
*** 21.9 Frameworks for Testing Erlang Code - 355
*** Exercises - 356

** 22. Introducing OTP - 359
*** 22.1 The Road to the Generic Server - 360
**** Server 1: The Basic Server - 360
**** Server 2: A Server with Transactions - 362
**** Server 3: A Server with Hot Code Swapping - 363
**** Server 4: Transactions and Hot Code Swapping - 365
**** Server 5: Even More Fun - 366

*** 22.2 Getting Started with ~gen_server~ - 368
**** Step 1: Decide on the Callback Module Name - 369
**** Step 2: Write the Interface Routines - 369
**** Step 3: Write the Callback Routines - 369
     
*** 22.3 The ~gen_server~ Callback Structure - 372
**** Starting the Server - 372
**** Calling the Server - 373
**** Calls and Casts - 374
**** Spontaneous Messages to the Server - 374
**** Hasta Ia Vista, Baby - 375
**** Code Change - 375
     
*** 22.4 Filling in the ~gen_server~ Template - 376
*** 22.5 Digging Deeper - 377
*** Exercises - 378
- 
** 23. Making a System with OTP - 381
*** 23.1 Generic Event Handling - 382
*** 23.2 The Error Logger - 384
**** Logging an Error - 385
**** Configuring the Error Logger - 386
***** The Standard Error Loggers - 386
***** SASL with No Configuration - 387
***** Controlling What Gets Logged - 387
***** Text File and Shell - 388
***** Rotating Log and Shell - 389
***** Production Environment - 390
      
**** Analyzing the Errors - 390
     
*** 23.3 Alarm Management - 392
**** Reading the Log - 393
    
*** 23.4 The Application Servers - 394
**** The Prime Number Server - 394
**** The Area Server - 395
     
*** 23.5 The Supervision Tree - 396
*** 23.6 Starting the System - 400
*** 23.7 The Application - 403
*** 23.8 File System Organization - 405
*** 23.9 The Application Monitor - 406
*** 23.10 How Did We Make That Prime? - 407
*** 23.11 Digging Deeper - 409
*** Exercises - 410
- 
* TODO Part V — Building Applications
** 24. Programming Idioms - 413
*** 24.1 Maintaining the Erlang View of the World - 413
*** 24.2 A Multipurpose Server - 416
*** 24.3 Stateful Modules - 418
**** A Counter with State - 418
     
*** 24.4 Adapter Patterns - 419
*** 24.5 Intentional Programming - 422
*** Exercises - 423

** 25. Third-Party Programs - 425
*** 25.1 Making a Shareable Archive and Managing Your Code with Rebar - 425
**** Installing Rebar - 426
**** Making a New Project on GitHub - 426
**** Cloning the Project Locally - 426
**** Making an OTP Application - 426
**** Publicizing Your Project - 428
     
*** 25.2 Integrating External Programs with Our Code - 428
*** 25.3 Making a Local Copy of the Dependencies - 430
*** 25.4 Building Embedded Web Servers with Cowboy - 431
*** Exercises - 437

** 26. Programming Multicore CPUs - 439
*** 26.1 Good News for Erlang Programmers - 440
*** 26.2 How to Make Programs Run Efficiently on a Multicore CPU - 441
**** Use Lots of Processes - 441
**** Avoid Side Effects - 442
***** Don't Use Shared ETS or DETS Tables - 442
      
**** Avoid Sequential Bottlenecks - 443
***** A Distributed Ticket-Booking System - 444
    
*** 26.3 Parallelizing Sequential Code - 445
**** When Can We Use pmap? - 446
***** Granularity of Concurrency - 446
***** Don't Create Too Many Processes - 446
***** Think About the Abstractions You Need - 446
    
*** 26.4 Small Messages, Big Computations - 447
**** Running SMP Erlang - 448
    
*** 26.5 Parallelizing Computations with mapreduce - 451
**** mapreduce - 452
     
*** Exercises - 456

** 27. Sherlock’s Last Case - 457
*** 27.1 Finding Similarities in Data - 458
*** 27.2 A Session with Sherlock - 458
**** Fetching and Preprocessing the Data - 459
**** Finding the Most Similar Mail to a Given File - 460
**** Searching Mails for a Specific Author, Date, or Subject - 462
     
*** 27.3 The Importance of Partitioning the Data - 463
*** 27.4 Adding Keywords to the Postings - 464
**** The Significance of a Word: The TF*IDF Weight - 465
**** Cosine Similarity: The Similarity of Two Weighted Vectors - 466
**** Similarity Queries - 467
     
*** 27.5 Overview of the Implementation - 467
*** 27.6 Exercises - 469
**** Finding Similarities Between Modules - 469
**** Finding the History of a Module - 469
**** Analyzing Data in Other Mailing Lists - 469
**** Beautiful Soup - 469
**** Improving the Text Analyses - 469
**** Faceted Search - 469
**** Make a Web Interface - 469
**** Grade the Mails - 470
**** Graph the Results - 470
**** Turn the Collection of Mails into an Ebook - 470
    
*** 27.7 Wrapping Up - 470

* TODO A1. OTP Templates - 471
** A1.1 The Generic Server Template - 471
** A1.2 The Supervisor Template - 474
** A1.3 The Application Template - 475

* TODO A2. A Socket Application - 477
** A2.1 An Example - 477
*** Step 1: Write a Configuration File - 478
*** Step 2: Write the Code for the Server - 478
*** Step 3: Starting the Server - 479
*** Step 4: Accessing the Server Over the Network - 479
   
** A2.2 How ~lib_chan~ Works - 479
*** ~lib_chan~ - 480
*** ~lib_chan_mm~: The Middle Man - 480
*** ~lib_chan_cs~ - 482
*** ~lib_chan_auth~ - 482
   
** A2.3 The ~lib_chan~ Code - 483
*** ~lib_chan~ - 483
*** ~lib_chan_cs~ - 487
*** ~lib_chan_mm~ - 490
*** ~lib_chan_auth~ - 491
 
* TODO A3. A Simple Execution Environment - 493
** A3.1 How Erlang Starts - 494
** A3.2 Running Some Test Programs in SEE - 496
** A3.3 The SEE API - 499
** A3.4 SEE Implementation Details - 500
*** The SEE Main Program - 500
*** The Client-Server Model in SEE - 501
*** The Code Server - 503
*** The Error Logger - 504
*** The Halt Demon - 504
*** The I/O Server - 504
*** Environment Server - 505
*** Support for Global Processes - 506
*** Support for Processes - 507
*** Utilities - 507
    
** A3.5 How Code Gets Loaded in Erlang - 508
** Exercises - 509
 
* TODO Index - 511
