#+TITLE: Elixir
#+VERSION: 1.11
#+AUTHOR: Community
#+STARTUP: entitiespretty
#+STARTUP: overview

* TODO Getting Started
** DONE 1. Introduction
   CLOSED: [2021-01-25 Mon 20:02]
   - In this tutorial, we are going to teach you about Elixir fundamentals:
     * the language _syntax_
     * how to *define* /modules/
     * how to manipulate the characteristics of _common data structures_, and more.

   - This chapter will focus on ensuring that Elixir is installed and that you
     can successfully run Elixir's Interactive Shell, called IEx.
     
   - Our requirements are (see =elixir -v=):
     * Elixir 1.5.0 onwards
     * Erlang/OTP 19 onwards
     
*** 1. Installation
    If you haven't yet installed Elixir, visit our installation page. Once you
    are done, you can run ~elixir --version~ to get the current Elixir version.
    
*** 2. Interactive mode
    - After installation you will see three new executables:
      * iex
      * elixir
      * elixirc
      
    - Example (use REPL):
      #+begin_src elixir
        40 + 2
        # 42

        "hello" <> " world"
        # "hello world"
      #+end_src

    - To exit _iex_ press Ctrl+C twice.

    - In Windows, run =iex --werl=
      
*** 3. Running scripts
    #+begin_src elixir
      # simple.exs
      IO.puts "Hello world from Elixir"
    #+end_src
    
    Run it
    #+begin_src shell
      elixir simple.exs
      # Hello world from Elixir
    #+end_src
    
    - Later on we will learn =TODO=
      * how to *compile* Elixir code (in Chapter 8)
      * how to *use* the _Mix build tool_ (in the Mix & OTP guide).
    
*** TODO 4. Asking questions
    
** DONE 2. Basic types
   CLOSED: [2021-01-25 Mon 22:04]
   #+begin_src elixir
     1          # integer
     0x1F       # integer
     1.0        # float
     true       # boolean
     :atom      # atom / symbol
     "elixir"   # string
     [1, 2, 3]  # list
     {1, 2, 3}  # tuple
   #+end_src
   
*** DONE 1. Basic arithmetic
    CLOSED: [2021-01-25 Mon 20:31]
    #+begin_src elixir
      1 + 2   # 3
      5 * 5   # 25
      10 / 2  # 5.0
      div(10, 2)  # 5 -- integer division
      div 10, 2   # 5
      rem 10, 3   # 1
    #+end_src
    - _ALLOW_ to _drop the parentheses_ when invoking named functions.
      * This feature gives a cleaner syntax when writing declarations and
        control-flow constructs.

    - _Shortcut notations_ for entering /binary/, /octal/, and
      /hexadecimal numbers/:
      #+begin_src elixir
        0b1010  # 10
        0o777   # 511
        0x1F    # 31
      #+end_src
      
    - Float numbers (64-bit double precision)
      #+begin_src elixir
        1.0      # 1.0
        1.0e-10  # 1.0e-10
      #+end_src

    - ~round~ and ~trunc~
      #+begin_src elixir
        round(3.58)  # 4
        trunc(3.58)  # 3
      #+end_src
    
*** DONE 2. Identifying functions and documentation
    CLOSED: [2021-01-25 Mon 22:04]
    Functions in Elixir are identified by both their /name/ and their /arity/. 
    
    - Use ~h~ function to how documentation for any function:
      run ~h trunc/1~ in IEx.
      * This will work, even though ~trunc/1~ is actually defined in the /module/
        ~Kernel~. This is because all functions in ~Kernel~ will automatically
        imported into our namespace.

      * More often, for /funcitons/ _NOT in ~Kernel~,_ we hould ue full path:
        ~h Kernel.trunc/1~
    
    - Invoking ~h~ without argument displays the documentation for ~IEx.Helpers~,
      which is where ~h~ and other functionality is defined.
      
*** DONE 3. Booleans
    CLOSED: [2021-01-25 Mon 20:33]
    ~true~ and ~false~
    
    - ~is_boolean/1~ function

    - ~is_integer/1~, ~is_float/1~, and ~is_number/1~.
    
*** DONE 4. Atoms
    CLOSED: [2021-01-25 Mon 20:40]
    - atom :: a constant whose value is its own name.

    - Some other languages call these /symbols/.
    
    - They are often useful to enumerate over distinct values, such as:
      #+begin_src elixir
        :apple   # :apple
        :orange  # :orange
      #+end_src

    - Equality check:
      #+begin_src elixir
        :apple == :apple   # true
        :apple == :orange  # false
      #+end_src

    - the /boolean constants/ ~true~ and ~false~ are also /atoms/:
      #+begin_src elixir
        true == :true       # true
        is_atom(false)      # true
        is_boolean(:false)  # true
      #+end_src
      Elixir allows you to skip the leading ~:~ for the /atoms/ ~false~, ~true~,
      and ~nil~.

    - Finally, Elixir has a construct called aliases which we will explore later. =TODO=
      /Aliases/ *start in upper case* and are also /atoms/:
      #+begin_src elixir
        is_atom(Hello)  # true
      #+end_src

*** DONE 5. Strings
    CLOSED: [2021-01-25 Mon 21:02]
    - /String/ in UTF-8:
      #+begin_src elixir
        "hellö"  # "hellö"
      #+end_src
      In Windows, you may use a terminal that doesn't use UTF-8 by default.
      Run ~chcp 65001~ in your current session before entering IEx.

    - /String interpolation/:
      #+begin_src elixir
        string = :word
        "hellö #{string}"  # "hellö world"
      #+end_src

    - /Strings/ can have _line breaks_ in them.
      You can introduce them using escape sequences:
      #+begin_src elixir
        iex> "hello
        ...> world"
        # "hello\nworld"

        iex> "hello\nworld"
        "hello\nworld"
      #+end_src

    - You can print a /string/ using the ~IO.puts/1~ /function/ from the ~IO~ /module/:
      #+begin_src elixir
        iex> IO.puts "hello\nworld"
        hello
        world
        :ok
      #+end_src
      Notice that the ~IO.puts/1~ /function/ *returns* the /atom/ ~:ok~ after printing.

    - /Strings/ in Elixir are _represented internally_ by *contiguous sequences of
      bytes* known as /binaries/:
      #+begin_src elixir
        is_binary("hellö")  # true
      #+end_src

    - Get the _number of bytes_ in a /string/:
      #+begin_src elixir
        byte_size("hellö")  # 6
      #+end_src
      
    - Notice that the _number of bytes_ in that /string/ is 6, even though it has
      5 /graphemes/.
        That's because the /grapheme/ =“ö”= takes 2 bytes to be represented in
      UTF-8. We can get the actual length of the /string/, based on the number of
      /graphemes/, by using the ~String.length/1~ /function/:
      #+begin_src elixir
        String.length("hellö")  # 5
      #+end_src
      
    - The ~String~ /module/
      contains a bunch of /functions/ that _operate on_ /strings/ as defined in
      the /Unicode standard/
      #+begin_src elixir
        String.upcase("hellö")  # "HELLÖ"
      #+end_src
      
*** DONE 6. Anonymous functions
    CLOSED: [2021-01-25 Mon 21:58]
    #+begin_src elixir
      add = fn a, b -> a + b end
      add.(1, 2)        # 3
      is_function(add)  # true

      x = 42
      (fn -> x = 0 end).()  # 0
      x  # 42
    #+end_src
    
    - The ~.~ in the _anonymous function invocations_ is used to distinguish the 
      /anonymous function/ ~add~ and the named function ~add/2~.
      * In Elixir, named functions can only be defined within a /module/.
    
*** DONE 7. (Linked) Lists
    CLOSED: [2021-01-25 Mon 21:17]
    - Elixir uses _square brackets_ to specify a _list_ of values.
      Values can be of *any* type:
      #+begin_src elixir
        [1, 2, true, 3]   # [1, 2, true, 3]
        length [1, 2, 3]  # 3
      #+end_src

    - Two /lists/ can be *concatenated* or *subtracted* using the ~++/2~ and ~--/2~
      operators respectively:
      #+begin_src elixir
        [1, 2, 3] ++ [4, 5, 6]
        # [1, 2, 3, 4, 5, 6]

        [1, true, 2, false, 3, true] -- [true, false]
        # [1, 2, 3, true]
      #+end_src

    - List operators *NEVER modify* the existing list.
      We say that Elixir data structures are *immutable*.

    - ~hd/1~ and ~tl/1~
      #+begin_src elixir
        list = [1, 2, 3]
        hd(list)  # 1
        tl(list)  # [2, 3]
      #+end_src

    - Sometimes you will create a /list/ and it will return a _value in single quotes_.
      For example:
      #+begin_src elixir
        [11, 12, 13]               # '\v\f\r'
        [104, 101, 108, 108, 111]  # 'hello'
      #+end_src
      When Elixir sees a /list/ of _printable ASCII numbers_, Elixir will *print
      that as a /charlist/ (literally a list of characters).*
      * /Charlists/ are quite common when interfacing with existing Erlang code.

      * Whenever you see a value in IEx and you are not quite sure what it is,
        you can use the ~i/1~ to retrieve information about it:
        #+begin_src elixir
          i 'hello'
          Term
            'hello'
          Data type
            List
          Description
            ...
          Raw representation
            [104, 101, 108, 108, 111]
          Reference modules
            List
          Implemented protocols
            ...
        #+end_src

    - Keep in mind *single-quoted representation* and *double-quoted representation*
      are not equivalent in Elixir as they are represented by different types:
      #+begin_src elixir
        'hello' == "hello"
        # false
      #+end_src
      * Single quotes are /charlists/
      * Double quotes are /strings/
      =TODO= More in _"Binaries, strings and charlists"_
    
*** DONE 8. Tuples
    CLOSED: [2021-01-25 Mon 21:38]
    - tuple :: curly bracket delimited, comma separated.
    
    - Example:
      #+begin_src elixir
        pair = {:ok, "hello"}

        tuple_size pair  # 2

        put_elem(pair, 1, "wolrd")  # {:ok, "world"}
      #+end_src
    
*** DONE 9. Lists or tuples?
    CLOSED: [2021-01-25 Mon 21:52]
    - /Lists/ are /linked lists/ that stored in memory with no contiguous memory
      guarantee.

    - /Tuples/ are stored in contiguously in memory.
      * One very common use case for /tuples/ is to use them to return *extra*
        information from a function. For example,
        #+begin_src elixir
          File.read("path/to/existing/file")
          # {:ok, "... contents ..."}

          File.read("path/to/unknown/file")
          # {:error, :enoent}
        #+end_src

    - Elixir convention of function names that used to count elements in a data
      structure:
      * Constant time: ~size~
        + ~byte_size/1~ (for the number of /bytes/ in a /string/)
        + ~tuple_size/1~

      * Linear time: ~length~
        + ~length/1~ (for list length)
        + ~String.length/1~ (for the number of frapheme in a string)
    
** DONE 3. Basic operators
   CLOSED: [2021-01-25 Mon 22:08]
   - ~or~, ~and~, and ~not~ are for boolean expresions only.
     * ~and~ and ~or~ are mapped from ~Erlang~'s ~andalso~ and ~orelse~, respectively.

   - ~||~, ~&&~, and ~!~ accept arguments of ANY type.
     * All values *excpet* ~false~ and ~nil~ will evaluate to ~true~.

   - Both ~==~ and ~===~ exist.
     The latter is more strict when comparing /integer/ and /floats/.
       
   - Order of different types values:
     *number < atom < reference < function < port < pid < tuple < map < list < bitstring*
     
** DONE 4. Pattern matching
   CLOSED: [2021-01-25 Mon 22:22]
*** DONE 1. The match operator
    CLOSED: [2021-01-25 Mon 22:16]
    In Elixir, ~=~ is actually the /match operator/.
    
*** DONE 2. Pattern matching
    CLOSED: [2021-01-25 Mon 22:16]
    #+begin_src elixir
      [head | tail] = [1, 2, 3]
      # [1, 2, 3]

      head  # 1
      tail  # [2, 3]
    #+end_src
    
*** DONE 3. The pin operator 
    CLOSED: [2021-01-25 Mon 22:22]
    Variable in Elixir can be *rebound*.
    Ue the /pin operator/ to avoid /rebound/.
    
    #+begin_src elixir
      x = 1
      [^x, 2, 3] = [1, 2, 3]  # [1, 2, 3]
      {y, ^x} = {2, 1}        # {2, 1}

      {y, ^x} = {2, 2}
      # ** (MatchError) no match of right hand side value: {2, 2}
    #+end_src

    - If a variable is mentioned *more than once* in a pattern,
      all references should bind to the *SAME* value:
      #+begin_src elixir
        {x, x} = {1, 1}  # {1, 1}

        {x, x} = {1, 2}  # ** (MatchError) no match of right hand side value: {1, 2}
      #+end_src

    - ~_~ in pattern is supported.
      * The variable ~_~ is special in that it can *never* be read from.
        Trying to read from it gives a _compile error_.
    
** TODO 5. ~case~, ~cond~, and ~if~
*** DONE 1. ~case~
    CLOSED: [2021-01-25 Mon 22:35]
    #+begin_src elixir
      ## Basic
      ##---------
      case {1, 2, 3} do
        {4, 5, 6} -> "This clause won't match"
        {1, x, 3} -> "This clause will match and bind x to 2 in thi clause"
        _         -> "This clause would match any value"
      end

      # "This clause will match and bind x to 2 in thi clause"


      ## Pin operator
      ##-------------
      x = 1

      case 10 do
        ^x -> "Won't match"
        _  -> "Will match"
      end

      # "Will match"


      ## Guards
      ##-------------
      case {1, 2, 3} do
        {1, x, 3} when x > 0 -> "Will match"
        _                    -> "Would match, if guard condition were not satisfied"
      end

      # "Will match"
    #+end_src

    - Anonymous function can also have *MULTIPLE* clauses and /guards/:
      #+begin_src elixir
        f = fn
          x, y when x > 0 -> x + y
          x, y            -> x * y
        end

        f.(1, 3)   # 4
        f.(-1, 3)  # -3
      #+end_src
      * The number of arguments in EACH /anonymous function clause/ needs to be the
        *SAME*, otherwise an error is raised.
        #+begin_src elixir
          f2 = fn
            x, y when x > 0 -> x + y
            x, y, z         -> x * y + z
          end

          # ** (CompileError) iex:1: cannot mix clauses with different arities in anonymous functions
        #+end_src
    
*** DONE 2. ~cond~
    CLOSED: [2021-01-25 Mon 22:39]
    #+begin_src elixir
      cond do
        2 + 2 == 5 -> "This will not be true"
        2 * 2 == 3 -> "Nor this"
        1 + 1 == 2 -> "But this will"
      end

      # "But this will"
    #+end_src
    
*** DONE 3. ~if~ and ~unless~
    CLOSED: [2021-01-25 Mon 22:41]
    ~if/2~ and ~unless/2~ are implemented as /macros/.
    They aren't special language constructs in Elixir.
    
*** TODO 4. ~do/end~ blocks - =RE-NOTE=
    At this point, we have learned _FOUR_ /control structures/: ~case~, ~cond~,
    ~if~, and ~unless~, and they were all wrapped in ~do/end~ blocks.
    It happens we could *also write* if as follows: ~if true, do: 1 + 2~

    - Notice how the example above has a comma between true and do:, that’s
      because it is using Elixir’s regular syntax where each argument is
      separated by a comma. We say this syntax is using keyword lists. We can
      pass else using keywords too:
      #+begin_src elixir
        if false, do: :this, else: :that
        #=> :that
      #+end_src

    - ~do/end~ blocks are a syntactic convenience built on top of the keyword ones.
      That’s why ~do/end~ blocks do not require a comma between the previous
      argument and the block. They are useful exactly because they remove the
      verbosity when writing blocks of code. These are equivalent:
      #+begin_src elixir
        if true do
          a = 1 + 2
          a + 10
        end
        #=> 13


        if true, do: {
          a = 1 + 2
          a + 10
        }
        #=> 13
      #+end_src

    - =IMPORTANT=
      One thing to keep in mind when using ~do/end~ blocks is they are
      *ALWAYS bound to the _outermost_ /function call/.*
      For example, the following expression:
      #+begin_src elixir
        is_number if true do
          1 + 2
        end
        ## **(CompileError) iex:1: undefined function is_number/2
      #+end_src
      
      would be parsed as:
      
      #+begin_src elixir
        is_number(if true) do
          1 + 2
        end
        ## **(CompileError) iex:1: undefined function is_number/2
      #+end_src
      which leads to an undefined function error because that invocation passes
      two arguments, and is_number/2 does not exist. The if true expression is
      invalid in itself because it needs the block, but since the arity of
      is_number/2 does not match, Elixir does not even reach its evaluation.

      * Adding *explicit parentheses* is enough to bind the block to ~if~:
        #+begin_src elixir
          is_number(if true do
            1 + 2
          end)

          #=> true
        #+end_src

    - /Keyword lists/
      * play an important role in the language and
      * are quite common in many /functions/ and /macros/.

    - =NEXT=
      We will explore them a bit more in a future chapter.
      Now it is time to talk about “Binaries, strings, and char lists”.
   
** TODO 6. Binaries, strings, and charlists
*** 1. Unicode and Code Points
*** 2. UTF-8 and Encodings
*** 3. Bitstrings
*** 4. Binaries
*** 5. Charlists
   
** DONE 7. Keyword lists and maps
   CLOSED: [2021-01-27 Wed 00:46]
   In Elixir, we have TWO main /associative data structures/:
   - /keyword lists/
   - /maps/
   
*** DONE 1. Keyword lists
    CLOSED: [2021-01-26 Tue 01:42]
    - Equivalent way of definitions:
      #+begin_src elixir
        list = [{:a, 1}, {:b, 2}]  #=> [a: 1, b: 2]
        list == [a: 1, b: 2]       #=> true
      #+end_src

    - Concatenate:
      #+begin_src elixir
        list ++ [c: 3]  #=> [a: 1, b: 2, c: 3]

        [a: 0] ++ list  #=> [a: 0, a: 1, b: 2]
      #+end_src

    - On lookup, the first match will be picked:
      #+begin_src elixir
        new_list = [a: 0] ++ list  #=> [a: 0, a: 1, b: 2]
        new_list[:a]               #=> 0
      #+end_src

    - /Keyword lists/ are important because they have *THREE* _special
      characteristics_:
      * Keys must be /atoms/.
      * Keys are *ordered*, as specified by the developer.
      * Keys can be given *more than once*.

    - For example, =TODO=
      the *Ecto* library makes use of these features to provide an elegant DSL for
      writing database queries:
      #+begin_src elixir
        query = from w in Weather,
              where: w.prcp > 0,
              where: w.temp < 20,
              select: w
      #+end_src

    - These characteristics are what prompted /keyword lists/ to be the default
      mechanism for passing _options_ to /functions/ in Elixir.
        In chapter 5, when we discussed the ~if/2~ /macro/, we mentioned that
      the following syntax is supported:
      #+begin_src elixir
        if false, do: :this, else: :that
      #+end_src
      * In fact, the call above is equivalent to:
        #+begin_src elixir
          if(false, [do: :this, else: :that])  #=> :that

          if(false, [{:do, :this}, {:else, :that}])  #=> :that
        #+end_src
        *In general, when the /keyword list/ is the _LAST argument_ of a /function/,
        the _square brackets_ are _optional_.*

    - It is rarely done that in practice pattern match /keyword lists/, since
      pattern matching on lists requires the number of items and their order to
      match

    - In order to manipulate /keyword lists/, Elixir provides the =Keyword= module.

    - For the linear performance reason, /keyword lists/ are used in Elixir *mainly
      for passing optional values.* If you need to store many items or guarantee
      one-key associates with at maximum one-value, you should use /maps/ instead.
      
*** DONE 2. Maps
    CLOSED: [2021-01-26 Tue 16:46]
    - Syntax illustrated by an example:
      #+begin_src elixir
        map = %{:a => 1, 2 => :b}  #=> %{2 => :b, :a => 1}

        map[:a]  #=> 1
        map[2]   #=> :b
        map[:c]  #=> nil
      #+end_src

    - Compared to /keyword lists/, we can already see _TWO_ DIFFERENCES:
      * Maps allow *any* value as a /key/.
      * Maps' /keys/ do *not* follow any _ordering_.

    - Pattern match /maps/ always match on a subset of the given value:
      #+begin_src elixir
        %{} = %{:a => 1, 2 => :b}         #=> %{2 => :b, :a => 1}

        %{:a => a} = %{:a => 1, 2 => :b}  #=> %{2 => :b, :a => 1}
        a  # 1

        %{:c => c} = %{:a => 1, 2 => :b}
        # ** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}
      #+end_src

    - The ~Map~ /module/ provides a _very similar API_ to the ~Keyword~ /module/
      with convenience /functions/ to MANIPULATE /maps/:
      #+begin_src elixir
        Map.get(%{:a => 1, 2 => :b}, :a)     #=> 1
        Map.put(%{:a => 1, 2 => :b}, :c, 3)  #=> %{2 => :b, :a => 1, :c => 3}
        Map.to_list(%{:a => 1, 2 => :b})     #=> [{2, :b}, {:a, 1}]
      #+end_src

    - /Maps/ have the following syntax for *updating* a _key's value_:
      #+begin_src elixir
        map = %{:a => 1, 2 => :b}  #=> %{2 => :b, :a => 1}
        %{map | 2 => "two"}        #=> %{2 => "two", :a => 1}

        %{map | :c => 3}
        #=> ** (KeyError) key :c not found in %{2 => :b, :a => 1}
      #+end_src

    - When *all* the /keys/ in a /map/ are /atoms/,
      you can use the /keyword syntax/ for convenience:
      #+begin_src elixir
        map = %{a: 1, b: 2}  #=> %{a: 1, b: 2}
      #+end_src
      
    - Another interesting property of /maps/ is that they provide their OWN syntax
      for *accessing* /atom keys/:
      #+begin_src elixir
        map = %{:a => 1, 2 => :b}  #=> %{2 => :b, :a => 1}

        map.a #=> 1

        map.c
        #=> ** (KeyError) key :c not found in: %{2 => :b, :a => 1}
      #+end_src
      Elixir developers typically
      *PREFER to use the ~map.field~ syntax and pattern matching*
      instead of the /functions/ in the ~Map~ /module/ when working with /maps/
      because they lead to an /assertive style of programming/.

      * =TODO=
        [[https://dashbit.co/blog/writing-assertive-code-with-elixir][This blog post by José Valim]] provides insight and examples on how you
        get more concise and faster software by writing assertive code in
        Elixir.
      
*** DONE 3. Nested data structures
    CLOSED: [2021-01-27 Wed 00:46]
    Often we will have _/maps/ *inside* /maps/,_ or even _/keywords lists/
    *inside* /maps/,_ and so forth.
      Elixir provides conveniences for MANIPULATING _nested data structures_ via
    the ~put_in/2~, ~update_in/2~ and other /macros/ giving the same conveniences
    you would find in imperative languages while keeping the immutable properties
    of the language

    - Imagine you have the following structure:
      #+begin_src elixir
        users = [
          john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
          mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
        ]
        # =>
        # [john: %{age: 27, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
        #  mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}]

        ## Access the value of `john`
        ##---------------------------
        users[:john].age  #=> 27


        ## Update the value with a expression:
        ##---------------------------
        users = put_in users[:john].age, 31
        #=> [john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
        #    mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}]


        ## Update the value with a function:
        ##---------------------------
        users = update_in users[:mary].languages, fn languages -> List.delete(languages, "Clojure") end
        #=> [john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
        #    mary: %{age: 29, languages: ["Elixir", "F#"], name: "Mary"}]
      #+end_src
      * More to learn (Check the ~Kernel~ module):
        + ~get_and_update_in/2~:
          extract a value and update the data structure at once.

        + ~put_in/3~, ~update_in/3~, ~get_and_update_in/3~:
          dynamic access into the data structure.
   
** DONE 8. Modules and Functions
   CLOSED: [2021-01-26 Tue 01:10]
   We use the ~defmodule~ /macro/ to define /modules/.
   We use the ~def~ /macro/ to define /functions/ in /modules/.
   
   - Example:
     #+begin_src elixir
       defmodule Math do
         def sum(a, b) do
           a + b
         end
       end
     #+end_src
     
*** DONE 1. Compilation
    CLOSED: [2021-01-26 Tue 00:29]
    - Steps of compilation and use: 
      1. Write the code above in file =math.ex=.
      2. Compile ~elixirc math.ex~, and get the file =Elixir.Math.beam= containing bytecode.
      3. Start IEx in the same directory of the bytecode file from step 2.
      4. Then you can call ~Math.sum(1, 2)~ in IEx.
    
    - Elixir projects are usually organized into three directories:
      * =ebin= - contains the compiled bytecode
      * =lib= - contains Elixir code (usually =.ex= files)
      * =test= - contains tests (usually =.exs= files)

    - =TODO=
      When working on actual projects, the build tool called =mix= will be
      responsible for compiling and setting up the proper paths for you.

    - For learning purposes,
      Elixir also supports a *scripted mode* which
      * is _more flexible_
      * does *NOT generate* any compiled artifacts.
        
*** DONE 2. Scripted mode
    CLOSED: [2021-01-26 Tue 00:33]
    #+begin_src elixir
      defmodule Math do
        def sum(a, b) do
          a + b
        end
      end

      IO.puts Math.sum(1, 2)
    #+end_src
    Run it: ~elixir math.exs~.
    
    - =.ex= files used for compiling to =.beam= files,
      while =.exs= files are used for scripting.
    
*** DONE 3. Named functions
    CLOSED: [2021-01-26 Tue 00:40]
    - ~defp/2~ is used to define /private functions/.
    
    - /Function declarations/ also support /guards/ and /multiple clauses/.
      * Example:
        #+begin_src elixir
          defmodule Math do
            def zero?(0) do
              true
            end

            def zero?(x) when is_integer(x) do
              false
            end
          end

          IO.puts Math.zero?(0)          #=> true
          IO.puts Math.zero?(1)          #=> false
          IO.puts Math.zero?([1, 2, 3])  #=> ** (FunctionClauseError)
          IO.puts Math.zero?(0.0)        #=> ** (FunctionClauseError)
        #+end_src

    - Similar to constructs like ~if~, named functions support both ~do:~ and
      ~do/end~ block syntax, 
      * Example:
        #+begin_src elixir
          defmodule Math do
            def zero?(0), do: true
            def zero?(x) when is_integer(x), do: false
          end
        #+end_src
        _Use ~do:~ for one-liner is good!_
    
*** DONE 4. Function capturing
    CLOSED: [2021-01-26 Tue 00:56]
    The ~name/arity~ can also be used to *retrieve* a /named function/ as a
    /function type/.
    
    - Example:
      #+begin_src elixir
        # Run `iex math.exs`, and then type

        Math.zero?(0)        # true

        fun = &Math.zero?/1  # &Math.zero?/1

        is_function(fun)     # true

        fun.(0)              # true
      #+end_src

    - Local or imported functions, like ~is_function/1~, can be _captured *without*
      the /module/:_
      #+begin_src elixir
        &is_function/1          #=> &:erlang.is_function/1
        (&is_funciton/1).(fun)  #=> true
      #+end_src

    - /Capture syntax/ can also be used as a _shortcut_ for *creating* /functions/:
      #+begin_src elixir
        fun = &(&1 + 1)  #=> #Function<6.71889879/1 in :erl_eval.expr/5>
        fun.(1)          #=> 2

        fun2 = &"Good #{&1}"  #=> #Function<6.127694169/1 in :erl_eval.expr/5>
        fun2.("morning")      #=> "Good morning"
      #+end_src

    - If you want to *capture* a /function/ from a /module/,
      there is an alternative syntax similar to ~&Module.function/arity~:
      #+begin_src elixir
        fun = &List.flatten(&1, &2)  #=> &List.flatten/2
        fun.([1, [[2], 3]], [4, 5])  #=> [1, 2, 3, 4, 5]
      #+end_src
    
*** DONE 5. Default arguments
    CLOSED: [2021-01-26 Tue 01:10]
    - Example:
      #+begin_src elixir
        defmodule Concat do
          def join(a, b, sep \\ " ") do
            a <> sep <> b
          end
        end

        IO.puts Concat.join("Hello", "world")      #=> Hello world
        IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
      #+end_src

    - Any expression is allowed to serve as a /default value/,
      * *BUT it won't be evaluated during the /function definition/.*

      * Every time the function is invoked and any of its /default values/ _have
        to be used_, the expression for that /default value/ will be evaluated:

      * Example:
        #+begin_src elixir
          defmodule DefaultTest do
            def dowork(x \\ "hello") do
              x
            end
          end

          DefaultTest.dowork      #=> "hello"
          DefaultTest.dowork 123  #=> 123
        #+end_src

    - /Multiple clauses function defintion/ with /default values/ requires to create
      a function head (without an actual body) _for declaring defaults_. For example:
      #+begin_src elixir
        defmodule Concat do
          # A function head declaring defaults
          def join(a, b \\ nil, sep \\ " ")

          def join(a, b, _sep) when is_nil(b) do
            a
          end

          def join(a, b, sep) do
            a <> sep <> b
          end
        end
      #+end_src
      The _leading underscore_ in ~_sep~ means that the variable will be *ignored* in
      this function.
        
    - When using /default values/, one must be CAREFUL to *avoid overlapping function
      definitions*. 
      #+begin_src elixir
        defmodule Concat do
          def join(a, b) do
            IO.puts "***First join"
            a <> b
          end

          def join(a, b, sep \\ " ") do
            IO.puts "***Second join"
            a <> sep <> b
          end
        end
      #+end_src
      Compile this will receive a _warning_:
      =warning: this clause cannot match because a previous clause at line 2 always matches=

      * =from Jian= =TODO=
        If this is on purpose, how can I suppress this warning for this definition???
      
** DONE 9. Recursion
   CLOSED: [2021-01-26 Tue 01:20]
*** DONE 1. Loops through recursion
    CLOSED: [2021-01-26 Tue 01:20]
    Due to *immutability*, loops in Elixir (as in any /functional programming
    language/) are written differently from /imperative languages/.
    
*** DONE 2. Reduce and map algorithms
    CLOSED: [2021-01-26 Tue 01:20]
    - Reduce algorithm example:
      #+begin_src elixir
        defmodule Math do
          def sum_list([head | tail], accumulator) do
            sum_list(tail, head + accumulator)
          end

          def sum_list([], accumulator) do
            accumulator
          end
        end

        IO.puts Math.sum_list([1, 2, 3], 0) #=> 6
      #+end_src

    - Map algorithm example:
      #+begin_src elixir
        defmodule Math do
          def double_each([head | tail]) do
            [head * 2 | double_each(tail)]
          end

          def double_each([]) do
            []
          end
        end
      #+end_src

    - We usually don't write code manually like above.
      * We will use the provided functionalities in the ~Enum~ /module/.
        For example:
        #+begin_src elixir
          Enum.reduce([1, 2, 3], 0, &+/2)  #=> 6
          Enum.map([1, 2, 3], &(&1 * 2))   #=> [2, 4, 6]
        #+end_src
        =NEXT=
        Let’s take a deeper look at ~Enumerable~ and, while we're at it, its
        *lazy* counterpart, ~Stream~.

** DONE 10. Enumerables and streams
   CLOSED: [2021-01-27 Wed 03:13]
*** DONE 1. Enumerables
    CLOSED: [2021-01-27 Wed 02:49]
    Elixir provides the concept of /enumerables/ and the ~Enum~ /module/ to work
    with them.

    - We have already learned _TWO_ /enumerables/: /lists/ and /maps/.
      #+begin_src elixir
        Enum.map([1, 2, 3], fn &(&1 * 2) end)            #=> [2, 4, 6]
        Enum.map(%{1 => 2, 3 => 4}, fn {} -> k * v end)  #=> [2, 12]
      #+end_src

    - The ~Enum~ /module/ provides a huge range of /functions/ to
      * /transform/
      * /sort/
      * /group/
      * /filter/
      * /retrieve items/ from /enumerables/.

      It is one of the /modules/ *developers use frequently* in their Elixir code.

    - Elixir also provides /ranges/:
      #+begin_src elixir
        Enum.map(1..3, &(&1 * 2))  #=> [2, 4, 6]
        Enum.reduce(1..3, &+/2)    #=> 6
      #+end_src

    - The /functions/ in the ~Enum~ /module/ are *limited to*, as the name says,
      /enumerating values/ in /data structures/.
      * For specific operations, like *inserting* and *updating* particular
        elements, you may need to reach for /modules/ specific to the _data type_.

      * For example, =TODO= =TRY IT=
        if you want to insert an element at a given position in a /list/, you
        should use the ~List.insert_at/3~ /function/ from the ~List~ /module/,
        as it would make little sense to insert a value into, for example, a /range/.

    - The /functions/ in the ~Enum~ /module/ are /polymorphic/
      because they can work with _DIVERSE data types_, ANY data type that implements
      the ~Enumerable~ /protocol/.
      * =TODO=
        We are going to discuss /Protocols/ in a later chapter;
        for now we are going to move on to a specific kind of /enumerable/ called
        a /stream/.
      
*** DONE 2. Eager vs Lazy
    CLOSED: [2021-01-27 Wed 02:56]
    *All* the /functions/ in the ~Enum~ /module/ are *eager*.

    - Many /functions/ in the ~Enum~ /module/
      _expect_ an /enumerable/ and
      _return_ a /list/ back.
      #+begin_src elixir
        odd? = &(rem(&1, 2) != 0) #=> #Function<6.80484245/1 in :erl_eval.expr/5>
        Enum.filter(1..3, odd?)   #=> [1, 3]
      #+end_src
    
*** DONE 3. The pipe operator
    CLOSED: [2021-01-27 Wed 02:56]
    - ~|>~ (pipe operator) ::
      expression on its left side and
      passes it *as the FIRST argument* to the function call on its right side.

    - Example:
      #+begin_src elixir
        1..100_000            |>
          Enum.map(&(&1 * 3)) |>
          Enum.filter(odd?)   |>
          Enum.sum

        #=> 7500000000
      #+end_src
      
      is equivalent to
      
      #+begin_src elixir
        Enum.sum(Enum.filter(Enum.map(1..100_000, &(&1 * 3)), odd?))
        #=> 7500000000
      #+end_src
      
*** DONE 4. Streams
    CLOSED: [2021-01-27 Wed 03:13]
    As an _ALTERNATIVE_ to ~Enum~, Elixir provides the ~Stream~ /module/ which
    supports *lazy operations*.
    
    - Example:
      #+begin_src elixir
        1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum
        #=> 7500000000
      #+end_src

    - streams :: lazy and composable enumerables.

    - Instead of *generating* _intermediate_ /lists/,
      /streams/ build a series of computations that are invoked
      *only* when we pass the underlying /stream/ to the ~Enum~ /module/.

    - /Streams/ are useful when working with
      * large
      * possibly infinite
      * collections

    - Many /functions/ in the ~Stream~ /module/
      1. *accept* ANY /enumerable/ as an argument
      2. *return* a /stream/ as a result.

    - It also provides /functions/ for *creating* /streams/.
      * For example,
        ~Stream.cycle/1~ can be used to *create* a /stream/ that cycles a given
        enumerable infinitely.
          Be careful to *NOT* call a /function/ like ~Enum.map/2~ on such
        /streams/, as they would *cycle forever*:
        #+begin_src elixir
          stream = Stream.cycle([1, 2, 3])  #=> #Function<15.16982430/2 in Stream.unfold/2>
          Enum.take(stream, 10)             #=> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]
        #+end_src

    - On the other hand, ~Stream.unfold/2~ can be used to *generate values*
      from a _given initial value_:
      #+begin_src elixir
        stream = Stream.unfold("hełło", &String.next_codepoint/1)
        #=> #Function<39.75994740/2 in Stream.unfold/2>

        Enum.take(stream, 3)
        #=> ["h", "e", "ł"]
      #+end_src

    - ~Stream.resource/3~ which can be used to _WRAP around *resources*,_
      guaranteeing they are
      1. *opened* right _BEFORE_ enumeration
      2. *closed* _AFTERWARDS_, even in the case of failures.

    - For example, ~File.stream!/1~ builds on top of ~Stream.resource/3~ to stream
      files:
      #+begin_src elixir
        stream = File.stream!("path/to/file")
        #=>
        #  %File.Stream{
        #    line_or_bytes: :line,
        #    modes: [:raw, :read_ahead, :binary],
        #    path: "path/to/file",
        #    raw: true
        #  }

        Enum.take(stream, 10)
      #+end_src
      This can be very useful for _handling large files_ or even _slow
      resources_ like /network resources/.
      
** TODO 11. Processes
*** 1. ~spawn~
*** 2. ~send~ and ~receive~
*** 3. Links
*** 4. Tasks
*** 5. State
   
** TODO 12. IO and the file system
*** 1. The ~IO~ module
*** 2. The ~File~ module
*** 3. The ~Path~ module
*** 4. Processes
*** 5. ~iodata~ and ~chardata~

** TODO 13. alias, require, and import
*** 1. alias
*** 2. require
*** 3. import
*** 4. use
*** 5. Understanding Aliases
*** 6. Module nesting
*** 7. Multi alias/import/require/use
   
** TODO 14. Module attributes
*** 1. As annotations
*** 2. As “constants”
*** 3. As temporary storage
   
** TODO 15. Structs
*** 1. Defining structs
*** 2. Accessing and updating structs
*** 3. Structs are bare maps underneath
*** 4. Default values and required keys
   
** TODO 16. Protocols
*** 1. Example
*** 2. Protocols and structs
*** 3. Implementing Any
**** 3.1. Deriving
**** 3.2. Fallback to Any
     
*** 4. Built-in protocols
   
** TODO 17. Comprehensions
*** 1. Generators and filters
*** 2. Bitstring generators
*** 3. The ~:into~ option
*** 4. Other options

** TODO 18. Sigils
*** 1. Regular expressions
*** 2. Strings, char lists, and word lists sigils
**** 2.1 Strings
**** 2.2 Char lists
**** 2.3 Word lists
    
*** 3. Interpolation and escaping in string sigils
*** 4. Calendar sigils
**** 4.1. Date
**** 4.2. Time
**** 4.3. NaiveDateTime
**** 4.4. DateTime
    
*** 5. Custom sigils

** TODO 19. try, catch, and rescue
*** 1. Errors
*** 2. Throws
*** 3. Exits
*** 4. After
*** 5. Else
*** 6. Variables scope
   
** TODO 20. Typespecs and behaviours
*** Types and specs
**** Function specifications
**** Defining custom types
**** Static code analysis
     
*** Behaviours
**** Defining behaviours
**** Adopting behaviours
**** Dynamic dispatch

** TODO 21. Debugging
*** IO.inspect/2
*** ~IEx.pry/0~ and ~IEx.break!/2~
*** Debugger
*** Observer
*** Other tools and community
   
** TODO 22. Erlang libraries
*** 1. The binary module
*** 2. Formatted text output
*** 3. The crypto module
*** 4. The digraph module
*** 5. Erlang Term Storage
*** 6. The math module
*** 7. The queue module
*** 8. The rand module
*** 9. The zip and zlib modules

** TODO 23. Where to go next
*** 1. Build your first Elixir project
*** 2. Meta-programming
*** 3. Community and other resources
*** 4. A byte of Erlang

* TODO Mix and OTP
** TODO 1. Introduction to Mix
   - =TODO= note
     
*** TODO 1 Our first project
*** TODO 2 Project compilation
*** TODO 3 Running tests
*** DONE 4 Automatic code formatting
    CLOSED: [2021-01-27 Wed 01:45]
    - One of the files generated by ~mix new~ is the =.formatter.exs=.
      * Elixir ships with a *code formatter* that is capable of automatically
        formatting our codebase according to a consistent style.
          The formatter is triggered with the ~mix format~ task. The generated
        =.formatter.exs= file configures which files should be formatted when
        ~mix format~ runs.

    - For companies and teams, =IMPORTANT=
      we recommend developers to run
      ~mix format --check-formatted~ on their _continuous integration servers_,
      ensuring all current and future code follows the standard.

    - You can learn more about the code formatter by checking
      [[https://hexdocs.pm/mix/Mix.Tasks.Format.html][the format task documentation]] or by reading [[https://elixir-lang.org/blog/2018/01/17/elixir-v1-6-0-released/][the release announcement for
      Elixir v1.6]], the first version to include the formatter.
      
*** DONE 5 Environments - =RE-READ=
    CLOSED: [2021-01-27 Wed 02:23]
    Mix provides the concept of *“environments”*.

    - They allow a developer to *customize* _compilation_ and _other options for
      specific scenarios_.
      By default, Mix understands _THREE_ /environments/:
      * ~:dev~ - the one in which Mix tasks (like ~compile~) run by default
      * ~:test~ - used by ~mix test~
      * ~:prod~ - the one you will use to run your project in production

    - The /environment/ applies only to the _current project_.

    - As we will see in future chapters, ANY /dependency/ you add to your project
      will _BY DEFAULT_ run in the ~:prod~ /environment/.

    - Customization per /environment/ can be done by accessing [[https://hexdocs.pm/mix/Mix.html#env/0][the ~Mix.env~ function]]
      in your =mix.exs= file, which _returns_ the *current environment* as an /atom/.
      That's what we have used in the ~:start_permanent~ options
      #+begin_src elixir
        def project do
          [
            ...,
            start_permanent: Mix.env == :prod,
            ...
          ]
        end
      #+end_src
      - When true, the ~:start_permanent~ option starts your application in
        /permanent mode/, which means the /Erlang VM/ will crash if your
        application's /supervision tree/ _shuts down_.
        * Notice
          we don't want this behaviour in *dev* and *test* because it is useful to
          _keep the VM instance running in those /environments/ for TROUBLESHOOTING
          purposes._
      
    - Mix will *default to* the ~:dev~ /environment/,
      EXCEPT for the ~test~ /task/ that will *default to* the ~:test~ /environment/.
      The environment can be changed via the ~MIX_ENV~ environment variable:
      #+begin_src shell
        MIX_ENV=prod mix compile
      #+end_src
      Or on Windows:
      #+begin_src shell
        set "MIX_EN=prod" && mix compile
      #+end_src
      =TODO= TRY THESE COMMANDS
      
    - Mix is a /build tool/ and, as such,
      it is *not expected* to be available in production.
      =IMPORTANT=
        Therefore, it is recommended to access ~Mix.env~ only in _configuration
      files_ and inside =mix.exs=, never in your application code (~lib~).
      
*** DONE 6 Exploring
    CLOSED: [2021-01-27 Wed 01:33]
    - A [[https://hexdocs.pm/mix/][general overview is available on the Mix documentation]].
      Read [[https://github.com/elixir-lang/elixir/tree/master/lib/mix][the Mix source code here]].

    - Keep in mind that you can always invoke the help task to list all available tasks:
      #+begin_src shell
        mix help
      #+end_src
      * You can get further information about a _particular task_ by invoking
        ~mix help TASK~.
    
** TODO 2. Agent
*** 1. The trouble with state
*** 2. Agents
*** 3. Test setup with ExUnit callbacks
*** 4. Other agent actions
*** 5. Client/Server in agents
   
** 3. GenServer
*** 1. GenServer callbacks
*** 2. The Client API
*** 3. Testing a GenServer
*** 4. The need for monitoring
*** 5. ~call~, ~cast~ or ~info~?
*** 6. Monitors or links?
    
** 4. Supervisor and Application
*** 1 Our first supervisor
*** 2 Naming processes
*** 3 Understanding applications
**** 3.1 Starting applications
     
*** 4 The application callback
*** 5 Projects or applications?
*** 6 Next steps
    
** 5. Dynamic supervisors
*** 1. The bucket supervisor 
*** 2. Supervision trees
*** 3. Shared state in tests
*** 4. Observer
    
** 6. ETS
*** ETS as a cache
*** Race conditions?
   
** 7. Dependencies and umbrella projects
*** 1. External dependencies
*** 2. Internal dependencies
*** 3. Umbrella projects
*** 4. Dependencies within an umbrella project
*** 5. Don’t drink the kool aid
*** 6. Summing up
    
** 8. Task and ~gen_tcp~
*** 1. Echo server
*** 2. Tasks
*** 3. Task supervisor
   
** 9. Doctests, patterns and with
*** 1. Doctests
*** 2. with
*** 3. Running commands
   
** 10. Distributed tasks and tags
*** 1. Enumerables
*** 2. Eager vs Lazy
*** 3. The pipe operator
*** 4. Streams
    
** 11. Configuration and releases
*** 1. Application environment
*** 2. Configuration
*** 3. Releases
*** 4. Why releases?
*** 5. Assembling multiple releases
*** 6. Configuring releases
**** 6.1 Operating System environment configuration
**** 6.2 Runtime configuration
     
*** 7. Summing up
    
* TODO Meta-programming in Elixir
** 1. Quote and unquote
*** 1. Quoting
*** 2. Unquoting
*** 3. Escaping
    
** 2. Macros
*** 1. Foreword
*** 2. Our first macro
*** 3. Macro hygiene
*** 4. The environment
*** 5. Private macros
*** 6. Write macros responsibly
    
** 3. Domain-specific languages
*** 1. Foreword
*** 2. Building our own test case
*** 3. The test macro
*** 4. Storing information with attributes
