#+TITLE: Java Generics and Collections
#+VERSION: 2007
#+AUTHOR: Maurice Naftalin, Philip Wadler
#+STARTUP: entitiespretty

* Preface - xi
* Part I. Generics - 1
  This part of the book describes /generics/, using the _Collections Framework_
  as a source of examples. A comprehensive introduction to the _Collections
  Framework_ appears in the second part of the book.

  - The first *FIVE* chapters focus on the fundamentals of generics.
      Once you have these five chapters under your belt, you will be able to use
    /generics/ effectively in most basic situations.
    + Chapter 1
      OVERVIEW TO /generics/ and _other new features in Java 5_ including
      * /boxing/
      * /foreach loops/
      * functions with a /variable number of arguments/.

    + Chapter 2
      REVIEWS
      * how /subtyping/ works
      * explains how /wildcards/ let you use /subtyping/ in connection with /generics/.

    + Chapter 3
      DESCRIBES
      * how /generics/ work with the ~Comparable~ /interface/, which requires a
        notion of /bounds on type variables/.

    + Chapter 4
      LOOKS AT
      * how /generics/ work with VARIOUS /declarations/, including /constructors/,
        /static members/, and /nested classes/.

    + Chapter 5
      EXPLAINS
      * how to evolve *legacy code* to exploit /generics/
      * how ease of evolution is a key advantage of the design of /generics/ in Java.

  - The next *FOUR* chapters treat _ADVANCED_ topics.
    + Chapter 6
      explains how the same design that
      * leads to ease of evolution

      * ALSO necessarily leads to a few rough edges in _the treatment of /casts/,
        /exceptions/, and /arrays/._
          The fit between /generics/ and /arrays/ is the *WORST* rough corner of the
        language, and we formulate two principles to help you *work around* the
        problems.

    + Chapter 7
      explains new features that relate /generics/ and /reflection/, including
      * the newly generified type ~Class<T>~
      * additions to the Java library that support /reflection of generic types/.

    + Chapter 8
      contains advice on how to use generics effectively in practical coding.
      We consider /checked collections/, /security issues/, /specialized classes/,
      and /binary compatibility/.

    + Chapter 9
      presents FIVE extended examples, looking at how generics affect five well-known
      /design patterns/:
      * Visitor
      * Interpreter
      * Function
      * Strategy
      * Subject-Observer

** TODO 1. Introduction - 3
   - Example (Java 5 and Java 5+):
     #+begin_src java
       List<Integer> ints = Arrays.asList(1, 2, 3);  // generics, Collection Framework, and varargs
       int s = 0;
       for (int n : ints) { s += n; }  // foreach loop
       assert s == 6;
     #+end_src

   - Example (Java 4 and Java 4-):
     #+begin_src java
       List ints = Arrays.asList( new Integer[] {
               new Integer(1), new Integer(2), new Integer(3)
       } );
       int s = 0;
       for (Iterator it = ints.iterator(); it.hasNext();) {
           int n = ((Integer)it.next()).intValue();
           s += n;
       }
       assert s == 6;
     #+end_src

   - If we don't need the flexibility that ~ints~ doesn't have a fixed size, and
     use /integer array/:
     #+begin_src java
       int[] ints = new int[] { 1, 2, 3 };
       int s = 0;
       for (int i = 0; i < ints.length; ++i) {
           s += ints[i];
       }
       assert s == 6;
     #+end_src

   - =from Jian=
     From Java 8 on:
     #+begin_src java
       List<Integer> ints = Arrays.asList(1, 2, 3);  // generics, Collection Framework, and varargs
       final int sum = ints.stream().reduce(0, Integer::sum);
       assert sum == 6;

       // OR

       assert 6 == IntStream.of(1, 2, 3).reduce(0, Integer::sum);
     #+end_src

*** TODO 1.1 Generics - 4
    - Examples:
      + With /generics/:
        #+begin_src java
          List<String> words = new ArrayList<String>();
          words.add("Hello ");
          words.add("world!");
          String s = words.get(0) + words.get(1);
          assert s.equals("Hello world!");
        #+end_src

      + Before Java 5:
        #+begin_src java
          List words = new ArrayList();
          words.add("Hello ");
          words.add("world!");
          String s = (String)words.get(0) + (String)words.get(1);
          assert s.equals("Hello world!");
        #+end_src

      + The bytecode compiled from the two sources above will be *identical*.

    - /Type erasure/ is actually
      + *erase type parameters*
        AND
      + *add casts*.

    - Cast-iron guarantee :: the implicit casts added by the compilation of /generics/
         _NEVER fail_.
      + There is also some fine print on this guarantee: it applies _only when_ NO
        /unchecked warnings/ have been issued by the compiler.
        TODO Later, we will discuss at some length what causes /unchecked warnings/
        to be issued and how to _minimize_ their effect.

    - TODO ARRAY, COLLECTION, /reifieds/.
      NOTE NOTE NOTE

    - Implementing /generics/ by /erasure/ has a number of important effects (here
      are the good ones):
      + It keeps things *simple*, in that /generics/ do not add anything
        fundamentally new.

      + It keeps things *small*, in that there is exactly one implementation of ~List~,
        not one version for each type.

      + And it *eases evolution*, since the same library can be accessed in both
        nongeneric and generic forms.

    - *Java Generics Versus C++ Templates*
      There are just *TWO* important things to bear in mind about the relationship
      between /Java generics/ and /C++ templates/: /syntax/ and /semantics/.
      *The /syntax/ is deliberately _similar_ and the /semantics/ are
      deliberately _different_.*
      + Syntactically,
        /Angle brackets/ was chosen in Java because they are familiar to C++
        /template/ uses.
        * Differences:
          - C++ nested parameters require extra spaces.
            For example, ~List< List<String> >~.
            Withoug these extra spaces, a problem arises becase ~>>~ will always
            be considered as right-shift operator.

          - Java do NOT need extra spaces.
            Java fixes the problem by a trick in the grammar. TODO ??? TODO

      + Semantically,
        * /Java generics/ are defined by /erasure/, whereas /C++ templates/ are defined
          by /expansion/.
          - The /expansion/ way can benefit optimization, but it may lead to /code bloat/.

          - The /erasure/ way does NOT help doing optimization as in C++, but there
            is also NO /code bloat/ possibility.

          - In practice, /Code bloat/ can be MORE CRUCIAL than _efficiency_.

        * /C++ tempalte/ support singleton type (constant value).
          /Java generics/ are restricted to types.

*** DONE 1.2 Boxing and Unboxing - 6
    CLOSED: [2020-02-03 Mon 14:27]
    - boxing :: Conversion of /primitive type/ -> CORRESPONDING /reference type/.

    - unboxing :: Conversion of /reference type/ -> CORRESPONDING /primitive type/.

    - Java do /boxing/ and /unboxing/ automatically.
      Code like
      #+begin_src java
        List<Integer> ints = new ArrayList<Integer>();
        ints.add(1);
        int n = ints.get(0);
      #+end_src
      after /boxing/ and /unboxing/ will become
      #+begin_src java
        List<Integer> ints = new ArrayList<Integer>();
        ints.add(Integer.valueOf(1));
        int n = ints.get(0).intValue;
      #+end_src

    - TODO *Explain soon!*
      ~Integer.valueOf(1)~ is similar in effect to ~new Integer(1)~,
      but may _cache some values_ for improved performance.
      + =from Jian= The constructor form of ~Integer~ is already marked as /Deprecated/.

    - Performance:
      #+begin_src java
        public static int sum (List<Integer> ints) {
            int s = 0;
            for (int n : ints) { s += n; }
            return s;
        }

        // is MUCH faster than

        public static Integer sum (List<Integer> ints) {
            Integer s = 0;                      // extra auto-boxing
            for (Integer n : ints) { s += n; }  // extra auto-unboxing for the `+` operation, and auto-boxing after `+` is done.
            return s;
        }
      #+end_src
      With the 2007 version of Sun's compiler, the ~Integer sum (List<Integer> ints)~
      version is 60% slower!!!

    - *Look Out for This!* TODO
      + One _SUBTLETY_ of /boxing/ and /unboxing/ is that ~==~ is defined differently
        on primitive and on reference types.
        * On type ~int~, it is defined by equality of values, and
        * on type ~Integer~, it is defined by object identity.

      + So both of the following assertions succeed using Sun's JVM:
        #+begin_src java
          List<Integer> bigs = Arrays.asList(100, 200, 300);
          // Case 1
          assert sumInteger(bigs) == sum(bigs);

          // Case 2
          assert sumInteger(bigs) != sumInteger(bigs);  // not recommended
        #+end_src
        * Case 1: The two sides are equal (~==~) because of /auto-unboxing/

        * Case 2: You shouldn't use this way to compare!!! It's not always equal
          or unequal!
          - When no value cached, Case 2 will be true!
          - *Subtlety* of /caching/:
            + Caching is _required_
              when boxing ~int~ or ~short~ value in the range of [-128, 127], a ~char~
              value in the range of ['\u0000', '\u007f'], a ~byte~, or a ~boolean~.

            + Caching is _permitted_
              when boxing other values.

*** DONE 1.3 Foreach - 9
    CLOSED: [2020-01-04 Sat 22:41]
    /foreach loop/ can be applied to *ANY* _object that importants the
    /interface/ ~Iterable<E>~._
    #+begin_src java
      List<Integer> ints = Arrays.asList(1, 2, 3);
      int sum = 0;
      for (int n : ints) {  // unboxing happens in this line, when assigning `ints.next()` to `n`
          sum += n;
      }
    #+end_src
    is equivalent to the following:
    #+begin_src java
      for (Iterator<Integer> i = ints.iterator(); i.hasNext();) {
          int n = i.next();
          sum += n;
      }
    #+end_src

    - _The /foreach loop/ catches ONLY The MOST common case._
        You need to EXPLICITLY introduce an /iterator/ if you wan't do something
      not that simple like:
      + Use ~remove~ method
        #+begin_src java
          // Remove negatives
          public static void removeNegative(List<Double> v) {
              for (Iterator<Double> it = v.iterator(); it.hasNext();) {
                  if (it.next() < 0) it.remove();
              }
          }
        #+end_src

      + Iterate over _more than one_ list IN PARALLEL.
        #+begin_src java
          // Loop two iterators in parallel
          public static double dot(List<Double> u, List<Double> v) {
              if (u.size() != v.size()) throw new IllegalArgumentException("different sizes");
              double d = 0;
              Iterator<Double> uIt = u.iterator();
              Iterator<Double> vIt = v.iterator();
              while (uIt.hasNext()) {
                  assert uIt.hasNext() && vIt.hasNext();
                  d += uIt.next() * vIt.next();
              }
              assert !uIt.hasNext() && !vIt.hasNext();
              return d;
          }
        #+end_src

*** DONE 1.4 Generic Methods and Varargs - 10
    CLOSED: [2020-01-30 Thu 11:50]
    - /Generic method/ example:
      Convert ~T[]~ to ~List<T>~ for arbitrary legal ~T~
      #+begin_src java
        class Lists {
            public static <T> List<T> toList(T[] arr) {
                List<T> list = new ArrayList<>();
                for (T elt : arr) list.add(elt);
                return list;
            }
        }
      #+end_src
      + The /scope/ of ~T~ is the signature and the body of the method that
        declares it.

      + Invoke:
        #+begin_src java
          List<Integer> ints = Lists.toList(new Integer[] { 1, 2, 3 });
          List<String> words = Lists.toList(new String[] { "hello", "world" });
        #+end_src
        In the first line, /auto-boxing/ happens.

    - /vararg/:
      + Permit a special, more convenient syntax for the case in which _the last
        argument of a method is an /array/._

      + Syntax: ~T... variable~ in parameter list.

      + Example:
        #+begin_src java
          class Lists {
              public static <T> List<T> toList(T... arr) {
                  List<T> list = new ArrayList<>();
                  for (T elt : arr) list.add(elt);
                  return list;
              }
          }
        #+end_src
        * Invoke:
          #+begin_src java
            List<Integer> ints = Lists.toList(1, 2, 3);
            List<String> words = Lists.toList("hello", "world");
          #+end_src

    - In the preceding examples, the /type parameter/ to the /generic method/ is
      *inferred*, and we didn't write it out explicitly. The explicit form is like:
      #+begin_src java
        List<Integer> ints = Lists.<Integer>toList();
        List<Integer> ints = Lists.<Object>toList(1, "two");
      #+end_src
      For the first statement:
      + Old Sun's compiler can't infer the type when we use ~Lists.toList()~
        instead on the RHS. Even if we declared ~List<Integer>~ on the RHS. No
        compiling error, but _unchecked type warning_.

      + Eclipse compiler use a different type inference algorithm, and compiles
        the same line correctly without the explicit parameter.

      + New Java compiler (from JDK 11 or OpenJDK 11, not sure about Java 6 ~ 10)
        can infer the type.

      + In JShell, if we evaluate ~Lists.toList()~ expression without a declared
        varaible type and name, the element type will be inferred as ~Object~.
        Therefore, we may need to use ~Lists.<TypeArg>toList()~ don't want to
        manually specify its type.

    - In general, the following rule of thumb suffices: in a call to a generic method,
      if there are one or more arguments that correspond to a type parameter and
      they all have the same type then the type parameter may be inferred; if
      there are no arguments that correspond to the type parameter or the
      arguments belong to different subtypes of the intended type then the type
      parameter must be given explicitly.

    - *LIMITATION* (Grammar):
      The ~<T>~ can only show up in the qualified form, following ~.~.
      ~<Integer>toList()~ will trigger a compile-time error.

    - Similar (to our defined ~toList~) methods:
      + ~Arrays.asList~
      + ~Collections.addAll~

*** DONE 1.5 Assertions - 12
    CLOSED: [2020-01-04 Sat 23:01]
    /Assertions/ are enabled by invoing the JVM with the ~-ea~ or
    ~-enableassertions~ flag.

    - Since /assertions/ can be enabled or disabled, and
      also because of the semantics of /assertions/,
      an /assertion/ should *never* have /side effects/ upon which any
      nonassertion code depends.

** TODO 2. Subtyping and Wildcards - 15
   Topics that we will discuss in this chapter:
   - Review how /subtyping/ works;
   - See how /wildcards/ let you use /subtyping/ *in connection with* /generics/;
   - Illustrate our points with examples from the _Collections Framework_.

*** DONE 2.1 Subtyping and the Substitution Principle - 15
    CLOSED: [2020-02-04 Tue 15:20]
    /Subtyping/ is a key feature of OOP such as Java.

    - subtyping (in Java) :: one type is a /subtype/ of another if they are
         related by an ~extends~ or ~implements~ clause.
      + /Subtyping/ is *transitive*.

    - With the concept of /subtyping/, it is easy to describe /supertype/.

    - EVERY /reference type/ is a /subtype/ of ~Object~.
      ~Object~ is a /supertype/ of EVERY /reference type/.
      Every /type/ is a /subtype/ of itself.

    - Substitution Principle :: a /variable/ of a given type may be assigned a
         value of any /subtype/ of that type, and a /method/ with a parameter of
         a given type may be invoked with an argument of any /subtype/ of that
         type.
      + Example:
        #+begin_src java
          List<Integer> ints = new ArrayList<>();
          ints.add(1);
          ints.add(2);
          List<Number> nums = ints;  // compile-time error
          nums.add(3.14);
          assert ints.toString().equals("[1, 2, 3.14]");  // uh oh!
        #+end_src

    - The /substitution principle/ does *NOT* regulate the /subtyping relation/
      between, for instance, ~List<A>~ and ~List<B>~ if ~B~ is a /subtype/ of ~A~.
      + /Java array/ is not a part of the _Collection Framework_, and it follow a
        DIFFERENT rule. (TODO: See Section 2.5 -- bad design for Java with
        generics, but required design for Java without generics).

    - The relation between types like ~List<A>~ and ~List<B>~, when ~B~ is a /subtype/
      of ~A~, can be specified with /wildcards/. TODO: Next SECTION

*** DONE 2.2 Wildcards with ~extends~ - 17
    CLOSED: [2020-02-04 Tue 15:41]
    /Covariance/
    Example:
    #+begin_src java
      interface Collection<E> {
          public boolean addAll(Collection<? extends E> c);
          // ...
      }
    #+end_src
    - ~? extends E~ means any type that is a subtype of ~E~.

    - Example:
      #+begin_src java
        List<Number> nums = new ArrayList<Number>();
        List<Integer> ints = Arrays.asList(1, 2);
        List<Double> dbls = Arrays.asList(2.78, 3.14);
        nums.addAll(ints);
        nums.addAll(dbls);
        assert nums.toString().equals("[1, 2, 2.78, 3.14]");
      #+end_src

    - We can also use /wildcards/ when _declaring variables_.

    - One commmon error:
      #+begin_src java
        List<Integer> ints = new ArrayList<>();
        ints.add(1);
        ints.add(2);
        List<? extends Number> nums = ints;
        nums.addAll(3.14);  // compile-time error
      #+end_src
      1. ~nums~ is a list that contains values of a subtype of ~Number~.
         The /compile-time error/ happens because a subtype of ~Number~ might
         conflict with the type of ~3.14~ (~double~) -- confirmed in the code
         above.

    - In general, if a structure contains elements with a type of the form
      ~? extends E~, we
      + CAN _get_ elements out of the structure,
      + BUT we CANNOT _put_ elements into the structure.

    - To _put elements into the structure_ we need another kind of /wildcard/, as
      explained in the next section. TODO Next Section

*** TODO 2.3 Wildcards with ~super~ - 18 - TODO RE-READ
    Illstration Example:
    Copy all of the elements from a source list to a destination list.
    #+begin_src java
      // This comes from `Collections`
      public static <T> void copy(List<? super T> dst, List<? extends T> src) {
          for (int i = 0; i < src.size(); ++i) {
              dst.set(i, src.get(i));
          }
      }
    #+end_src
    The _first_ ~?~ is the /supertype/ of ~T~, and ~T~ is the /supertype/ of the
    _second_ ~?~. This means the _first_ ~?~ is the /supertype/ of the _second_ ~?~.

    - Example:
      #+begin_src java
        List<Object> objs = Arrays.<Object>asList(2, 3.14, "four");
        List<Integer> ints = Arrays.asList(5, 6);
        Collections.copy(objs, ints);
        assert objs.toString().equals("[5, 6, four]");
      #+end_src
      As with any /generic method/, the /type parameter/
      _may be INFERRED_ or _may be Given EXPLICITLY_
      + In this case, there are *FOUR* possible choices, all of which type-check
        and all of which have the same effect:
        #+begin_src java
          Collections.copy(objs, ints);           // The exact type of `ints` is given, and the tightest type `Integer` is inferred.
          Collections.<Object>copy(objs, ints);   // compatible
          Collections.<Number>copy(objs, ints);   // compatible
          Collections.<Integer>copy(objs, ints);  // compatible
        #+end_src
        * TODO NOTE
        * TODO NOTE
        * TODO NOTE

    - Declare the ~copy~ method with different signatures, and find out how are
      they affected by their /wildcards/.
      #+begin_src java
        public static <T> void copy(List<T> dst, List<T> src);                    // 1
        public static <T> void copy(List<T> dst, List<? extends T> src);          // 2
        public static <T> void copy(List<? super T> dst, List<T> src);            // 3
        public static <T> void copy(List<? super T> dst, List<? extends T> src);  // 4
      #+end_src
      + 1 is TOO restrictive
        It only permits calls when the _destination_ and _source_ have *EXACTLY
        the SAME /type/.*

      + The remaining three are
        equivalent for calls that use implicit type parameters,
        BUT differ for explicit type parameters.
        * 2 works only when the /type parameter/ is ~Object~,
        * 3 works only when the /type parameter/ is ~Integer~,
        * 4 works (as we have seen) for all three /type parameters/
          i.e., ~Object~, ~Number~, and ~Integer~.

      + Always use wildcards where you can in a signature, since this permits the
        widest range of calls.

*** TODO 2.4 The Get and Put Principle - 19
    - The Get and Put Principle ::
      + use an ~extends~ /wildcard/ when you only _get_ values out of a structure,
      + use a ~super~ /wildcard/ when you only _put_ values into a structure,
      + DON'T use a /wildcard/ when you both _get_ and _put_.

*** DONE 2.5 Arrays - 22
    CLOSED: [2020-02-06 Thu 13:51]
    It is instructive to compare the treatment of /lists/ and /arrays/ in Java,
    keeping in mind /the Substitution Principle/ and /the Get and Put Principle/.

    - *In Java, array subtyping is /covariant/,*
      meaning the type ~S[]~ is considered to be a /subtype/ of ~T[]~ _whenever
      ~S~ is a subtype of ~T~._
      + There is *no way* to create any _contravariant array_ in Java.
        No syntax like ~(? wildcard Integer)[]~. Although, the semantics of
        ~(? extends Integer)[]~ is the default.

    - Illustrate the issue introduced by the *(by default) convariance of array*
      with a example:
      #+begin_src java
        Integer[] ints = new Integer[] {1, 2, 3};
        Number[] nums = ints;
        nums[2] = 3.14;  // ArrayStoreException in runtime
        assert Arrays.toString(ints).equals("[1, 2, 3.14]");  // uh oh! Can't reach this line.
      #+end_src
      + Since Java array is /covariant/, this doesn't violate the /Substitution Principle/.

      + The reason why this issue is caught at run time:
        When an array is allocated (as on the first line),
        _it is tagged with its /reified type/ (a run-time representation of its
        component type, in this case, ~Integer~)_, and every time an array is
        assigned into (as on the third line), an ~ArrayStoreException~ is raised
        if the /reified type/ is not compatible with the assigned value.

      + Compare with ~List~:
        * Without /wildcards/, /invariant/:
          #+begin_src java
            List<Integer> ints = Arrays.asList(1, 2, 3);
            List<Number> nums = ints;  // compile-time error
            nums.set(2, 3.14);
            assert ints.toString().equals("[1, 2, 3.14]");  // uh oh! Can't reach this line.
          #+end_src
          Violate /the Substitution Principle/

        * With ~extends~, /covariant/:
          #+begin_src java
            List<Integer> ints = Arrays.asList(1, 2, 3);
            List<? extends Number> nums = ints;
            nums.set(2, 3.14);  // compile-time error
            assert ints.toString().equals("[1, 2, 3.14]");  // uh oh! Can't reach this line.
          #+end_src
          Violate /the Get and _Put_ Principle/

        * Since Java /array/ can't be /contravariant/, there is no need to compare
          the /contravariant/ ~List~ with /array/.

    - Q :: Is make /array/ /covariant/ (BY DEFAULT, and ONLY) is a good design decision?

    - A ::
      + Before the advent of /generics/, it was absolutely necessary.
        Without it, there is no way to declare /methods/ that apply for many/all
        types like:
        #+begin_src java
          public static void sort(Object[] a);
          public static void fill(Object[] a, Object val);
        #+end_src

      + Now, with /generics/, /covariant arrays/ _are no longer necessary_.
        #+begin_src java
          public static <T> void sort(T[] a);
          public static <T> void fill(T[] a, T val);
        #+end_src

    - In some sense, covariant arrays are an artifact of the lack of generics in
      earlier versions of Java. Once you have generics, covariant arrays are
      probably the wrong design choice, and the only reason for retaining them
      is backward compatibility.

    - TODO
      Sections _Section 6.4 - Section 6.8_ discuss inconvenient interactions
      between /generics/ and /arrays/. *For many purposes, it may be sensible to
      consider arrays a deprecated type.* We return to this point in Section
      6.9.

*** DONE 2.6 Wildcards Versus Type Parameters - 25
    CLOSED: [2020-02-06 Thu 14:26]
   - *Wildcards*
     #+begin_src java
       interface Collection<E> {
           public boolean contains(Object o);
           public boolean containsAll(Collection<?> c);
           // ...
       }
     #+end_src
     + ~<?>~ stands for ~<? extends Object>~

     + Legal code:
       #+begin_src java
         Object obj = "one";
         List<Object> objs = Arrays.<Object>asList("one", 2, 3.14, 4);
         List<Integer> ints = Arrays.asList(2, 4);
         assert objs.contains(obj);
         assert objs.containsAll(ints);
         assert !ints.contains(obj);
         assert !ints.containsAll(obj);
       #+end_src

   - *Type Parameters*
     #+begin_src java
       interface MyCollection<E> {  // alternative design
           public boolean contains(E o);
           public boolean containsAll(Collection<? extends E> c);
           // ...
       }
     #+end_src
     + This only allow single direction check:
       #+begin_src java
         Object obj = "one";
         MyList<Object> objs = MyList.<Object>asList("one", 2, 3.14, 4);
         MyList<Integer> ints = MyList.asList(2, 4);
         assert objs.contains(obj);
         assert objs.containsAll(ints);
         assert !ints.contains(obj);     // compile-time error
         assert !ints.containsAll(objs); // compile-time error
       #+end_src

   - Q :: Which is a better design?

   - A :: This is argurable!!!
     + Use site backward compatibility prefer the _wildcards solution_.
     + The _wildcards solution_ can do _two direction check_.
     + The _two direction check_ is rarely used, and can be work around by the
       _type parameters solution_.
     + _Type parameters solution_ catch more errors in compile time.

   - Similar design happens in the signature of ~remove~, ~removeAll~, and ~retianAll~
     of the ~Collection<E>~ class.

*** TODO 2.7 Wildcard Capture - 27
*** TODO 2.8 Restrictions on Wildcards - 28
    - *Generic Method Calls*
    - *Supertypes*

** TODO 3. Comparison and Bounds - 31
   Now let's look at some more advanced uses of generics.
   This chapter describes the /interfaces/ ~Comparable<T>~ and ~Comparator<T>~.
   - Along the way, we will introduce /bounds/ on /type variables/, _an important
     feature_ of /generics/ that is particularly useful in combination with the
     /interfaces/ like ~Comparable<T>~ .

*** TODO 3.1 Comparable - 31
    #+begin_src java
      interface Comparable<T> {
          public int compareTo(T o);
      }
    #+end_src

    - natural ordering :: the ordering specified by ~Comparable~

    - Comparison is not supported between ARBITRARY /numerical types/.
      The ~Number~ class does NOT implement the ~Comparable~ interface.

    - *Consistent with Equals*
      Usually, we require that two objects are equal iff they compare as the same.
      ~x.equals(y)~ iff ~x.compareTo(y) == 0~.
      We say that the /natural ordering/ is *consistent* with equals.

    - *Contract for Comparable*

    - *Look Out for This!*

*** TODO 3.2 Maximum of a Collection - 34
*** TODO 3.3 A Fruity Example - 36
*** TODO 3.4 Comparator - 37
*** TODO 3.5 Enumerated Types - 42
    Java 5 inlcudes support for /enumerated types/.
    - Example:
      #+begin_src java
        enum Season { WINTER, SPRING, SUMMER, FALL }
      #+end_src

*** TODO 3.6 Multiple Bounds - 45
*** TODO 3.7 Bridges - 47
*** TODO 3.8 Covariant Overriding - 49

** TODO 4. Declarations - 51
   _This chapter discusses how to *declare* a /generic class/._
   It describes /constructors/, /static members/, and /nested classes/, and it
   fills in some details of *how /erasure/ works*.

*** DONE 4.1 Constructors - 51
    CLOSED: [2020-01-05 Sun 16:00]
    In a /generic class/, /type parameters/ appear IN THE HEADER that declares the
    class, but _NOT IN the /constructor/._
      However, /type parameters/ need to be passed to the /constructor/ whenever
    construction required.
    #+begin_src java
      class Pair<T, U> {
          private final T first;
          private final U second;

          public Pair(T first, U second) {
              this.first = first;
              this.second = second;
          }
      }

      // The form with all required type parameters being given EXPLICITLY.
      Pair<String, Integer> pair0 = new Pair<>("one", 2);

      // Java 10+
      // The form with all required type parameters being given, though they are IMPLICIT.
      var pair1 = new Pair<>("one", 2);
    #+end_src

    - *Look Out for This!*
      DO NOT forget the ~<>~.

*** DONE 4.2 Static Members - 52
    CLOSED: [2020-01-05 Sun 16:26]
    Because of the /erasure/, /static members/ of a /generic class/ *can't refer*
    to the the /type parameters/, not only the /generic class/ it belongs to, but
    also any other /type parameters/.

    - It is obvious that /static members/ can't refer to the /type parameters/ of
      the /generic class/ that it belongs to. Then,
      + Q :: Can one /static method/ have its own type parameter?
      + A :: Still *NO*!!!
        * For a class like ~Cell<T>~, a /method/ ~static List<U> f~ can't make a
          lot of sense -- no clear relation between ~T~ and ~U~, and ~f~ is used
          across ~Cell~'s with _different_ /type parameters/.

        * =from Jian=
          For ~Cell<T>~, a /method/ ~static List<T> g~ can be meaningful, but if
          it is meaningful, why not use non-static definition ~List<T> g~.
            If we want to make ~static List<T> g~ meaningful, we need to do a lot
          of work to the compiler (may also introduce some conflicts I can't
          imagine till now).

    - No restriction to /static memember/ with /type arguments/.
      For example, ~static List<Integer> f~ is LEGAL!!!

    - Because /static members/ are *independent* of ANY /type parameters/, we are
      _NOT permitted_ to follow the /class/ name with /type parameters/ when
      accessing a /static member/:
      #+begin_src java
        Cell.getCount();          // ok
        Cell<Integer>.getCount(); // compile-time error
        Cell<?>.getCount();       // compile-time error
      #+end_src

*** DONE 4.3 Nested Classes - 53
    CLOSED: [2020-01-05 Sun 16:39]
    /Outer class type parameters/ are *visible* to /inner non-static class/.
    *When applicable, /static inner classes/ are always preferred* -- they don't
    include a /reference/ to the /enclosing instance/, which make it _simpler_ and
    _efficient_ than /non-static inner classes/.

*** TODO 4.4 How Erasure Works - 55
    TODO - Need knowledge about /bound/!!! -- Read Chapter 3 first!!!

** TODO 5. Evolution, Not Revolution - 59
*** 5.1 Legacy Library with Legacy Client - 60
*** 5.2 Generic Library with Generic Client - 60
*** 5.3 Generic Library with Legacy Client - 62
*** 5.4 Legacy Library with Generic Client - 65
**** 5.4.1 Evolving a Library using Minimal Changes - 65
**** 5.4.2 Evolving a Library using Stubs - 68
**** 5.4.3 Evolving a Library using Wrappers - 68

*** 5.5 Conclusions - 71

** TODO 6. Reification - 73
*** 6.1 Reifiable Types - 73
*** 6.2 Instance Tests and Casts - 74
    - *Nonreifiable Casts*

    - *Unchecked casts*

*** 6.3 Exception Handling - 79
    - *Type Variable in a Throws Clause*

*** 6.4 Array Creation - 80
*** 6.5 The Principle of Truth in Advertising - 82
    - *Array Begets Array*

    - *A Classy Alternative*

*** 6.6 The Principle of Indecent Exposure - 86
*** 6.7 How to Define ~ArrayList~ - 89
*** 6.8 Array Creation and Varargs - 90
*** 6.9 Arrays as a Deprecated Type? - 92
*** 6.10 Summing Up - 95

** TODO 7. Reflection - 97
*** 7.1 Generics for Reflection - 97
    - *Further Examples of Generics for Reflection*

*** 7.2 Reflected Types are Reifiable Types - 100
*** 7.3 Reflection for Primitive Types - 101
*** 7.4 A Generic Reflection Library - 101
*** 7.5 Reflection for Generics - 104
*** 7.6 Reflecting Generic Types - 105

** TODO 8. Effective Generics - 109
*** 8.1 Take Care when Calling Legacy Code - 109
*** 8.2 Use Checked Collections to Enforce Security - 111
*** 8.3 Specialize to Create Reifiable Types - 112
    - *Delegation*

    - *Inheritance*

    - *Other Types*

*** 8.4 Maintain Binary Compatibility - 117
    - *Adjusting the Erasure*

    - *Bridges*

    - *Covariant Overriding*

** TODO 9. Design Patterns - 123
*** 9.1 Visitor - 123
*** 9.2 Interpreter - 127
*** 9.3 Function - 128
*** 9.4 Strategy - 131
    - *Parallel Class Hierarchies*
    - *An Advanced Strategy Pattern with Recursive Generics*
    - *Summary*

*** 9.5 Subject-Observer - 136

* Part II. Collections - 143
  /The Java Collections Framework/ is a set of /interfaces/ and /classes/
  IN the /packages/ ~java.util~ and ~java.util.concurrent~.

** TODO 10. The Main Interfaces of the Java Collections Framework - 145
   - Figure 10-1. The main interfaces of the Java Collections Framework
     =IMPORTANT=

   - Figure 10-1 inlcudes one /interface/ that doesn't belong to the _Java Collections
     Framework_ but an essential adjunct to it.

   - The Framework /interfaces/ have the following purposes:
     + ~Collection~
       contains the core functionality required of any collection _other than a
       map_.
       * =from Jian= Map is a /collection/ and it is a part of the _Java Collection
         Framework_, but ~Collection~ doesn't includes core functionalities of it???
         What a design??? This design can be accepted if this interface was NOT called
         _Collection_!

       * No direct concrete implementations.

     + ~Set~ TODO
       * ~SortedSet~
       * ~NavigableSet~ extends ~SortedSet~

     + ~Queue~ TODO
       * ~BlockingQueue~
       * ~Deque~
         - ~BlockingDeque~

     + ~List~ :: A collection in which _order is significant._

     + ~Map~ TODO
       * ~SortedMap~
         - ~NavigableMap~

       * ~ConcurrentMap~
         - ~ConcurrentNavigableMap~

** TODO 11. Preliminaries - 147
*** DONE 11.1 ~Iterable~ and ~Iterator~'s - 147
    CLOSED: [2018-11-27 Tue 00:34]
    - ~Iterator~
      #+BEGIN_SRC java
        public Iterator<E> {
            boolean hasNext();
            E next();
            void remove();  // remove the last element returned by the iterator
        }
      #+END_SRC

    - The PURPOSE of /iterators/:
      *provide a uniform way of accessing collection elements sequentially*,

      Then whatever kind of /collection/ you are dealing with, and however it is
      implemented, you always know how to process its elements in turn.

    - ~Iterator~'s are useful, but no one want to write code like:
      #+BEGIN_SRC java
        // coll refers to an object which implements `Collection`
        // ----- not the preferred idiom from Java 5 on -----
        for (Iterator itr = coll.iterator(); itr.hasNext();) {
            System.out.println(itr.next());
        }
      #+END_SRC
      + _This is the idiom before Java 5._

      + This works because ~Collection~ has an ~iterator~ /method/ which returns
        an /iterator/ appropriate to objects of that /class/.

    - From Java 5 on, /foreach iteration syntax/ is introduced.
      It works with anything that implements the interface ~Iterable~,
      #+BEGIN_SRC java
        public Iterable<T> {
            Iterator<T> iterator();  // return an iterator over elements of type `T`
        }
      #+END_SRC

      Then we can do
      #+BEGIN_SRC java
        for (Object o : coll) {
            System.out.pirntln(o);
        }
      #+END_SRC

      + In Java 5, the ~Collection~ /interface/ was made to extend ~Iterable~, so
        as any /set/, /list/, or /queue/ can be the target of /foreach/, as can
        /arrays/.

    - =from Jian= In Java 8, you would like to use
      #+BEGIN_SRC java
        coll.stream().forEach(System.out::println);
      #+END_SRC

    - In Java 5, the ~Collection~ /interface/ was made to extend ~Iterable~.
      This was NOT in the original design tracing back to Java 1.2 (Java 2).

    - In practice, it is _UNUSUAL_ to implement ~Iterable~ _DIRECTLY_ in the way
      of Example 11-1. Directly implementing ~Iterable~ as /foreach/ is most
      commonly used with /arrays/ and /the standard collections classes/.

    - ~CocurrentModificationException~ can be thrown from single-threaded code.

      This can happend when you modify a colleciton, at the same time you are
      using its /iterator/ -- /iterators/ are created as view of the underlying
      /iterables/, structurally chane the underlying /iteratables/ usually lead
      to failure or unpredictable results. The designer of Java decide to
      *fail-fast* when this happen.

    - The /concurrent collections/ have other strategies for *handling* /concurrent
      modification/, such as /weakly consistent iterators/ =???= TODO.
      TODO We discuss them in more detail in Section 11.5.

*** TODO 11.2 Implementations - 149
    - Arrays
    - Linked Lists
    - Hash tables
    - Trees

*** TODO 11.3 Efficiency and the O-Notation - 150
*** TODO 11.4 Contracts - 152
*** TODO 11.5 Collections and Thread Safety - 153
**** TODO 11.5.1 Synchronization and the Legacy Collections - 155
**** TODO 11.5.2 JDK 1.2: Synchronized Collections and Fail-Fast Iterators - 156
     - *Using Synchronized Collections Safely*

**** TODO 11.5.3 Concurrent Collections: Java 5 and Beyond - 158
     - *Mechanisms*
     - *Iterators*

** TODO 12. The ~Collection~ Interface - 161
   - The /interface/ ~Collection~ (see Figure 12-1) defines the core functionality
     that we expect of any collection *other than a /map/.*

     + Remember ~Map~ does NOT implement ~Collection~!!!


   - It provides methods in *4* groups:
     + *Adding Elements*
       #+BEGIN_SRC java
         public interface Collection<E> extends Iterable<E> {
             boolean add(E e);
             boolean addAll(E e);

             // other methods
         }
       #+END_SRC

       * The ~boolean~ return values indicate if a collection is changed after
         invoking ~add~ or ~addAll~.
         =from Jian= Usually, this can be very useful for /sets/.

       * The /method contracts/ specify that the elements being added *must be
         present* after execution so,

         *IF* the collection *refuses* an element for any other reason (for
         example, some collection don't permit ~null~ elements), *these /methods/
         must throw an exception!!!*

     + *Removing Elements*
       #+BEGIN_SRC java
         public interface Collection<E> extends Iterable<E> {
             boolean remove(Object o);            // remove the elements `o`
             void clear();                        // remove all elements
             boolean removeAll(Collection<?> c);  // remove the elements in c
             boolean retainAll(Collection<?> c);  // remove the elements *not* in `c`

             // other methods
         }
       #+END_SRC
       * Differences from /adding methods/: they accept any type of parameters --
         ~Object~ and the ~?~ /type parameter/.
         TODO Explain later!

     + *Querying the Contents of a Collection*
       #+BEGIN_SRC java
         public interface Collection<E> extends Iterable<E> {
             boolean contains(Object o);            // `true` if `o` is present
             boolean containsAll(Collection<?> c);  // `true` if all elements of `c`
             boolean isEmpty();                     // ...
             int size();                            // return the element count (or
                                                    // `Integer.MAX_VALUE` if that is less)
             // other methods
         }
       #+END_SRC
       * The desing of
         returning ~Integer.MAX_VALUE~ if it is less than the actually size
         is a BAD design!!!  =from Jian=

         =from Jian= the author also say something similar but NOT in a very
         straightforward way. The author thinks /exceptions/ can be a better
         choice.

     + *Making a Colleciton's Contents Available for Futher Processing* TODO
       #+BEGIN_SRC java
         public interface Collection<E> extends Iterable<E> {
             Iterator<E> iterator();  // return an `Iterator` over the elements
             Object[] toArray();      // copy contents to an `Object[]`
             <T> T[] toArray(T[] t);  // copy contents to a `T[]` (for any `T`)
         }
       #+END_SRC

       * This book is old.
         =from Jian= this part should includes ~stream()~

       * TODO
         More detailed discussion about the last two ~toArray~ /methods/
       * TODO
       * TODO
       * TODO
       * TODO

*** TODO 12.1 Using the Methods of Collection - 164
    - *Adding Elements*
    - *Removing Elements*
    - *Querying the Contents of a Collection*
    - *Making the Collection Contents Available for Further Processing*

*** DONE 12.2 Implementing Collection - 169
    CLOSED: [2018-11-27 Tue 01:36]
    - There are *NO concrete implementations* of ~Collection~.

    - There a re a series of /skeletal implementations/ -- some /abstract classes/
      that partially implements /colleciton framework interfaces/.

      + ~AbstractCollection~ implements ~Collection~.
        It is on the top of this /skeletal implementations/ of ~Collection~.

      + ~AbstractSet~, ~AbstractList~, and some other /classes/ *extends*
        ~AbstractCollection~.

    - These /skeletal implementations/ are created to *help* the designer of
      new implementations of the /Framework interfaces/ -- they have partially
      implements some functionalities.

      + =From Jian= Here I see a example why /trait/ is better!!!

        For example, ~Collection~ could serve as the /interface/ for /bags
      (unordered lists)/, and a programmer implementing bags could extend
      ~AbstractCollection~ and find most of the implementation work already done.

*** DONE 12.3 Collection Constructors - 169
    CLOSED: [2018-11-27 Tue 01:45]
    - *Two* COMMON FORMS of /constructors/ which are shared by MOST collection
      implementation (illustrated by ~HashSet~ examples):
      1. ~public HashSet()~

      2. ~public HashSet(Collection<? extends E> c)~

    - Use 2. has the same effect as creating an empty set with the /DEFAULT
      constructor/, and then adding the contents of a collection using ~addAll~.

    - *CAUTION*
      + The second form is usually called "copy constructor", since it copies the
        passed in collection, and create a new collection of required type.

      + *HOWEVER*,
        we should really reserve the name /copy constructor/ to constructors that
        only accept same type collections, copy and create a new one.

      + Joshua Block suggested the term /conversion constructor/ for the 2.-like
        /constructors/.

    - NOT ALL the collections have both of these two /constructors/.

** TODO 13. Sets - 171
*** 13.1 Implementing ~Set~ - 171
**** 13.1.1 ~HashSet~ - 172
**** 13.1.2 ~LinkedHashSet~ - 174
**** 13.1.3 ~CopyOnWriteArraySet~ - 175
**** 13.1.4 ~EnumSet~ - 176

*** 13.2 ~SortedSet~ and ~NavigableSet~ - 178
    - *Getting the First and Last Elements*
    - *Retrieving the Comparator*
    - *Getting Range Views*

**** 13.2.1 ~NavigableSet~ - 181
     - *Getting the First and Last Elements*
     - *Getting Range Views*
     - *Getting Closest Matches*
     - *Navigating the Set in Reverse Order*

**** 13.2.2 ~TreeSet~ - 184
**** 13.2.3 ~ConcurrentSkipListSet~ - 186

*** 13.3 Comparing ~Set~ Implementations - 188

** TODO 14. Queues - 191
   - *Adding an Element to a Queue*
   - *Retrieving an Element from a Queue*

*** 14.1 Using the Methods of ~Queue~ - 193
*** 14.2 Implementing ~Queue~ - 195
**** 14.2.1 ~PriorityQueue~ - 195
**** 14.2.2 ~ConcurrentLinkedQueue~ - 197

*** 14.3 ~BlockingQueue~ - 198
    - *Adding an Element*
    - *Removing an Element*
    - *Retrieving or Querying the Contents of the Queue*

**** 14.3.1 Using the Methods of ~BlockingQueue~ - 199
**** 14.3.2 Implementing ~BlockingQueue~ - 202
     - *LinkedBlockingQueue*
     - *ArrayBlockingQueue*
     - *PriorityBlockingQueue*
     - *DelayQueue*
     - *SynchronousQueue*

*** 14.4 ~Deque~ - 206
    - *Collection-like Methods*
    - *Queue-like Methods*

**** 14.4.1 Implementing ~Deque~ - 208
     - *ArrayDeque*
     - *LinkedList*

**** 14.4.2 ~BlockingDeque~ - 209
     - *Implementing BlockingDeque*

*** 14.5 Comparing ~Queue~ Implementations - 210

** TODO 15. Lists - 213
   - *Positional Access*
   - *Search*
   - *Range-View*
   - *List Iteration*

*** 15.1 Using the Methods of ~List~ - 215
    - *Using Range-View and Iterator Methods*

*** 15.2 Implementing ~List~ - 218
**** 15.2.1 ~ArrayList~ - 218
**** 15.2.2 ~LinkedList~ - 221
**** 15.2.3 ~CopyOnWriteArrayList~ - 221

*** 15.3 Comparing ~List~ Implementations - 221

** TODO 16. Maps - 223
   - *Adding Associations*
   - *Removing Associations*
   - *Querying the Contents of a Map*
   - *Providing Collection Views of the Keys, Values, or Associations:*

*** 16.1 Using the Methods of ~Map~ - 225
*** 16.2 Implementing ~Map~ - 226
**** 16.2.1 ~HashMap~ - 227
**** 16.2.2 ~LinkedHashMap~ - 227
**** 16.2.3 ~WeakHashMap~ - 229
**** 16.2.4 ~IdentityHashMap~ - 231
**** 16.2.5 ~EnumMap~ - 233

*** 16.3 ~SortedMap~ and ~NavigableMap~ - 234
    - *Getting the First and Last Elements*
    - *Retrieving the Comparator*
    - *Finding Subsequences*

**** 16.3.1 ~NavigableMap~ - 235
     - *Getting the First and Last Elements*
     - *Getting Range Views*
     - *Getting Closest Matches*
     - *Navigating the Map*

**** 16.3.2 ~TreeMap~ - 236

*** 16.4 ~ConcurrentMap~ - 237
**** 16.4.1 ~ConcurrentHashMap~ - 238

*** 16.5 ~ConcurrentNavigableMap~ - 238
**** 16.5.1 ~ConcurrentSkipListMap~ - 239

*** 16.6 Comparing ~Map~ Implementations - 239

** TODO 17. The ~Collections~ Class - 241
*** 17.1 Generic Algorithms - 241
**** 17.1.1 Changing the Order of List Elements - 241
**** 17.1.2 Changing the Contents of a List - 242
**** 17.1.3 Finding Extreme Values in a Collection - 243
**** 17.1.4 Finding Specific Values in a List - 243

*** 17.2 Collection Factories - 244
*** 17.3 Wrappers - 245
**** 17.3.1 Synchronized Collections - 245
**** 17.3.2 Unmodifiable Collections - 246
**** 17.3.3 Checked Collections - 246

*** 17.4 Other Methods - 247
    - ~addAll~
    - ~asLifoQueue~
    - ~disjoint~
    - ~enumeration~
    - ~frequency~
    - ~list~
    - ~newSetFromMap~
    - ~reverseOrder~
    - ~Conclusion~

* Index - 251
