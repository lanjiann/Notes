#+TITLE: Dotty Documentation
#+VERSION: 0.17.0-bin-SNAPSHOT
#+AUTHOR: 
#+STARTUP: entitiespretty

* BLOG
* USAGE
** Getting Started
   *Getting Started: Users*
*** Trying out Dotty
**** In your web browser
**** sbt
**** IDE support
**** Standalone installation

** sbt-projects
** IDE support for Dotty
*** Prerequisites
*** Usage
*** Status
**** Fully supported features
**** Partial working features
**** Unimplemented features
**** Current limitations, to be fixed

*** Feedback

** Worksheet mode in Dotty IDE
*** How to use the worksheets
*** Implementation details

** cbt-projects
** Dottydoc
*** Using existing Templates and Layouts
*** Blog
*** Includes
*** Sidebar
*** Dottydoc Specific Tags and Behavior
**** Linking to API
**** Rendering Docstrings
**** Other extensions

*** Default Layouts
**** =main.html=
***** Variables

**** =sidebar.html=
***** Variables

**** =doc-page.html=
**** =api-page.html=
**** =blog-page.html=

*** Default Includes

* REFERENCE
** Overview
*** Goals
*** Essential Foundations
*** Simplifications
*** Restrictions
*** Dropped Constructs
*** Changes
*** New Constructs
*** Meta Programming
*** See Also

** NEW TYPES
*** Intersection types
**** Type Checking

*** Union types
*** Type lambdas
*** Match types
**** Representation of Match Types
**** Match type reduction
**** Subtyping Rules for Match Types
**** Variance Laws for Match Types
**** Typing Rules for Match Expressions
**** Overlapping Patterns
**** Handling Termination
**** Related Work

*** Dependent Function Types

** ENUMS
*** Enumerations
**** Parameterized enums
**** Methods defined for enums
**** User-defined members of enums
**** Compatibility with Java Enums
**** Implementation
**** Reference

*** Algebraic Data Types
**** Syntax of Enums
**** Reference

*** Translation
**** Translation of Enumerations
**** Scopes for Enum Cases
**** Translation of Java-compatible enums
**** Other Rules

** CONTEXTUAL ABSTRACTIONS
*** Overview
**** Critique of the Status Quo
**** The New Design

*** Delegates
**** Anonymous Delegates
**** Alias Delegates
**** Delegate Instantiation
**** Syntax

*** Given Clauses
**** Anonymous Given Clauses
**** Inferring Complex Arguments
**** Multiple Given Clauses
**** Summoning Delegates
**** Syntax

*** Context Bounds
**** Context Bounds
**** Syntax

*** Delegate Imports
**** Importing By Type
**** Migration

*** Extension Methods
**** Translation of Extension Methods
**** Translation of Calls to Extension Methods
**** Delegates for Extension Methods
**** Operators
**** Generic Example
**** Syntax

*** Implementing Typeclasses
**** Semigroups and monoids
**** Functors and monads

*** Typeclass Derivation
**** Deriving Types
**** Derivable Types
**** The Shape Type
**** The Generic Typeclass
**** Mirrors
**** GenericClass
**** How to Write Generic Typeclasses
**** Deriving Delegates Elsewhere
**** Syntax
**** Discussion

*** Multiversal Equality
**** Deriving ~Eql~ Delegates
**** Precise Rules for Equality Checking
**** Predefined ~Eql~ Delegates
**** Why Two Type Parameters?

*** Implicit Function Types
**** Example: Builder Pattern
**** Example: Postconditions
**** Reference

*** Implicit Conversions
**** Examples

*** Implicit By-Name Parameters
**** Reference

*** Relationship with Scala 2 Implicits
**** Simulating Contextual Abstraction with Implicits
***** Delegates
***** Anonymous Delegates
***** Given Clauses
***** Context Bounds
***** Extension Methods
***** Typeclass Derivation
***** Implicit Function Types
***** Implicit By-Name Parameters

**** Simulating Scala 2 Implicits in Dotty
***** Implicit Conversions
***** Implicit Classes
***** Implicit Values
***** Abstract Implicit

**** Implementation Status and Timeline

** METAPROGRAMMING
*** Overview
*** Inline
**** Inline Definitions
**** Recursive Inline Methods
**** Relationship to ~@inline~
***** The definition of constant expression

**** Specializing Inline (Whitebox)
**** Inline Conditionals
**** Inline Matches
**** The ~scala.compiletime~ Package
***** ~constValue~, ~constValueOpt~, and the ~S~ combinator
***** ~erasedValue~
***** ~error~

**** Implicit Matches
**** Reference

*** Macros
**** Macros: Quotes and Splices
**** Types for Quotations
**** The Phase Consistency Principle
**** From ~Expr~'s to Functions and Back
**** Types and the PCP
**** Lifting Expressions
**** Lifting Types
**** Relationship with Inline
**** Scope Extrusion
**** Example Expansion
**** Relationship with Whitebox Inline

*** Staging
**** API
**** Example

*** Erased Terms
**** Why erased terms?
**** How to define erased terms?
**** What happens with erased values at runtime?
**** State machine with erased evidence example

*** TASTy Reflection
**** API: From quotes and splices to TASTy reflect trees and back
***** Sealing and Unsealing
***** Obtaining and underlying argument
***** Positions
***** Tree Utilities
***** Let

**** TASTy Reflect API
**** More Examples

*** TASTy Inspection
**** Inspecting TASTy files

** OTHER NEW FEATURES
*** Trait Parameters
**** Reference

*** Creator Applications
**** Motivation
**** Discussion

*** Export Clauses
**** Motivation
**** Syntax changes
**** Elaboration of Export Clauses

*** Opaque Type Alias
**** Bounds For Opaque Type Alias

*** Parameter Untupling
    For data like ~val xs: List[(Int, Int)]~,
    - In Scala 2.x,
      use _EXPLICIT_ /pattern matching/ (partial function) decomposition:
      #+BEGIN_SRC scala
        xs map {
          case (x, y) => x + y
        }
      #+END_SRC

    - Dotty allows the syntax:
      #+BEGIN_SRC scala
        xs map {
          (x, y) => x + y
        }

        // OR, EQUIVALENTLY:
        xs.map(_ + _)
      #+END_SRC

    - Generally, a /function value/ with *n > 1 parameters* is _converted to_ a
      /pattern-matching closure/ using ~case~ if the expected type is a /unary
      function type/ of the form ~((T_1, ..., T_n)) => U~.

**** Reference

*** Kind Polymorphism
*** Tupled Function
**** Tupled Function
**** Examples

*** ~threadUnsafe~ Annotation
**** Examples

** OTHER CHANGED FEATURES
*** Programmatic Structural Types
**** Example
**** Extensibility
**** Relation with ~scala.Dynamic~

*** Rules for Operators
**** The ~@alpha~ Annotation
***** Motivation
***** Details

**** The ~@infix~ Annotation
***** Motivation
***** Details

*** Wildcard Arguments in Types
**** Motivation
**** Migration Strategy

*** Changes in Type Checking
*** Changes in Type Inference
*** Changes in Implicit Resolution
*** Implicit Conversions
**** Examples

*** Changes in Overload Resolution
**** Looking Beyond the First Argument List
**** Parameter Types of Function Values

*** Vararg Patterns
**** Compatibility considerations

*** Pattern Bindings
**** Bindings in Pattern Definitions
**** Pattern Bindings in For Expressions
**** Syntax Changes
**** Migration

*** Option-less pattern matching
**** Extractors
***** Fixed-Arity Extractors
***** Variadic Extractors

**** Boolean Match
**** Product Match
**** Single Match
**** Name-based Match
**** Sequence Match
**** Product-Sequence Match

*** Automatic Eta Expansion
**** Automatic eta-expansion and nullary methods

*** Changes in Compiler Plugins
**** Using Compiler Plugins
**** Writing a Standard Compiler Plugin
**** Writing a Research Compiler Plugin

*** Lazy Vals initialization
**** Motivation
**** Implementation
**** Note on recursive lazy vals
**** Reference

** DROPPED FEATURES
*** Dropped: DelayedInit
*** Dropped: Scala 2 Macros
*** Dropped: Existential Types
*** Dropped: General Type Projection
*** Dropped: Procedure Syntax
*** Dropped: Package Objects
*** Dropped: Early Initializers
*** Dropped: Class Shadowing
*** Dropped: Limit 22
*** Dropped: XML Literals
*** Dropped: Symbol Literals
*** Dropped: Auto-Application
**** Migrating code
**** Reference

*** Dropped: Weak Conformance
*** Dropped: Nonlocal Returns

* CONTRIBUTING
** Getting Started
*** Requirements
*** Compiling and Running
*** Starting a REPL
*** Generating Documentation

** Workflow
*** Compiling files with dotc
*** Inspecting Trees with Type Stealer
*** Pretty-printing

** Eclipse
*** Setup
*** Import to Eclipse
*** Running/Debugging

** IntelliJ IDEA
   Building Dotty with IntelliJ IDEA
*** Setup
*** Running/Debugging

** Testing
   Testing in Dotty
*** Unit tests
**** Testing with checkfiles

*** Integration tests
**** Bootstrapped-only tests
**** From TASTy tests

** Release Model
*** Model
*** Example
**** At the Dotty Repo
**** At the CI
***** Canceling CI builds

**** Documentation
***** Release Procedure Checklist
***** GitHub Releases and Blog Post

**** Ecosystem

*** Procedure in Bash Scripts

* INTERNALS
** Backend
*** Data Flow
*** Architecture
**** (a) The queue subsystem
**** (b) Bytecode-level types, ~BType~
**** (c) Utilities offering a more "high-level" API to bytecode emission
**** (d) Mapping between type-checker types and ~BType~'s
**** (e) More "high-level" utilities for bytecode emission
**** (f) Building an ASM ~ClassNode~ given an AST ~TypeDef~

** Classpaths
** Core Data Structrues
*** Symbols and SymDenotations
*** Why is this important?
*** Are We Done Yet?
*** What Are the Next Steps?

** Contexts
*** Contexts in the typer
*** In other phases
*** Using contexts

** Differences between scalac and dotc
*** Denotation
**** Denotation vs. SymDenotation
**** Implicit Conversion

*** Symbol
*** Flags
*** Tree
*** Type

** Higher-Kinded Types
   *This page is out of date and preserved for posterity. Please see
   Implementing Higher-Kinded Types in Dotty for a more up to date version*

*** Higher-Kinded Types in Dotty V2
**** The duality
**** Named type parameters
**** Wildcards
**** Type parameters in the encodings
**** Partial applications
**** Modelling polymorphic type declarations
**** Modelling polymorphic type aliases: simple case
**** Modelling polymorphic type aliases: general case
**** Modelling higher-kinded types
**** Full example
**** Status of ~#~

** Overall Structure
*** Package Structure
*** Contexts
*** Compiler Phases

** Dotc's concept of time
** Syntax
   *Scala Syntax Summary*
*** Lexical Syntax
*** Keywords
**** Regular keywords
**** Soft keywords

*** Context-free Syntax
**** Literals and Paths
**** Types
**** Expressions
**** Type and Value Parameters
**** Bindings and Imports
**** Declarations and Definitions

** Type System
*** Class diagram
*** Proxy types and ground types
*** Representations of types
**** Representation of methods

*** Subtyping checks
**** Type rebasing

*** Type caching
    TODO

*** Type inference via constraint solving
    TODO

** Dotty Internals 1: Trees & Symbols (Meeting Notes)
*** Entry point
*** Phases
*** Trees
**** Untyped trees
**** Typed trees
**** Notes on some tree types
***** ThisTree

**** Creating trees
**** Meaning of trees

**** Errors
**** Assignment

*** Symbols
**** ClassSymbol
**** SymDenotation

** Debug Macros
*** position not set
*** unresolved symbols in pickling

* RESOURCES
*** Talks
**** Talks on Dotty
**** Deep Dive with Dotty
