#+TITLE: Dotty Documentation
#+VERSION: 0.17.0-bin-SNAPSHOT
#+AUTHOR: 
#+STARTUP: entitiespretty

* BLOG
* USAGE
** Getting Started
   *Getting Started: Users*
*** Trying out Dotty
**** In your web browser
**** sbt
**** IDE support
**** Standalone installation

** sbt-projects
** IDE support for Dotty
*** Prerequisites
*** Usage
*** Status
**** Fully supported features
**** Partial working features
**** Unimplemented features
**** Current limitations, to be fixed

*** Feedback

** Worksheet mode in Dotty IDE
*** How to use the worksheets
*** Implementation details

** cbt-projects
** Dottydoc
*** Using existing Templates and Layouts
*** Blog
*** Includes
*** Sidebar
*** Dottydoc Specific Tags and Behavior
**** Linking to API
**** Rendering Docstrings
**** Other extensions

*** Default Layouts
**** =main.html=
***** Variables

**** =sidebar.html=
***** Variables

**** =doc-page.html=
**** =api-page.html=
**** =blog-page.html=

*** Default Includes

* REFERENCE
** Overview
*** Goals
*** Essential Foundations
*** Simplifications
*** Restrictions
*** Dropped Constructs
*** Changes
*** New Constructs
*** Meta Programming
*** See Also

** NEW TYPES
*** Intersection types
**** Type Checking

*** Union types
*** Type lambdas
*** Match types
**** Representation of Match Types
**** Match type reduction
**** Subtyping Rules for Match Types
**** Variance Laws for Match Types
**** Typing Rules for Match Expressions
**** Overlapping Patterns
**** Handling Termination
**** Related Work

*** Dependent Function Types

** ENUMS
*** Enumerations
**** Parameterized enums
**** Methods defined for enums
**** User-defined members of enums
**** Compatibility with Java Enums
**** Implementation
**** Reference

*** Algebraic Data Types
**** Syntax of Enums
**** Reference

*** Translation
**** Translation of Enumerations
**** Scopes for Enum Cases
**** Translation of Java-compatible enums
**** Other Rules

** CONTEXTUAL ABSTRACTIONS
*** Overview
**** Critique of the Status Quo
**** The New Design

*** Delegates
**** Anonymous Delegates
**** Alias Delegates
**** Delegate Instantiation
**** Syntax

*** Given Clauses
**** Anonymous Given Clauses
**** Inferring Complex Arguments
**** Multiple Given Clauses
**** Summoning Delegates
**** Syntax

*** Context Bounds
**** Context Bounds
**** Syntax

*** Delegate Imports
**** Importing By Type
**** Migration

*** Extension Methods
**** Translation of Extension Methods
**** Translation of Calls to Extension Methods
**** Delegates for Extension Methods
**** Operators
**** Generic Example
**** Syntax

*** Implementing Typeclasses
**** Semigroups and monoids
**** Functors and monads

*** Typeclass Derivation
**** Deriving Types
**** Derivable Types
**** The Shape Type
**** The Generic Typeclass
**** Mirrors
**** GenericClass
**** How to Write Generic Typeclasses
**** Deriving Delegates Elsewhere
**** Syntax
**** Discussion

*** Multiversal Equality
**** Deriving ~Eql~ Delegates
**** Precise Rules for Equality Checking
**** Predefined ~Eql~ Delegates
**** Why Two Type Parameters?

*** Implicit Function Types
**** Example: Builder Pattern
**** Example: Postconditions
**** Reference

*** Implicit Conversions
**** Examples

*** Implicit By-Name Parameters
**** Reference

*** Relationship with Scala 2 Implicits
**** Simulating Contextual Abstraction with Implicits
***** Delegates
***** Anonymous Delegates
***** Given Clauses
***** Context Bounds
***** Extension Methods
***** Typeclass Derivation
***** Implicit Function Types
***** Implicit By-Name Parameters

**** Simulating Scala 2 Implicits in Dotty
***** Implicit Conversions
***** Implicit Classes
***** Implicit Values
***** Abstract Implicit

**** Implementation Status and Timeline

** METAPROGRAMMING
*** DONE Overview
    CLOSED: [2019-06-24 Mon 02:35]
    The following fundamental facilities:
    1. /Inline/
       /inline/ is a new _modifier_ that guarantees that a definition will be
       inlined at the point of use.

       - The primary motivation:
         _reduce the overhead_ behind function calls and access to values.

       - The expansion will be performed by the Scala compiler during the /Typer/
         /compiler phase/.

       - As opposed to /inlining/ in some other ecosystems, /inlining/ in Scala
         is _not merely_ a request to the compiler but is a command.

       - The reason is that /inlining/ in Scala can drive other _compile-time
         operations_, like
         + /inline/ /pattern matching/ (enabling type-level programming)
         + /macros/ (enabling compile-time, generative, metaprogramming)
         + /runtime code generation/ (multi-stage programming)

    2. /Macros/ construct code at /compile-time/
       - /Macros/ are built on two well-known fundamental operations:
         + quotation ::
           *converts program code to data*, specifically, a (tree-like)
           representation of this code. It is expressed as
           * ~'{...}~ for /expressions/
           * ~'[...]~ for /types/

         + splicing :: *converts a program's representation to program code*
           * expressed as ~${ ... }~.

       - The /inline/ and /splicing/ abstractions allow to construct program
         code programmatically.

    3. /Staging/ construct new code at /runtime/.
       That way, code generation can depend not only on static data but also on
       data available at runtime. This splits the evaluation of the program in
       two or more phases or ... /stages/.
         Consequently, this method generative programming is called /"Multi-Stage
       Programming"/. /Staging/ is built on the _SAME_ foundations as /macros/.
       It uses /quotes/ and /splices/, but _LEAVES OUT_ /inline/.

    4. /Erased Terms/ =???= TODO
       Erased terms are used to enforce guarantees about program constraints.
       As erased terms are guaranteed not to be used in computations, they will
       not appear at the generated code.

    5. /TASTy Reflection/
       + /Quotations/ are a "black-box" representation of code.
         They can be parameterized and composed using /splices/ but their
         structure cannot be analyzed from the outside.
       + /Tasty reflection/ gives a way to analyze code structure by partly
         revealing the representation type of a piece of code in a standard API.
         TODO
         The _representation type_ is a form of /typed abstract syntax tree/,
         which gives rise to the "TASTy` moniker.

    6. /TASTy Inspection/
       /Typed abstract syntax trees/ are serialized in a custom compressed
       binary format in =.tasty= files. /TASTy inspection/ allows to _load_
       these files and _analyze_ their content's tree structure.

*** TODO Inline
**** Inline Definitions
**** Recursive Inline Methods
**** Relationship to ~@inline~
***** The definition of constant expression

**** Specializing Inline (Whitebox)
**** DONE Inline Conditionals
     CLOSED: [2019-06-24 Mon 03:05]
     #+begin_src scala
       inline def update(delta: Int) =
         inline if (delta >= 0) increaseBy(delta)
                else            decreaseBy(-delta)
     #+end_src
     + Use ~inline~ means in the call site ~delta~ _MUST be_ a /compile-time
       constant/.

     + A call ~update(22)~ would re-write to ~increaseBy(22)~.

     + A call with a value of not compile-time constant will trigger a compile
       error:
       #+begin_src text
            |  inline if (delta >= 0) ???
            |  ^
            |  cannot reduce inline if
            |   its condition
            |     delta >= 0
            |   is not a constant value
            | This location is in code that was inlined at ...
       #+end_src

**** Inline Matches
     - TODO
       #+begin_src scala
         inline def g(x: Any) <: Any = inline x match {
           case x: String => (x, x)  // Tuple2[String, String](x, x)
           case x: Double => x
         }

         g(1.0d)  // Has type 1.0d which is a subtype of Double
           g("test")  // Has type (String, String)
       #+end_src

     - TODO
       #+begin_src scala
         trait Nat
         case object Zero extends Nat
         final case class Succ[N <: Nat](n: N) extends Nat

         inline def toInt(n: Nat) <: Int = inline n match {
           case Zero     => 0
           case Succ(n1) => toInt(n1) + 1
         }

         final val natTwo = toInt(Succ(Succ(Zero)))
         val intTwo: 2 = natTwo
       #+end_src

**** The ~scala.compiletime~ Package
***** ~constValue~, ~constValueOpt~, and the ~S~ combinator
***** ~erasedValue~
***** ~error~

**** Implicit Matches
**** Reference

*** Macros
**** Macros: Quotes and Splices
**** Types for Quotations
**** The Phase Consistency Principle
**** From ~Expr~'s to Functions and Back
**** Types and the PCP
**** Lifting Expressions
**** Lifting Types
**** Relationship with Inline
**** Scope Extrusion
**** Example Expansion
**** Relationship with Whitebox Inline

*** Staging
**** API
**** Example

*** Erased Terms
**** Why erased terms?
**** How to define erased terms?
**** What happens with erased values at runtime?
**** State machine with erased evidence example

*** TASTy Reflection
**** API: From quotes and splices to TASTy reflect trees and back
***** Sealing and Unsealing
***** Obtaining and underlying argument
***** Positions
***** Tree Utilities
***** Let

**** TASTy Reflect API
**** More Examples

*** TASTy Inspection
**** Inspecting TASTy files

** OTHER NEW FEATURES
*** Trait Parameters
**** Reference

*** Creator Applications
**** Motivation
**** Discussion

*** Export Clauses
**** Motivation
**** Syntax changes
**** Elaboration of Export Clauses

*** Opaque Type Alias
**** Bounds For Opaque Type Alias

*** Parameter Untupling
    For data like ~val xs: List[(Int, Int)]~,
    - In Scala 2.x,
      use _EXPLICIT_ /pattern matching/ (partial function) decomposition:
      #+BEGIN_SRC scala
        xs map {
          case (x, y) => x + y
        }
      #+END_SRC

    - Dotty allows the syntax:
      #+BEGIN_SRC scala
        xs map {
          (x, y) => x + y
        }

        // OR, EQUIVALENTLY:
        xs.map(_ + _)
      #+END_SRC

    - Generally, a /function value/ with *n > 1 parameters* is _converted to_ a
      /pattern-matching closure/ using ~case~ if the expected type is a /unary
      function type/ of the form ~((T_1, ..., T_n)) => U~.

**** Reference

*** Kind Polymorphism
*** Tupled Function
**** Tupled Function
**** Examples

*** ~threadUnsafe~ Annotation
**** Examples

** OTHER CHANGED FEATURES
*** Programmatic Structural Types
**** Example
**** Extensibility
**** Relation with ~scala.Dynamic~

*** Rules for Operators
**** The ~@alpha~ Annotation
***** Motivation
***** Details

**** The ~@infix~ Annotation
***** Motivation
***** Details

*** Wildcard Arguments in Types
**** Motivation
**** Migration Strategy

*** Changes in Type Checking
*** Changes in Type Inference
*** Changes in Implicit Resolution
*** Implicit Conversions
**** Examples

*** Changes in Overload Resolution
**** Looking Beyond the First Argument List
**** Parameter Types of Function Values

*** Vararg Patterns
**** Compatibility considerations

*** Pattern Bindings
**** Bindings in Pattern Definitions
**** Pattern Bindings in For Expressions
**** Syntax Changes
**** Migration

*** Option-less pattern matching
**** Extractors
***** Fixed-Arity Extractors
***** Variadic Extractors

**** Boolean Match
**** Product Match
**** Single Match
**** Name-based Match
**** Sequence Match
**** Product-Sequence Match

*** Automatic Eta Expansion
**** Automatic eta-expansion and nullary methods

*** Changes in Compiler Plugins
**** Using Compiler Plugins
**** Writing a Standard Compiler Plugin
**** Writing a Research Compiler Plugin

*** Lazy Vals initialization
**** Motivation
**** Implementation
**** Note on recursive lazy vals
**** Reference

** DROPPED FEATURES
*** Dropped: DelayedInit
*** Dropped: Scala 2 Macros
*** Dropped: Existential Types
*** Dropped: General Type Projection
*** Dropped: Procedure Syntax
*** Dropped: Package Objects
*** Dropped: Early Initializers
*** Dropped: Class Shadowing
*** Dropped: Limit 22
*** Dropped: XML Literals
*** Dropped: Symbol Literals
*** Dropped: Auto-Application
**** Migrating code
**** Reference

*** Dropped: Weak Conformance
*** Dropped: Nonlocal Returns

* CONTRIBUTING
** Getting Started
*** Requirements
*** Compiling and Running
*** Starting a REPL
*** Generating Documentation

** Workflow
*** Compiling files with dotc
*** Inspecting Trees with Type Stealer
*** Pretty-printing

** Eclipse
*** Setup
*** Import to Eclipse
*** Running/Debugging

** IntelliJ IDEA
   Building Dotty with IntelliJ IDEA
*** Setup
*** Running/Debugging

** Testing
   Testing in Dotty
*** Unit tests
**** Testing with checkfiles

*** Integration tests
**** Bootstrapped-only tests
**** From TASTy tests

** Release Model
*** Model
*** Example
**** At the Dotty Repo
**** At the CI
***** Canceling CI builds

**** Documentation
***** Release Procedure Checklist
***** GitHub Releases and Blog Post

**** Ecosystem

*** Procedure in Bash Scripts

* INTERNALS
** Backend
*** Data Flow
*** Architecture
**** (a) The queue subsystem
**** (b) Bytecode-level types, ~BType~
**** (c) Utilities offering a more "high-level" API to bytecode emission
**** (d) Mapping between type-checker types and ~BType~'s
**** (e) More "high-level" utilities for bytecode emission
**** (f) Building an ASM ~ClassNode~ given an AST ~TypeDef~

** Classpaths
** Core Data Structrues
*** Symbols and SymDenotations
*** Why is this important?
*** Are We Done Yet?
*** What Are the Next Steps?

** Contexts
*** Contexts in the typer
*** In other phases
*** Using contexts

** Differences between scalac and dotc
*** Denotation
**** Denotation vs. SymDenotation
**** Implicit Conversion

*** Symbol
*** Flags
*** Tree
*** Type

** Higher-Kinded Types
   *This page is out of date and preserved for posterity. Please see
   Implementing Higher-Kinded Types in Dotty for a more up to date version*

*** Higher-Kinded Types in Dotty V2
**** The duality
**** Named type parameters
**** Wildcards
**** Type parameters in the encodings
**** Partial applications
**** Modelling polymorphic type declarations
**** Modelling polymorphic type aliases: simple case
**** Modelling polymorphic type aliases: general case
**** Modelling higher-kinded types
**** Full example
**** Status of ~#~

** Overall Structure
*** Package Structure
*** Contexts
*** Compiler Phases

** Dotc's concept of time
** Syntax
   *Scala Syntax Summary*
*** Lexical Syntax
*** Keywords
**** Regular keywords
**** Soft keywords

*** Context-free Syntax
**** Literals and Paths
**** Types
**** Expressions
**** Type and Value Parameters
**** Bindings and Imports
**** Declarations and Definitions

** Type System
*** Class diagram
*** Proxy types and ground types
*** Representations of types
**** Representation of methods

*** Subtyping checks
**** Type rebasing

*** Type caching
    TODO

*** Type inference via constraint solving
    TODO

** Dotty Internals 1: Trees & Symbols (Meeting Notes)
*** Entry point
*** Phases
*** Trees
**** Untyped trees
**** Typed trees
**** Notes on some tree types
***** ThisTree

**** Creating trees
**** Meaning of trees

**** Errors
**** Assignment

*** Symbols
**** ClassSymbol
**** SymDenotation

** Debug Macros
*** position not set
*** unresolved symbols in pickling

* RESOURCES
*** Talks
**** Talks on Dotty
**** Deep Dive with Dotty
