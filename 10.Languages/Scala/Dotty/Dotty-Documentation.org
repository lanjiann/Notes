#+TITLE: Dotty Documentation
#+VERSION: 0.17.0-bin-SNAPSHOT
#+AUTHOR:
#+STARTUP: entitiespretty

* BLOG
* USAGE
** Getting Started
   *Getting Started: Users*
*** Trying out Dotty
**** In your web browser
**** sbt
**** IDE support
**** Standalone installation

** sbt-projects
** IDE support for Dotty
*** Prerequisites
*** Usage
*** Status
**** Fully supported features
**** Partial working features
**** Unimplemented features
**** Current limitations, to be fixed

*** Feedback

** Worksheet mode in Dotty IDE
*** How to use the worksheets
*** Implementation details

** cbt-projects
** Dottydoc
*** Using existing Templates and Layouts
*** Blog
*** Includes
*** Sidebar
*** Dottydoc Specific Tags and Behavior
**** Linking to API
**** Rendering Docstrings
**** Other extensions

*** Default Layouts
**** =main.html=
***** Variables

**** =sidebar.html=
***** Variables

**** =doc-page.html=
**** =api-page.html=
**** =blog-page.html=

*** Default Includes

* REFERENCE
** Overview
*** Goals
*** Essential Foundations
*** Simplifications
*** Restrictions
*** Dropped Constructs
*** Changes
*** New Constructs
*** Meta Programming
*** See Also

** NEW TYPES
*** Intersection types
**** Type Checking

*** Union types
*** Type lambdas
*** Match types
**** Representation of Match Types
**** Match type reduction
**** Subtyping Rules for Match Types
**** Variance Laws for Match Types
**** Typing Rules for Match Expressions
**** Overlapping Patterns
**** Handling Termination
**** Related Work

*** Dependent Function Types

** ENUMS
*** Enumerations
**** Parameterized enums
**** Methods defined for enums
**** User-defined members of enums
**** Compatibility with Java Enums
**** Implementation
**** Reference

*** Algebraic Data Types
**** Syntax of Enums
**** Reference

*** Translation
**** Translation of Enumerations
**** Scopes for Enum Cases
**** Translation of Java-compatible enums
**** Other Rules

** CONTEXTUAL ABSTRACTIONS
*** Overview
**** Critique of the Status Quo
**** The New Design

*** Delegates
**** Anonymous Delegates
**** Alias Delegates
**** Delegate Instantiation
**** Syntax

*** Given Clauses
**** Anonymous Given Clauses
**** Inferring Complex Arguments
**** Multiple Given Clauses
**** Summoning Delegates
**** Syntax

*** Context Bounds
**** Context Bounds
**** Syntax

*** Delegate Imports
**** Importing By Type
**** Migration

*** Extension Methods
**** Translation of Extension Methods
**** Translation of Calls to Extension Methods
**** Delegates for Extension Methods
**** Operators
**** Generic Example
**** Syntax

*** Implementing Typeclasses
**** Semigroups and monoids
**** Functors and monads

*** Typeclass Derivation
**** Deriving Types
**** Derivable Types
**** The Shape Type
**** The Generic Typeclass
**** Mirrors
**** GenericClass
**** How to Write Generic Typeclasses
**** Deriving Delegates Elsewhere
**** Syntax
**** Discussion

*** Multiversal Equality
**** Deriving ~Eql~ Delegates
**** Precise Rules for Equality Checking
**** Predefined ~Eql~ Delegates
**** Why Two Type Parameters?

*** Implicit Function Types
**** Example: Builder Pattern
**** Example: Postconditions
**** Reference

*** Implicit Conversions
**** Examples

*** Implicit By-Name Parameters
**** Reference

*** Relationship with Scala 2 Implicits
**** Simulating Contextual Abstraction with Implicits
***** Delegates
***** Anonymous Delegates
***** Given Clauses
***** Context Bounds
***** Extension Methods
***** Typeclass Derivation
***** Implicit Function Types
***** Implicit By-Name Parameters

**** Simulating Scala 2 Implicits in Dotty
***** Implicit Conversions
***** Implicit Classes
***** Implicit Values
***** Abstract Implicit

**** Implementation Status and Timeline

** METAPROGRAMMING
*** DONE Overview
    CLOSED: [2019-06-24 Mon 02:35]
    The following fundamental facilities:
    1. /Inline/
       /inline/ is a new _modifier_ that guarantees that a definition will be
       inlined at the point of use.

       - The primary motivation:
         _reduce the overhead_ behind function calls and access to values.

       - The expansion will be performed by the Scala compiler during the /Typer/
         /compiler phase/.

       - As opposed to /inlining/ in some other ecosystems, /inlining/ in Scala
         is _not merely_ a request to the compiler but is a command.

       - The reason is that /inlining/ in Scala can drive other _compile-time
         operations_, like
         + /inline/ /pattern matching/ (enabling type-level programming)
         + /macros/ (enabling compile-time, generative, metaprogramming)
         + /runtime code generation/ (multi-stage programming)

    2. /Macros/ construct code at /compile-time/
       - /Macros/ are built on two well-known fundamental operations:
         + quotation ::
           *converts program code to data*, specifically, a (tree-like)
           representation of this code. It is expressed as
           * ~'{...}~ for /expressions/
           * ~'[...]~ for /types/

         + splicing :: *converts a program's representation to program code*
           * expressed as ~${ ... }~.

       - The /inline/ and /splicing/ abstractions allow to construct program
         code programmatically.

    3. /Staging/ construct new code at /runtime/.
       That way, code generation can depend not only on static data but also on
       data available at runtime. This splits the evaluation of the program in
       two or more phases or ... /stages/.
         Consequently, this method generative programming is called /"Multi-Stage
       Programming"/. /Staging/ is built on the _SAME_ foundations as /macros/.
       It uses /quotes/ and /splices/, but _LEAVES OUT_ /inline/.

    4. /Erased Terms/ =???= TODO
       Erased terms are used to enforce guarantees about program constraints.
       As erased terms are guaranteed not to be used in computations, they will
       not appear at the generated code.

    5. /TASTy Reflection/
       + /Quotations/ are a "black-box" representation of code.
         They can be parameterized and composed using /splices/ but their
         structure cannot be analyzed from the outside.
       + /Tasty reflection/ gives a way to analyze code structure by partly
         revealing the representation type of a piece of code in a standard API.
         TODO
         The _representation type_ is a form of /typed abstract syntax tree/,
         which gives rise to the "TASTy` moniker.

    6. /TASTy Inspection/
       /Typed abstract syntax trees/ are serialized in a custom compressed
       binary format in =.tasty= files. /TASTy inspection/ allows to _load_
       these files and _analyze_ their content's tree structure.

*** TODO Inline
**** Inline Definitions
**** Recursive Inline Methods
**** Relationship to ~@inline~
***** The definition of constant expression

**** Specializing Inline (Whitebox)
**** DONE Inline Conditionals
     CLOSED: [2019-06-24 Mon 03:05]
     #+begin_src scala
       inline def update(delta: Int) =
         inline if (delta >= 0) increaseBy(delta)
                else            decreaseBy(-delta)
     #+end_src
     + Use ~inline~ means in the call site ~delta~ _MUST be_ a /compile-time
       constant/.

     + A call ~update(22)~ would re-write to ~increaseBy(22)~.

     + A call with a value of not compile-time constant will trigger a compile
       error:
       #+begin_src text
            |  inline if (delta >= 0) ???
            |  ^
            |  cannot reduce inline if
            |   its condition
            |     delta >= 0
            |   is not a constant value
            | This location is in code that was inlined at ...
       #+end_src

**** Inline Matches
     - TODO
       #+begin_src scala
         inline def g(x: Any) <: Any = inline x match {
           case x: String => (x, x)  // Tuple2[String, String](x, x)
           case x: Double => x
         }

         g(1.0d)  // Has type 1.0d which is a subtype of Double
           g("test")  // Has type (String, String)
       #+end_src

     - TODO
       #+begin_src scala
         trait Nat
         case object Zero extends Nat
         final case class Succ[N <: Nat](n: N) extends Nat

         inline def toInt(n: Nat) <: Int = inline n match {
           case Zero     => 0
           case Succ(n1) => toInt(n1) + 1
         }

         final val natTwo = toInt(Succ(Succ(Zero)))
         val intTwo: 2 = natTwo
       #+end_src

**** DONE The ~scala.compiletime~ Package
     CLOSED: [2019-06-24 Mon 16:36]
     The ~scala.compiletime~ package contains _helper definitions_ that provide
     support for /compile time/ OPERATIONS over _values_. They are described in the
     following.
***** ~constValue~, ~constValueOpt~, and the ~S~ combinator
      - ~constValue[T]~ generate a constant value of type ~T~

      -                0.200.13@25.3.1 (spacema~constValueOpt[T]~ generate a constant value of type ~Option[T]~

      - ~S~ is the type of the successor of some singleton type.
        For example, ~S[1]~ is the /singleton type/ ~2~.

***** ~eraseValue~
      - The ~erasedValue[T]~ function in ~scala.comiletime.erasedValue~ is not
        implemented -- it would always raise a ~NotImplementedError~ exception
        when called.
          _However, it can in fact never be called, since it is declared ~erased~ --
        it is only used at /compile-time/ during type checking._

      - Example:
        #+begin_src scala
          import scala.comiletime.erasedValue
          // erased def erasedValue[T]: T = ???

          inline def defaultValue[T] = inline erasedValue[T] match {
            case _: Byte    => Some(0: Byte)
            case _: Char    => Some(0: Char)
            case _: Short   => Some(0: Short)
            case _: Int     => Some(0)
            case _: Long    => Some(0L)
            case _: Float   => Some(0.0f)
            case _: Double  => Some(0.0d)
            case _: Boolean => Some(false)
            case _: Unit    => Some(())
            case _          => None
          }

          val dInt:     Some[Int]     = defaultValue[Int]
          val dDouble:  Some[Double]  = defaultValue[Double]
          val dBoolean: Some[Boolean] = defaultValue[Boolean]
          val dAny:     Any.type      = defaultValue[Any]
        #+end_src

      - Another example:
        #+begin_src scala
          inline def toIntT[N <: Nat] <: Int = inline erasedValue[N] match {
            case _: Zero.type => 0
            case _: Succ[n]   => toIntT[n] + 1
          }

          final val two = toIntT[Succ[Succ[Zero.type]]]
        #+end_src

      - TODO
        Last paragraph???

***** ~error~
      The ~error~ /method/ is used to produce _user-defined_ /compile errors/
      *DURING /inline expansion/.* It has the following signature:
      #+begin_src scala
        inline def error(inline msg: String): Nothing
      #+end_src

      - If an /inline expansion/ results in a call ~error(msgStr)~ the compiler produces
        an _error message_ containing the given ~msgStr~.
        + Example 1
          #+begin_src scala
            inline def fail() = {
              error("failed for a reason")
            }

            fail()  // error: failed for a reason
          #+end_src

          OR

        + Example 2
          #+begin_src scala
            inline def fail(p1: => Any) = {
              error(code"failed on: $p1")
            }

            fail(indentity("foo"))  // error: failed on: indentity("foo")
          #+end_src

**** DONE Implicit Matches
     CLOSED: [2019-06-24 Mon 16:46]
     TODO NOTE
     TODO NOTE
     TODO NOTE
     #+begin_src scala
       inline def setFor[T]: Set[T] = implicit match {
         case _: Ordering[T] => new TreeSet[T]
         case _              => new HashSet[T]
       }
     #+end_src

     + The old way is full of boilterplate:
       #+begin_src scala
         trait SetFor[T, S <: Set[T]]

         class LowPriority {
           implicit def hashSetFor[T]: SetFor[T, HashSet[T]] = ...
         }

         object SetFor extends LowPriority {
           implicit def treeSetFor[T: Ordering]: SetFor[T, TreeSet[T]] = ...
         }
       #+end_src

**** DONE Reference
     CLOSED: [2019-06-24 Mon 16:55]

*** TODO Macros
**** DONE Macros: Quotes and Splices
     CLOSED: [2019-06-26 Wed 15:36]
     - Macros are built on two well-known fundamental operations:
       + quotation :: ~'{...}~ for /expressions/ (both forms are equivalent);
                      ~'[...]~ for /types/.

       + splicing :: ~${ ... }~

     - Additionally, _within_ a /quote/ or a /splice/ we can /quote/ or /splice/
       _identifiers_ directly (i.e. ~'e~ and ~$e~).

     - Readers may notice the _RESEMBLANCE_ of the two aforementioned syntactic
       schemes with the familiar /string interpolation syntax/. /Quotes/ and
       /splices/ in this section allow us to treat code in a similar way,
       effectively supporting /macros/.
       #+begin_src scala
         println(s"Hello, $name, here is the result of 1 + 1 = ${1 + 1}")
       #+end_src
       In string interpolation we /quoted/ a string and then we /spliced/ into it,
       two others.
       1. ~name~, is a reference to a value of type string,
       2. an _arithmetic expression_ that will be evaluated followed by the /splicing/
          of its string representation.

     - The entry point for /macros/ is an /inline method/ with a *top-level* /splice/.
       We call it a top-level because it is the *only occasion* where we encounter a
       /splice/ *outside* a /quote/ (consider as a /quote/ the compilation-unit at the
       call-site).

       For example, the code below presents an ~inline~ /method/ ~assert~ which
       calls at compile-time a method ~assertImpl~ with a /boolean expression
       tree/ as argument. ~assertImpl~ evaluates the expression and prints it again
       in an error message if it evaluates to ~false~.
       #+begin_src scala
         import sala.quoted._

         inline def assert(expr: => Boolean): Unit =
           ${ assertImpl('expr) }

         def assertImpl(expr: Expr[Boolean]) = '{
           if (!$expr)
             throw new AssertionError(s"failed assertion: ${${ showExpr(expr) }}")
         }

         def showExpr(expr: Expr[Boolean]): Expr[String] =
           '{ "<some source code>" }  // Better implementation later in this document
       #+end_src

     - /Quotations/ can have _spliced_ parts in them; in this case the embedded /splices/
       _are evaluated and embedded as part of_ the formation of the /quotation/.

     - /Quotes/ and /splices/ can also be applied *DIRECTLY* to _identifiers_.
       + An /identifier/ ~$x~ starting with a ~$~ that appears _INSIDE_ a /quoted
         expression or type/ is _treated as_ a /splice/ ~${x}~.

       + Analogously, an /quoted identifier/ ~'x~ that appears _INSIDE_ a /splice/
         is _treated as_ a /quote/ ~'{x}~.

     - /Quotes/ and /splices/ are *DUALS of each other*.
       For arbitrary /expressions/ ~e~ and /types/ ~T~ we have:
       #+begin_src scala
         ${'{e}} = e
         '{${e}} = e
         ${'[T]} = T
         '{$[T]} = T
       #+end_src

**** DONE Types for Quotations
     CLOSED: [2019-06-26 Wed 15:44]
     - The /type signatures/ of /quotes/ and /splices/ can be described using
       _TWO_ _FUNDAMENTAL /types/:_
       + ~Expr[T]~: /abstract syntax trees/ representing /expressions/ of /type/ ~T~

       + ~Type[T]~: /type structures/ representing /type/ ~T~.

     - /Quoting/ takes
       + /expressions/ of /type/ ~T~ to /expressions/ of /type/ ~Expr[T]~
       + /types/ ~T~ to /expressions/ of /type/ ~Type[T]~.

     - /Splicing/ takes
       + expressions of /type/ ~Expr[T]~ to /expressions/ of /type/ ~T~
       + expressions of /type/ ~Type[T]~ to /types/ ~T~.

     - The two types can be defined in package ~scala.quoted~ as follows:
       #+begin_src scala
         package scala.quoted

         sealed abstract calss Expr[+T]
         sealed abstract calss Type[T]
       #+end_src
       All constructors for these types are provided by the system, which is the
       reason why they are defined as ~sealed~.

     - One way to construct values of type ~Expr[T]~ or ~Type[T]~ is by /quoting/,
       TODO ???
       the other is by /type-specific lifting operations/ that will be discussed later on.

**** TODO The Phase Consistency Principle
     - A fundamental /phase consistency principle (PCP)/ regulates accesses to /free
       variables/ in /quoted/ and /spliced/ code:
       + For any /free variable reference/ ~x~,
         the _number_ of /quoted scopes/ and the _number_ of /spliced scopes/
         between the reference to ~x~ and the definition of ~x~ *must be equal*.

     - Here, ~this~-reference count as /free variables/.
       TODO

     - We assume all imports are fully expanded and that ~_root_~ is *NOT* a /free
       variable/. So /references/ _to global definitions_ are allowed everywhere.
       TODO

     - The /phase consistency principle/ can _be motivated as follows_:
       1. Suppose the result of a program _P_ is some /quoted text/ ~'{ ... x ... }~
          that refers to a /free variable/ ~x~ in _P_. This can be represented only
          by referring to the original variable ~x~.

       2. Hence, the result of the program will need to persist the program state
          itself as one of its parts. We don't want to do this, hence this situation
          should be made illegal.

          Dually, suppose a top-level part of a program is a /spliced text/ ~${
          ... x ... }~ that refers to a /free variable/ ~x~ in _P_. This would
          mean that we refer during construction of _P_ to a value that is
          _available ONLY during execution of P._
          *This is of course impossible and therefore needs to be ruled out.*

       Now, the small-step evaluation of a program will reduce /quotes/ and
       /splices/ in equal measure using the cancellation rules above. But it will
       neither create nor remove /quotes/ or /splices/ individually. So the PCP
       ensures that program elaboration will lead to neither of the two unwanted
       situations described above.

**** From ~Expr~'s to Functions and Back
**** Types and the PCP
**** Lifting Expressions
**** Lifting Types
**** Relationship with Inline
**** Scope Extrusion
**** Example Expansion
**** Relationship with Whitebox Inline

*** TODO Staging
**** API
**** Example

*** TODO Erased Terms
**** Why erased terms?
**** How to define erased terms?
**** What happens with erased values at runtime?
**** State machine with erased evidence example

*** TODO TASTy Reflection
**** API: From quotes and splices to TASTy reflect trees and back
***** Sealing and Unsealing
***** Obtaining and underlying argument
***** Positions
***** Tree Utilities
***** Let

**** TASTy Reflect API
**** More Examples

*** TODO TASTy Inspection
**** Inspecting TASTy files

** OTHER NEW FEATURES
*** Trait Parameters
**** Reference

*** Creator Applications
**** Motivation
**** Discussion

*** Export Clauses
**** Motivation
**** Syntax changes
**** Elaboration of Export Clauses

*** Opaque Type Alias
**** Bounds For Opaque Type Alias

*** Parameter Untupling
    For data like ~val xs: List[(Int, Int)]~,
    - In Scala 2.x,
      use _EXPLICIT_ /pattern matching/ (partial function) decomposition:
      #+BEGIN_SRC scala
        xs map {
          case (x, y) => x + y
        }
      #+END_SRC

    - Dotty allows the syntax:
      #+BEGIN_SRC scala
        xs map {
          (x, y) => x + y
        }

        // OR, EQUIVALENTLY:
        xs.map(_ + _)
      #+END_SRC

    - Generally, a /function value/ with *n > 1 parameters* is _converted to_ a
      /pattern-matching closure/ using ~case~ if the expected type is a /unary
      function type/ of the form ~((T_1, ..., T_n)) => U~.

**** Reference

*** Kind Polymorphism
*** Tupled Function
**** Tupled Function
**** Examples

*** ~threadUnsafe~ Annotation
**** Examples

** OTHER CHANGED FEATURES
*** Programmatic Structural Types
**** Example
**** Extensibility
**** Relation with ~scala.Dynamic~

*** Rules for Operators
**** The ~@alpha~ Annotation
***** Motivation
***** Details

**** The ~@infix~ Annotation
***** Motivation
***** Details

*** Wildcard Arguments in Types
**** Motivation
**** Migration Strategy

*** Changes in Type Checking
*** Changes in Type Inference
*** Changes in Implicit Resolution
*** Implicit Conversions
**** Examples

*** Changes in Overload Resolution
**** Looking Beyond the First Argument List
**** Parameter Types of Function Values

*** Vararg Patterns
**** Compatibility considerations

*** Pattern Bindings
**** Bindings in Pattern Definitions
**** Pattern Bindings in For Expressions
**** Syntax Changes
**** Migration

*** Option-less pattern matching
**** Extractors
***** Fixed-Arity Extractors
***** Variadic Extractors

**** Boolean Match
**** Product Match
**** Single Match
**** Name-based Match
**** Sequence Match
**** Product-Sequence Match

*** Automatic Eta Expansion
**** Automatic eta-expansion and nullary methods

*** Changes in Compiler Plugins
**** Using Compiler Plugins
**** Writing a Standard Compiler Plugin
**** Writing a Research Compiler Plugin

*** Lazy Vals initialization
**** Motivation
**** Implementation
**** Note on recursive lazy vals
**** Reference

** DROPPED FEATURES
*** Dropped: DelayedInit
*** Dropped: Scala 2 Macros
*** Dropped: Existential Types
*** Dropped: General Type Projection
*** Dropped: Procedure Syntax
*** Dropped: Package Objects
*** Dropped: Early Initializers
*** Dropped: Class Shadowing
*** Dropped: Limit 22
*** Dropped: XML Literals
*** Dropped: Symbol Literals
*** Dropped: Auto-Application
**** Migrating code
**** Reference

*** Dropped: Weak Conformance
*** Dropped: Nonlocal Returns

* CONTRIBUTING
** Getting Started
*** Requirements
*** Compiling and Running
*** Starting a REPL
*** Generating Documentation

** Workflow
*** Compiling files with dotc
*** Inspecting Trees with Type Stealer
*** Pretty-printing

** Eclipse
*** Setup
*** Import to Eclipse
*** Running/Debugging

** IntelliJ IDEA
   Building Dotty with IntelliJ IDEA
*** Setup
*** Running/Debugging

** Testing
   Testing in Dotty
*** Unit tests
**** Testing with checkfiles

*** Integration tests
**** Bootstrapped-only tests
**** From TASTy tests

** Release Model
*** Model
*** Example
**** At the Dotty Repo
**** At the CI
***** Canceling CI builds

**** Documentation
***** Release Procedure Checklist
***** GitHub Releases and Blog Post

**** Ecosystem

*** Procedure in Bash Scripts

* INTERNALS
** Backend
*** Data Flow
*** Architecture
**** (a) The queue subsystem
**** (b) Bytecode-level types, ~BType~
**** (c) Utilities offering a more "high-level" API to bytecode emission
**** (d) Mapping between type-checker types and ~BType~'s
**** (e) More "high-level" utilities for bytecode emission
**** (f) Building an ASM ~ClassNode~ given an AST ~TypeDef~

** Classpaths
** Core Data Structrues
*** Symbols and SymDenotations
*** Why is this important?
*** Are We Done Yet?
*** What Are the Next Steps?

** Contexts
*** Contexts in the typer
*** In other phases
*** Using contexts

** Differences between scalac and dotc
*** Denotation
**** Denotation vs. SymDenotation
**** Implicit Conversion

*** Symbol
*** Flags
*** Tree
*** Type

** Higher-Kinded Types
   *This page is out of date and preserved for posterity. Please see
   Implementing Higher-Kinded Types in Dotty for a more up to date version*

*** Higher-Kinded Types in Dotty V2
**** The duality
**** Named type parameters
**** Wildcards
**** Type parameters in the encodings
**** Partial applications
**** Modelling polymorphic type declarations
**** Modelling polymorphic type aliases: simple case
**** Modelling polymorphic type aliases: general case
**** Modelling higher-kinded types
**** Full example
**** Status of ~#~

** Overall Structure
*** Package Structure
*** Contexts
*** Compiler Phases

** Dotc's concept of time
** Syntax
   *Scala Syntax Summary*
*** Lexical Syntax
*** Keywords
**** Regular keywords
**** Soft keywords

*** Context-free Syntax
**** Literals and Paths
**** Types
**** Expressions
**** Type and Value Parameters
**** Bindings and Imports
**** Declarations and Definitions

** Type System
*** Class diagram
*** Proxy types and ground types
*** Representations of types
**** Representation of methods

*** Subtyping checks
**** Type rebasing

*** Type caching
    TODO

*** Type inference via constraint solving
    TODO

** Dotty Internals 1: Trees & Symbols (Meeting Notes)
*** Entry point
*** Phases
*** Trees
**** Untyped trees
**** Typed trees
**** Notes on some tree types
***** ThisTree

**** Creating trees
**** Meaning of trees

**** Errors
**** Assignment

*** Symbols
**** ClassSymbol
**** SymDenotation

** Debug Macros
*** position not set
*** unresolved symbols in pickling

* RESOURCES
*** Talks
**** Talks on Dotty
**** Deep Dive with Dotty
