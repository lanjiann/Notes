#+TITLE: Things you need to know about JVM (that matter in Scala)
#+AUTHOR: Mateusz Kubuszok
#+STATUS: This book is 90% complete, LAST UPDATED ON 2020-08-31

* What is JVM - 1
** Primitives and references - 2
** Operations - 5
** More about memory - 9
*** Stack - 9
*** Heap - 14
*** Boxing and unboxing - 15
*** JVM types vs Scala type hierarchy - 16
    
** Exceptions - 18
** Classpath and ~ClassLoader~'s - 21
*** Classpath exception - 23
    
* Classes - 25
** What a normal class is made of - 26
*** Constructor - 27
*** Methods - 28
*** Inheritance - 35
*** Access control - 44
    
** What are ~object~'s (modules) - 47
** Parametric classes - 52
*** Type parameters and type erasure - 53
*** Issues with type erasure - 58
*** ~@specialized~ - 60
    
** Functions vs methods - 62
** ~case classe~'s and ~case object~'s - 67
** ~sealed~ hierarchies - 73
** ~AnyVal~'s - 74
   
* Threads - 79
** Parallel vs concurrent - 79
*** Concurrency - 79
*** Parallelism - 81
*** M:N threads - 82
    
** JVMâ€™s Threads - 82
*** Interruption and canceling - 84
*** ~synchronized~ and ~@volatile~ - 85
*** ~sleep~, ~wait~ and ~notify~ - 95
*** Can we avoid concurrency pitfalls? - 96
   
* Garbage collectors - 99
** GC root - 99
** How JVM cleans up memory - 101
*** Mark and sweep - 102
*** Memory fragmentation - 103
*** Generations, Serial GC and parallel GC - 104
*** Concurrent Mark-Sweep - 106
*** Garbage First (G1) - 107
*** Zero Garbage Collection (ZGC) - 109
*** No GC at all? - 112
*** GCs beyond HotSpot - 112
    
** Value specially treated by memory management - 112
** Memory leaks - 113
** How does memory matter for Scala? - 124
   
* Reflection - 127
** What ~Class[_]~ knows? - 127
** How to obtain ~Class[_]~? - 129
** Best thing since sliced bread? - 131
** Reflection in Scala - 132
** Why it matters that you understand reflection? - 139
   
* Optimizations - 141
** HotSpot - 141
** C1 and C2 - 142
*** Architecture Description (=.ad= files) - 144
    
** Observing JIT at work - 145
*** Printing assembly - 145
*** Printing compilation and inlining - 147
*** JITWatch - 150
    
** Microbenchmarks - 152
*** Example benchmark - 153
*** Flight Recorder and Java Mission Control - 156
*** async -profiler and flame graph - 159
    
** Some of the optimizations done by HotSpot - 165
*** Inlining - 165
*** Loop unrooling - 173
*** Dead code elimination - 175
*** Escape analysis - 177
*** Mono-, Bi- and Megamorphism and devirtualization - 181
*** On Stack Replacement (OSR) - 184
*** Reflection and optimizations - 186
*** More about JVM optimizations - 186
    
** Optimizations beyond JVM - 187
*** Memory alignment - 187
*** Branch prediction - 189
    
** Why it matters to have some idea about JIT? - 190

* Tooling and ecosystem - 193
** Official tools - 193
*** javap and scalap - 193
*** jdb - 194
*** jps - 196
*** jstat and jstatd - 196
*** jstack - 197
*** jcmd - 199
*** Other official tools - 199
    
** Third-party tools - 199
*** jEnv - 199
*** Dependency management and building - 201
    
** Printing all JVM flags - 203
   
* Summary - 205
* Appendix: JVM flags - 207
** GC and memory flags - 208
*** Generation-based memory layout and flags - 208
*** GC selection - 208
*** Memory debugging flags - 209
    
** JIT flags - 209
*** Compilation mode selection - 209
*** Compilation options - 209
*** Compilation debugging - 210
