#+TITLE: Scala with Cats
#+AUTHOR: Noel Welsh and Dave Gurnell
#+Date: November 2017
#+STARTUP: entitiespretty

* DONE Preface - 1
  CLOSED: [2018-10-25 Thu 00:07]
  - The *AIMS* of this book are _TWO-FOLD_:
    + to introduce /monads/, /functors/, and OTHER /functional programming patterns/
      as a way to *structure program design*,

      AND

    + to *explain* HOW these concepts are *implemented in Cats*.

  - Functional patterns differ from OO patterns in *TWO* main ways:
    + thye are _formally_, and thus precisely, defined;

      =from Jian= OO patterns also have formal theory, but not as the functional
      patterns, which are math itself. For OO, a bridge need to be built between
      it and math.

      AND

    + they are extremely (rextremely) GENERAL.

** DONE Versions - 2
   CLOSED: [2018-10-25 Thu 00:07]
   This book use *Scala 2.12.3* and *Cats 1.0.0*.
   You can use this minimal =build.sbt=:
   #+BEGIN_SRC scala
     scalaVersion := "2.12.3"

     libraryDependencies +=
       "org.typelevel" %% "cats-core" % "1.0.0"

     scalacOptions ++= Seq(
       "-Xfatal-warnings",
       "-Ypartial-unification"
     )
   #+END_SRC

*** DONE Template Projects - 2
    CLOSED: [2018-10-25 Thu 00:06]
    - The minimal one:
      ~sbt new underscoreio/cats-seed.g8~

    - The more batteries-included one:
      ~sbt new typelevel/sbt-catalysts.g8~

    - =TODO= =LEARN MORE=
      =tut-enabled=, =catalysts=, =sbt-catalysts=.

** DONE Conventions Used in This Book - 3
   CLOSED: [2018-10-25 Thu 00:07]
*** Typographical Conventions - 3
*** Source Code - 3
*** Callout Boxes - 4

** DONE Acknowledgements - 4
   CLOSED: [2018-10-25 Thu 00:07]
*** Backers - 4

* Part I. Theory - 7
* DONE 1 Introduction - 9
  CLOSED: [2019-03-23 Sat 02:53]
** DONE 1.1 Anatomy of a Type Class - 10
   CLOSED: [2019-03-17 Sun 00:46]
   There are *THREE* important _components_ to the /type class pattern/:
   1. the /type class/ itself

   2. /instances/ for particular types

   3. the /interface methods/ that we expose to users.

*** DONE 1.1.1 The Type Class - 10
    CLOSED: [2019-03-16 Sat 23:32]
    A /type class/ is an /interface/ OR /API/
    that REPRESENTS some functionality we want to implement.

    - In Cats a /type class/
      + is represented by a *trait*
        * with AT LEAST _ONE_ /type parameter/.

    - For example,
      represent generic "serialize to JSON" behaviour as follows:
      #+begin_src scala
        // Define a very simple JSON AST
        sealed trait Json
        final case class JsObject(get: Map[String, Json]) extends Json
        final case class JsString(get: String)            extends Json
        final case class JsNumber(get: Double)            extends Json
        case object JsNull                                extends Json

        // The "serialize to JSON" behaviour is encoded in this trait
        trait JsonWriter[A] {
          def write(value: A): Json
        }
      #+end_src
      ~JsonWriter~ is our "type class"

*** DONE 1.1.2 Type Class Instances - 10
    CLOSED: [2019-03-16 Sat 23:49]
    The /instances/ of a /type class/ provide *implementations for the types* we
    care about.

    - In Scala
      we define /instances/ by
      + creating *concrete implementations* of the /type class/
        AND
      + tagging them with the ~implicit~ keyword:

    - Example code:
      #+begin_src scala
        final case class Person(name: String, email: String)

        object JsonWriterInstances {
          implicit val stringWriter: JsonWriter[String] =
            new JsonWriter[String] {
              def write(value: String): Json =
                JsString(value)
            }

          implicit val personWriter: JsonWriter[Person] =
            new JsonWriter[Person] {
              def write(value: Person): Json =
                JsObject(Map("name"  -> JsString(value.name),
                             "email" -> JsString(value.email)))
            }
          // etc...
        }
      #+end_src

*** DONE 1.1.3 Type Class Interfaces - 11 - =RE-READ=
    CLOSED: [2019-03-17 Sun 00:46]
    A /type class interface/ is any functionality we expose to users.

    - /Interfaces/ are /generic methods/ that _accept_ /instances/ of the /type
      class/ as /implicit parameters/.

    - There are _two_ common ways of specifying an interface:
      1. Interface Objects
      2. Interface Syntax

**** DONE Interface Objects - 11
     CLOSED: [2019-03-17 Sun 00:33]
     The SIMPLEST way of creating an /interface/ is to place /methods/ in a
     /singleton object/:
     #+begin_src scala
       object Json {
         def toJson[A](value: A)(implicit w: JsonWriter[A]): Json =
           w.write(value)
       }
     #+end_src

     - Use case:
       #+begin_src scala
         import JsonWriterInstances._

         Json.toJson(Person("Dave", "dave@example.com"))
         // res4: Json = JsObject(Map(name -> JsString(Dave), email -> JsString(dave@example.com)))
       #+end_src

       The compiler inserts the required /implicit parameters/:
       ~Json.toJson(Person("Dave", "dave@example.com"))(personWriter)~

**** DONE Interface Syntax - 12
     CLOSED: [2019-03-17 Sun 00:46]
     - We can _ALTERNATIVELY_ use /extension methods/ to *extend* _existing
       types_ with /interface methods/.

       Cats refers to this as *syntax* for the /type class/:
       #+begin_src scala
         object JsonSyntax {
           implicit class JsonWriterOps[A](value: A) {
             def toJson(implicit w: JsonWriter[A]): Json =
               w.write(value)
           }
         }
       #+end_src

     - Use case:
       #+begin_src scala
         import JsonWriterInstances._
         import JsonSyntax._

         Person("Dave", "dave@example.com").toJson
         // res6: Json = JsObject(Map(name -> JsString(Dave), email -> JsString(dave@example.com)))
       #+end_src

       The compiler inserts the required /implicit parameters/:
       ~Person("Dave", "dave@example.com").toJson(personWriter)~

     - =TODO=
       + Q :: What is the process of
              expanding ~Person("Dave", "dave@example.com").toJson~
              to
              ~JsonWriterOps(Person("Dave", "dave@example.com")).toJson(personWriter)~?

       + A :: TODO ???


**** DONE The _implicitly_ Method - 13
     CLOSED: [2019-03-17 Sun 00:16]
     We can use ~implicitly~ to summon any value from /implicit scope/.

     - Definition from the Scala standard library:
       #+begin_src scala
         def implicitly[A](implicit value: A): A =
           value
       #+end_src

     - Use case:
       #+begin_src scala
         import JsonWriterInstances._

         implicitly[JsonWriter[String]]
         // res8: JsonWriter[String] = JsonWriterInstances$$anon$1@38ee55c4
       #+end_src

     - Most /type classes/ in Cats provide *other means* to _summon_ /instances/.

       HOWEVER, ~implicitly~ is a *good fallback* _for debugging purposes_.
       We can insert a call to ~implicitly~ within the general flow of our code
       to
       + _ensure_ the compiler CAN FIND an /instance/ of a /type class/
         and
       + _ensure_ that there are no AMBIGUOUS implicit errors.

** TODO 1.2 Working with Implicits - 13
   There are a few rules we need to know about /implicits/ (/implicit values/ and
   /implicit parameters/) to use them effectively.

*** DONE 1.2.1 Packaging Implicits - 13
    CLOSED: [2019-03-20 Wed 13:27]
    *Placing* /instances/ in a /companion object/ to the /type class/ has
    special significance in Scala because it plays into something called
    /implicit scope/.

*** DONE 1.2.2 Implicit Scope - 14
    CLOSED: [2019-03-20 Wed 15:34]
    - The _compiler_ *searches* for CANDIDATE /type class instances/ *by type*.
      =from Jian=
      In Scala 3, we may have /named implicits/, then search can be *by type AND
      name*.

    - For example,
      the compiler will search for ~JsonWriter[String]~ when it sees
      ~Json.toJson("A string!")~

    - The compiler searches for candidate instances in the /implicit scope/ at
      the call site, which _ROUGHLY_ consists of:
      + local or inherited definitions;

      + imported definitions;

      + definitions in the /companion object/ of the /type class/ or the
        /parameter type/ (in the example ~JsonWriter~ or ~String~).

      Of course, the ~implicit~ keyword is the prerequisite. Without it
      definitions can't be considered in /implicit scope/.

    - Ambiguous implicit values ERROR:
      *NOT only one* /implicit values/ with proper type can be found.

    - The precise rules of /implicit resolution/ are more complex then the ones
      listed above!

    - Footnote 3: =!!!=
      =READ= =IMPORTANT=

    - For our puposes, we can *package* /type class instances/ in roughly _FOUR_
      ways:
      1. by placing them in an /object/ such as ~JsonWriterInstances~;

      2. by placing them in a ~trait~;

      3. by placing them in the /companion object/ of the /type class/;

      4. by placing them in the /companion object/ of the /parameter type/.

    - How to use /implicits/ when you package like above:
      + With option 1 we bring instances into scope by *importing* them.

      + With option 2 we bring them *into scope with inheritance*.

      + With options 3 and 4, instances are *always in implicit scope*,
        regardless of where we try to use them.

*** TODO 1.2.3 Recursive Implicit Resolution - 15
    - =TODO=

    - Example:
      #+begin_src scala
        implicit def optionWriter[A]
          (implicit writer: JsonWriter[A]) =
          new JsonWriter[Option[A]] {
            def write(option: Option[A]): Json =
              option match {
                case Some(aValue) => writer.write(aValue)
                case None => JsNull
              }
          }

      #+end_src

      + A simplified version:
        #+begin_src scala
          import scala.reflect.ClassTag

          implicit def optionWriter[A : ClassTag](implicit writer: JsonWriter[A]) = {
            case Some(v: A) => writer.write(v)
            case None       => JsNull
          }
        #+end_src
        =TODO= WHY type ~A~ is erased???

    - =TODO=

    - *Implicit Conversions*
      + PREFERRED:
        /Implicit function/ definition with /implicit parameters/.

        This make compiler recursively search the required /implicits/. _This is
        the preferred pattern._

      + NOT Preferred in modern Scala code, older pattern:
        /implicit conversion/.

        Compiler will give a warning, and if you want to dimiss the warning
        (*DON'T!*), you need ~import scala.language.implicitConversions~ in your
        file (this is also indicated in the warning message).

      + Attention:
        /Interface Syntax/ is different from /implicit conversion/.
        It is defined as an /implicit class/ with /extension methods/!

** DONE 1.3 Exercise: Printable Library - 18
   CLOSED: [2019-03-22 Fri 13:03]
   The limitation of ~toString~ method. =TODO=
   Work around these problems with ~Printable~ /type class/.

   - Let's *define* a ~Printable~ /type class/ to work around these problems:
     1. *Define* a /type class/ ~Printable[A]~ containing a SINGLE /method/ ~format~,
        which
        + _accept_ a value of type ~A~
        + _return_ a ~String~.

     2. *Create* an object ~PrintableInstances~ containing /instanceS/ of
        ~Printable~ FOR ~String~ and ~Int~.

     3. *Define* an object ~Printable~ with TWO /generic interface methods/:
        + ~format~ uses the relevant ~Printable~ to convert the ~A~ to a ~String~.
          * accepts a value of type ~A~
          * returns a ~Printable~ of the corresponding type.

        + ~print~ prints the ~A~ value to the console using ~println~.
          * accepts the same parameters as ~format~
          * returns ~Unit~.

   - Code:
     #+begin_src scala
       trait Printable[A] {
         def format(value: A): String
       }

       object PrintableInstances {
         implicit val StringPrintable: Printable[String] =
           identity[String] _

         val IntPrintable: Printable[Int] =
           (_: Int).toString
       }

       object Printable {
         def format[A](input: A)(implicit p: Printable[A]): String =
           p.format(input)

         def print(input: A)(implicit p: Printable[A]): Unit =
           println(format(input))
       }
     #+end_src

*** DONE Using the Library - 19
    CLOSED: [2019-03-21 Thu 18:34]
    #+begin_src scala
      final case class Cat(name: String, age: Int, color: String)

      // Add to the `PrintableInstances`
      implicit val cat = new Printable[Cat] {
        def format(cat: Cat): String = {
          val name: String  = Printable.format(cat.name)
          val age: String   = Printable.format(cat.age)
          val color: String = Printable.format(cat.color)
          s"$name is a $age year-old $color cat."
        }
      }
    #+end_src

*** DONE Better Syntax - 19
    CLOSED: [2019-03-22 Fri 13:03]

** DONE 1.4 Meet Cats - 20 - =TODO= _Exercise_
   CLOSED: [2019-03-20 Wed 22:23]
   - Previous section:
     we saw *HOW* to *implement* /type classes/ _in Scala_.

     This section:
     we will look at *HOW* /type classes/ are *implemented* _in Cats_.

   - Cats is written using a /modular structure/ that allows us to choose which
     /type classes/, /instances/, and /interface methods/ we want to use.

     Let's take a first look using ~cats.Show~ as an example.
     ~Show~ is Cats' equivalent of the ~Printable~ /type class/ we defined in
     the last section.

     An abbreviated definition:
     #+begin_src scala
       package cats

       trait Show[A] {
         def show(value: A): String
       }
     #+end_src

*** DONE 1.4.1 Importing Type Classes - 20
    CLOSED: [2019-03-20 Wed 20:39]
    /Type classes/ are defined in ~cats~ /package/.
    Use it with ~import cats.Show~

    - The /companion object/ of *every* /Cats type class/ has an ~apply~ /method/
      that *locates* an /instance/ for any type we specify.

      However, you need to bring related /implicits/ to scope first.
      ONLY ~Show.apply[Int]~ will throw errors.

*** DONE 1.4.2 Importing Default Instances - 21
    CLOSED: [2019-03-20 Wed 20:49]
    The ~cats.instances~ /package/ provides /DEFAULT instances/ for a wide
    variety (=HOW WIDE???=) of types.

    - EACH /import/ provides /instances/ of ALL Cats' /type classes/
      for a SPECIFIC /parameter type/:
      + ~cats.instances.int~ provides instances for ~Int~

      + ~cats.instances.string~ provides instances for ~String~

      + ~cats.instances.list~ provides instances for ~List~

      + ~cats.instances.option~ provides instances for ~Option~

      + ~cats.instances.all~ provides *ALL* /instances/ that are shipped out of
        the box with Cats

    - Usage:
      #+begin_src scala
        import cats.instances.int._     //  for Show
        import cats.instances.string._  //  for Show

        val showInt: Show[Int]       = Show.apply[Int]
        val showString: Show[String] = Show.apply[String]


        val intAsString: String =
          showInt.show(123)
        // intAsstring: String = 123

        val stringAsString: String =
          showString.show("abc")
        // StringAsstring: String = abc
      #+end_src

*** DONE 1.4.3 Importing Interface Syntax - 22
    CLOSED: [2019-03-20 Wed 20:56]
    Make ~Show~ easier to use by _importing the /interface syntax/ from
    ~cats.syntax.show~._

    - This adds an /extension method/ called ~show~ to ANY /type/ for which we
      have an /instance/ of ~Show~ in scope:
      #+begin_src scala
        import cats.syntax.show._  // for show

        val shownInt = 123.show
        // showInt: String = 123

        val shownString = "abc".show
        // shownString: String = abc
      #+end_src

    - Cats provides *SEPARATE* syntax imports for EACH /type class/.
      =TODO= We will introduce these as we encounter them in later sections and
      chapters.

*** DONE 1.4.4 Importing All The Things! - 22
    CLOSED: [2019-03-20 Wed 21:14]
    - You should feel free to take one of the following shortcuts to simplify your
      imports:
      + ~import cats._~ imports *ALL* of Cats' /type classes/ in one go;

      + ~import cats.instances.all._~ imports *ALL* of the /type class instances/
        for the standard library in one go;

      + ~import cats.syntax.all._~ imports *ALL* of the /syntax/ in one go;

      + ~import cats.implicits._~ imports *ALL* of the /standard type class
        instances/ and *ALL* of the /syntax/ in one go.

    - Most people start their files with the following imports:
      #+begin_src scala
        import cats._
        import cats.implicits._
      #+end_src

      reverting to more specific imports only if they encounter naming conflicts
      or problems with ambiguous implicits:

*** DONE 1.4.5 Defining Custom Instances - 23
    CLOSED: [2019-03-20 Wed 22:23]
    - Q :: *HOW to define* an /instance/ of ~Show~?

    - A :: implementing the /trait/ for a given type:
           =TODO= Replace this example with ~java.time.LocalDate~.
                  STOP using ~java.util.Date~ even in example code!!!
           #+begin_src scala
             import java.util.Date

             implicit val dateShow: Show[Date] =
               new Show[Date] {
                 def show(date: Date): String = s"${date.getTime}ms since the epoch."
               }
           #+end_src

      + Simplified code:
        #+begin_src scala
          import java.util.Date

          implicit val dateShow: Show[Date] =
              date => s"${date.getTime}ms since the epoch."
        #+end_src

    - Cats also provides a couple of convenient methods to *simplify* the process
      of creating /instances/.

      For ~Show~, there are two _construction methods_ on the /companion object/.
      + ~def show[A](f: A => String): Show[A]~

      + ~def fromToString[A]: Show[A]~

    - Use the ~show~ _construction method_:
      #+begin_src scala
        implicitval dateShow: Show[Date] =
          Show.show(date => s"${date.getTime}ms since the epoch.")
      #+end_src

      =from Jian= This is still more code then my *Simplified code* above.
                  WHY do we need ~show~???

    - Many /type classes/ in Cats provide /helper methods/ like these for
      *constructing* /instances/,
      + either *from scratch*
      + or by *transforming existing* /instances/ for other types.
        =TODO= =TODO= =TODO=

*** TODO 1.4.6 Exercise: Cat _Show_ - 24

** DONE 1.5 Example: _Eq_ - 24
   CLOSED: [2018-10-24 Wed 22:10]
   - ~Eq~ is designed to
     + support *type-safe equality*
       and
     + address annoyances using Scala's built-in ~==~ operator.

   - With the built-in ~==~ no type-safty equality check, we may make _mistake_
     like:
     #+BEGIN_SRC scala
       List(1, 2, 3).map(Option.apply).filter(_ == 1)
       // res0: List[Option[Int]] = List()
     #+END_SRC

     It will be perfect if this is a /type error/ rather than /runtime error/.
     ~cats.Eq~ is designed to do this!!!

*** DONE 1.5.1 Equality, Liberty, and Fraternity - 25
    CLOSED: [2018-10-24 Wed 21:18]
    We can use ~Eq~ to define /type-safe equality/ between /instances/ of ANY
    given /type/:
    #+BEGIN_SRC scala
      package cats

      trait Eq[A] {
        def eqv(a: A, b: A): Boolean
        // other concrete methods based on `eqv`...
      }
    #+END_SRC
    The /interface syntax/, defined in ~cats.syntax.eq~, provides *two* /methods/
    for performing equality checks provided there is an instance ~Eq[A]~ _in
    scope_:
    - ~===~ compares two objects for /equality/;

    - ~=!=~ compares two objects for /inequality/.

*** DONE 1.5.2 Comparing Ints - 25
    CLOSED: [2018-10-24 Wed 21:21]
    Examples:
    #+BEGIN_SRC scala
      import cats.Eq
      import cats.instances.int._  // for `Eq`

      val eqInt = Eq[Int]

      eqInt.eqv(123, 123)
      // res2: Boolean = true

      eqInt.eqv(123, 234)
      // res2: Boolean = false

      eqInt.eqv(123, "234")
      //// type mismatch error

      import cats.syntax.eq._  // for `===` and `=!=`

      123 === 123
      // res5: Boolean = true

      123 =!= 234
      // res6: Boolean = true
    #+END_SRC

*** DONE 1.5.3 Comparing Options - 26
    CLOSED: [2018-10-24 Wed 21:26]
    #+BEGIN_SRC scala
      import cats.instances.int._     // for `Eq`
      import cats.instances.option._  // for `Eq`
      import cats.syntax.eq._

      Some(1) === None
      //// type mismatch

      (Some(1): Option[Int]) === (None: Option[Int])  // too verbose
      // res9: Boolean = false

      Option(1) === Option.empty[Int]
      // res10: Boolean = false
    #+END_SRC

    =IMPORTANT= =RE-READ= =RE-READ=
    =from Jian=
    Must be ~(Some(1): Option[Int])~ or ~Option(1)~.
    ~Some(1) === (None: Option[Int])~ have /type error/ -- here you can only
    compre ~Option[Int]~ with ~Option[Int]~, and compre its different subtypes
    will lead to /type error/ -- extremely strict type checking!!!

    OR use special syntax from ~cats.syntax.option~:
    #+BEGIN_SRC scala
      import cats.syntax.option._  // for some and none

      1.some === none[Int]
      // res11: Boolean = false

      1.some =!= none[Int]
      // res12: Boolean = true
    #+END_SRC

*** DONE 1.5.4 Comparing Custom Types - 28
    CLOSED: [2018-10-24 Wed 21:30]
    Define our own instances of ~Eq~ with ~Eq.instance~ /method/, which accepts
    a function of type ~(A, A) => Boolean~ and returns an ~Eq[A]~:
    #+BEGIN_SRC scala
      import java.util.Date
      import cats.instances.long._  // for `Eq`

      implicit val dateEq: Eq[Date] =
        Eq.instance[Date] { (date1, date2) =>
          date1.getTime === date2.getTime
        }

      val x = new Date  // now
      val y = new Date  // a bit later than `x`

      x === x  // true
      x === y  // false
    #+END_SRC

*** DONE 1.5.5 Exercise: Equality, Liberty, and Felinity - 28
    CLOSED: [2018-10-24 Wed 22:06]
    #+BEGIN_SRC scala
      import cats.Eq
      import cats.syntax.eq._
      import cats.instances.int._
      import cats.instances.string._

      final case class Cat(name: String, age: Int, color: String)

      implicit val catEq: Eq[Cat] =
        Eq.instance[Cat] { case (Cat(nm1, ag1, clr1), Cat(nm2, ag2, clr2)) =>
          nm1 == nm2 &&
            ag1 == ag2 &&
            clr1 == clr2
        }

      val cat1 = Cat("Garfield",   38, "orange and black")
      val cat2 = Cat("Heathcliff", 33, "orange and black")

      cat1 === cat2  //
      cat1 =!= cat2  //

      // `Option[Cat]`
      import cats.instances.option._

      val optionCat1 = Option(cat1)
      val optionCat2 = Option.empty[Cat]

      optionCat1 === optionCat2  //
      optionCat1 =!= optionCat2  //
    #+END_SRC

    =from Jian= I think, after considering the features of /case classes/, a
    better implementation of ~catEq~ (still *type safe equality check*):
    #+BEGIN_SRC scala
      implicit val catEq: Eq[Cat] =
        Eq.instance[Cat] { (c1, c2) => c1 == c2 }
    #+END_SRC
    This is NOT applicable for /non-case classes/.

    - =IMPORTANT= =TODO=
      Justify!!!
      Re-consider it with corner cases.
      =from Jian= Till now, it is right!

** DONE 1.6 Controlling Instance Selection - 29
   CLOSED: [2019-03-23 Sat 02:53]
   Two issues that _CONTROL /instance/ selection_ must be considered:
   - What is the _relationship_ BETWEEN an instance defined on _a type and its
     subtypes_?

     Example: ~JsonWriter[Option[Int]]~ and ~Json.toJson(Some(1))~

   - How do we choose between /type class instances/ when there are many
     available?

     Example: TWO ~JsonWriter~ for ~Person~.

*** DONE 1.6.1 Variance - 29
    CLOSED: [2019-03-23 Sat 02:52]
**** DONE Covariance - 29
     CLOSED: [2019-03-22 Fri 15:00]
     - Covariance :: the type ~F[B]~ is a /subtype/ of the type ~F[A]~ if ~B~ is
                     a /subtype/ of ~A~.

     - /Covariance/ is useful for modelling many types, including collections.

     - Almost / ALL (_I'm NOT sure_)
       /immutable collections/ are /covariant/.

**** DONE Contravariance - 30
     CLOSED: [2019-03-22 Fri 15:11]
     - Contravariance :: the type ~F[B]~ is a /subtype/ of the type ~F[A]~ if ~A~ is
                         a /subtype/ of ~B~.

     - /Covariance/ is useful for modelling types that represent processes,
       like our ~JsonWriter~ /type class/ above:
       #+begin_src scala
         trait JsonWriter[-A] {
           def write(value: A): Json
         }
       #+end_src

     - It's easy to find out why do we need /contravariance/:
       #+begin_src scala
         val shape: Shape = ???
         val circle: Circle = ???

         val shapeWriter: JsonWriter[Shape] = ???
         val circleWriter: JsonWriter[Circle] = ???

         def format[A](value: A, writer: JsonWriter[A]): Json =
           writer.write(value)
       #+end_src

     - =TODO=

**** DONE Invariance - 31
     CLOSED: [2019-03-22 Fri 15:11]
     - Invariance :: types ~F[A]~ and ~F[B]~ are *never* /subtypes/ of one
                     another, no matter waht the relationship between ~A~ and
                     ~B~.

     - /Invariance/ is *the default semantics for Scala type constructors.*

     - There are *TWO* issues that tend to arise.
       Let's imagine we have an /algebraic data type/ like:
       #+begin_src scala
         sealed trait A
         final case object B extends A
         final case object C extends A
       #+end_src
       1. Will an /supertype/ (in this example, it is ~A~) /instance/ be selected
          for /subtypes/ (in this example, they are ~B~ and ~C~)?

       2. Will an /instance/ for a /subtype/ (~B~) be selected in preference to
          that of a /supertype/ (~A~).

          For instance, if we define an /instance/ for ~A~ and ~B~, and we have
          a value of type ~B~, will the /instance/ for ~B~ be selected in
          preference to ~A~?

     - We can't have both at once. Here are the choices:
       | Type Class Variance           | Invariant | Covariant | Contravariant |
       |-------------------------------+-----------+-----------+---------------|
       | Supertype instance used?      | No        | No        | Yes           |
       | More specific type preferred? | No        | Yes       | No            |

     - _Cats generally *prefers* to use /invariant type classes/._
       =IMPORTANT=
       + Q :: WHY???

       + A :: This allows us to *specify more specific* /instances/ for
              /subtypes/ if we want.

              For example, a value of /type/ ~Some[Int]~, our /type class
              instance/ for ~Option~ will *NOT* be used.
                We can solve this problem with a type annotation like
              ~Some(1): Option[Int]~ or by using /"smart constructors"/ like the
              ~Option.apply~, ~Option.empty~, ~some~, and ~none~ /methods/.

** DONE 1.7 Summary - 32
   CLOSED: [2018-10-24 Wed 22:18]
   - First, we use plain Scala to introduce the concept of /type classes/.
     =TODO= LINK IN YOUTUBE
     We implementated our own ~Printable~ /type class/ using plain Scala before
     looking at two examples from /Cats/ -- ~Show~ and ~Eq~

   - The _general patterns_ in ~Cats~ /type classes/:
     + /Type classes/ are /generic traits/ _in the ~cats~ package_.

     + *EACH* /type class/ has a /companion object/ with,
       * an ~apply~ /method/ for materializing instances;
       * ONE or MORE /construction methods/ for creating /instances/;
       * a collection of other relevant /helper methods/.

     + /DEFAULT instances/ are provided via objects in the ~cats.instances~
       /package/, and are *organized BY* /parameter type/ _RATHER THAN_ BY /type
       class/.

     + MANY /type classes/ have /syntax/ provided via the ~cats.syntax~ /package/.
       =from Jian= Usually, /extension methods/.

   - *NEXT*
     Look at several broad and powerful /type classes/ -- ~Semigroup~, ~Monoid~,
     ~Functor~, ~Monad~, ~Semigroupal~, ~Applicative~, ~Traverse~, and more.

     + We will learn
       * what functionality the /type class/ *provides*,
       * the _formal rules_ (*laws* in math) it *follows*,
       * how it is *implemented* in Cats.

* TODO 2 Monoids and Semigroups - 35
*** DONE Integer addition - 35
    CLOSED: [2018-10-26 Fri 21:35]
    - Operation: Closed under integer ~+~
    - Identity: ~0~
    - Associativity

*** DONE Integer multiplication - 36
    CLOSED: [2018-10-26 Fri 21:35]
    - Operation: Closed under integer ~*~
    - Identity: ~1~
    - Associativity

*** DONE String and sequence concatenation - 36
    CLOSED: [2018-10-26 Fri 21:35]
    - Operation: Closed under String concatenation ~++~
    - Identity: ~""~
    - Associativity


** DONE 2.1 Definition of a _Monoid_ - 37
   CLOSED: [2018-10-26 Fri 22:43]
   #+BEGIN_SRC scala
     trait Monoid[A] {
       def combine(x: A, y: A): A
       def empty: A
     }
   #+END_SRC
   - Only the ~combine~ and ~empty~ /methods/ of this ~trait~ *CANNOT* guarantee
     the _monoid in math_ -- /monoids/ *must formally obey* several /laws/, here
     are functions that can be used to _test_ the /laws/:
     #+BEGIN_SRC scala
       def associativeLaw[A : Monoid](x: A, y: A, z: A): Boolean = {
         val m = implicitly[A]
         m.combine(x, m.combine(y, z)) == m.combine(m.combine(x, y), z)
       }

       def identityLaw[A : Monoid](x: A): Boolean = {
         val m = implicitly[A]
         (m.combine(x, m.empty) == x) && (m.combine(m.empty, x) == x)
       }
     #+END_SRC
     + /Integer subtraction/ does *NOT* obey the /associative law (for /monoid/)/,
       and there is NO /monoid/ under /integer subtraction/ operation.

   - AGAIN,
     *Unlawful instances are dangerous*!!!
     *Unlawful instances are dangerous*!!!
     *Unlawful instances are dangerous*!!!

     It will yield *unpredictable results*.

** DONE 2.2 Definition of a _Semigroup_ - 38
   CLOSED: [2018-10-26 Fri 22:52]
   /Semigroups/ have only ~combine~ and NO ~empty~.

   - /Semigroups/ are often /monoids/.

   - We can add some _restriction_ to eliminate /identitis/ of /monoids/, and
     make them no longer /monids/, but /semigroups/ ONLY.
     For example,
     + positive numbers

     + none empty sequences.
       For example, the ~NonEmptyList~ in Cats.

   - A more accurate, but still simplified compared to the code in Cats,
     definition of Cat's ~Monoid~ is:
     #+begin_src scala
       trait Semigroup[A] {
         def combine(x: A, y: A): A
       }

       trait Monoid[A] extends Semigroup[A] {
         def empty: A
       }
     #+end_src
     =From Jian= The book use /inheritance/, but I want to argue that this is
     actually a /subtyping/. I replace the "inheritance" in the book with
     "subtyping", and get:
       We'll see this kind of /subtypping/ often when discussing /type classes/.
     It provides _modularity_ and allows us to re-use behaviour (=from Jian= API
     compatibility):
       if we define a ~Monoid~ for a type A, we get a ~Semigroup~ _for free_.
     Similarly, if a /method/ requires a parameter of /type/ ~Semigroup[B]~, we
     can pass a ~Monoid[B]~ instead.

** DONE 2.3 Exercise: The Truth About Monoids - 39
   CLOSED: [2018-10-26 Fri 22:59]
   We first complete the ~Monoid~ related definitions in Cats:
   #+begin_src scala
     trait Semigroup[A] {
       def combine(x: A, y: A): A
     }

     trait Monoid[A] extends Semigroup[A] {
       def empty: A
     }

     object Monoid {
       def apply[A](implicit monoid: Monoid[A]) =
         monoid
     }
   #+end_src

   Then let's define the ~Boolean~ related ~Monoid~ (NOT only one):
   #+BEGIN_SRC scala
     implict val booleanAndMonoid = new Monoid[Boolean] {
       def combine(x: Boolean, y: Boolean): Boolean = x && y
       def empty: Boolean = true
     }

     implict val booleanOrMonoid = new Monoid[Boolean] {
       def combine(x: Boolean, y: Boolean): Boolean = x || y
       def empty: Boolean = false
     }

     implict val booleanXorMonoid = new Monoid[Boolean] {
       def combine(x: Boolean, y: Boolean): Boolean = (x && !y) || (!x && y)
       def empty: Boolean = false
     }

     implict val booleanXnorMonoid = new Monoid[Boolean] {
       def combine(x: Boolean, y: Boolean): Boolean = (!x || y) && (x || !y)
       def empty: Boolean = true
     }
   #+END_SRC
   The /identity law/ holds in each case is straightforward.
   The /associative law/ can be proved by enumerating the cases.

** DONE 2.4 Exercise: All _Set_ for Monoids - 40
   CLOSED: [2018-10-26 Fri 23:06]
   - ~Monoid[Set[A]]~ exists UNDER /sets/ ~union~ operation with ~Set.empty[A]~ as
     /identity/:
     #+BEGIN_SRC scala
       implicit def setUnionMonoid[A] = new Monoid[Set[A]] {
         def combine(x: Set[A], y: Set[A]): Set[A] =
           x union y

         // Now you know why we use `def` for `empty` in the definition of `Monoid`!
         def empty: Set[A] = Set.empty
       }
     #+END_SRC
     + Use cases:
       #+begin_src scala
         val intSetMonoid = Monoid[Set[Int]]
         val strSetMonoid = Monoid[Set[String]]

         intSetMonoid.combine(Set(1, 2), Set(2, 3))
         // res2: Set[Int] = Set(1, 2, 3)

         strSetMonoid.combine(Set("A", "B"), Set("B", "C"))
         // res3: Set[String] = Set(A, B, C)
       #+end_src

   - ~Semigroup[Set[A]]~ exists UNDER /sets/ ~intersect~ opertion.
     There is *NO* ~Monoid[Set[A]]~ under this operation.

   - /Set complement/ and /set difference/ are *NOT* /associative/.
     They are not /monoid/ or /semigroup/.

   - ~Monoid[Set[A]]~ exists UNDER /sets/ /symmetric difference/ operation with
     ~Set.empty[A]~ as /identity/:
     #+BEGIN_SRC scala
       implicit def setSymDiffMonoid[A] = new Monoid[Set[A]] {
         def combine(x: Set[A], y: Set[A]): Set[A] =
           (x diff y) union (y diff x)

         def empty: Set[A] = Set.empty
       }
     #+END_SRC

** DONE 2.5 Monoids in Cats - 40
   CLOSED: [2018-10-26 Fri 23:35]
   We've seen what /monoids/ are.
   Now let's look at their _implementation in Cats_.

   - Once again we'll look at the *THREE* main aspects of the implementation:
     + the /type class/
     + the /instances/
     + the /interface/

*** DONE 2.5.1 The Monoid Type Class - 40
    CLOSED: [2018-10-26 Fri 23:09]
    ~cats.Monoid~ (an alias of ~cats.kernel.Monoid~) and ~cats.Semigroup~ (an
    alias of ~cats.kernel.Semigroup~).
    #+begin_src scala
      import cats.Monoid
      import cats.Semigroup
    #+end_src

    - *Cats Kernel?*
      /Cats Kernel/ is a _subproject_ of Cats providing _a small set_ of
      /typeclasses/ *for libraries that don't require the full Cats toolbox*.

      While these _CORE_ /type classes/ are technically defined in the
      ~cats.kernel~ /package/, they are ALL *aliased* to the ~cats~ package so
      we rarely need to be aware of the distinction.

        The /Cats Kernel/ /type classes/ covered in this book: ~Eq~,
      ~Semigroup~, and ~Monoid~.

      All the other /type classes/ we cover are part of the main Cats project and
      are defined _directly_ in the ~cats~ /package/.

*** DONE 2.5.2 Monoid Instances - 41
    CLOSED: [2018-10-26 Fri 23:12]
    - Example (usage):
      #+BEGIN_SRC scala
        import cats.Monoid
        import cats.instances.string._

        Monoid[String].combine("Hi ", "there")  // "Hi there"
        Monoid[String].empty                    // ""
      #+END_SRC
      + ~Monoid[String]~ is actually ~Monoid.apply[String]~

      + ~Semigroup~ usage is similar.

    - Aseemble a ~Monoid[Option[Int]]~:
      #+begin_src scala
        import cats.Monoid
        import cats.instances.int._     // for Monoid
        import cats.instances.option._  // for Monoid

        val a = Option(22)  // a: Option[Int] = Some(22)
        val b = Option(20)  // b: Option[Int] = Some(20)

        Monoid[Option[Int]].combine(a, b)
      #+end_src

*** DONE 2.5.3 Monoid Syntax - 42
    CLOSED: [2018-10-26 Fri 23:14]
    ~|+|~ is the /combine/ operator, which comes from ~cats.syntax.semigroup._~
    #+BEGIN_SRC scala
      import cats.instances.string._
      import cats.syntax.semigroup._  // for |+|

      val stringResult = "Hi " |+| "there" |+| Monoid[String].empty
      // stringResult: String = Hi there

      import cats.instances.int._ // for Monoid
      val intResult = 1 |+| 2 |+| Monoid[Int].empty
      // inResult: Int = 3
    #+END_SRC

*** DONE 2.5.4 Exercise: Adding All The Things - 43 - =TODO= =???=
    CLOSED: [2018-10-26 Fri 23:35]
    - Write ~add~ for ~Int~
      #+BEGIN_SRC scala
        def add(items: List[Int]): Int =
          items.foldLeft(0)(_ + _)
      #+END_SRC

    - Write generics that can work for ~Int~ and ~Option[Int]~
      #+BEGIN_SRC scala
        import cats.Monoid
        import cats.instances.int._
        import cats.instances.option._
        import cats.syntax.semigroup._

        def add[A : Monoid](items: List[A])(implicit monoid: Monoid[A]): A =
          items.foldLeft(monoid.empty)(_ |+| _)
      #+END_SRC

      If there is NOT ~None~ in the list, we'll see:
      #+BEGIN_SRC scala
        add(List(Some(1), Some(2), Some(3)))
        // <console>:61: error: could not find implicit value for evidence parameter of type cats.Monoid[Some[Int]]
        //        add(List(Some(1), Some(2), Some(3)))
        //           ^
      #+END_SRC
      This is because /Cats/ will ONLY generate a ~Monoid~ for ~Option[Int]~.

      =TODO= =IMPORTANT= =HOWTO= =???=
      We'll se how to get around this in a moment.
      =TODO= =IMPORTANT= =HOWTO= =???=

    - Make ~Order~ addable.
      #+BEGIN_SRC scala
        import cats.Monoid

        case class Order(totalCost: Double, quantity: Double)

        implicit val orderMonoid = new Monoid[Order] {
          def combine(x: Order, y: Order): Order =
            Order(x.totalCost + y.totalCost, x.quantity + y.quantity)

          def empty: Order =
            Order(0.0, 0.0)
        }
      #+END_SRC

** DONE 2.6 Applications of Monoids - 43
   CLOSED: [2018-10-27 Sat 00:08]
   Here are a few big ideas where /monoids/ play a major role.

*** DONE 2.6.1 Big Data - 44
    CLOSED: [2018-10-26 Fri 23:46]
    - Use cases (Need process a huge amount of logs, NOT/CANNOT in ONLY one
      computer):
      + Calculate how many total visitors a web site has received.
        -- thanks for the reality non-negative ~Int~ under the operation of
           /addition/ and the /zero element/ of ~0~ is a /monoid/.

      + Calculate how many unique visitors a web site has received.
        -- thanks for the reality that ~Set(Int)~ under the operation of
           /union/ and the /zero element/ of ~Set.empty[Int]~ is a /monoid/.

      + If we want to calculate 99% and 95% response times from our server logs,
        we can use a data structure called a ~QTree~ for which there is a /monoid/.
        =TODO= =???= ~QTree~.

    - Summary:
      Almost every analysis that we might want to do over a large data set is a
      /monoid/, and therefore we can build an expressive and powerful analytics
      system around this idea.

      This is exactly what Twitter's Algebird and Summingbird projects have
      done. We explore this idea further in the map-reduce case study.

*** DONE 2.6.2 Distributed Systems - 44 - =TODO= =Case-Study= =NOTE=
    CLOSED: [2018-10-27 Sat 00:06]
    We explore this idea further in *the CRDT case study*.

*** DONE 2.6.3 Monoids in the Small - 45
    CLOSED: [2018-10-27 Sat 00:08]
    There are also many cases where having a monoid around makes it easier to
    write a small code fragment.

    See *case studies* of this book

** TODO 2.7 Summary - 45

* TODO 3 Functors - 47
  - /Functors/ allow us to represent sequences of operations within a /context/.

    + =from Jian=
      Here the author use /(COMPUTATIONAL) context/ is more exact than /structure/.
        It might NOT be /structure/ -- unless you think the type is a concrete
      container. =from Jian= This what a book told me. Need Examples!!!

  - /Functor/ is the base of /applicative functor/ and /monad/, which are more
    useful.

** DONE 3.1 Examples of Functors - 47 - =???=
   CLOSED: [2018-10-27 Sat 00:22]
   - Because ~map~ leaves the the /context/ unchanged, we can call it repeatedly
     to *sequence* multiple computations on the _contents_ of an initial data
     structure.

   - We should think of ~map~
     + *NOT* as an /iteration pattern/,
     + BUT as a way of *sequencing* computations on values
       IGNORING SOME COMPLICATION dictated by the relevant data type.

     =NOT very clear about this paragraph!!!=

** DONE 3.2 More Examples of Functors - 49
   CLOSED: [2018-10-27 Sat 00:54]
*** DONE ~Futures~ - 49 - =Not a good and simple example for Functor=
    CLOSED: [2018-10-27 Sat 00:26]
    - =TODO=
      Some thing about ~Future~ and its async features.

    - *Futures and Referential Transparency*
      + Scala's ~Future~'s are *NOT* a great EXAMPLE of _pure functional pro-
        gramming_ because they are *NOT* /referentially transparent/.

      + Example =TODO=

*** DONE Functions (?!) - 49
    CLOSED: [2018-10-27 Sat 00:53]
    - /Single argument functions/ are also /functors/
      =IMPORTANT=

    - ~map~ for /single argument functions/ is, by concept, /function composition/
      (it works like ~andThen~) -- a kind of *sequencing*! We can think of this as
      lazily queueing up operations similar to ~Future~.

      For example:
      #+begin_src scala
        val func =
          ((x: Int) => x.toDouble).
            map(_ + 1).
            map(_ * 2).
            map(_ + "!")

        func(123)
        // res10: String = 248.0!
      #+end_src

    - *Partial Unification*
      _BEFORE Scala 2.13_, You need ~scalaOptions += "-Ypartial-unification"~

      Or you'll see some error like:
      #+BEGIN_SRC scala
        func1.map(func2)
        // <console>: error: value map is not a member of Int => Double
        //        func1.map(func2)
      #+END_SRC

      + =TODO= EXPLAIN in Seciton 3.8
        =IMPORTANT=
        =IMPORTANT=
        =IMPORTANT=

** DONE 3.3 Definition of a Functor - 54
   CLOSED: [2018-10-27 Sat 00:53]
   #+BEGIN_SRC scala
     package cats

     import scala.language.higherKinds

     trait Functor[F[_]] {
       def map[A, B](fa: F[A])(f: A => B): F[B]
     }
   #+END_SRC
   - =TODO=
     NEXT SECTION will explain:
     + /type constructors/ and /higher kinded types/ -- be related to the ~F[_]~
       above.

     + The ~scala.language~ line.


   - *Functor Laws*
     =from Jian= You implment the ~Functor[F[_]]~ /trait/, you only create a
     /functor in code/, you must VERIFY these /laws/ to guarantee a *FORMAL*
     /functor in math/.

     + *Identity*:
       calling ~map~ with the /identity function/ is the same as doing nothing:
       _fa.map(identity) \equiv{} fa_

     + *Composition*:
       mapping with two functions ~f~ and ~g~ is the same as mapping with ~f~
       and then mapping with ~g~:
       _fa.map(g(f(_))) \equiv{} fa.map(f).map(g)_

** DONE 3.4 Aside: Higher Kinds and Type Constructors - 55
   CLOSED: [2018-10-27 Sat 01:50]
   =IMPORTANT=
   - kinds :: "types" for /types/ -- a concept used to category /types/.

   - Informally, a /kind/ of a /type/ is the "hole" in a type -- how many
     /types/ we need to feed in to get a *no ~=>~ /type/.*

   - If a /type/ has "hole" (a /type/ on the left hand side of ~=>~ is a "hole"),
     it is called a /higher kinded type/ or a /type constructor/.

     + For example,
       ~List~ is a /type constructor/ (/higher kinded type/), and ~List[Int]~ is a
       /type/ (/kind one type/).

     + A close analogy:
       In Scala, function is also a /value/ in general, but we can also call it
       "value constructor", and call the /value/ that cannot take any parameter
       "value".

   - In Scala
     #+BEGIN_SRC scala
       def myMethod[F[_]] = {            // Define
         val functor = Functor.apply[F]  // Reference
       }
     #+END_SRC
     1. we *declare* /type constructors/ with the help of _underscores_.
        Once we've declared them, however,
     2. we *refer to* them as SIMPLE /identifiers/ -- ~F~.

     This is *analogous to* specifying a function's parameters in its definition and
     ommiting them when refering to it:
     #+BEGIN_SRC scala
       val f = (x: Int) => x * 2  // Declare
       val f2 = f andThen f       // Reference
     #+END_SRC

   - *Language Feature Imports*
     /Higher kinded types/ are considered an _ADVANCED language feature_ in
     Scala, and you need to enable it in the compiler. There are two ways:
     + Explicit import:
       ~import scala.language.higherKinds~
       More explicit, use it in this book.

     + Set in =build.sbt=:
       ~scalacOptions += "-language:higherKinds~
       More concise, and you may prefer this in your projects.

** DONE 3.5 Functors in Cats - 57
   CLOSED: [2019-03-26 Tue 00:02]
   Examine the aspects we did for /monoids/:
   1. the /type class/

   2. the /instances/

   3. the /syntax/

*** DONE 3.5.1 The ~Functor~ Type Class - 57
    CLOSED: [2018-10-27 Sat 02:10]
    - We *obtain* /instances/ using the STANDARD ~Functor.apply~ /method/ on the
      /companion object/.

    - Basic usage:
      #+BEGIN_SRC scala
        import scala.language.higherKinds
        import cats.Functor

        //------------------------------------------
        // `List` functor
        //------------------------------------------
        import cats.instances.list._

        val list1 = List(1, 2, 3)
        // list1: List[Int] = List(1, 2, 3)

        val list2 = Functor[List].map(list1)(_ * 2)
        // list2: List[Int] = List(2, 4, 6)

        //------------------------------------------
        // `Option` functor
        //------------------------------------------
        import cats.instances.option._

        val option1 = Option(123)
        // option1: Option[Int] = Some(123)

        val option2 = Functor[Option].map(option1)(_.toString)
        // option2: Option[String] = Some(123)
      #+END_SRC

    - The ~lift~ /method/ of /functors/:
      ~A => B~ to ~F[A] => F[B]~

      #+BEGIN_SRC scala
        val func = (x: Int) => x + 1
        // func: Int => Int = <function1>

        val liftedFunc = Functor[Option].lift(func)
        // liftedFunc: Option[Int] => Option[Int] = cats.Functor$$Lambda$11699/1098992879@279f562e

        liftedFunc(Option(1))
        // res0: Option[Int] = Some(2)
      #+END_SRC

*** DONE 3.5.2 ~Functor~ Syntax - 58
    CLOSED: [2018-11-26 Mon 01:37]
    Use examples other than ~Option~ and ~List~ as illustration.
    (Rationale: Compiler _always prefer a built-in_ method _over_ an extension
    method).

    - ~Function1~ example:
      #+begin_src scala
        import cats.instances.function._ // for Functor
        import cats.syntax.functor._ // for map

        val func1 = (a: Int) => a + 1
        val func2 = (a: Int) => a * 2
        val func3 = (a: Int) => a + "!"
        val func4 = func1.map(func2).map(func3)

        func4(123)
        // res1: String = 248!
      #+end_src

    - A method for general /functors/:
      #+begin_src scala
        def doMath[F[_]](start: F[Int])
                  (implicit functor: Functor[F]): F[Int] =
          start.map(_ + 2)

        import cats.instances.option._
        import cats.instances.list._

        doMath(Option(20))
        // res3: Option[Int] = Some(22)

        doMath(List(1, 2, 3))
        // res4: List[Int] = List(3, 4, 5)
      #+end_src

    - To illustrate how this works, let's take a look at the definition of the
      ~map~ /method/ in ~cats.syntax.functor~. Here is a simplified version:
      #+begin_src scala
        implicit class FunctorOps[F[_], A](src: F[A]) {
          def map[B](func: A => B)
                 (implicit functor: Functor[F]): F[B] =
            functor.map(src)(func)
        }
      #+end_src

      =Jian's Guess= =Still not clear about the implicit searching details=
      #+begin_src scala
        foo.map(_ + 1)
        // `foo` should have type `F[Int]`

        // 1.
        new FunctorOps(foo).map(_ + 1)
        // There should be a `Functor[F]` implicit parameter.

        // 2.
        new FunctorOps(foo).map(_ + 1)(fooFunctor)

      #+end_src

      + Example: =from Jian= The procesure of /implicit search/.
        We have a expression ~foo.map(_ + 1)~.
        * Assuming ~foo~ has no built-in ~map~ /method/,
          the compiler detects the potential error and wraps the expression in a
          ~FunctorOps~ to fix the code:
          #+begin_src scala
            new FunctorOps(foo).map(_ + 1)
          #+end_src

        * The ~map~ /method/ of ~FunctorOps~ *requires* an ~implicit Functor~ as
          a parameter.
            This means this code will *ONLY compile* if we have a ~Functor~ for
          ~foo~ (type ~A~) in scope. If we don't, we get a compiler error.

*** DONE 3.5.3 Instances for Custom Types - 60
    CLOSED: [2019-03-25 Mon 23:59]
    - Simple and straightfoward example (already in ~cats.instances~):
      #+BEGIN_SRC scala
        implicit val optionFunctor: Functor[Option] =
          new Functor[Option] {
            def map[A, B](value: Option[A])(func: A => B): Option[B] =
              value.map(func)
          }
      #+END_SRC

    - Must *inject dependencies* into our /instances/,
      BUT we can't add parameter(s) to ~future.map~.

      Thus, we provide /dependencies/ when summon the required /instance/.
      #+BEGIN_SRC scala
        import scala.concurrent.{Future, ExecutionContext}

        implicit def futureFunctor(implicit ec: ExecutionContext): Functor[Future] =
          new Functor[Future] {
            def map[A, B](value: Future[A])(func: A => B): Future[B] =
              value.map(func)
          }
      #+END_SRC

    - Whenever we summon a ~Functor~ for ~Future~, either directly using
      ~Functor.apply~ or indirectly via the ~map~ /extension method/, the
      compiler will locate ~futureFunctor~ by /implicit resolution and recursively
      search/ for an ~ExecutionContext~ at the call site.

      This is what the expansion might look like:
      #+begin_src scala
        // We write this:
        Functor[Future]

        // Step 1.
        Functor.apply[Future]

        // Step 2.
        Functor.apply[Future](futureFunctor)

        // Step 3.
        Functor.apply[Future](futureFunctor(executionContext))
      #+end_src

*** DONE 3.5.4 Exercise: Branching out with Functors - 61
    CLOSED: [2018-10-27 Sat 02:24]
    #+BEGIN_SRC scala
      sealed trait Tree[+A]

      final case class Branch[A](left: Tree[A], right: Tree[A])
          extends Tree[A]
      final case class Leaf[A](value: A)
          extends Tree[A]

      implicit treeFunctor = new Functor[Tree] {
        def map[A, B](tree: Tree[A])(func: A => B): Tree[B] =
          tree match {
            case Leaf(v)      => Leaf(func(v))
            case Branch(l, r) => Branch(map(l)(func), map(r)(func))
          }
      }
    #+END_SRC
    This is right, but not complete:
    #+begin_src scala
      Branch(Leaf(10), Leaf(20)).map(_ * 2)
      // <console>: 42: error: value map is not a member of wrapper.Branch[Int]
      //        Branch(Leaf(10), Leaf(20)).map(_ * 2)
      //
    #+end_src
    =from Jian= Can dotty resolve this???
    Let's add some smart constructors to compensate:
    #+begin_src scala
      object Tree {
        def branch[A](left: Tree[A], right: Tree[A]): Tree[A] =
          Branch(left, right)

        def leaf[A](value: A): Tree[A] =
          Leaf(value)
      }

      Tree.leaf(100).map(_ * 2)
      Tree.branch(Tree.leaf(10), Tree.leaf(20)).map(_ * 2)
    #+end_src

** DONE 3.6 Contravariant and Invariant Functors - 61
   CLOSED: [2019-03-31 Sun 01:56]
   - As we have seen,
     we can think of ~Functor~'s ~map~ /method/ as *"appending"* a
     transformation to a chain.

   - The ~Functor~ we explored is actually /covariant functor/, and its ~map~
     *appends* a transformation to a chain.

   - We're now going to look at _TWO_ other /type classes/:
     + contravariant functor ::
          one representing *prepending* operations to a chain,

     + invariant functor ::
          one representing building a *bidirectional* chain of operations.

   - *This Section is Optional!*
     You do _NOT NEED_ to know about /contravariant and invariant functors/ to
     understand /monads/, the most important pattern in this book.

       HOWEVER, /contravariant/ and /invariant/ do come in HANDY in our
     discussion of ~Semigroupal~ and ~Applicative~ in Chapter 6.
     =from Jian= WHY???

     _If you want to move on to monads now, feel free to skip straight to
     Chapter 4. Come back here before you read Chapter 6._

*** DONE 3.6.1 Contravariant Functors and the ~contramap~ Method - 62
    CLOSED: [2019-03-31 Sun 01:55]
    - /contravariant functor/:
      + ~contramap~ - "prepending" an operation to a chain.

    - The ~contramap~ /method/ *only makes sense* for
      _data types that represent transformations._
      =IMPORTANT=
      For example,
      + _Can't_
        There is *NO WAY* to feed a value in an ~Option[B]~ backwards through a
        function ~A => B~.

      + _Can_
        #+begin_src scala
          trait Printable[A] { self =>
            def format(value: A): String
            def contramap[B](func: B => A): Printable[B] = ???
          }
        #+end_src

**** DONE 3.6.1.1 Exercise: Showing off with Contramap - 63
     CLOSED: [2019-03-31 Sun 01:55]
     #+BEGIN_SRC scala
       trait Printable[A] { self =>
         def format(value: A): String

         def contramap[B](func: B => A): Printable[B] =
           new Printable[B] {
             def format(value: B): String = self.format(func(value))
           }

         //// More concise version:
         // def contramap[B](func: B => A): Printable[B] =
         //   value => self.format(func(value))
       }

       def format[A](value: A)(implicit p: Printable[A]): String =
         p.format(value)
     #+END_SRC

     - Exercise:
       ~final case class Box[A](value: A)~
       Define an /instance/ of ~Printable~ for ~Box~.
       #+begin_src scala
         implicit def boxPrintable[A](implicit p: Printable[A]): Box[A] =
           p.contramap[Box[A]](_.value)
       #+end_src

*** DONE 3.6.2 Invariant functors and the ~imap~ method - 65
    CLOSED: [2019-03-31 Sun 01:47]
    /Invariant functors/ implement a method called ~imap~.

    - ~imap~ is _INFORMALLY equivalent to a combination of ~map~ and ~contramap~._

    - If ~map~ generates new /type class/ instances by *appending* a function to a chain,
         and
         ~contramap~ generates them by *prepending* an operation to a chain,

      ~imap~ generates them via _a PAIR of_ *BIDIRECTIONAL transformations*.

    - The most intuitive examples:
      A /type class/ that represents _encoding_ and _decoding_ as some data type,
      such as Play JSON's ~Format~ and scodec's ~Codec~.
      =TODO= I know the former, but I don't know the latter. =TODO=

    - Build our own ~Codec~ by enhancing ~Printable~ to support /encoding/ and
      /deconding/ to/from a ~String~:
      #+begin_src scala
        trait Codec[A] {
          def encode(value: A): String
          def decode(value: String): A
          def imap[B](dec: A => B, enc: B => A): Codec[B] = ???
        }

        def encode[A](value: A)(implicit c: Codec[A]): String =
          c.encode(value)

        def decode[A](value: String)(implicit c: Codec[A]): A =
          c.decode(value)
      #+end_src

    - The type chart for imap is shown in *Figure 3.6*. If we have a ~Codec[A]~
      and a pair of functions ~A => B~ and ~B => A~, the imap method creates a
      ~Codec[B]~.

    - As an example use case, imagine we have a basic ~Codec[String]~, whose
      ~encode~ and ~decode~ /methods/ are both a no-op:
      #+begin_src scala
        implicit val stringCodec: Codec[String] =
          new Codec[String] {
            def encode(value: String): String = value
            def decode(value: String): String = value
          }
      #+end_src
      We can construct many usefull ~Codec~'s for other types by building off of
      ~stringCodec~ using ~imap~:
      #+begin_src scala
        implicit val intCodec: Codec[Int] =
          stringCodec.imap(_.toInt, _.toString)

        implicit val booleanCodec: Codec[Boolean] =
          stringCodec.imap(_.toBoolean, _.toString)
      #+end_src

    - *Coping with Failure* TODO TODO TODO
      + Our ~Codec~ /type class/ does NOT account for failures.

      + If we want to model more sophisticated relationships we can move beyond
        /functors/ to look at /lenses/ and /optics/.

        _This beyond this book (See Julien Truffaut's /Monocle/)._

**** DONE 3.6.2.1 Transformative Thinking with ~imap~ - 66
     CLOSED: [2019-10-09 Wed 18:20]
     - Exercise:
       Implement ~Codec[A]~
       #+begin_src scala
         trait Codec[A] { self =>
           def encode(value: A): String
           def decode(value: String): A

           def imap[B](dec: A => B, enc: B => A): Codec[B] =
             new Codec[B] {
               override def encode(value: B): String =
                 self.encode(enc(value))

               override def decode(value: String): B =
                 dec(self.decode(value))
             }
         }
       #+end_src

     - Exercise:
       Implement ~Codec[Double]~
       #+begin_src scala
         implicit val doubleCodec =
           stringCodec.imap(_.toDouble, _.toString)
       #+end_src

     - Exercise:
       ~case class Box[A](value: A)~
       Implement ~Codec[Box]~
       #+begin_src scala
         implicit def boxCodec[A](implicit aCodec: Codec[A]): Codec[Box[A]] =
           c.imap[Box[A]](Box.apply, _.value)
       #+end_src

     - Usage:
       #+begin_src scala
         encode(123.4)
         // res0: String = 123.4

         decode[Double]("123.4")
         // res1: Double = 123.4

         encode(Box(123.4))
         // res2: String = 123.4

         decode[Box[Double]]("123.4")
         // res3: Box[Double] = Box(123.4)
       #+end_src

     - *What's With the Names?*
       =TODO=
       =RE-DO=

** DONE 3.7 Contravariant and Invariant in Cats - 68 - =TODO= =NOTE=
   CLOSED: [2019-03-31 Sun 02:12]
   Cats provide /contravariant and invariant functors/ through /type classes/
   ~cats.Contravariant~ and ~cats.Invariant~. Here is a SIMPLIFIED version:
   #+begin_src scala
     trait Contravariant[F[_]] {
       def contramap[A, B](fa: F[A])(f: B => A): F[B]
     }

     trait Invariant[F[_]] {
       def imap[A, B](fa: F[A])(f: A => B)(g: B => A): F[B]
     }
   #+end_src

*** TODO 3.7.1 Contravariant in Cats - 68
    #+begin_src scala
      // TODO: Example code
    #+end_src

*** TODO 3.7.2 Invariant in Cats - 69
    #+begin_src scala
      // TODO: Example code
    #+end_src

** TODO 3.8 Aside: Partial Unification - 70
   - SI-2712, which is identified as a bug, is a type inference limitation. It is
     already fixed.
     + Before Scala 2.13,
       Use the compiler option =-Ypartial-unification=;

     + From Scala 2.13 on, partial-unification is there by default, and no option
       for it.

   - Example:
     + With =-Ypartial-unification= set in =build.sbt=
       #+begin_src scala
         import cats.Functor
         import cats.instances.function._ // for Functor
         import cats.syntax.functor._     // for map

         val func1 = (x: Int) => x.toDouble
         val func2 = (y: Double) => y * 2

         val func3 = func1.map(func2)
         // func3: Int => Double = scala.runtime.AbstractFunction1$$Lambda$7404/290370740@246b5bc6
       #+end_src

     + Without =-Ypartial-unification=, you can see
       #+begin_src scala
         val func3 = func1.map(func2)
         // <console>: error: value map is not a member of Int => Double
         //        val func3 = func1.map(func2)
         //                          ^
       #+end_src

*** TODO 3.8.1 Unifying Type Constructors - 70
    In order to compile an expression like ~func1.map(func2)~ above, the compiler
    has to search for a ~Functor~ for ~Function1~.

    - During the search, however, ~Functor~ accepts a /type constructor/ with *ONE*
      /type parameter/:
      #+begin_src scala
        trait Functor[F[_]] {
          def map[A, B](fa: F[A])(func: A => B): F[B]
        }
      #+end_src

*** TODO 3.8.2 Left-to-Right Elimination - 71

** DONE 3.9 Summary - 74
   CLOSED: [2019-10-10 Thu 14:16]
   Functors represent sequencing behaviours.

   - We covered three types of functor in this chapter:
     - /Covariant Functors/,
       represent the ability to _apply functions to a value in some context_
       with their ~map~ /method/,

       Successive calls to ~map~ apply these functions _in sequence_, each
       accepting the result of its PREdecessor as a parameter.

     - /Contravariant functors/,
       with their ~contramap~ /method/,
       represent the ability to *"prepend"* functions to a function-like context.

       Successive calls to ~contramap~ sequence these functions _in the opposite
       order to_ ~map~.

     - /Invariant functors/,
       represent _bidirectional transformations_. It has the ~imap~ method.

   - The ~Contravariant~ and ~Invariant~ /type classes/ are less widely applicable
     but are still useful for building data types that _represent *transformations*._

     TODO TODO TODO
     We will revisit them to discuss the ~Semigroupal~ /type class/ later in Chapter 6.

* TODO 4 Monads - 77
  - Informally,
    a /monad/ is anything with a /computational context/ and a ~flatMap~
    /method/ that obey the /monad laws/.

  - _Special syntax_ to SUPPORT /monads/: /for comprehensions/.

    However, despite the ubiquity of the concept,
    *the Scala standard library lacks a concrete type to encompass "things that
    can be flatMapped".*

    =from Jian=
    Programming languages like Scala and Rust don't want to scare their users
    with Monad concept support in their standard library.
      However, because of the good type system and their design, /monad/ is
    inevitable -- actually we should give a hug to it. I believe They will
    definitely support /monad/ in their standard libary in the future.
    =END Comment=

    *This type class is one of the benefits brought to us by Cats.*

** DONE 4.1 What is a Monad? - 77
   CLOSED: [2018-10-28 Sun 01:00]
   - *A /monad/ is a mechanism for _SEQUENCING computations_.*

**** DONE ~Option~'s - 78
     CLOSED: [2019-03-31 Sun 04:01]
     #+begin_src scala
       import scala.util.Try

       def parseInt(str: String): Option[Int] =
         Try(str.toInt).toOption

       def divide(a: Int, b: Int): Option[Int] =
         if (b == 0) None else Some(a / b)

       def strignDivideBy(aStr: String, bStr: String): Option[Int] =
         parseInt(aStr).flatMap { aNum =>
           parseInt(bStr).flatMap { bNum =>
             divide(aNum, bNum)
           }
         }

       def strignDivideBy(aStr: String, bStr: String): Option[Int] =
         for {
           aNum <- parseInt(aStr)
           bNum <- parseInt(bStr)
           ans <- divide(aNum, bNum)
         } yield ans
     #+end_src

**** DONE ~List~'s - 80
     CLOSED: [2019-03-31 Sun 03:55]
     The for-comprehension form with ~List~'s looks very like imperative for loops.
     #+begin_src scala
       for {
         x <- List(1, 2, 3)
         y <- List(4, 5)
       } yield (x, y)
     #+end_src

     _HOWEVER_, there is _ANOTHER_ *mental model* we can apply that highlights the
      /monadic behaviour/ of ~List~:
      if we think of ~List~'s as sets of /intermediate results/, ~flatMap~ becomes
      a construct that calculates _permutations and combinations_.

**** DONE ~Future~'s - 81
     CLOSED: [2019-03-31 Sun 03:51]
     This section we give example with for-comprehension, and ~Future~'s *are
     sequenced*.
       We *can* run /futures/ in _parallel_, but this is another story and shall
     be told another time. =TODO= =TODO= =TODO=

     *Monads are all about sequencing.*

*** DONE 4.1.1 Definition of a Monad - 82
    CLOSED: [2018-10-28 Sun 00:04]
    #+BEGIN_SRC scala
      import scala.language.higherKinds

      trait Monad[F[_]] {
        def pure[A](value: A): F[A]

        def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]
      }
    #+END_SRC

    - *Monad Laws*
      ~pure~ and ~flatMap~ must obey a set of /laws/ that allow us to sequence
      operations freely *WITHOUT* unintended glitches and side-effects:

      + Left identity:
        calling ~pure~ and transforming the result with ~func~ is the same as
        calling ~func~:
        ~pure(a).flatMap(func)~ \equiv{} ~func(a)~

      + Right identity:
        passing ~pure~ to ~flatMap~ is the same as doing nothing:
        ~m.flatMap(pure)~ \equiv{} ~m~

      + Associativity:
        flatMapping over two functions ~f~ and ~g~ is the same as flatMapping
        over ~f~ and then flatMapping over ~g~:
        ~m.flatMap(f).flatMap(g)~ \equiv{} ~m.flatMap(x => f(x).flatMap(g))~

*** DONE 4.1.2 Exercise: Getting Func-y - 83
    CLOSED: [2018-10-28 Sun 00:04]
    #+BEGIN_SRC scala
      import scala.language.higherKinds

      trait Monad[F[_]] {
        def pure[A](a: A): F[A]

        def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]

        def map[A, B](value: F[A])(func: A => B): F[B] =
          flatMap(value)(a => pure(func(a)))
          // from Jian:
          // can I write: flatMap(value)(func andThen pure)
      }
    #+END_SRC

** DONE 4.2 ~Monad~'s in Cats - 84
   CLOSED: [2018-10-28 Sun 01:00]
   Still
   - type class
   - instances
   - syntax

*** DONE 4.2.1 The ~Monad~ Type Class - 84
    CLOSED: [2019-04-01 Mon 13:32]
    - ~Monad~ extends _TWO_ other /type classes/:
      + ~FlatMap~, which provides ~flatMap~;
      + ~Applicative~, which provides ~pure~.

*** DONE 4.2.2 Default Instances - 85
    CLOSED: [2019-04-01 Mon 13:32]
    Still inside ~cats.instances~

    - There is a ~Monad~ for ~Future~.
      However, the ~ExecutionContext~ should be provided when summon it.
      #+begin_src scala
        import scala.concurrent.ExecutionContext.Implicits.global

        val fm = Monad[Future]
      #+end_src

*** DONE 4.2.3 ~Monad~ Syntax - 86
    CLOSED: [2019-04-01 Mon 13:44]
    - The syntax for /monads/ comes from _THREE_ places:
      + ~cats.syntax.flatMap~ provides syntax for ~flatMap~;
      + ~cats.syntax.functor~ provides syntax for ~map~;
      + ~cats.syntax.applicative~ provides syntax for ~pure~.

      In practice it's often easier to import everything in one go from
      ~cats.implicits~. For clarity here, we do individual imports.

    - We can use ~pure~ to construct /instances/ of a /monad/.
      Disambiguate with the /type parameter/.
      #+begin_src scala
        import cats.instances.option._       // for Monad
        import cats.instances.list._         // for Monad
        import cats.instances.applicative._  // for pure

        l.pure[Option]
        // res4: Option[Int] = Some(1)

        l.pure[List]
        // res5: List[Int] = List(1)
      #+end_src

    - Usage:
      #+begin_src scala
        import cats.Monad
        import cats.syntax.functor._ // for map
        import cats.syntax.flatMap._ // for flatMap
        import scala.language.higherKinds

        def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] =
          a.flatMap(x => b.map(y => x*x + y*y))

        import cats.instances.option._ // for Monad
        import cats.instances.list._ // for Monad

        sumSquare(Option(3), Option(4))
        // res8: Option[Int] = Some(25)

        sumSquare(List(1, 2, 3), List(4, 5))
        // res9: List[Int] = List(17, 26, 20, 29, 25, 34)
      #+end_src

      + The /comprehension/ version:
        #+begin_src scala
          def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] =
            for {
              x <- a
              y <- b
            } yield x*x + y*y

          sumSquare(Option(3), Option(4))
          // res10: Option[Int] = Some(25)

          sumSquare(List(1, 2, 3), List(4, 5))
          // res11: List[Int] = List(17, 26, 20, 29, 25, 34)
        #+end_src

** DONE 4.3 The ~Identity~ Monad - 88
   CLOSED: [2019-04-01 Mon 14:33]
   - =TODO= NOTE
   - =TODO= NOTE
   - =TODO= NOTE

*** 4.3.1 Exercise: Monadic Secret Identies - 91
    #+begin_src scala
      trait Id[A] extends Functor[A] with Applicative[A] with Monoad[A] {
        def pure[A]: Id[A] =
          this.value

        def map[B](f: A => B): Id[B] =
          f(this.value)

        def flaMap[B](f: A => Id[B]): Id[B] =
          f(this.value)
      }
    #+end_src
    - The Scala compiler is able to interpret values of type ~A~ as ~Id[A]~ and
      vice versa by the context in which they are used.

    - =IMPORATNAT=
      *The only restriction* we've seen to this:
      Scala *CANNOT* _unify types and type constructors_
      _when searching for /implicits/._
        Hence our need to re-type ~Int~ as ~Id[Int]~ in the call to ~sumSquare~
      at the opening of this section: ~sumSquare(3 : Id[Int], 4 : Id[Int])~

** DONE 4.4 ~Either~ - 91
   CLOSED: [2019-04-13 Sat 20:05]
   - In Scala 2.11 and earlier,
     many people didn't consider ~Either~ a /monad/ because it didn't have ~map~
     and ~flatMap~ /methods/.

   - Since Scala 2.12,
     ~Either~ becase right biased with added ~map~ and ~flatMap~.

*** DONE 4.4.1 ~Left~ and ~Right~ Bias - 91
    CLOSED: [2019-04-10 Wed 14:11]
    - Scala 2.11,
      It is inconvenient to use ~Either~ in for-comprehensions.
      #+begin_src scala
        val either1: Either[String, Int] = Right(10)
        val either2: Either[String, Int] = Right(32)

        for {
          a <- either1.right
          b <- either2.right
        } yield a + b
        // res0: scala.util.Either[String,Int] = Right(42)
      #+end_src

    - Scala 2.12, there is a redesigned ~Either~,
      #+begin_src scala
        for {
          a <- either1
          b <- either2
        } yield a + b
        // res1: scala.util.Either[String,Int] = Right(42)
      #+end_src

    - Cats *back-ports* this behaviour to Scala 2.11 via the ~cats.syntax.either~
      import, allowing us to use right-biased ~Either~ in all supported versions
      of Scala.
      #+begin_src scala
        import cats.syntax.either._  // (no need for Scala 2.12+) for map and flatMap

        for {
          a <- either1
          b <- either2
        } yield a + b
      #+end_src

*** DONE 4.4.2 Creating Instances - 92
    CLOSED: [2019-04-10 Wed 18:16]
    - Syntax from ~cats.syntax.either~
      #+begin_src scala
        import cats.syntax.either._  // for asRight

        val a = 3.asRight[String]
        // a: Either[String,Int] = Right(3)

        val b = 4.asRight[String]
        // b: Either[String,Int] = Right(4)

        for {
          x <- a
          y <- b
        } yield x*x + y*y
        // res4: scala.util.Either[String,Int] = Right(25)
      #+end_src

    - The syntax above has advantages over ~Left.apply~ and ~Right.apply~:
      *avoid over-narrowing types*.
      + Over-narrowing:
        #+begin_src scala
          def countPositive(nums: List[Int]) =
            nums.foldLeft(Right(0)) { (accumulator, num) =>
              if(num > 0) {
                accumulator.map(_ + 1)
              } else {
                Left("Negative. Stopping!")
              }
            }
          // <console>:21: error: type mismatch;
          // found   : scala.util.Either[Nothing,Int]
          // required: scala.util.Right[Nothing,Int]
          //             accumulator.map(_ + 1)
          //                            ^
          // <console>:23: error: type mismatch;
          // found   : scala.util.Left[String,Nothing]
          // required: scala.util.Right[Nothing,Int]
          //             Left("Negative. Stopping!")
          //                 ^
        #+end_src
        This code fails to compile for _TWO_ reasons:
        1. the compiler *infers* the type of the accumulator as ~Right~ instead
           of ~Either~;

        2. we didn't specify type parameters for ~Right.apply~ (=from Jian= two:
           one for result, one for error) so the compiler infers the left
           parameter as ~Nothing~.

      + NO over-narrowing:
        #+begin_src scala
          def countPositive(nums: List[Int]) =
            nums.foldLeft(0.asRight[String]) { (accumulator, num) =>
              if(num > 0) {
                accumulator.map(_ + 1)
              } else {
                Left("Negative. Stopping!")
              }
            }

          countPositive(List(1, 2, 3))
          // res5: Either[String,Int] = Right(3)

          countPositive(List(1, -2, 3))
          // res6: Either[String,Int] = Left(Negative. Stopping!)
        #+end_src

    - ~cats.syntax.either~ adds some extension methods to the ~Either~ /companion
      object/. The ~catchOnly~ and ~catchNonFatal~ /methods/ are great for
      capturing ~Exception~'s as instances of ~Either~:
      #+begin_src scala
        Either.catchOnly[NumberFormatException]("foo".toInt)
        // res7: Either[NumberFormatexception, Int] = Left(java.lang.NumberFormatException: For input string: "too")

        Either.catchNonFatal(sys.error("Badness"))
        // res8: Either[Throwable, Nothing] = Left(java.lang.RuntimeException: Badness)
      #+end_src

    - Create an ~Either~ from other data types:
      #+begin_src scala
        Either.fromTry(scala.util.Try("foo".toInt))
        // res9: Either[Throwable,Int] = Left(java.lang.NumberFormatException: For input string: "foo")

        Either.fromOption[String, Int](None, "Badness")
        // res10: Either[String,Int] = Left(Badness)
      #+end_src

*** DONE 4.4.3 Transforming ~Either~'s - 94
    CLOSED: [2019-04-13 Sat 17:48]
    - ~cats.syntax.either~ also _adds_ some useful /methods/ for /instances/ of
      ~Either~.

    - Use ~orElse~ and ~getOrElse~ to extract values _from the *right* side_.
      #+begin_src scala
        import cats.syntax.either._

        "Error".asLeft[Int].getOrElse(0)
        // res11: Int = 0

        "Error".asLeft[Int] orElse 2.asRight[String]
        // res11: Int = Right(2)

      #+end_src

    - ~ensure~ allows us to check whether the right-hand value satisfies a /predicate/:
      #+begin_src scala
        -1.asRight[String].ensure("Must be non-negative!")(_ > 0)
        // res13: Either[String,Int] = Left(Must be non-negative!)
      #+end_src

    - ~recover~ and ~recoverWith~ provide similar error handling to their namesakes
      on ~Future~:
      #+begin_src scala
        "error".asLeft[Int].recover {
          case str: String => -1
        }
        // res14: Either[String,Int] = Right(-1)

        "error".asLeft[Int].recover {
          case str: String => Right(-1)
        }
        // res15: Either[String,Int] = Right(-1)
      #+end_src

    - ~leftMap~ and ~bimap~:
      #+begin_src scala
        "foo".asLeft[Int].leftMap(_.reverse)
        // res16: Either[String,Int] = Left(oof)

        6.asRight[String].bimap(_.reverse, _ * 7)
        // res17: Either[String,Int] = Right(42)

        "bar".asLeft[Int].leftMap(_.reverse, _ * 7)
        // res18: Either[String,Int] = Left(rab)
      #+end_src

    - ~swap~ exchanges left for right:
      #+begin_src scala
        123.asRight[String]
        // res19: Either[String,Int] = Right(123)

        123.asRight[String].swap
        // res20: Either[String,Int] = Left(123)
      #+end_src

    - ~toOption~, ~toList~, ~toTry~, ~toValidated~, and so on.

*** DONE 4.4.4 Error Handling - 96
    CLOSED: [2019-04-13 Sat 18:10]
    ~Either~ is typically used to implement fail-fast error handling.

    - We *sequence* computations using ~flatMap~ as usual.
      #+begin_src scala
        for {
          a <- 1.asRight[String]
          b <- 0.asRight[String]
          c <- if (b == 0) "DIV0".asLeft[Int]
          else        (a / b).asRight[String]
        } yield c * 100
        // res21: Either[String, Int] = Left(DIV0)
      #+end_src

    - When using ~Either~ for error handling,
      we need to _determine what type we want to useto represent errors._
      1. We could use ~Throwable~ for this:
         ~type Result[A] = Either[Throwable, A]~
         This has similar semantics to ~scala.util.Try~.

      2. Mostly, we don't want such ~Throwable~, which is a extremely broad type.
         We can define an /algebraic data type/ to represent errors, for
         exmaple, that may occur in our program:
         #+begin_src scala
           sealed trait LoginError extends Product with Serializable

           final case class UserNotFound(username: String) extends LoginError
           final case class PasswordIncorrect(username: String) extends LoginError
           case object UnexpectedError extends LoginError

           type LoginResult = Either[LoginError, User]


           // Choose error-handling behaviour based on type:
           def handleError(error: LoginError): Unit =
             error match {
               case UserNotFound(u) =>
                 println(s"User not found: $u")

               case PasswordIncorrect(u) =>
                 println(s"Password incorrect: $u")

               case UnexpectedError =>
                 println(s"Unexpected error")
             }

           val result1: LoginResult = User("dave", "passw0rd").asRight
           // result1: LoginResult = Right(User(dave,passw0rd))

           val result2: LoginResult = UserNotFound("dave").asLeft
           // result2: LoginResult = Left(UserNotFound(dave))

           result1.fold(handleError, println)
           // User(dave,passw0rd)

           result2.fold(handleError, println)
           // User not found: dave
         #+end_src

*** DONE 4.4.5 Exercise: What is Best? - 98
    CLOSED: [2019-04-13 Sat 20:05]
    =RE-DO=

** DONE 4.5 Aside: Error Handling and ~MonadError~ - 98
   CLOSED: [2019-04-10 Wed 14:02]
   Cats provides an additional /type class/ called ~MonadError~ that abstracts
   over ~Either~-like data types that are used for *error handling*.

   - ~MonadError~ provides extra operations for
     + raising errors
     + handling errors

   - *This Section is Optional!*
     You won't need to use ~MonadError~ unless you need to *abstract over error
     handling monads* (If you don't need this kind of abstraction right now, feel free to skip
     onwards to Section 4.6).

     + For example, you can use ~MonadError~ to abstract =TODO=
       * over ~Future~ and ~Try~,
         OR
       * over ~Either~ and ~EitherT~ (which we will meet in Chapter 5).

*** DONE 4.5.1 The ~MonadError~ Type Class - 98
    CLOSED: [2019-04-10 Wed 13:35]
    - The simplified definition of ~MonadError~:
      #+begin_src scala
        package cats

        trait MonadError[F[_], E] extends Monad[F] {
          // Lift an error in to the `F` context:
          def raiseError[A](e: E): F[A]

          // Handle an error, potentially recovering from it:
          def handleError[A](fa: F[A])(f: E => A): F[A]

          // Test an instance of `F`,
          // failing if the predicate is not satisfied:
          def ensure[A](fa: F[A])(e: E)(f: A => Boolean): F[A]
        }
      #+end_src

    - ~MonadError~ is defined in terms of two type parameters:
      * ~F~
        the type of the /monad/;

      * ~E~
        the type of error contained within ~F~.

    - To demonstrate how these parameters fit together, here's an example where
      we instantiate the type class for ~Either~:
      #+begin_src scala
        import cats.MonadError
        import cats.instances.either._  // for MonadError

        type ErrorOr[A] = Either[String, A]
        val monadError = MonadError[ErrorOr, String]
      #+end_src

    - ~ApplicativeError~
      _In reality_,
      ~MonadError~ extends another /type class/ called ~ApplicativeError~.
      However, we won't encounter ~Applicative~'s until Chapter 6.
      _The /semantics/ are the SAME_ for each /type class/ so we can _ignore
      this detail for now_.

*** DONE 4.5.2 Raising and Handling Errors - 99
    CLOSED: [2019-04-10 Wed 13:52]
    - The _two_ most important /methods/ of ~MonadError~:
      + ~raiseError~
      + ~handleError~.

    - ~raiseError~ is like the ~pure~ /method/ for ~Monad~
      except that it creates an instance representing a _failure_:
      #+begin_src scala
        val success = monadError.pure(42)
        // success: ErrorOr[Int] = Right(42)

        val failure = monadError.raiseError("Badness")
        // failure: ErrorOr[Nothing] = Left(Badness)
      #+end_src

    - ~handleError~ is the complement of ~raiseError~.
      It is similar to the ~recover~ /method/ of ~Future~:
      #+begin_src scala
        monadError.handleError(failure) {
          case "Badness" => monadError.pure("It's ok")
          case other     => monadError.raiseError("It's not ok")
        }
        // res2: ErrorOr[ErrorOr[String]] = Right(Right(It's ok))
      #+end_src

    - ~ensure~ implements a filter-like behaviour:
      #+begin_src scala
        import cats.syntax.either._  // for asRight

        monadError.ensure(success)("Number too low!")(_ > 1000)
        // res3: ErrorOr[Int] = Left(Number too low!)
      #+end_src

    - Syntax:
      ~raiseError~ and ~handleError~ from ~cats.syntax.applicativeError~
      ~ensure~ from ~cats.syntax.monadError~
      #+begin_src scala
        import cats.syntax.applicative._       // for pure
        import cats.syntax.applicativeError._  // for raiseError etc
        import cats.syntax.monadError._        // for pure

        val success = 42.pure[ErrorOr]
        // success: ErrorOr[Int] = Right(42)

        val failure = "Badness".raiseError[ErrorOr, Int]
        // failure: ErrorOr[Int] = Left(Badness)

        success.ensure("Number to low!")(_ > 1000)
        // res4: Either[String,Int] = Left(Number to low!)
      #+end_src

    - There are other useful variants of these /methods/. =TODO= =TODO= =TODO=
      See the source of ~cats.MonadError~ and ~cats.ApplicativeError~ for more
      info.

*** DONE 4.5.3 Instances of ~MonadError~ - 101
    CLOSED: [2019-04-10 Wed 14:02]
    Cats provides instances of ~MonadError~ for numerous data types including
    ~Either~, ~Future~, and ~Try~.

    - The instance for ~Either~ is customisable to any error type,
      whereas the instances for ~Future~ and ~Try~ always represent errors as
      ~Throwables~:
      #+begin_src scala
        import scala.util.Try
        import cats.instances.try_._  // for MonadError


        val exn: Throwable =
          new RuntimeException("It's all gone wrong")

        exn.raiseError[Try, Int]
        // res6: scala.util.Try[Int] = Failure(java.lang.RuntimeException: It's all gone wrong)
      #+end_src

*** TODO 4.5.4 Exercise: Abstracting - 101 - =OPEN ISSUE=
    No exercise here -- there is an open issue for this in github

** DONE 4.6 The ~Eval~ Monad - 101
   CLOSED: [2019-04-02 Tue 17:57]
   ~cats.Eval~ is a /monad/ that allows us to _abstract over different models of
   evaluation._

   - We typically hear of _TWO_ such models: /eager/ and /lazy/.
       ~Eval~ throws in a _further distinction_ of whether or not a result is
     /memoized/.

*** DONE 4.6.1 Eager, Lazy, Memoized, Oh My! - 101
    CLOSED: [2019-04-02 Tue 15:33]
    - /Eager computations/ HAPPEN _immediately_
      whereas
      /Lazy computations/ HAPPEN _on access_.

      /Memoized computations/ are run *ONCE* _on first access_,
      after which the results are *cached*.

    - For example,
      in Scala (the _evaluation properties_ of the three ways below can be shown
      through a _visible side-effect_),
      + ~val~'s are /eager/ and /memoized/.
        #+begin_src scala
          val x = {
            println("Computing X")
            math.random
          }
          // Computing X
          // x: Double = 0.0657586956104027

          x  // first access
          // res0: Double = 0.0657586956104027

          x  // second access
          // res1: Double = 0.0657586956104027
        #+end_src

      + ~def~'s are /lazy/ and *NOT* /memoized/.
        #+begin_src scala
          def y = {
            println("Computing X")
            math.random
          }
          // y: Double

          y  // first access
          // Computing Y
          // res2: Double = 0.9184384488125138

          y  // second access
          // Computing Y
          // res3: Double = 0.20807113447602488
        #+end_src

      + ~lazy val~'s are /lazy/ and /memoized/.
        #+begin_src scala
          lazy val z = {
            println("Computing Z")
            math.random
          }
          // z: Double = <lazy>

          z  // first access
          // Computing Z
          // res4: Double = 0.1783014120350146

          z  // second access
          // res5: Double = 0.1783014120350146
        #+end_src

*** DONE 4.6.2 Eval's Models of Evaluation - 103
    CLOSED: [2019-04-02 Tue 16:19]
    - ~Eval~ has THREE /subtypes/: ~Now~, ~Later~, and ~Always~.

    - We construct these with _THREE /constructor methods/,_ which create
      instances of the THREE /classes/ and *return them typed as ~Eval~:*
      #+begin_src scala
        import cats.Eval

        val now = Eval.now(math.random + 1000)
        // now: cats.Eval[Double] = Now(1000.885603643474)

        val later = Eval.later(math.random + 2000)
        // later: cats.Eval[Double] = cats.Later@679671c

        val always = Eval.always(math.random + 3000)
        // always: cats.Eval[Double] = cats.Always@396fe27e
      #+end_src

      =From Jian= =START=
      It's critical that we should use these /constructor methods/, rather then
      the /constructors/ of EACH /subtypes/.

      *The return type is important!!!*

      The compiler needs ~Eval~, rather than its /subtypes/, too narrow types
      can make the compiler be confused. =TODO= =MORE DETAILS= =???=
      =From Jian= =END=

    - Extract the result of an ~Eval~ using its ~value~ /method/:
      #+begin_src scala
        now.value
        // res6: Double = 1000.885603643474

        later.value
        // res7: Double = 2000.1770874422618

        always.value
        // res8: Double = 3000.637554292833
      #+end_src

    - ~Eval.now~ captures a value _right now_.
      Its semantics are similar to a ~val~ -- /eager/ and /memoized/.

    - ~Eval.always~ captures a /lazy/ computation, similar to a ~def~ -- /lazy/
      and *NOT* /memoized/.

    - ~Eval.later~ captures a /lazy/, /memoized/ computation, similar to a
      ~lazy val~ -- /lazy/ and /memoized/.

    - The three behaviours are summarized below:
      | Scala      | Cats     | Properties         |
      |------------+----------+--------------------|
      | ~val~      | ~Now~    | eager, memoized    |
      | ~lazy val~ | ~Later~  | lazy, memoized     |
      | ~def~      | ~Always~ | lazy, not memoized |

    - =From Jian=
      We *DO NOT* have /eager/ and *NOT* /memoized/ evaluation model, which is
      not reasonable -- just like copy and paste a segment of code everywhere,
      Everytime see them evaluate them. Even though they are the same code
      segment, sometimes even same calculation (when no side effect), but no
      connections built between them.

*** DONE 4.6.3 ~Eval~ as a ~Monad~ - 105
    CLOSED: [2019-04-02 Tue 17:20]
    - Like all monads, Eval's ~map~ and ~flatMap~ /methods/ add computations to a
      _chain_.

    - In the case of ~Eval~, the _chain_ is stored explicitly as _a list of functions_.
      The functions are NOT run until we call ~Eval~'s ~value~ /method/ to request
      a result:
      #+begin_src scala
        val greeting = Eval.
          always { println("Step 1"); "Hello" }.
          map { str => println("Step 2"); s"$str world" }
        // greeting: cats.Eval[String] = cats.Eval$$anon$8@157f7b8c

        greeting.value
        // Step 1
        // Step 2
        // res15: String = Hello world
      #+end_src

    - =IMPORTANT=
      While the /semantics/ of the originating ~Eval~ /instances/ are maintained,
      _mapping functions are *always called lazily* on demand (~def~ /semantics/)._
      #+begin_src scala
        val ans = for {
          a <- Eval.now { println("Calculating A"); 40 }
          b <- Eval.always { println("Calculating B"); 2 }
        } yield {
          println("Adding A and B")
          a + b
        }
        // Calculating A
        // ans: cats.Eval[Int] = cats.Eval$$anon$8@37c1363d

        ans.value  // first access
        // Calculating B
        // Adding A and B
        // res16: Int = 42

        ans.value  // second access
        // Calculating B
        // Adding A and B
        // res17: Int = 42
      #+end_src

    - Some times we don't want the ~def~ /semantics/, and ~Eval~ has a ~memoize~
      /method/ that allows us to _memoize a chain of computations_
      + the result of the chain up to the call to ~memoize~ is _CACHED_,
        whereas
      + calculations after the call _RETAIN their ORIGINAL_ /semantics/:
      #+begin_src scala
        val saying = Eval.
          always { println("Step 1"); "The cat" }.
          map { str => println("Step 2"); s"$str sat on" }.
          memoize.
          map { str => println("Step 3"); s"$str the mat" }
        // saying: cats.Eval[String] = cats.Eval$$anon$8@2196a9a1

        saying.value  // first access
        // Step 1
        // Step 2
        // Step 3
        // res18: String = The cat sat on the mat

        saying.value  // second access
        // Step 3
        // res19: String = The cat sat on the mat
      #+end_src

*** DONE 4.6.4 Trampolining and ~Eval.defer~ - 107
    CLOSED: [2019-04-02 Tue 17:56]
    =from Jian= Try to learn more about /trampolining/.
    ~Eval~'s ~map~ and ~flatMap~ /methods/ are /trampolined/, which means we can
    nest calls to ~map~ and ~flatMap~ *ARBITRARILY without consuming stack
    frames.*

    _We call this property /stack safety/._

    - For example,
      #+begin_src scala
        def factorial(n: BigInt): BigInt =
          if (n == 1) n else n * factorial(n - 1)
      #+end_src
      will stack overflow when the input is large, for instance 50000.

      1. First try:
         #+begin_src scala
           def factorial(n: BigInt): Eval[BigInt] =
             if(n == 1) {
               Eval.now(n)
             } else {
               factorial(n - 1).map(_ * n)
             }
         #+end_src

         This still doesn't work, and we will see
         #+begin_src scala
           factorial(50000).value
           // java.lang.StackOverflowError
           // ...
         #+end_src

         The problem here is we didn't avoid the ~factorial~ call stack overflow
         -- only ~Eval.now(n)~ in the base case and make the return value of type
         ~Eval[BigInt]~ is NOT enough.

      2. Resolve the problem of the first try:
         #+begin_src scala
           def factorial(n: BigInt): Eval[BigInt] =
             if(n == 1) {
               Eval.now(n)
             } else {
               Eval.defer(factorial(n - 1).map(_ * n))
             }
         #+end_src
         This will work perfectly.

    - Everything has a cost!!!
      /Trampolining/ help us avoiding consuming /stack/ by creating a chain of
      function /objects/ on the /heap/ -- like some recursion to iterative
      method (iterative traverse of a tree).

    - There are still limits on how deeply we can nest computations,
      BUT they are *bounded by the size of the /heap/ rather than the /stack/.*

*** TODO 4.6.5 Exercise: Safer Folding using ~Eval~ - 108
    =TODO=
    =from Jian= I made a mistake at my first try. Try to do it again later.

** DONE 4.7 The ~Writer~ Monad - 108
   CLOSED: [2019-04-14 Sun 02:04]
   ~cats.data.Writer~ is a /monad/ that lets us carry a log along with a
   computation.

   - We can use it to
     1. record messages, errors, or additional data about a computation
        AND
     2. extract the log alongside the final result.

   - One common use for ~Writer~'s is _recording sequences of steps in multi-threaded
     computations_ where
     + standard imperative logging techniques can result in *interleaved messages
       from different contexts*.

     + With ~Writer~ the log for the computation is _tied to the result_, so we can
       run concurrent computations *without mixing logs*.

   - *Cats Data Types*
     ~Writer~ is the FIRST /data type/ we've seen from the ~cats.data~ package.

     - This package provides instances of various /type classes/ that *produce
       useful semantics*.

     - Other examples from ~cats.data~ include the /monad transformers/ that we
       will see in the next chapter, and the ~Validated~ type we will encounter
       in Chapter 6. =TODO= =TODO= =TODO=

*** DONE 4.7.1 Creating and Unpacking Writers - 109
    CLOSED: [2019-04-13 Sat 23:55]
    - A ~Writer[W, A]~ carries two values:
      + a log of type ~W~
      + a result of type ~A~

    - We can create a ~Writer~ from values of each type as follows:
      #+begin_src scala
        import cats.data.Writer
        import cats.instances.vector._  // for Monoid

        Writer(Vector("It was the best of times",
                      "it was the wrost of times"),
               1859)
        // res0: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String], Int] =
        //       WriterT((Vector(It was the best of times, it was the wrost of times),1859))
      #+end_src
      Cats implements ~Writer~ in terms of another type, ~WriterT~:
      ~type Writer[W, A] = Writer[Id, W, A]~ (ignore this before Chapter 5).

    - When you only have a result (type ~A~), in scope there must be a ~Monoid[W]~
      which help Cats find proper empty log value.
      For instance,
      #+begin_src scala
        import cats.instances.vector._    // for Monoid
        import cats.syntax.applicative._  // for pure

        type Logged[A] = Writer[Vector[String], A]

        123.pure[Logged]
        // res2: Logged[Int] = WriterT((Vector(), 123))
      #+end_src

    - Similary, you may have a log and no result.
      You can create a ~Writer[Unit]~ using ~tell~ syntax from
      ~cats.syntax.writer~:
      #+begin_src scala
        import cats.syntax.writer._  // for tell

        Vector("msg1", "msg2", "msg3").tell
        // res3: cats.data.Writer[scala.collection.immutable.Vector[String],Unit] = WriterT((Vector(msg1, msg2, msg3),()))
      #+end_src

    - If we have both a log and a result,
      we can either use
      + ~Writer.apply~
        #+begin_src scala
          val a = Writer(Vector("msg1", "msg2", "msg3"), 123)
          // a: cats.data.WriterT[cats.Id.scala.collection.immutable.Vector[String],Int] =
          //    WriterT((Vector(msg1, msg2, msg3),123))
        #+end_src
        OR
      + the ~writer~ sytnax from ~cats.syntax.writer~:
        #+begin_src scala
          import cats.syntax.writer._  // for writer

          val b = 123.writer(Vector("msg1", "msg2", "msg3"))
          // b: cats.data.WriterT[cats.Id.scala.collection.immutable.Vector[String],Int] = WriterT((Vector(msg1, msg2, msg3),123))
        #+end_src

    - Extract result or log:
      #+begin_src scala
        val aResult: Int = a.value
        // aResult: Int = 123

        val aLog: Vector[String] = a.written
        // aLog: Vector[String] = Vector(msg1, msg2, msg3)
      #+end_src

    - We can extract both values at the same time:
      #+begin_src scala
        val (log, result) = b.run
        // log: scala.collection.immutable.Vector[String] = Vector(msg1, msg2, msg3)
        // result: Int = 123
      #+end_src

*** DONE 4.7.2 Composing and Transforming Writers - 111
    CLOSED: [2019-04-14 Sun 01:49]
    As a /moand/, ~Writer~ can be preserved when applying ~map~ or ~flatMap~
    over it.

    - ~flatMap~ *appends* the logs from the source ~Writer~ and the result of the
      user's sequencing function.
        For this reason, efficient *append* and *concatenate* operations are
      important! We usually use ~Vector~:
      #+begin_src scala
        val writer1 = for {
          a <- 10.pure[Logged]
          _ <- Vector("a", "b", "c").tell
          b <- 32.writer(Vector("x", "y", "z"))
        } yield a + b
        // writer1: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(a, b, c, x, y, z),42))

        writer1.run
        // res4: cats.Id[(Vector[String], Int)] = (Vector(a, b, c, x, y, z) ,42)
      #+end_src

    - Transform the log in a /writer/:
      #+begin_src scala
        val writer2 = writer1.mapWritten(_.map(_.toUpperCase))
        // writer2: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] = WriterT((Vector(A, B, C, X, Y, Z),42))

        writer2.run
        // res5: cats.Id[(scala.collection.immutable.Vector[String], Int)] = (Vector(A, B, C, X, Y, Z),42)
      #+end_src

    - Transform both log and result simultaneously using
      #+begin_src scala
        val writer3 = writer1.bimap(
          log => log.map(_.toUpperCase),
          res => res * 100
        )
        // writer3: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] =
        //   WriterT((Vector(A, B, C, X, Y, Z),4200))

        writer3.run
        // res6: cats.Id[(scala.collection.immutable.Vector[String], Int)] =
        //   (Vector(A, B, C, X, Y, Z),4200)

        val writer4 = writer1.mapBoth { (log, res) =>
          val log2 = log.map(_ + "!")
          val res2 = res * 1000
          (log2, res2)
        }
        // writer4: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] =
        //   WriterT((Vector(a!, b!, c!, x!, y!, z!),4200))

        writer4.run
        // res7: cats.Id[(scala.collection.immutable.Vector[String], Int)] =
        //   (Vector(A, B, C, X, Y, Z),4200)
      #+end_src
      + ~bimap~, which accept two function parameters for log and result respectively.
      + ~mapBoth~, which accept single function parameter that accept two parameters.

    - Clear log with ~reset~;
      Swap log and result with ~swap~.
      #+begin_src scala
        val writer5 = writer1.reset
        // writer5: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(),42))

        writer5.run
        // res8: cats.Id[(Vector[String], Int)] = (Vector(),42)

        val writer6 = writer1.swap
        // writer6: cats.data.WriterT[cats.Id,Int,Vector[String]] = WriterT((42,Vector(a, b, c, x, y, z)))

        writer6.run
        // res9: cats.Id[(Int, Vector[String])] = (42,Vector(a, b, c, x, y, z))
      #+end_src

*** DONE 4.7.3 Exercise: Show Your Working - 113
    CLOSED: [2019-04-14 Sun 02:04]
    =from Jian= Can we make it look better???
    #+begin_src scala
      def slowly[A](body: => A) =
        try body finally Thread.sleep(100)

      type IntWriter = Writer[Vector[String], Int]

      def factorial(n: Int): IntWriter =
        for {
          ans <- n match {
            case 0 => 1.pure[IntWriter]
            case _ => slowly(factorial(n - 1).map(_ * n))
          }

          _ <- Vector(s"fact $n $ans").tell
        } yield ans
    #+end_src

** DONE 4.8 The ~Reader~ Monad - 114
   CLOSED: [2019-04-17 Wed 15:23]
   ~cats.data.Reader~ is a /monad/ that allows us to *sequence operations that
   depend on some input*.

   - Instances of ~Reader~
     + *wrap up* functions of _ONE argument_,
     + providing us with useful methods for *composing* them.

   - *One common use for ~Reader~'s is /dependency injection/.*
     =IMPORTANT= =IMPORTANT= =IMPORTANT=
     + dependency injection ::
          If we have a number of operations that all _depend on some EXTERNAL
       configuration_, we can
       * _chain_ them together using a ~Reader~ to produce one large operation
         that
         accepts the configuration _as a parameter_
         and
         runs our program _in the order specified_.

*** DONE 4.8.1 Creating and Unpacking Readers - 115
    CLOSED: [2019-04-16 Tue 17:12]
    1. Create a ~Reader[A, B]~ from a function ~A => B~ using the ~Reader.apply~.
      #+begin_src scala
        import cats.data.Reader

        case class Cat(name: String, favoriteFood: String)

        val catName: Reader[Cat, String] =
          Reader(_.name)
        // catName: cats.data.Reader[Cat,String] = Kleisli(<function1>)
      #+end_src

    2. Extract the function again using the ~Reader~'s ~run~ /method/ and call it
       using ~apply~:
       #+begin_src scala
         catName.run(Cat("Garfield", "lasagne"))
         // res0: cats.Id[String] = Garfield
       #+end_src

    3. =TODO= What advantage do ~Reader~'s give us over the raw functions???

*** DONE 4.8.2 Composing Readers - 115
    CLOSED: [2019-04-16 Tue 17:12]
    The power of ~Reader~'s comes from their ~map~ and ~flatMap~ /methods/, which
    represent _DIFFERENT kinds of *function composition*._
      We typically create a set of ~Reader~'s that accept the *SAME type* of
    configuration, combine them with ~map~ and ~flatMap~, and then call ~run~ to
    /inject/ the config at the end.

    - ~map~ extends the computation in the ~Reader~ by passing its result through
      a function:
      #+begin_src scala
        val greetKitty: Reader[Cat, String] =
          catName.map(name => s"Hello $name")

        greetKitty.run(Cat("Heathcliff", "junk food"))
        // res1: cats.Id[String] = Hello Heathcliff
      #+end_src

    - ~flatMap~ combine /readers/ that depend on the _SAME input type_.
      #+begin_src scala
        val feedKitty: Reader[Cat, String] =
          Reader(cat => s"Have a nice bowl of ${cat.favoriteFood}")

        val greetAndFeed: Reader[Cat, String] =
          for {
            greet <- greetKitty
            feed <- feedKitty
          } yield s"$greet. $feed."

        greetAndFeed(Cat("Garfield", "lasagne"))
        // res3: cats.Id[String] = Hello Garfield. Have a nice bowl of lasagne.

        greetAndFeed(Cat("Heathcliff", "junk food"))
        // res4: cats.Id[String] = Hello Heathcliff. Have a nice bowl of junk food.
      #+end_src

*** DONE 4.8.3 Exercise: Hacking on Readers - 116
    CLOSED: [2019-04-17 Wed 15:06]
    The classic use of ~Reader~'s is to build programs that accept a configuration
    as a parameter.

    - Example: Simple login system
      + Our configuration will consist of _TWO_ databases:
        a list of valid users and a list of their password:
        #+begin_src scala
          case class Db(
            usernames: Map[Int, String],
            passwords: Map[String, String]
          )
        #+end_src
        * Create ~DbReader~:
          ~type DbReader[A] = Reader[Db, A]~

      + Create /methods/ that generate ~DbReader~'s to look up the username for
        an ~Int~ user ID, and look up the password for a ~String~ username. The
        type signatures should be as follows:
        #+begin_src scala
          def findUsername(userId: Int): DbReader[Option[String]] =
            Reader(_.usernames.get(userId))

          def checkPassword(username: String, password: String): DbReader[Boolean] =
            Reader(_.password.get(username).contains(password))
        #+end_src

      + Create ~checkLogin~ /method/ to check the password for a given user ID.
        =from Jian= This code does not have good look!!!!!
        #+begin_src scala
          def checkLogin(usedId: Int, password: String): DbReader[Boolean] =
            for {
              oUsername <- findUsername(userId)
              oPassword = username.map(un => checkPassword(un, passowrd))
              passwordOk <- oPassword.getOrElse(false.pure[DbReader])
            } yield passwordOk
        #+end_src

*** DONE 4.8.4 When to Use Readers? - 118
    CLOSED: [2019-04-17 Wed 15:22]
    - ~Reader~'s provide a tool for doing /dependency injection/.
      1. Write steps of our program as /instances/ of ~Reader~
      2. Chain them together with ~map~ and ~flatMap~
      3. Build a function that accepts the /dependency/ as input.

    - There are many ways of implementing /dependency injection/ in Scala, from
      _SIMPLE TECHNIQUES like /methods/ with multiple parameter lists_, through
      _/implicit parameters/ and /type classes/,_ to _COMPLEX TECHNIQUES like
      the /cake pattern/ and /DI frameworks/._

    - ~Reader~'s are most useful in situations where:
      + we are constructing a batch program that can EASILY be *represented by a
        function*;

      + we need to *defer* /injection/ of a known parameter or set of parameters;

      + we want to be able to *test* parts of the program _in isolation_.

    - By representing the steps of our program as ~Reader~'s
      + we can *test* them as easily as pure functions
      + we gain access to the ~map~ and ~flatMap~ /combinators/

    - DI and use other ways rather than ~Reader~ =???= =WHY=
      For more advanced problems
      where we have lots of /dependencies/,  =TODO= =EXAMPLE???=
      or
      where a program _isn't easily represented as a pure function_, =TODO= =EXAMPLE???=
      _other /dependency injection/ techniques tend to be more appropriate_.

    - *Kleisli Arraows*
      You may have noticed from console output that ~Reader~ is implemented
      in terms of another type called ~Kleisli~.

      + /Kleisli arrows/ provide a _more general form_ of ~Reader~ that _generalise
        over the type constructor of the result type_.

      + =TODO= We will encounter ~Kleislis~ again in Chapter 5.

** TODO 4.9 The ~State~ Monad - 119
   ~cats.data.State~ allows us to
   pass additional /state/ around as part of a computation.
   =from Jian= /state/ as /computation context/.

   - We define ~State~ /instances/ representing /atomic state/ operations and
     thread them together using ~map~ and ~flatMap~.
       In this way *we can model /mutable state/ in a purely functional way,
     without using mutation.*

*** DONE 4.9.1 Creating and Unpacking State - 119
    CLOSED: [2019-04-08 Mon 23:07]
    The instance of /state monad/ ~State[S, A]~ represent functions of type
    ~S => (S, A)~, where ~S~ is the /type/ of the /state/ and ~A~ is the /type/
    of the result.

    - Example:
      #+begin_src scala
        import cats.data.State

        val a = State[Int, String] { state =>
          (state, s"The state is $state")
        }
        // a: cats.data.State[Int, String] = cats.data.IndexedStateT@12c18313
      #+end_src

    - In other words,
      an instance of ~State~ is a function that does _TWO_ things:
      + *transforms* an _input state_ to an _output state_;
      + *computes* a result.

    - ~State~ provides _THREE_ /methods/:
      + ~run~
      + ~runS~
      + ~runA~
      they return different combinations of /state/ and /result/.
      TODO ??? ??? ???

    - _Each_ /method/ returns an /instance/ of ~Eval~, which ~State~ uses to
      maintain /stack safety/.
      TODO ??? ??? ???

    - We call the ~value~ /method/ as usual to extract actual result:
      #+begin_src scala
        // Get the state and the result;
        val (state, result) = a.run(10).value
        // state: Int = 10
        // result: String = The state is 10

        // Get the state, ignore the result;
        val state = a.runS(10).value
        // state: Int = 10

        // Get the result, ignore the state;
        val state = a.runR(10).value
        // result: String = The state is 10
      #+end_src

*** TODO 4.9.2 Composing and Transforming State - 120
    As we've seen with ~Reader~ and ~Writer~, the power of the ~State~ /monad/
    comes from *combining* /instances/.

    - The ~map~ and ~flatMap~ /methods/ thread the /state/ from one /instance/ to
      another.

    - Each individual /instance/ represents an _atomic_ /state transformation/,
      and their combination represents a complete sequence of changes:
      #+begin_src scala
        val step1 = State[Int, String] { num =>
          val ans = num + 1
          (ans, s"Result of step1: $ans")
        }
        // step1: cats.data.State[Int,String] = cats.data.IndexedStateT@7c6e31c4

        val step2 = State[Int, String] { num =>
          val ans = num * 2
          (ans, s"Result of step2: $ans")
        }
        // step2: cats.data.State[Int,String] = cats.data.IndexedStateT@7428b330

        val both = for {
          a <- step1
          b <- step2
        } yield (a, b)
        // both: cats.data.IndexedStateT[cats.Eval,Int,Int,(String, String)] = cats.data.IndexedStateT@716401f3

        val (state, result) = both.run(20).value
        // state: Int = 42
        // result: (String, String) = (Result of step1: 21,Result of step2: 42)
      #+end_src

*** TODO 4.9.3 Exercise: Post-Order Calculator - 123

** TODO 4.10 Defining Custom Monads - 126
   - =TODO=

*** TODO 4.10.1 Exercise: Branching out Further with Monads - 127
    #+begin_src scala
      sealed trait Tree[+A]

      final case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]
      final case class Leaf[A](value: A) extends Tree[A]

      def branch[A](left: Tree[A], right: Tree[A]): Tree[A] =
        Branch(left, right)

      def leaf[A](value: A): Tree[A] =
        Leaf(value)


      import cats.Monad

      val treeMonad = new Monad[Option] {
        def flatMap[A, B](t: Tree[A])
                   (fn: A => Tree[B]): Tree[B] =
          t match {
            case Branch(l, r) => Branch(flatMap(l)(fn), flatMap(r)(fn))
            case Leaf(v)      => fn(v)
          }

        def pure[A](v: A): Tree[A] =
          leaf(v)

        def tailRecM[A, B](a: A)(fn: A => Tree[Either[A, B]]): Tree[B] =
          flatMap(fn(a)) {
            case Left(v) => tailRecM(v)(fn)
            case Right(v) => Leaf(v)
          }
      }
    #+end_src

** TODO 4.11 Summary - 128

* TODO 5 Monad Transformers - 129
  /Monads/ can potentially bloat the code base through nested
  for-comprehensions.

  - Example:
    #+begin_src scala
      def lookupUserName(id: Long): Either[Error, Option[String]] =
        for (optUser <- lookupUser(id))
        yield {
          for (user <- optUser)
          yield user.name
        }
    #+end_src

** TODO 5.1 Exercise: Composing Monads - 130
** TODO 5.2 A Transformative Example - 131
** TODO 5.3 Monad Transformers in Cats - 133
*** TODO 5.3.1 The Monad Transformer Classes - 133
*** TODO 5.3.2 Building Monad Stacks - 134
*** TODO 5.3.3 Constructing and Unpacking Instances - 136
*** TODO 5.3.4 Default Instances - 137
*** TODO 5.3.5 Usage Patterns - 138

** TODO 5.4 Exercise: Monads: Transform and Roll Out - 140
** TODO 5.5 Summary - 141

* DONE 6 ~Semigroupal~ and ~Applicative~ - 143 - NOTE
  CLOSED: [2019-04-08 Mon 00:25]
  - We'll explore certain types of program flow that they cannot represent.
    + For example, _form validation_:
      When we validate a form we want to return all the errors to the user, *not
      stop* on the first error we encounter.
        _If we model this with a /monad/ like ~Either~, we fail fast and lose
      errors. This is because one depends on the previous one._

  - We need a weaker construct -- one that does _NOT guarantee_ sequencing -- to
    achieve the result we want.
      In this chapter we will look at TWO /type classes/ that support this
    pattern:
    + ~Semigroupal~ encompasses the notion of *composing pairs of contexts*.

      Cats provides a ~cats.syntax.apply~ module that makes use of ~Semigroupal~
      and ~Functor~ to allow users to _sequence functions with multiple
      arguments_.

    + ~Applicative~ extends ~Semigroupal~ and ~Functor~.
      It provides a way of _applying functions to parameters within a context_.
      ~Applicative~ is the source of the ~pure~ /method/ we introduced in
      Chapter 4.

  - ~Applicative~'s are often formulated in terms of function application, instead
    of the /semigroupal/ formulation that is _emphasised in Cats_.
      This alternative formulation provides a link to other libraries and languages
    such as Scalaz and Haskell.

    =TODO= =TODO= =TODO=
    We'll take a look at different formulations of ~Applicative~, as well as the
    relationships between ~Semigroupal~, ~Functor~, ~Applicative~, and ~Monad~,
    towards the end of the chapter.
    =IMPORTANT=

** DONE 6.1 ~Semigroupal~ - 144
   CLOSED: [2019-04-03 Wed 18:17]
   ~cat.Semigroupal~ is a /type class/ that allows us to *combine contexts*:
   If we have two objects of type ~F[A]~ and ~F[B]~, a ~Semigroupal[F]~ allows
   us to combine them to form an ~F[(A, B)]~.

   - Definition in Cats:
     #+begin_src scala
       trait Semigroupal[F[_]] {
         def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]
       }
     #+end_src
     + More freedom than ~Monad~:
       ~fa~ and ~fb~ are mutually independent, and we can compute them *in either
       order* before passing them to ~product~.

       This is in contrast to ~flatMap~, which *imposes a strict order* on its
       parameters.

*** DONE 6.1.1 Joining Two Contexts - 145
    CLOSED: [2019-04-03 Wed 17:11]
    - While ~Semigroup~ allows us to *join* /values/,
      ~Semigroupal~ allows us to *join* /contexts/.
      For example,
      #+begin_src scala
        import cats.Semigroupal
        import cats.instances.option._  // for Semigroupal

        Semigroupal[Option].product(Some(123), Some("abc"))
        // res0: Option[(Int, String)] = Some((123,abc))

        Semigroupal[Option].product(None, Some("abc"))
        // res1: Option[(Nothing, String)] = None

        Semigroupal[Option].product(Some(123), None)
        // res2: Option[(Int, Nothing)] = None
      #+end_src

*** DONE 6.1.2 Joining Three or More Contexts - 145
    CLOSED: [2019-04-03 Wed 18:17]
    The companion object for ~Semigroupal~ defines a set of methods on top of
    ~product~.

    - ~tuple2~ to ~tuple22~ generalise ~product~ to different arities:
      #+begin_src scala
        import cats.instances.option._ // for Semigroupal

        Semigroupal.tuple3(Option(1), Option(2), Option(3))
        // res3: Option[(Int, Int, Int)] = Some((1,2,3))

        Semigroupal.tuple3(Option(1), Option(2), Option.empty[Int])
        // res4: Option[(Int, Int, Int)] = None
      #+end_src

    - ~map2~ to ~map22~ apply a user-specified function to the values inside 2 to
      22 contexts:
      #+begin_src scala
        Semigroupal.map3(Option(1), Option(2), Option(3))(_ + _ + _)
        // res5: Option[Int] = Some(6)

        Semigroupal.map2(Option(1), Option.empty[Int])(_ + _)
        // res6: Option[Int] = None
      #+end_src

    - There are also: TODO TODO TODO
      ~contramap2~ to ~contramap22~ for ~Contravariant~;
      ~impa2~ to ~imap22~ for ~Invariant~.

** DONE 6.2 Apply Syntax - 146
   CLOSED: [2019-04-04 Thu 13:18]
   /Apply syntax/ is a shorthand for the /methods/ described above.

   - Import the syntax form ~cats.syntax.apply~.
     #+begin_src scala
       import cats.instances.option._  // for Semigroupal
       import cats.syntax.apply._      // for tupled and mapN
     #+end_src

   - The ~tupled~ /method/ is implicitly added to the tuple of ~Option~'s.
     It uses the ~Semigroupal~ for ~Option~ to zip the values inside the
     ~Option~'s, creating a single ~Option~ of a tuple:
     #+begin_src scala
       (Option(123), Option("abc")).tupled
       // res7: Option[(Int, String)] = Some((123,abc))

     #+end_src

     This can be up to 22 values.
     #+begin_src scala
       (Option(123), Option("abc"), Option(true)).tupled
       // res8: Option[(Int, String, Boolean)] = Some((123,abc,true))
     #+end_src

   - ~mapN~:
     #+begin_src scala
       case class Cat(name: String, born: Int, color: String)

       (Option("Garfield"),
        Option(1978),
        Option("Orange & black")).mapN(Cat.apply)
       // res9: Option[Cat] = Some(Cat(Garfield,1978,Orange & black))
     #+end_src
     + You must guarantee _RIGHT ARITY_, or there will be compile time error.

     + Internally ~mapN~ uses the ~Semigroupal~ to extract the values from the
       ~Option~ and the ~Functor~ to apply the values to the function.

*** DONE 6.2.1 Fancy Functors and Apply Syntax - 148
    CLOSED: [2019-04-04 Thu 13:16]
    /Apply syntax/ also has ~contramapN~ and ~imapN~ /methods/ that accept
    /Contravariant functors/ and /Invariant functors/.

    - WHY??????????????
      =TODO= =IMPORTANT= =TODO= =TODO= =IMPORTANT=
      Why do we combine ~Monoid~ with ~Invariant~, rather than others?

    - For example, we can combine ~Monoid~'s using ~Invariant~:
      #+begin_src scala
        import cats.Monoid
        import cats.instances.int._ // for Monoid
        import cats.instances.invariant._ // for Semigroupal
        import cats.instances.list._ // for Monoid
        import cats.instances.string._ // for Monoid
        import cats.syntax.apply._ // for imapN

        case class Cat(
          name: String,
          yearOfBirth: Int,
          favoriteFoods: List[String]
        )

        val tupleToCat: (String, Int, List[String]) => Cat =
          Cat.apply _

        val catToTuple: Cat => (String, Int, List[String]) =
          cat => (cat.name, cat.yearOfBirth, cat.favoriteFoods)

        implicit val catMonoid: Monoid[Cat] = (
          Monoid[String],
          Monoid[Int],
          Monoid[List[String]]
        ).imapN(tupleToCat)(catToTuple)
      #+end_src

      ~Monoid~ allows us to create "empty" ~Cat~'s, and add ~Cat~'s together
      using the /syntax/ from Chapter 2:
      #+begin_src scala
        import cats.syntax.semigroup._ // for |+|

        val garfield = Cat("Garfield", 1978, List("Lasagne"))
        val heathcliff = Cat("Heathcliff", 1988, List("Junk Food"))

        garfield |+| heathcliff
        // res17: Cat = Cat(GarfieldHeathcliff,3966,List(Lasagne, Junk Food))
      #+end_src

** DONE 6.3 ~Semigroupal~ Applied to Different Types - 149 - =NOTE=
   CLOSED: [2019-04-04 Thu 15:32]
   ~Semigroupal~ doesn't always provide the behaviour we expect, particularly
   for types that also have instances of ~Monad~.

   We have seen the behaviour of the ~Semigroupal~ for ~Option~.
   Let's look at some examples for other types.

**** TODO ~Future~ - 149
     NOTE

**** TODO ~List~ - 150
     NOTE

**** TODO ~Either~ - 150
     NOTE

*** TODO 6.3.1 Semigroupal Applied to Monads - 151
**** DONE 6.3.1.1 Exercise: The Product of Monads - 152 - =TODO= =RE-DO=
     CLOSED: [2019-04-04 Thu 15:31]
     #+begin_src scala
       import cats.Monad

       import cats.syntax.flatMap._  // for flatMap
       import cats.syntax.functor._  // for map

       def product[M[_]: Monad, A, B](x: M[A], y: M[B]): M[(A, B)] =
         x.flatMap(xx => y.map(yy => (xx, yy)))
     #+end_src

** TODO 6.4 Validated - 152
   - By now we are familiar with the fail-fast error handling behaviour of
     ~Either~.
       Furthermore, because ~Either~ is a /monad/, we know that the sematics of
     product are the same as those for ~flatMap~.

     =IMPORTANT=
     In fact, it is *IMPOSSIBLE* for us to
     design a /monadic data type/ that implements error accumulating semantics
     without breaking the consistency of these two methods.

   - Cats provides a /data type/ called ~Validated~ that has an instance of
     ~Semigroupal~ but *NO* /instance/ of ~Monad~.
       The implementation of ~product~ is therefore free to accumulate errors:
     #+begin_src scala
       import cats.Semigroupal
       import cats.data.Validated
       import cats.instances.list._  // for Monoid

       type AllErrorsOr[A] = Validated[List[String], A]

       Semigroupal[AllErrorsOr].product(
         Validated.invalid(List("Error 1")),
         Validated.invalid(List("Error 2"))
       )

       // res1: AllErrorsOr[(Nothing, Nothing)] = Invalid(List(Error 1, Error 2))
     #+end_src

   - ~Validated~ _complements_ ~Either~ nicely.
     With them, we have support for both of the common types of error handling:
     + fail-fast
     + accumulating

*** DONE 6.4.1 Creating Instances of Validated - 153
    CLOSED: [2019-04-07 Sun 00:35]
    - ~Validated~ has two subtypes:
      + ~Validated.Valid~
      + ~Validated.Invalid~

    - Construct ~Validated~ values
      + Use the ~apply~ methods of corresponding subtypes, which is
        _NOT preferred_ because of /over narrow types/:
        #+begin_src scala
          val v = Validated.Valid(123)
          // v: cats.data.Validated.Valid[Int] = Valid(123)

          val i = Validated.Invalid(List("Badness"))
          // i: cats.data.Validated.Invalid[List[String]] = Invalid(List(Badness))
        #+end_src

      + Use /static methods/ ~valid~ and ~invalid~, which is _preferred_.
        #+begin_src scala
          val v = Validated.valid[List[String], Int](123)
          // v: cats.data.Validated[List[String], Int] = Valid(123)

          val i = Validated.invalid[List[String], Int](List("Badness"))
          // i: cats.data.Validated[List[String], Int] = Invalid(List(Badness))
        #+end_src

      + Use extension methods:
        #+begin_src scala
          import cats.syntax.validated._  // for valid and invalid

          123.valid[List[String]]
          // res2: cats.data.Validated[List[String], Int] = Valid(123)

          List("Badness").invalid[Int]
          // res3: cats.data.Validated[List[String], Int] = Invalid(List(Badness))
        #+end_src

      + As a fourth option we can use ~pure~ and ~raiseError~ from
        ~cats.syntax.applicative~ and ~cats.syntax.applicativeError~
        respectively:
        #+begin_src scala
          import cats.syntax.applicative._       // for pure
          import cats.syntax.applicativeError._  // for raiseError

          type ErrorsOr[A] = Validated[List[String], A]

          123.pure[ErrorsOr]
          // res5: ErrorsOr[Int] = Valid(123)

          List("Badness").raiseError[ErrorsOr, Int]
          // res6: ErrorsOr[Int] = Invalid(List(Badness))
        #+end_src

      + From other resources (other types of values):
        #+begin_src scala
          Validated.catchOnly[NumberFormatException]("foo".toInt)
          // res7: cats.data.Validated[NumberFormatException,Int] = Invalid(java.lang.NumberFormatException: For input string: "foo")

          Validated.catchNonFatal(sys.error("Badness"))
          // res8: cats.data.Validated[Throwable,Nothing] = Invalid(java.lang.RuntimeException: Badness)

          Validated.fromTry(scala.util.Try("foo".toInt))
          // res9: cats.data.Validated[Throwable,Int] = Invalid(java.lang.NumberFormatException: For input string: "foo")

          Validated.fromEither[String, Int](Left("Badness"))
          // res10: cats.data.Validated[String,Int] = Invalid(Badness)

          Validated.fromOption[String, Int](None, "Badness")
          // res11: cats.data.Validated[String,Int] = Invalid(Badness)
        #+end_src

*** TODO 6.4.2 Combining Instances of Validated - 154

*** DONE 6.4.3 Methods of Validated - 156
    CLOSED: [2019-04-07 Sun 01:18]
    - ~Validated~ comes with a suite of /methods/ that closely resemble those
      available for ~Either~, including the /methods/ from ~cats.syntax.either~.
      + ~map~
        #+begin_src scala
          123.valid.map(_ * 100)
          // res17: cats.data.Validated[Nothing,Int] = Valid(12300)
        #+end_src

      + ~leftMap~
        #+begin_src scala
          "?".invalid.leftMap(_.toString)
          // res18: cats.data.Validated[String,Nothing] = Invalid(?)
        #+end_src

      + ~bimap~
        #+begin_src scala
          123.valid[String].bimap(_ + "!", _ * 100)
          // res19: cats.data.Validated[String,Int] = Valid(12300)

          "?".invalid[String].bimap(_ + "!", _ * 100)
          // res20: cats.data.Validated[String,Int] = Invalid(?!)
        #+end_src

    - Use ~andThen~ to do ~flatMap~ like operation.
      #+begin_src scala
        32.valid.andThen { a =>
          10.valid.map { b =>
            a + b
          }
        }
        // res21: cats.data.Vlidated[Nothing,Int] = Valid(42)
      #+end_src
      Of course, there is no for-comprehension syntax support.

    - If more ~flatMap~ operations are required, try to convert back and forth
      between ~Validated~ and ~Either~ using the /methods/ of
      + ~toEither~
        #+begin_src scala
          "Badness".invalid[Int]
          // res22: cats.data.Validated[String,Int] = Invalid(Badness)

          res22.toEither
          // res23: Either[String,Int] = Left(Badness)
        #+end_src

      + ~toValidated~, which comes from ~cats.syntax.either~
        #+begin_src scala
          import cats.syntax.either._  // for `toValidated`

          "Badness".invalid[Int].toEither.toValidated
          // res24: cats.data.Validated[String,Int] = Invalid(Badness)
        #+end_src

    - As with ~Either~, we can use the ~ensure~ /method/ to fail with a specified
      error if a predicate does not hold:
      #+begin_src scala
        123.valid[String].ensure("Negative!")(_ > 0)
        // res25: cats.data.Validated[String,Int] = Valid(123)
      #+end_src

    - Extract value from a ~Validated~ value:
      #+begin_src scala
        "fail".invalid[Int].getOrElse(0)
        // res26: Int = 0

        "fail".invalid[Int].fold(_ + "!!!", _.toString)
        // res27: String = fail!!!
      #+end_src

*** TODO 6.4.4 Exercise: Form Validation - 158

** TODO 6.5 Apply and ~Applicative~ - 159
   /Semigroupals/ are NOT mentioned FREQUENTLY in the wider functional
   programming literature.
     They provide a _subset_ of the functionality of a related /type class/
   called an /applicative functor/ ("applicative" for short).

   - /Semigroupal/ and /Applicative/ _effectively provide ALTERNATIVE *encodings*
     of the same notion of *joining contexts*._

   - Both /Semigroupal/ and /Applicative/ encodings are introduced in the same
     2008 paper by Conor McBride and Ross Paterson.
     + /Semigroupal/ is referred to as "monoidal" in the paper

   - Cats models /applicatives/ using _TWO_ /type classes/:
     1. ~cats.Apply~, extends ~Semigroupal~ and ~Functor~ and adds an ~ap~ /method/
        that applies a parameter to a function within a context.

     2. ~cats.Applicative~, extends ~Apply~, adds the ~pure~ /method/ introduced
        in Chapter 4.

   - Here's a simplified definition in code:
     #+begin_src scala
       trait Apply[F[_]] extends Semigroupal[F] with Functor[F] {
         def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]

         def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
           ap(map(fa)(a => (b: B) => (a, b)))(fb)
       }

       trait Applicative[F[_]] extends Apply[F] {
         def pure[A](a: A): F[A]
     #+end_src

   - Don't worry too much about the implementation of /product/!
     It's difficult to read and the details aren't particuarly important.

     The main point is that there is a _tight relationship between_ ~product~,
     ~ap~, and ~map~
     that
     allows _any one of them to be defined in terms of the other two_.

   - ~Applicative~ also introduces the ~pure~ method.
       This is the SAME ~pure~ we saw in ~Monad~.
     It constructs a new applicative instance from an unwrapped value.

     In this sense,
     ~Applicative~ is related to ~Apply~ as ~Monoid~ is related to ~Semigroup~.
     =TODO= =???= =TODO= =???=

*** TODO 6.5.1 The Hierarchy of Sequencing Type Classes - 160
    There is a whole family of /type classes/ that concern themselves with
    *sequencing* computations _in different ways_.

    - =TODO= NOTE

** TODO 6.6 Summary - 162
    - =TODO= NOTE

    - The next chapter covers ~Traverse~ and ~Foldable~, two powerful /type
      classes/ for *converting between* data types.

* TODO 7 ~Foldable~ and ~Traverse~ - 165
  _TWO_ /type classes/ that capture *iteration over collecons*:
  - ~Foldable~ abstracts the familiar ~foldLeft~ and ~foldRight~ operations;

  - ~Traverse~ is a higher-level abstraction that uses ~Applicative~'s to *iterate*
    _with LESS pain than folding_. =TODO=

  We'll start by looking at ~Foldable~, and then _examine cases where folding
  becomes complex and ~Traverse~ becomes convenient._ =TODO= =IMPORTANT=

** DONE 7.1 ~Foldable~ - 165
   CLOSED: [2019-04-08 Mon 01:03]
   - The ~Foldable~ /type class/ captures the ~foldLeft~ and ~foldRight~ /methods/
     we're used to in sequences like ~List~'s, ~Vector~'s, and ~Stream~'s.

   - Using ~Foldable~,
     + we can write /generic folds/ that work with a variety of /sequence types/.

     + We can also
       _invent_ new sequences
       and
       _plug_ them _into_ our code.

   - ~Foldable~ gives us greate use cases for ~Monoid~'s and the ~Eval~ /monad/.
     =TODO= =???=

*** DONE 7.1.1 Folds and Folding - 166
    CLOSED: [2019-03-31 Sun 02:40]
    - Depending on the operation we're performing, the order in which we fold may
      be important. Thus there are _TWO_ standard variants of /fold/:
      + ~foldLeft~ traverses from "left" to "right" (start to finish)
      + ~foldRight~ traverses from "right" to "left" (finish to start)

    - ~foldLeft~ and ~foldRight~ are equivalent if our binary operation is
      /associative/.

*** DONE 7.1.2 Exercise: Reflecting on Folds - 167
    CLOSED: [2019-03-31 Sun 02:44]
    Try using ~foldLeft~ and ~foldRight~ with _empty lists_ as accumulator and
    ~::~ as the binary operator. See the result.
    #+begin_src scala
      val list: List[Int] = List(1, 2, 3)

      list.foldLeft(List.empty[Int]) {
        (acc, e) => e :: acc
      }
      // List(3, 2, 1)

      list.foldRight(List.empty[Int]) {
        (e, acc) => e :: acc
      }
      // List(1, 2, 3)
    #+end_src
    + We are carefully specify the type of the accumulator to avoid a type error.
      If we use ~Nil~, Scala will think we use ~List.empty[Nothing]~ as an
      accumulator, which will lead to a type error.

*** DONE 7.1.3 Exercise: Scaf-fold-ing Other Methods - 167
    CLOSED: [2019-03-31 Sun 03:03]
    Implement ~List~'s ~map~, ~flatMap~, ~filter~, and ~sum~ /methods/ in terms
    of ~foldRight~:
    #+begin_src scala
      abstract class List[+A] {
        // Assume already implemented
        def foldRight[B](acc: B)(op: (A, B) => B) = ???

        def map[B](f: A => B): List[B] =
          this.foldRight(List.empty[B]){ (e, acc) =>
            f(e) :: acc
          }

        def flatMap[B](f: A => List[B]): List[B] =
          this.foldRight(List.empty[B]){ (e, acc) =>
            f(e) ::: acc
          }

        def filter[A](p: A => Boolean): List[A] =
          this.foldRight(List.empty[A]){ (e, acc) =>
            if (p(e)) e :: acc else acc
          }

        def sum[A](implicit m: Monoid[A]): A =
          this.foldRight(m.empty)(m.combine)
      }
    #+end_src

*** DONE 7.1.4 Foldable in Cats - 168
    CLOSED: [2019-04-08 Mon 01:03]
    Cats' ~Foldable~ abstracts ~foldLeft~ and ~foldRight~ into a /type class/.
    - Instances of ~Foldable~
      1. _define_ these TWO /methods/

      2. _inherit_ a host of /derived methods/.

    - Cats provides out-of-the-box /instances/ of ~Foldable~ for a handful of
      Scala data types: ~List~, ~Vector~, ~Stream~, and ~Option~.

    - ~List~ with ~Foldable~:
      #+begin_src scala
        import cats.Foldable
        import cats.instance.list._  // for Foldable

        val ints = List(1, 2, 3)

        Foldable[List].foldLeft(ints, 0)(_ + _)
        // res1: Int = 6
      #+end_src

    - =from Jian=
      Suggestion to this book:
      Replace ~Stream~ (Deprecated) with ~LazyList~.

    - ~Option~ with ~Foldable~:
      #+begin_src scala
        import cats.Foldable
        import cats.instance.option._  // for Foldable

        val maybeInt = Option(123)

        Foldable[Option].foldLeft(maybeInt, 10)(_ * _)
        // res3: Int = 1230
      #+end_src

**** DONE 7.1.4.1 Folding Right - 168 - ???
     CLOSED: [2019-04-08 Mon 00:56]
     ~Foldable~ defines ~foldRight~ differently to ~foldLeft~, in terms of the
     ~Eval~ /monad/:
     #+begin_src scala
       def foldRight[A, B](fa: F[A], lb: Eval[B])
                    (f: (A, Eval[B]) => Eval[B]): Eval[B]
     #+end_src
     The ~Eval~ /monad/ can promise /stack safe/,

     - =from Jian= I think this sentence is *Misleading*!!!
       EVEN WHEN the collection's default definition of ~foldRight~ is NOT.

       =from Jian= Suggestion: delete!

     - Example:
       =from Jian= Replace ~Stream~ with other data types. Might not be
       ~LazyList~, I guess ~LazyList~ might have already done the right thing.
       =from Jian= =IMPORTANT= =TODO= =TODO=

       #+begin_src scala
         import cats.Eval
         import cats.Foldable
         import cats.instance.stream._  // for Foldable

         def bigData = (1 to 100000).toStream

         bigData.foldRight(0L)(_ + _)
         // java.lang.StackOverflowError ...


         val eval: Eval[Long] =
           Foldable[Stream].
             foldRight(bigData, Eval.now(0L)) { (num, eval) =>
               eval.map(_ + num)
             }

         eval.value
         // res7: Long = 5000050000
       #+end_src

     - *Stack Safety in the Standard Library*
       /Stack Safety/ is NOT typically an issue when using the standard library.

       The most commonly used collection types, such as ~List~ and ~Vector~,
       provide /stack safe/ implementations of ~foldRight~.

       We use ~Stream~ here is just because ~Stream~ is an exception.

**** DONE 7.1.4.2 Folding with Monoids - 170 - ???
     CLOSED: [2019-09-16 Mon 00:16]
     - ~Foldable~ provides us with a host of useful /methods/ defined on top of
       ~foldLeft~. Many of these are facsimilies of familiar methods from the
       standard library:
       + ~find~
       + ~exists~
       + ~forall~
       + ~toList~
       + ~isEmpty~
       + ~nonEmpty~, and so on.

     - In addition to these familiar methods, Cats provides two /methods/ that
       make use of ~Monoid~'s:
       + ~combineAll~ (and its alias ~fold~) combines all elements in the sequence
         using their ~Monoid~;
         #+begin_src scala
           import cats.instances.int._  // for Monoid

           Foldable[List].combineAll(List(1, 2, 3))
           // res12: Int = 6
         #+end_src

       + ~foldMap~ maps a user-supplied function over the sequence and combines
         the results using a ~Monoid~.
         #+begin_src scala
           import cats.instances.string._  // for Monoid

           Foldable[List].combineAll(List(1, 2, 3))(_.toString)
           // res12: Int = 123
         #+end_src

     - Finally, we can compose ~Foldable~'s to support deep traversal of nested
       sequences: TODO ??? ??? ???
       #+begin_src scala
         import cats.instance.vector._  // for Monoid

         val ints = List(Vector(1, 2, 3), Vector(4, 5, 6))

         (Foldable[List] compose Foldable[Vector]).combineAll(ints)
         // res15: Int = 21
       #+end_src

**** DONE 7.1.4.3 Syntax for Foldable - 171
     CLOSED: [2019-04-08 Mon 01:02]
     With syntax imported, the first argument to the /static method/ becomes
     the /receiver/ of the /method/ call:
     #+begin_src scala
       import cats.syntax.foldable._  // for combineAll and foldMap

       List(1, 2, 3).combineAll
       // res16: Int = 6

       List(1, 2, 3).foldMap(_.toString)
       // res17: String = 123
     #+end_src

     - *Explicits over Implicits*
       + Scala feature: Use the _explicit available_ on the /receiver/ if it exists.
         For example,
         * Use the ~foldLeft~ defined on ~List~:
           #+begin_src scala
             List(1, 2, 3).foldLeft(0)(_ + _)  // res18: Int = 6
           #+end_src

         * The following generic code will use ~Foldbale~:
           #+begin_src scala
             import scala.language.higherKinds

             def sum[F[_]: Foldable](values: F[Int]): Int =
               values.foldLeft(0)(_ + _)
             // sum: [F[_]](values: F[Int])(implicit evidence$1: cats.Foldable[F])Int
           #+end_src

       + If we need a *stack-safe implementation* of ~foldRight~, using ~Eval~ as
         the accumulator is enough to force the compiler to select the method
         from Cats -- from the type the compiler knows the right one!
         TODO TODO TODO -- =REVIEW ~Eval~=

** TODO 7.2 ~Traverse~ - 172
   ~foldLeft~ and ~foldRight~ are flexible iteration methods but they require us
   to do a lot of work to define _accumulators_ and _combinator functions_.
     The ~Traverse~ /type class/ is a higher level tool that leverages
   ~Applicative~'s to provide a more convenient, more lawful, pattern for
   iteration.

*** DONE 7.2.1 Traversing with ~Future~'s - 172
    CLOSED: [2019-07-14 Sun 13:41]
    - Question:
      A list of server hostnames and method to poll a host for its uptime:
      #+begin_src scala
        import scala.concurrent._
        import scala.concurrent.duration._
        import scala.concurrent.ExecutionContext.Implicits.global

        val hostnames = List(
          "alpha.example.com",
          "beta.example.com",
          "gamma.demo.com"
        )

        def getUptime(hostname: String): Future[Int] =
          Future(hostname.length * 60)  // just for demonstration
      #+end_src

    - We can't simply map over ~hostnames~ because the result -- a ~List[Future[Int]]~
      -- would contain more than one ~Future~.
        We need to reduce the results to a single ~Future~ to get something we can
      block on. Let's start by doing this manually using a ~fold~:
      #+begin_src scala
        val allUptimes: Future[List[Int]] =
          hostnames.foldLeft(Future(List.empty[Int])) { (accum, host) =>
            val uptime = getUptime(host)
            for {
              acc <- accum
              ut  <- uptime
            } yield acc :+ ut
          }

        Await.result(allUptimes, 1.second)
        //res2: List[Int] = List(1020, 960, 840)
      #+end_src

    - Expected when simplified:
      #+begin_src scala
        val allUptimes: Future[List[Int]] =
          Future.traverse(hostname)(getUptime)

        Await.result(allUptimes, 1.second)
        // res3: List[Int] = List(1020, 960, 840)
      #+end_src
      + How does this implementated?
        If we ignore distractions like ~CanBuildFrom~ and ~ExecutionContext~,
        #+begin_src scala
          def traverse[A, B](values: List[A])
                            (func: A => Future[B]): Future[List[B]] =
            values.foldLeft(Future(List.empty[A])) { (accum, host) =>
              val item = func(host)
              for {
                acc <- accum
                e   <- item
              } yield acc :+ e
            }
        #+end_src

      + This is essentially the same as our example code above.
        It gives us a clean high-level interface to do what we want:
        * start with a ~List[A]~
        * provide a function ~A => Future[B]~
        * end up with a ~Future[List[B]]~

    - There is also a ~Future.sequence~ method defined as
      #+begin_src scala
        object Future {
          def sequence[B](futures: List[Future[B]]): Future[List[B]] =
            traverse(futures)(identity)

          // etc...
        }
      #+end_src
      + start with a ~List[Future[A]]~
      + end up with a ~Future[List[A]]~

    - The simplified examples above only work with ~List~'s, but the real
      ~Future.traverse~ and ~Future.sequence~ work with *any* standard Scala
      collection.

    - Cats' ~Traverse~ /type class/ generalises these patterns to work with any
      type of ~Applicative~: ~Future~, ~Option~, ~Validated~, and so on.

    - We'll approach ~Traverse~ in the next sections in two steps:
      1. We'll generalise over the ~Applicative~, then we'll generalise over the
         /sequence type/.

      2. We'll end up with an extremely valuable tool that trivialises many
         operations involving sequences and other data types.

*** TODO 7.2.2 Traversing with ~Applicative~'s - 175
    - If we squint, we'll see that we can _rewrite_ ~traverse~ in terms of an
      ~Applicative~. Our accumulator from the example above:
      ~Future(List.empty[Int])~ is equivalent to ~Applicative.pure~:
      #+begin_src scala
        import cats.Applicative
        import cats.instances.future._    // for Applicative
        import cats.syntax.applicative._  // for pure

        List.empty[Int].pure[Future]

        def oldCombine(
          accum: Future[List[Int]],
          host : String
        ): Future[List[Int]] = {
          val uptime = getUptime(host)
          for {
            acc <- accum
            ut  <- uptime
          } yield acc :+ ut
        }
      #+end_src
      is now equivalent to ~Semigroupal.combine~:
      #+begin_src scala
        import cats.syntax.apply._ // for mapN

        // Combining accumulator and hostname using an Applicative:
        def newCombine(accum: Future[List[Int]],
                       host: String): Future[List[Int]] =
          (accum, getUptime(host)).mapN(_ :+ _)
      #+end_src

    - By substituting these snippets back into the definition of ~traverse~ we can
      generalise it to to work with any ~Applicative~:
      #+begin_src scala
        import scala.language.higherKinds

        def listTraverse[F[_]: Applicative, A, B](list: List[A])(func: A => F[B]): F[List[B]] =
          list.foldLeft(List.empty[B].pure[F]) { (accum, item) =>
            (accum, func(item)).mapN(_ :+ _)
          }

        def listSequence[F[_]: Applicative, B](list: List[F[B]]): F[List[B]] =
          listTraverse(list)(identity)
      #+end_src
      + Use ~listTraverse~ to re-implement our uptime example:
        #+begin_src scala
          val totalUptime = listTraverse(hostname)(getUptime)
          Await.result(totalUptime, 1.second)
          // res11: List[Int] = List(1020, 960, 840)
        #+end_src

**** DONE 7.2.2.1 Exercise: Traversing with ~Vector~'s - 177
     CLOSED: [2019-07-14 Sun 13:58]
     #+begin_src scala
       import cats.instances.vector._  // for Applicative

       listSequence(List(Vector(1, 2), Vector(3, 4)))
     #+end_src
     - Solution:
       ~Vector(List(1, 3), List(1, 4), List(2, 3), List(2, 4))~

**** DONE 7.2.2.2 Exercise: Traversing with ~Option~'s - 177
     CLOSED: [2019-07-14 Sun 14:04]
     #+begin_src scala
       import cats.instances.option._  // for Applicative

       def process(inputs: List[Int]) =
         listTraverse(inputs)(n => if (n % 2 == 0) Some(n) else None)
     #+end_src
     - What is the _return type_ of this method?
       ~Option[List[Int]]~

     - What does it produce for the following inputs?
       #+begin_src scala
         process(List(2, 4, 6))
         // Some(List(2, 4, 6))

         process(List(1, 2, 3))
         // None
       #+end_src

**** TODO 7.2.2.3 Exercise: Traversing with ~Validated~ - 177
     #+begin_src scala
       import cats.data.Validated
       import cats.instances.list._ // for Monoid

       type ErrorsOr[A] = Validated[List[String], A]

       def process(inputs: List[Int]): ErrorsOr[List[Int]] =
         listTraverse(inputs) { n =>
           n % 2 match {
             case 0 => Validated.valid(n)
             case _ => Validated.invalid(List(s"$n is not even"))
           }
         }
     #+end_src

*** TODO 7.2.3 ~Traverse~ in Cats - 178

** TODO 7.3 Summary - 180

* Part II. Case Studies - 181
* TODO 8 Case Study: Testing Asynchronous Code - 183
** TODO 8.1 Abstracting over Type Constructors - 185
** TODO 8.2 Abstracting over Monads - 186
** TODO 8.3 Summary - 187

* TODO 9 Case Study: Map-Reduce - 189
** TODO 9.1 Parallelizing ~map~ and ~fold~ - 189
** TODO 9.2 Implementing ~foldMap~ - 191
** TODO 9.3 Parallelising ~foldMap~ - 193
*** TODO 9.3.1 ~Future~'s, Thread Pools, and ~ExecutionContext~'s - 193
*** TODO 9.3.2 Dividing Work - 196
*** TODO 9.3.3 Implementing ~parallelFoldMap~ - 197
*** TODO 9.3.4 ~parallelFoldMap~ with more Cats - 197

** TODO 9.4 Summary - 198

* TODO 10 Case Study: Data Validation - 199
** TODO 10.1 Sketching the Library Structure - 200
*** TODO Providing error messages - 200
*** TODO Combine checks - 201
*** TODO Accumulating errors as we check - 202
*** TODO Transforming data as we check it - 202

** TODO 10.2 The Check Datatype - 203
** TODO 10.3 Basic Combinators - 204
** TODO 10.4 Transforming Data - 205
*** TODO 10.4.1 Predicates - 206
*** TODO 10.4.2 Checks - 208
*** TODO 10.4.3 Recap - 210

** TODO 10.5 Kleislis - 211
** TODO 10.6 Summary - 215

* TODO 11 Case Study: CRDTs - 217
** TODO 11.1 Eventual Consistency - 217
** TODO 11.2 The GCounter - 218
*** TODO 11.2.1 Simple Counters - 218
*** TODO 11.2.2 GCounters - 220
*** TODO 11.2.3 Exercise: GCounter Implementation - 221

** TODO 11.3 Generalisation - 222
*** TODO 11.3.1 Implementation - 224
*** TODO 11.3.2 Exercise: ~BoundedSemiLattice~ Instances - 225
*** TODO 11.3.3 Exercise: Generic GCounter - 225

** TODO 11.4 Abstracting GCounter to a Type Class - 225
** TODO 11.5 Abstracting a Key Value Store - 227
** TODO 11.6 Summary - 228

* Part III. Solutions to Exercises - 231
* TODO Appendix A Solutions for: Introduction - 233
** A.1 Printable Library - 233
** A.2 Printable Library Part 2 - 234
** A.3 Printable Library Part 3 - 235
** A.4 Cat ~Show~ - 236
** A.5 Equality, Liberty, and Felinity - 237

* TODO Appendix B Solutions for: Monoids and Semigroups - 239
** B.1 The Truth About Monoids - 239
** B.2 All Set for Monoids - 240
** B.3 Adding All The Things - 241
** B.4 Adding All The Things Part 2 - 242
** B.5 Adding All The Things Part 3 - 243

* TODO Appendix C Solutions for: Functors - 245
** C.1 Branching out with Functors - 245
** C.2 Showing off with Contramap - 246
** C.3 Showing off with Contramap Part 2 - 247
** C.4 Transforma ve Thinking with imap - 248
** C.5 Transforma ve Thinking with imap Part 2 - 248
** C.6 Transforma ve Thinking with imap Part 3 - 248

* TODO Appendix D Solutions for: Monads - 251
** D.1 Getting Func-y - 251
** D.2 Monadic Secret Identities - 252
** D.3 What is Best? - 253
** D.4 Safer Folding using Eval - 254
** D.5 Show Your Working - 255
** D.6 Hacking on Readers - 256
** D.7 Hacking on Readers Part 2 - 257
** D.8 Hacking on Readers Part 3 - 257
** D.9 Post-Order Calculator - 258
** D.10 Post-Order Calculator Part 2 - 259
** D.11 Post-Order Calculator Part 3 - 259
** D.12 Branching out Further with Monads - 260

* TODO Appendix E Solutions for: Monad Transformers - 263
** E.1 Monads: Transform and Roll Out - 263
** E.2 Monads: Transform and Roll Out Part 2 - 263
** E.3 Monads: Transform and Roll Out Part 3 - 264
** E.4 Monads: Transform and Roll Out Part 4 - 264

* TODO Appendix F Solutions for: Semigroupal and Applicative - 267
** F.1 The Product of Monads - 267
** F.2 Form Validation - 268
** F.3 Form Validation Part 2 - 269
** F.4 Form Validation Part 3 - 270
** F.5 Form Validation Part 4 - 270
** F.6 Form Validation Part 5 - 271

* TODO Appendix G Solutions for: ~Foldable~ and ~Traverse~ - 273
** G.1 Reflecting on Folds - 273
** G.2 Scaf-fold-ing Other Methods - 274
** G.3 Traversing with Vectors - 275
** G.4 Traversing with Vectors Part 2 - 276
** G.5 Traversing with Options - 276
** G.6 Traversing with Validated 277

* TODO Appendix H Solutions for: Case Study: Testing Asynchronous Code - 279
** H.1 Abstracting over Type Constructors - 279
** H.2 Abstracting over Type Constructors Part 2 - 280
** H.3 Abstracting over Monads - 280
** H.4 Abstracting over Monads Part 2 - 281

* TODO Appendix I Solutions for: Case Study: Map-Reduce 283
** I.1 Implementing ~foldMap~ - 283
** I.2 Implementing ~foldMap~ Part 2 - 283
** I.3 Implementing ~parallelFoldMap~ - 284
** I.4 ~parallelFoldMap~ with more Cats - 286

* TODO Appendix J Solutions for: Case Study: Data Validation - 289
** J.1 Basic Combinators - 289
** J.2 Basic Combinators Part 2 - 290
** J.3 Basic Combinators Part 3 - 290
** J.4 Basic Combinators Part 4 - 294
** J.5 Basic Combinators Part 5 - 295
** J.6 Checks - 296
** J.7 Checks Part 2 - 297
** J.8 Checks Part 3 - 298
** J.9 Recap - 298
** J.10 Recap Part 2 - 301
** J.11 Kleislis - 304
** J.12 Kleislis Part 2 - 304

* TODO Appendix K Solutions for: Case Study: CRDTs - 307
** K.1 ~GCounter~ Implementation - 307
** K.2 ~BoundedSemiLattice~ Instances - 308
** K.3 Generic ~GCounter~ - 308
** K.4 Abstracting ~GCounter~ to a Type Class - 309
** K.5 Abstracting a Key Value Store - 310
