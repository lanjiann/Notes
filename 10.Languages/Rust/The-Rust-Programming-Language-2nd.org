#+TITLE: The Rust Programming Language
#+VERSION: 2nd
#+AUTHOR: Community
#+STARTUP: entitiespretty
#+STARTUP: fold

* Foreword - xix
  =TODO=
  -- Nicholas Matsakis and Aaron Turon
  
* Preface - xxi
* Acknowledgments - xxiii
* Introduction - xxv
** Who Rust Is For - xxvi
*** Teams of Developers - xxvi
*** Students - xxvi
*** Companies - xxvi
*** Open Source Developers - xxvi
*** People Who Value Speed and Stability - xxvii

** Who This Book Is For - xxvii
** How to Use This Book - xxvii
** Resources and How to Contribute to This Book - xxix

* DONE 1. Getting Started - 1
  CLOSED: [2021-01-01 Fri 15:54]
  - There's a lot to learn, but every journey starts somewhere.
    In this chapter, we'll discuss:
    * Installing Rust on Linux, macOS, and Windows
    * Writing a program that prints ~Hello, world!~
    * Using _cargo_, Rust’s package manager and build system

  - Rust package registry site, [[https://crates.io/][crates.io]]

** DONE Installation - 1
   CLOSED: [2017-08-16 Wed 00:43]
   - Convention: =$= prompt means normal user, and =#= means super user.

*** Installing rustup on Linux or macOS
*** Installing rustup on Windows
*** Updating and Uninstalling
*** Troubleshooting
*** Local Documentation

** DONE Hello, World! - 4
   CLOSED: [2021-01-01 Fri 01:39]
*** DONE Creating a Project Directory - 4
    CLOSED: [2021-01-01 Fri 01:38]
*** DONE Writing and Running a Rust Program - 5
    CLOSED: [2021-01-01 Fri 01:39]
    The source code:
    #+BEGIN_SRC rust
      // main.rs
      fn main() {
          println!("Hello, world!");
      }
    #+END_SRC

    ~$ rustc main.rs~

    ~$ ./main~
    =From Jian=: NOT ~a.out~ anymore!!!
    The output is ="Hello, world!"=

*** DONE Anatomy of a Rust Program - 5
    CLOSED: [2021-01-01 Fri 01:39]
    - rustfmt

    - It's good style to place the _opening curly bracket_ *on the same line* as
      the function declaration, adding one space in between.

    - ~println!~ is a /Rust macro/.
      =TODO= Discuss Rust macros in more details in Appendix E.
      ~!~ means you're calling a macro instead of a normal function.

    - There are four important details to notice here:
      1. Rust style is to indent with four spaces, not a tab.

      2. ~println!~ is a /Rust macro/.
         It will be discussed in Chapter 19.

      3. You see the ~"Hello, world!"~ string. We pass this string as an argument
         to ~println!~, and the string is printed to the screen.

      4. End the line with a semicolon (~;~), which indicates that this expression
         is over and the next one is ready to begin.
         =TODO= Most lines of Rust code end with a semicolon.
         =from Jian= Why _MOST_???

*** DONE Compiling and Running Are Separate Steps - 6
    CLOSED: [2021-01-01 Fri 01:39]
    The command is mentioned in the _Writing and Running a Rust Program_ section.
    
    - ~rustc main.rs~

    - In Linux and macOS,
      =main= and =main.rs=

    - In Windows,
      =main.exe=, =main.pdb=, and =main.rs=
      * =main.pdb= is a file containing debugging information

    - Just compiling with =rustc= is fine for simple programs,
      but as your project grows, you'll want to manage all the options and make
      it easy to share your code.
      * Next, we'll introduce you to the _Cargo tool_, which will help you write
        real-world Rust programs.

** DONE Hello, Cargo! - 7
   CLOSED: [2021-01-01 Fri 15:53]
   Cargo is Rust's build system and package manager.
   
   - Most Rustaceans use this tool to manage their Rust projects because Cargo
     handles a lot of tasks for you, such as
     * building your code,
     * downloading the libraries your code depends on, and
     * building those libraries. (We call libraries your code needs dependencies.)
   
   - If you installed Rust with the given command (Section 1.1)
     ~$ curl https://sh.rustup.rs -sSf | sh~, *Cargo* should have been installed.
     * Use ~cargo --version~ to check if it is installed properly.

*** DONE Creating a Project with Cargo - 8
    CLOSED: [2021-01-01 Fri 15:53]
    ~cargo new hello_cargo --bin~
    - ~--bin~ argument (to ~cargo new~):
      make an _executable application_, as opposed to a _library_.

    - The new project contains three files:
      * =Cargo.toml=: a structured plain text file.
      * =src= folder
      * =.gitignore= file and =.git= folder
        + This won't be generated if you run =cargo new= within an existing Git repository
        + Override this behavior by using
          =cargo new --vcs=some-vcs-system=, or
          =cargo new --vcs some-vcs-system=.
          - Current (1.51.0-nightly) [possible values: fossil, git, hg, none, pijul]

    - This simple =Cargo.toml= file:
      #+BEGIN_SRC toml
        [package]
        name = "hello_cargo"
        version = "0.1.0"
        authors = ["Your Name <you@example.com>"]
        edition = "2018"

        [dependencies]
      #+END_SRC
      This file is the *TOML* (Tom's Obvious, Minimal Language) format.
      *TOML* is similar to *INI* but has some extra goodies and is used as
      Cargo's configuration format.
      * ~[package]~ is a section heading that indicates that the following
        statements are configuring a /package/.
        + The next four lines set the _configuration information Cargo needs to
          compile your program_:
          - the name,
          - the version,
          - who wrote it, and
          - the edition of Rust to use.

          Cargo gets your name and email information from your environment, so
          if that information is not correct, fix the information now and then
          save the file. =from Jian= From where???
          =TODO= We'll talk about the edition key in _Appendix E_.

      * =TODO= =SIMPLIFY NOTE=
        ~[dependencies]~ is the start of a section for you to list any of your
        project's dependencies.
        + In Rust, packages of code are referred to as /crates/.

    - The =src/main.rs= file is initialized as a simple _hello world_ program.

    - Cargo EXPECTS your source files to live *INSIDE* the =src= directory.

    - The top-level project directory is just for
      * =READMEs=
      * license info
      * configuration files
      * anything else not related to your code

    - Using Cargo helps you organize your projects.
      There's a place for everything, and everything is in its place.

*** DONE Building and Running a Cargo Project - 9
    CLOSED: [2021-01-01 Fri 15:53]
    - Build:
      ~$ cargo build~

      The output:
      #+begin_src text
        Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
         Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
      #+end_src

    - This should have created an executable file in =target/debug/hello_cargo=.

    - Manually Run (just a try, not recommended):
      ~$ ./target/debug/hello_cargo~

      The output:
      ="Hello, world!"=
      
    - The first time you run ~cargo build~ in a project, a =Cargo.lock= file
      will be added in the top level of this project.
      #+BEGIN_SRC toml
        [root]
        name = "hello_cargo"
        version = "0.1.0"
      #+END_SRC

    - Run:
      ~$ cargo run~
      * The output:
        #+begin_src text
             Compiling hello_cargo v0.1.0 (/home/shapeless-cat/Practices/hello_cargo)
              Finished dev [unoptimized + debuginfo] target(s) in 0.42s
               Running `target/debug/hello_cargo`
          Hello, world!
        #+end_src

    - Cargo also provides a command called ~cargo check~.
      This command quickly checks your code to make sure it compiles but doesn’t
      produce an executable:
      ~$ cargo check~
      The output:
      #+begin_src text
        Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
         Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
      #+end_src

    - Q :: Why would you not want an executable?
    - A :: Often, ~cargo check~ is much faster than ~cargo build~,
           because it *skips the step of producing an executable.*
      * Many Rustaceans run ~cargo check~ periodically as they write their program
        to make sure it compiles.
          Then they run ~cargo build~ when they're ready to use the executable.

    - Let's recap what we've learned so far about Cargo:
      * We can build a project using ~cargo build~.

      * We can build and run a project in one step using ~cargo run~.

      * We can build a project *without producing a binary* to check for errors
        using ~cargo check~.

      * Instead of saving the result of the build in the same directory as our
        code, Cargo stores it in the =target/debug= directory.

    - An additional advantage of using Cargo is that the commands are the same no
      matter which operating system you're working on.

*** DONE Building for Release - 10
    CLOSED: [2021-01-01 Fri 15:53]
    When your project is finally ready for release, you can use
    ~cargo build --release~ to compile it with optimizations.

    - This command will create an executable in =target/release= instead of
      =target/debug=.

    - The optimizations make your Rust code run faster, but turning them on
      lengthens the time it takes for your program to compile.

    - This is why there are _TWO_ different profiles:
      * _one for development_, when you want to *rebuild quickly and often*, and
      * another for building the final program you'll give to a user that won't
        be rebuilt repeatedly and that will run as fast as possible.

    - If you're _benchmarking_ your code's running time,
      be sure to run ~cargo build --release~ and benchmark with the executable
      in =target/release=.
    
*** DONE Cargo as Convention - 11
    CLOSED: [2021-01-01 Fri 15:53]
    You can always expect to do this:
    ~$ git clone someurl.com/someproject~
    ~$ cd someproject~
    ~$ cargo build~

** DONE Summary - 11
   CLOSED: [2021-01-01 Fri 15:53]

* DONE 2. Programming a Guessing Game - 13
  CLOSED: [2021-01-02 Sat 01:26]
  Generate a random integer between 1 and 100.
  Try to guess.
  The program tells you if it is right, too low, or to high?
  If not right keep guessing.
  If right print congratulations and exit.
  
** DONE Setting Up a New Project - 14
   CLOSED: [2021-01-02 Sat 01:23]
   ~$ cargo new guessing_game~
   ~$ cd guessing_game~

   - Look at the generated =Cargo.toml= file:
     #+begin_src toml
       [package]
       name = "guessing_game"
       version = "0.1.0"
       author = ["Your Name <you@example.com>"]
       edition = "2018"

       [dependencies]
     #+end_src
     If the author information that Cargo obtained from your environment is not
     correct, fix that in the file and save it again.
     
** DONE Processing a Guess - 14
   CLOSED: [2021-01-02 Sat 01:24]
   #+BEGIN_SRC rust
     // src/main.rs

     use std::io;

     fn main() {
         println!("Guess the number!");

         println!("Please input your guess.");

         let mut guess = String::new();

         io::stdin()
             .read_line(&mut guess)
             .expect("Failed to read line");

         println!("You guessed: {}", guess);
     }
   #+END_SRC

   - ~std~ means the standard library.
     ~io~ library comes from the standard library.

   - Use ~use~ when the required libraries are not in the /prelude/.

   - This code is printing a prompt stating what the game is and requesting input
     from the user.

*** Storing Values with Variables - 15
    - ~String~ is a /string type/ provided by the /standard library/ that is a
      growable, UTF-8 encoded bit of text.

      * The ~::~ syntax in the ~::new~ line indicates that new is an /associated
        function/ of the ~String~ type.

        + /an associated function/ ::
          a function that is implemented *on a /type/,* in this case ~String~,
          _rather than on a particular instance_ of a ~String~ (Some languages
          call this a /static method/).

      * ~String::new()~ create a _NEW, EMPTY string._

      * TO SUMMARIZE,
        the ~let mut guess = String::new();~ line has *created* a
        /mutable variable/ that is currently bound to a NEW, EMPTY /instance/ of
        a ~String~.

    - ~io::stdin~ should be written as ~std::io::stdin~ if you did NOT
      ~use std::io~.

    - The job of ~read_line~ is to
      1. take whatever the user types into standard input
         and
      2. place that into a /string/, so it takes that string as an argument.
         
    - The /string argument/ of ~read_line~, ~guess~,
      needs to be /mutable/
      so the /method/ can change the _string's content_ by adding the user input.

    - The ~&~ indicates that this argument is a /reference/, which gives you a way
      to let multiple parts of your code access one piece of data _without_ needing
      to copy that data into memory multiple times.

    - /References/ are a COMPLEX feature, and one of Rust's major advantages is
      how safe and easy it is to use /references/.
      * /references/ are *immutable* BY DEFAULT.
        Hence, you need to write ~&mut guess~ rather than ~&guess~ to make it /mutable/.
        =TODO= (Chapter 4 will explain references more thoroughly.)

*** Handling Potential Failure with the ~Result~ Type - 17
    - ~read_line~ also returns a value -- an ~io::Result~ typed value.

    - Rust has a number of /types/ named ~Result~ in its standard library:
      * a generic ~Rusult~
      * a specific versions for submodules, such as ~io::Result~.

    - The ~Result~ types are /enumerations/, often referred to as ~enums~.
        An enumeration is a type that can have a _fixed_ set of values, and those
      values are called the /enum's variants/.
      =TODO= CHAPTER 6

    - For ~Result~, the /variants/ are ~Ok~ or ~Err~.
      * ~Ok~ indicates the operation was successful, and it contains the success-
        fully generated value.

      * ~Err~ indicates the operation was failed, and it contains info about
        _how_ and _why_ the operation failed.

    - ~io::Result~ has an ~expect~ method that you can call.
      * With an ~Err~ value, ~expect~ will cause the program to crash and
        display the message that you passed as an argument to ~expect~.

      * With an ~Ok~ value, ~expect~ will take the return value that ~Ok~ is
        holding and return just the value to you.

    - If you have a ~Result~ type value, and you don't use ~expect~ method or try
      to catch the error (=TODO= CHAPTER 9), The compiler will issue a warning
      becuase of _unused value_ issue.

    - =TODO=
      Chapter 9 will show how to recover from errors.

*** Printing Values with ~println!~ Placeholders - 18
    The ~{}~ syntax for ~println!~ ......
    
*** Testing the First Part - 18
    ~cargo run~ and try it (we currently only finished the input part).
    
    Output:
    #+begin_src text
        Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
         Finished dev [unoptimized + debuginfo] target(s) in 6.44s
          Running `target/debug/guessing_game`
      Guess the number!
      Please input your guess.
      6
      You guessed: 6
    #+end_src
    
** DONE Generating a Secret Number - 19
   CLOSED: [2021-01-02 Sat 01:24]
   Not random number functionality in /standard library/, however, the Rust team
   does provide a =rand= /create/.

*** DONE Using a Crate to Get More Functionality - 19
    CLOSED: [2021-01-02 Sat 01:24]
     - /crate/ is a collection of Rust source code files.

       * The project we've been building is a /binary crate/, which is an
         executable.

       * The =rand= /crate/ is a /library crate/, which contains code intended to be
         used in other programs.

     - To use a crate in a Rust project, we need to modify the =Cargo.toml= -- add
       a /dependency/:
       #+BEGIN_SRC toml
         [dependencies]
         rand = "0.5.5"
       #+END_SRC

     - Cargo understand [[http://semver.org][Semantic Versioning]] (/SemVer/ for short), which is a
       standard for writing version numbers.
       * The =0.5.5= is a _shorthand_ for =^0.5.5=, which means
         "any version that has a public API compatible with version =0.5.5=".
         =IMPORTANT=

     - /Crates.io/ :: a place people in the Rust ecosystem post their open source
                      Rust projects for others to use.

     - /registry/ :: a copy of data from Crates.io.

     - Now that we have an _external dependency_,
       Cargo fetches the latest versions of everything from the /registry/.

     - ~$ cargo build~
       Output:
       #+BEGIN_SRC text
           Updating crates.io index
         Downloaded rand v0.5.5
         Downloaded libc v0.2.62
         Downloaded rand_core v0.2.2
         Downloaded rand_core v0.3.1
         Downloaded rand_core v0.4.2
          Compiling rand_core v0.4.2
          Compiling libc v0.2.62
          Compiling rand_core v0.3.1
          Compiling rand_core v0.2.2
          Compiling rand v0.5.5
          Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
           Finished dev [unoptimized + debuginfo] target(s) in 2.53s
       #+END_SRC
       * Cargo also grabbed =libc= and =rand_core=, because =rand= depends on them.

     - Run ~cargo build~ again, and we can only see the =Finished dev ...= line.
       * Only when we modify =src/main.rs=, we can see the =Compiling ...= lines.

       * Only when we modify the ~[dependencies]~ section,
         we can see the =Downloaded ...= lines.

**** Ensuring Reproducible Builds with the =Cargo.lock= File
     The first time you run ~$ cargo build~ (or ~$cargo run~) Cargo tries to
     figure out the versions of the dependencies that fit the criteria and then
     writes them to the =Cargo.lock= file.

     When you build in the future, Cargo will read =Cargo.lock= rather then tries
     to figure out the verions of dependencies again through parsing =Cargo.toml=.

     _Remember_: the acutally used versions of dependencies (info is in
     =Cargo.lock=) are different from the ones written in =Cargo.toml= -- Cargo
     may choose a higher but can fit version.

**** Updating a Crate to Get a New Version
     - ~$ cargo update~ will help you to update the dependencies to the lastest
       fit version. For instance, 0.5.5 to 0.5.6.

     - If the *first time* you run ~$ cargo build~ it used version _0.5.5_, the
       later ~$ cargo update~ will choose version _exclusively_ between _0.5.5_
       and _0.6.0_.

     - If you want a higher version, like _0.6.0_, you must manually update the
       =Cargo.toml= file.

*** DONE Generating a Random Number - 21
    CLOSED: [2021-01-02 Sat 01:24]
    Update the =src/main.rs=.

    #+BEGIN_SRC rust
      extern crate rand;

      use std::io;
      use rand::Rng;

      fn main() {
          println!("Guess the number!");

          let secret_number = rand::thread_rng().gen_range(1, 101);
          // let secret_number = rand::thread_rng().gen_range(1..101);  // when use rand 0.8

          println!("The secret number is: {}", secret_number);

          println!("Please input your guess.");

          let mut guess = String::new();

          io::stdin().read_line(&mut guess)
              .expect("Failed to read line");

          println!("You guessed: {}", guess);
      }
    #+END_SRC

    - ~Rng~ is a /trait/ that defines /methods/ that /random number generators/
      IMPLEMENT, and this /trait/ MUST BE *in scope* for us to use those /methods/.
      =TODO= CHAPTER 10 =details=

    - ~rand::thread_rng~ function will give us the PARTICULAR /random number generator/
      to be used:
      one that is
      * local to the CURRENT /thread/ of execution
      * *seeded by* the operating system.

    - The ~gen_range~ /method/ is defined by the ~Rng~ trait.

    - Note:
      Run the ~cargo doc --open~ command that will BUILD documentation provided
      by all of your dependencies locally and open it in your browser.
      =IMPORTANT= Then you know what /traits/ you should ~use~.

** DONE Comparing the Guess to the Secret Number - 23
   CLOSED: [2021-01-02 Sat 01:24]
   #+BEGIN_SRC rust
     use rand::Rng;
     use std::cmp::Ordering;
     use std::io;

     fn main() {
         // --snip--

         println!("You guessed: {}", guess);

         match guess.cmp(&secret_number) {
             Ordering::Less    => println!("Too small!"),
             Ordering::Greater => println!("Too big!"),
             Ordering::Equal   => println!("You win!"),
         }
     }
   #+END_SRC

   - ~Ordering~ is a type, and it has three variants:
     ~Less~, ~Greater~, and ~Equal~.

   - A ~match~ expression is made up of /arms/.

   - An /arm/ consists of a /pattern/ and the code that should be run when
     pattern matching can be applied.

   - The code above CANNOT be compiled -- type mismatching:
     ~guess~ should be a number if we want to compare it with ~secret_number~.

   - Integer types: ~i32~, ~u32~, ~i64~.
     Rust defaults to an ~i32~, which is the type of ~secret_number~.
     Here, ~u32~ is more reasonable.

   - The corrected code:
     #+BEGIN_SRC rust
       use rand::Rng;
       use std::cmp::Ordering;
       use std::io;

       fn main() {
           println!("Guess the number!");
           let secret_number = rand::thread_rng().gen_range(1, 101);
           println!("The secret number is: {}", secret_number);
           println!("Please input your guess.");

           let mut guess = String::new();

           io::stdin()
               .read_line(&mut guess)
               .expect("Failed to read line");

           let guess: u32 = guess.trim().parse().expect("Please type a number!");

           println!("You guessed: {}", guess);

           match guess.cmp(&secret_number) {
               Ordering::Less    => println!("Too small!"),
               Ordering::Greater => println!("Too big!"),
               Ordering::Equal   => println!("You win!"),
           }
       }
     #+END_SRC

     * =from Jian= I DO NOT like the /shadow/ feature. Here is what I prefered:
       =TODO= CHAPTER 3 - more about the /shadow/ feature.
       #+BEGIN_SRC rust
         use rand::Rng;
         use std::cmp::Ordering;
         use std::io;

         fn main() {
             println!("Guess the number!");
             let secret_number = rand::thread_rng().gen_range(1, 101);
             println!("The secret number is: {}", secret_number);
             println!("Please input your guess.");

             // `line` can be an alternative name.
             let mut input = String::new();

             io::stdin().read_line(&mut input)
                 .expect("Failed to read line");

             println!("You guessed: {}", input);

             let guess: u32 = input.trim().parse().expect("Please type a number!");

             match guess.cmp(&secret_number) {
                 Ordering::Less    => println!("Too small!"),
                 Ordering::Greater => println!("Too big!"),
                 Ordering::Equal   => println!("You win!"),
             }
         }
       #+END_SRC

     * ~trim~ eliminate any WHITESPACE _at the beginning and end_.

     * The ~parse~ /method/ on /strings/ parses a /string/ into some kind of
       /number/. 
       + ~parse~ can parse a variety of /number types/,
         we need to tell Rust the EXACT /number type/ we want by using ~let
         guess: u32~.

     * with the help of ~u32~, ~parse~ knows what's essential type (_essential_
       here means the cotent of the ~Result~ value) of its result.

     * =TODO=
       Need a loop to given the users MULTIPLE choices to guesses.

** DONE Allowing Multiple Guesses with Looping - 26
   CLOSED: [2021-01-02 Sat 01:25]
   Make a simple forever loop with ~loop~
   #+BEGIN_SRC rust
     use rand::Rng;
     use std::cmp::Ordering;
     use std::io;

     fn main() {
         println!("Guess the number!");
         let secret_number = rand::thread_rng().gen_range(1, 101);
         println!("The secret number is: {}", secret_number);

         loop {
             println!("Please input your guess.");

             // `line` can be an alternative name.
             let mut input = String::new();

             io::stdin().read_line(&mut input)
                 .expect("Failed to read line");

             println!("You guessed: {}", input);

             let guess: u32 = input.trim().parse()
                 .expect("Please type a number!");

             match guess.cmp(&secret_number) {
                 Ordering::Less    => println!("Too small!"),
                 Ordering::Greater => println!("Too big!"),
                 Ordering::Equal   => println!("You win!"),
             }
         }
     }
   #+END_SRC

*** DONE Quitting After a Correct Guess - 27
    CLOSED: [2021-01-02 Sat 01:25]
    ~break~ when ="You win!"=.

   #+BEGIN_SRC rust
     use rand::Rng;
     use std::cmp::Ordering;
     use std::io;

     fn main() {
         println!("Guess the number!");
         let secret_number = rand::thread_rng().gen_range(1, 101);
         println!("The secret number is: {}", secret_number);

         loop {
             println!("Please input your guess.");

             // `line` can be an alternative name.
             let mut input = String::new();

             io::stdin().read_line(&mut input)
                 .expect("Failed to read line");

             println!("You guessed: {}", input);

             let guess: u32 = input.trim().parse()
                 .expect("Please type a number!");

             match guess.cmp(&secret_number) {
                 Ordering::Less    => println!("Too small!"),
                 Ordering::Greater => println!("Too big!"),
                 Ordering::Equal   => {
                     println!("You win!");
                     break;
                 }
             }
         }
     }
   #+END_SRC

*** DONE Handling Invalid Input - 28
    CLOSED: [2021-01-02 Sat 01:25]
    To further refine the game's behavior, rather than crashing the program when
    the user inputs a non-number, _let's make the game ignore a non-number so the
    user can continue guessing._
    
    Do that by altering the line where ~guess~ in converted from a ~String~ to a
    ~u32~.
    
    The final version is:
    #+BEGIN_SRC rust
      use rand::Rng;
      use std::cmp::Ordering;
      use std::io;

      fn main() {
          println!("Guess the positive integer number!");

          let secret_number = rand::thread_rng().gen_range(1, 101);

          loop {
              println!("Please input your guess.");

              let mut input = String::new();

              io::stdin().read_line(&mut input)
                  .expect("Failed to read line");

              let guess: u32 = match input.trim().parse() {
                  Ok(num) => num,
                  Err(_)  => continue,
              };

              println!("You guessed: {}", guess);

              match guess.cmp(&secret_number) {
                  Ordering::Less    => println!("Too small!"),
                  Ordering::Greater => println!("Too big!"),
                  Ordering::Equal   => {
                      println!("You win!");
                      break;
                  }
              }
          }
      }
    #+END_SRC
    - Switching from an ~expect~ call to a ~match~ expression is
      how you generally _move from crashing on an error to handling the error._

    - Delete the ~secret_number~ print.

    - =from Jian=
      Add a ~println!~ before ~continue~ to tell one invalid ~guess~ is ignored
      is a good tweak.

** DONE Summary - 30
   CLOSED: [2021-01-02 Sat 01:25]
   
* DONE 3. Common Programming Concepts - 31 - =START=
  CLOSED: [2017-08-17 Thu 23:57]
  *Keywords* See Appendix A =TODO=
** DONE Variables and Mutability - 32
   CLOSED: [2017-08-17 Thu 00:51]
*** DONE Differences Between Variables and Constants - 34
    CLOSED: [2017-08-17 Thu 00:41]
    - Rust has ~const~ keyword.

    - Constants are NOT only immutable by default, they're always immutable.

    - The type of constant (declared with ~const~) _must_ be annotated.

    - Constants can be declared in any scope, including the global scope.

    - A constant can ONLY be set to a constant expression,
      NOT
      + the result of a function call
        or
      + any other value that could only be computed at runtime.

    - ~_~'s are allowed when you write a number, and they will be ignored when do
      evaluation.

*** DONE Shadowing - 34
    CLOSED: [2017-08-17 Thu 00:44]
    _I the /shadowing/ feature is BAD._

    =From Jian=
    From my point of view, the only natural way of shadowing is in embeded scope.
    I don't want to see shadowing happend in a flat structure.

    There should a feature to let you write down the transition of types of
    a varaible, and this transition only describes the type transition in the
    local scope.
** DONE Data Types - 36
   CLOSED: [2017-08-17 Thu 21:53]
   Sometime the type CANNOT be inferred, you must add the type annotation.

   For example, ~parse~ below need to know the type of its result, or it does NOT
   know what to do: ~let guess: u32 = "42".parse().expect("Not a number!");~

*** DONE Scalar Types - 36
    CLOSED: [2017-08-17 Thu 21:53]
    - /scala types/ :: The types of some single values.

    - Four primary scalar types in Rust:
      + integers
      + floating-point numbers
      + booleans
      + characters

**** DONE Integer Types
     CLOSED: [2017-08-17 Thu 04:15]
     Table 3-1: Integer Types in Rust

     | Length | Signed | Unsigned |
     |--------+--------+----------|
     | 8-bit  | i8     | u8       |
     | 16-bit | i16    | u16      |
     | 32-bit | i32    | u32      |
     | 64-bit | i64    | u64      |
     | arch   | isize  | usize    |

     - signed numbers range: -(2 ^ (n-1)) to (2 ^ (n-1)) - 1 inclusive.

     - unsigned variants can store numbers from 0 to 2^n - 1

     - ~isize~ and ~usize~ depend on the architectures:
       32-bit for 32-bit architecture;
       64-bit for 64-bit architecture.

     - All number literals _except the byte literal_ allow a /type suffix/, for
       example: ~57u8~
       =IMPORTANT=

     - ~_~ as a visual separator, such as ~1_000~. You can put the ~_~ anywhere
       in numbers.

     - Table 3-2: Integer Literals in Rust
       | Number literals | Example     |
       |-----------------+-------------|
       | Decimal         | 98\under222      |
       | Hex             | 0xff        |
       | Octal           | 0o77        |
       | Binary          | 0b1111\under0000 |
       | Byte(~u8~ only) | b'A'        |

     - If you don't know which type of integer to use, use the default ~i32~.
       It is generally the fastest, even on 64-bit systems.

     - The primary situation in which you'd use ~isize~ or ~usize~ is when
       indexing some sort of collection.
       =From Jian= This sounds like the ~size_t~ type in C.

**** DONE Floating-Point Types
     CLOSED: [2017-08-17 Thu 21:50]
     ~f32~ (IEEE-754 single-precision) and ~f64~ (IEEE-754 double-precision).
     The performance of ~f32~ is bettern in the 32bit systems.
     The performance of ~f64~ is bettern in the 64bit systems.
     #+BEGIN_SRC rust
       fn main() {
           let x = 2.0; // f64
           let y: f32 = 3.0; // f32
       }
     #+END_SRC

**** DONE Numeric Operations
     CLOSED: [2017-08-17 Thu 21:51]
     ~+~, ~-~, ~*~, ~/~, ~%~
     Read Appendix B.

**** DONE The Boolean Type
     CLOSED: [2017-08-17 Thu 21:53]
     Type name ~bool~. Its values: ~true~ and ~false~.

**** DONE The Character Type
     CLOSED: [2017-08-17 Thu 04:19]
     In Rust, ~char~ type values are Unicode Scalar Values.
     Range: from =U+0000= to =U+D7FF= and =U+E000= to =U+10FFFF= inclusive.

     However, a "character" is NOT really a concept in Unicode, so your human
     intuition for what a "charactr" is may NOT match up with what a ~char~ is in
     Rust.
     =TODO= Chapter 8

*** DONE Compound Types - 40
    CLOSED: [2017-08-17 Thu 03:57]
**** DONE The Tuple Type
     CLOSED: [2017-08-17 Thu 00:54]
    - ~let tup: (i32, f64, u8) = (500, 6.4, 1);~
      + Pattern matching is a good way to extract value(s) from a tuple.
        ~let (x, y, z) = tup;~

      + ~.~ syntax
        ~tup.0~ is ~(500 : i32)~.

**** DONE The Array Type
     CLOSED: [2017-08-17 Thu 03:57]
     Rust /arrays/ have a fixed length: once declared, they CANNOT grow or shrink
     in size.
     ~let a = [1, 2, 3, 4, 5];~

     - Arrays are useful
       + when you want your data allocated on the /stack/ _rather than_ the
         /heap/ (=TODO= we will discuss the /stack/ and the /heap/ more in
         Chapter 4),
         or
       + when you want to ensure you always have a fixed number of elements.

***** DONE Accessing Array Elements
      CLOSED: [2017-08-17 Thu 03:57]
      ~a[0]~
***** DONE Invalid Array Element Access
      CLOSED: [2017-08-17 Thu 03:57]
      - When this happens, compilation wouldn't produce any errors, but the
        program would result in a /runtime error/.

      - /panic/ :: a program exits with an error.

      - =TODO= Chapter 9 error handling.

** DONE Functions - 43
   CLOSED: [2017-08-17 Thu 22:30]
   /snake case/: all letters are lowercase and underscores separate words.

*** DONE Function Parameters - 44
    CLOSED: [2017-08-17 Thu 22:14]
    - Technically, the concrete values are called /arguments/.

    - In casual conversation people tend to use the words "parameter" and
      "argument" interchangeably.

    - Example:
      #+BEGIN_SRC rust
        // src/main.rs
        fn main() {
            another_function(5, 6);
        }

        fun another_function(x: i32, y: i32) {
            println!("The value of x is: {}", x);
            println!("The vlaue of y is: {}", y);
        }
      #+END_SRC

*** DONE Statements and Expressions in Function Bodies - 45
    CLOSED: [2017-08-17 Thu 22:29]
    - /statements/ :: instructions that perform some action and do not return a
                      value.

    - /expressions/ :: evaluate to a resulting value.

    - Calling a _function_ is an expression.

    - Calling a _macro_ is an expression.

    - The _block_ that we use to create new scopes, {}, is an expression.
      #+BEGIN_SRC rust
        let y = {
            let x = 3;
            x + 1
        };
      #+END_SRC

    - =IMPORTANT=
      Expressions do NOT include ending semicolons.
      If you add a semicolon to the end of an expression, you turn it into a
      statement, which _will then NOT return a value_.
*** DONE Functions with Return Values - 47
    CLOSED: [2017-08-17 Thu 22:29]
    - Anotate the return value type of a function:
      #+BEGIN_SRC rust
        fn plus_one(x: i32) -> i32 {
            x + 1
            // NO ;
        }

        fn main() {
            let x = plus_one(5);
            println!("The value of x is: {}", x);
        }
      #+END_SRC

** TODO Comments - 49
   ~//~
** DONE Control Flow - 49
   CLOSED: [2017-08-17 Thu 23:57]
*** DONE ~if~ Expressions - 49
    CLOSED: [2017-08-17 Thu 22:33]
    #+BEGIN_SRC rust
      if number < 5 {
          println!("condition was true");
      } else {
          println!("condition was false");
      }
    #+END_SRC

    The branches of a ~if ... else~ structure is also called /arms/.

**** DONE Handling Multiple Conditions with ~else if~
     CLOSED: [2017-08-17 Thu 22:34]
     In many cases, ~match~ is a better way.
     =TODO= CHAPTER 6
**** DONE Using ~if~ in a ~let~ statement
     CLOSED: [2017-08-17 Thu 22:35]

*** DONE Repetition with Loops - 54
    CLOSED: [2017-08-17 Thu 23:57]
**** DONE Repeating Code with ~loop~
     CLOSED: [2017-08-17 Thu 22:37]
     ~loop~ is like the ~while(true)~ in the C programming language.

**** DONE Conditional Loops with ~while~
     CLOSED: [2017-08-17 Thu 22:38]
     #+BEGIN_SRC rust
       while number != 0 {
           println!("{}!", number);
           number = number - 1;
       }
     #+END_SRC

**** DONE Looping Through a Collection with ~for~
     CLOSED: [2017-08-17 Thu 22:42]
     #+BEGIN_SRC rust
       fn main() {
           let a = [10, 20, 30, 40, 50];

           for element in a.iter() {
               println!("the value is: {}", element);
           }
       }
     #+END_SRC

     We prefer ~for~ to ~while~. We use ~for~ to iterate a collection of data,
     and no boundary check is needed.

     Use type ~Range~ values:
     #+BEGIN_SRC rust
       fn main() {
           for number in (1..4).rev() {
               println!("{}!", number);
           }
           println!("LIFTOFF!!!");
       }
     #+END_SRC

** DONE Summary - 57
   CLOSED: [2017-08-17 Thu 23:57]
* DONE 4. Understanding Ownership - 59
  CLOSED: [2017-08-19 Sat 00:31]
  /ownership/ is the most unique feature of Rust,
  and
  it enables Rust to make memory safety guarantees _without_ needing a garbage
  collector.

  This chapter will talk about several related features:
  - /borrowing/
  - /slice/
  - how Rust lays data out in memory.

** DONE What is Ownership? - 59
   CLOSED: [2017-08-18 Fri 01:15]
   - ~ownership~ is the central feature of Rust.

   - _Most languages_ can be group to _TWO_ categories if considering the ways
     they manage memory:
     + With garbage collector
     + Explicitly call _allocate_ and _deallocate (free)_ operations to manage
       the memory.

     However, Rust is different from these two categories -- it has its own
     approach to manage memory:
       Memory is managed through a system of /ownership/ with a set of rules that
     the compiler checks at compile time.
       _NO run-time costs_ are incurred for any of the ownership features.

       =From Jian= I think this can be considered as a semi-automatic approach,
     you need to annotate something to make the compiler know what to do, but you
     don't need to manually and explicitly use a _deallocation/free_ operation.

   - =TODO= This chapter we work through some examples to learn how /ownership/
     works. The examples focus on a very common data structure: _strings_.

   - *The Stack and the Heap*
     - In a systems programming language like Rust, whether a value is on the
       /stack/ or the /heap/ has _more of an effect on_

       + how the language behaves

       + why we have to make certain decision.

     - Here is a brief explanation in preparation
       (We'll describe parts of /ownership/ in relation to the /stack/ and the
        /heap/ _later_ in this chapter).

       + Both the /stack/ and the /heap/ are parts of memory that is available to
         your code _at runtime_.

       + /stack/ -- LIFO.
         /push on to/ and /pop off/

       + Use the dat in /stack/ is fast:
         * no need to search
         * fixed size

       + The process of get space from /heap/ is called /allocating on the heap/.

       + /pointers/ (rather than the data it points to, some of which can be
         fixed size but not all) are known and have fixed size. They can be
         stored on the /stack/.

       + Keeping track of what parts of code are using what data on the /heap/,
         _minimizing the amount of duplicate data_ on the /heap/,
         and /cleaning up/ unused data on the /heap/ so we don't run out of space
         are all problems that /ownership/ addresses.
         =IMPORTANT=

         Once you understand /ownership/, you won't need to think about the /stack/
         and the /heap/ very often, but knowing that managing /heap/ data is why
         /ownership/ exists can help explain why it works the way it does.

*** DONE Ownership Rules - 61
    CLOSED: [2017-08-18 Fri 01:17]
    1. _EACH_ value in Rust has a variable that's called its /owner/.
       (/owner/ is one variable)

    2. There can ONLY be ONE /owner/ at a time.

    3. When the /owner/ goes out of scope, the value will be dropped.

*** DONE Variable Scope - 61
    CLOSED: [2017-08-18 Fri 01:20]
    As in C/C++, the boundaries of a scope is marked with a pair of curly braces.
*** DONE The ~String~ Type - 62
    CLOSED: [2017-08-18 Fri 01:41]
    To illustrate the rules of /ownership/, we need data that stored on the
    /heap/. The data type we mentioned in Chapter 3 are all stored on the
    /stack/ (they will be popped off the /stack/ when their scope is over, NO
    need for /ownership/).

    - String literals are not enough.
      String literals are immutable, and they have known size (of course,
      "literal" indicates they are hard coded, and hard coded things are always
      of known sizes).

      What if we want _immutable_, and _unknow size_ space to store a sequence of
      characters? Then we need ~String~ variables.

    - WHY ~String~ CAN be mutated but literals CANNOT?
      #+BEGIN_SRC rust
        let mut s = String::from("hello");
        s.push_str(", world!");
        println!("{}", s);  // This will print "hello, world!"
      #+END_SRC

      _The difference is how these two types deal with memory._

*** DONE Memory and Allocation - 63
    CLOSED: [2017-08-18 Fri 03:41]
    - WHY /string literals/ are immutable?

      All the info about string literals are fixed, they are hardcoded directly
      into the final executable (saved in the /stack/), making string literals
      fast and efficient. These properties only come from its immutability.

    - For ~String~, we need /heap/:
      + /allocation/ :: The memory must be requested from the operating system at
                        runtime.

      + /deallocation/ :: We need a way of returning this memory to the operating
                          system when we're done with our ~String~.

    - /allocation/ is done when we call ~String::from~.
      This is pretty much universal in programming languages.

    - /deallocation/ is different.
      + Some languages use GC.

      + Without GC, it is usually hard
        * if we forget, we'll waste memory.
          =From Jian= ??? _memory leak_

        * if we do it too early, we'll have an invalid variable. =TODO= segFault???

        * if we do it twice (or more), that's a but too. This happens frequently.

    - We need to pair exactly one ~allocate~ with exactly one ~free~.

    - Rust does NOT use GC, but it also takes a different path from the tradition
      way of explicitly using /allocation/ and /deallocation/:
        the memory is automatically returned once the variable that owns it goes
      out of scope.

      Rust calls the special function ~drop~ automatically and implicitly at the
      closing ~}~.

    - Note: =TODO=
      In C++, this pattern of deallocating resources at the end of an item's
      lifetime is sometimes called /Resource Acquisition Is Initialization (RAII)/.

      The ~drop~ function in Rust will be familiar to you if you've used RAII
      patterns.

    - =IMPORTANT=
      The Rust way seems simple, but it can be unexpected in more complicated
      situations when we want to have multiple variables use the data we've
      allocated on the /heap/.

**** DONE Ways That Variables and Data Interact: /Move/
     CLOSED: [2017-08-18 Fri 03:25]
     #+BEGIN_SRC rust
       let s1 = String::from("hello");
       let s2 = s1;
     #+END_SRC

     - A ~String~ basic info is made up of three parts:
       + a pointer to the (/heap/) memory that holds the contents of the string,
       + a length
       + a capacity.

       This group of data is stored on the /stack/.

     - /length/ :: how much memory, in bytes, the contents of the ~String~ is
                   currently using.

     - /capacity/ :: the total amount of memory, in bytes, that the ~String~ has
                     received from the OS.

     - The _different_ between /length/ and /capacity/ matters,
       BUT _NOT in the context_, so for now, it's fine to ignore the /capacity/.

     - When we _assign_ ~s1~ to ~s2~, the ~String~ info data is copied, meaning
       we copy the /pointer/, the /length/, and the /capacity/ that are on the
       /stack/.

       We do _NOT_ copy the data on the /heap/ that the pointer refers to.

     - For the example above, if ~drop~ is naive, there will be a
       /double free error/, and it is one of the memory safety bugs.

     - Complie the code below
       #+BEGIN_SRC rust
         let s1 = String::from("hello");
         let s2 = s1;

         println!("{}", s1);
       #+END_SRC
       You'll get an error message that tells you the ~s1~ in the ~println!~ line
       is =value used here after move=.

     - /move/ :: when do operations like assignment,
       1. copy the meta info (in /stack/) of a variable,
          and
       2. invalidate the old one

       The 1. is just like the "shallow copy" concept as you know, BUT now we
       also have the step 2, that's why we have this new concept /move/.

     - In addition, there’s a design choice that’s implied by this:
       Rust will _NEVER automatically_ create “deep” copies of your data.

       Therefore, any automatic copying can be assumed to be _inexpensive_ in
       terms of runtime performance.

**** DONE Ways That Variables and Data Interact: /Clone/
     CLOSED: [2017-08-18 Fri 03:25]
     If you DO want to copy the heap data of the ~String~:
     #+BEGIN_SRC rust
       let s1 = String::from("hello");
       let s2 = s1.clone();

       println!("s1 = {}, s2 = {}", s1, s2);
     #+END_SRC

     This is called /clone/, which might be _expensive_.

**** DONE Stack-Only Data: /Copy/
     CLOSED: [2017-08-18 Fri 03:41]
     #+BEGIN_SRC rust
       let x = 5;
       let y = x;

       println!("x = {}, y = {}", x, y);
     #+END_SRC

     - No compile error, ~x~ is still valid in the ~println!~ line.

     - Values of types like integer are stored on /stack/.
       Copy a value in /stack/ is NOT expensive (even in the /move/ operation, we
       copy the data in /stack/ which is cheap, we just DID NOT copy the data in
       /heap/ which can be expensive).
       Thus, NO reason to prevent ~x~ from being valid after we create ~y~.

     - ~Copy~ trait:
       + If a type has the ~Copy~ trait, an older variable is still usable after
         assignment.

       + Rust WON'T let us annotate a type with the ~Copy~ trait if the type, or
         any of its parts, has implemented the ~Drop~ trait (The _exclusive_
         property between the ~Copy~ trait and the ~Drop~ trait).

       + If the type needs something special to happen when the value goes out of
         scope and we add the ~Copy~ annotation to that type, we'll get a
         compile time error.

         =TODO= see Appendix C on Derivable Traits to learn about how to add the
         ~Copy~ annotation to your type.

     - Examples of the types that are ~Copy~:
       + All integer types
       + The boolean type
       + All floating point types
       + Tuples, but ONLY if they contain types that are also ~Copy~:
         Values of type ~(i32, i32)~ are ~Copy~.
         Values of type ~(i32, String)~ are _NOT_.

*** DONE Ownership and Functions - 68
    CLOSED: [2017-08-18 Fri 03:44]
    The semantics for passing a value to a function are similar to assigning a
    value to a variable -- /move/ or /copy/.

*** DONE Return Values and Scope - 68
    CLOSED: [2017-08-18 Fri 03:52]
    Returning values can also transfer ownership.

    - ~drop~ won't touch variables whose values have been /moved/.
      This is about the "content" of this variable, which is in the /heap/.

      For the meta data of this variable in /stack/, no need to pay attention,
      no matter this is a mechanism of GC or NOT, /stack/ will pop and push as
      the program run, and the programmer should almost always never touch it
      manually.

    - If we pass the value of a variable into a function and we still want to use
      this value after this call, we can return this value back:
      #+BEGIN_SRC rust
        fn main() {
            let s1 = String::from("hello");

            let (s2, len) = calculate_length(s1);

            println!("The length of '{}' is {}.", s2, len);
        }

        fn calculate_length(s: String) -> (String, usize) {
            let length = s.len(); // len() returns the length of a String.

            (s, length)
        }
      #+END_SRC

      However, this is tedious. Luckily for us, Rust has a feature called
      /references/.

** DONE References & Borrowing - 70
   CLOSED: [2017-08-18 Fri 18:23]
   The last example of the last section, with the help of /reference/:
   #+BEGIN_SRC rust
     fn main() {
         let s1 = String::from("hello");
         let len = calculate_length(&s1);
         println!("The length of '{}' is {}.", s1, len);
     }

     fn calculate_length(s: &String) -> usize {
         s.len()
     }
   #+END_SRC

   - These _ampersands_ above are /references/.

   - A /reference/ is essentially a pointer points to the basic info data (a
     pointer, string length, and its capacity) of ~s1~.

   - The name /reference/ indicates _NOT OWN_. NO ~drop~ will be applied to the
     data it refers to when ~s~ goes out of scope.
       On the other hand, since pointers are on /stack/, they will be poped out
     automatically.

   - We call having references as function parameters /borrowing/ -- when it's
     done, give it back.

   - If you try to modify the borrowed value, the compiler will issue an error
     =error: cannot borrow immutable borrowed content `*some_string` as mutable=
     Just as variables are immutable by default, so are references.

*** DONE Mutable References - 72
    CLOSED: [2017-08-18 Fri 04:29]
    #+BEGIN_SRC rust
      fn main() {
          let mut s = String::from("hello");
          change(&mut s);
      }

      fn change(some_string: &mut String) {
          some_string.push_str(", world");
      }
    #+END_SRC

    =IMPORATN=
    ONE big _restriction_ to /mutable references/:
    you can only have _one_ /mutable reference/ to a particular piece of data
    _in a particular scope_.

    - Example of fail (CANNOT be compiled):
      =error[E0499]: cannot borrow `s` as mutable more than once at a time=
      #+BEGIN_SRC rust
        let mut s = String::from("hello");

        let r1 = &mut s;
        let r2 = &mut s;
      #+END_SRC

    - This restriction allows for mutation but _in a very controlled fashion_.
      + pros: Rust can prevent data races at compile time.
      + cons: new Rustaceans struggle with this restriction -- NOT a real cons

    - A /data race/ is a particular type of race condition in which these three
      behaviors occur:
      1. Two or more pointers access the same data at the same time.
      2. At least one of the pointers is being used to write to the data.
      3. There's no mechanism being used to synchronize access to the data.

    - Data races cause undefined behavior and can be difficult to diagnose and
      fix when you're trying to track them down at runtime;

      Rust prevents this problem from happening because it won't even compile
      code with data races!

    - As always, we can use curly brackets to create a new scope, allowing for
      multiple mutable references, just NOT simultaneous ones:
      #+BEGIN_SRC rust
        let mut s = String::from("hello");

        {
            let r1 = &mut s;
        } // r1 goes out of scope here, so we can make a new reference with no problems.

        let r2 = &mut s;
      #+END_SRC

    - A similar rule exists for combining mutable and immutable references.
      #+BEGIN_SRC rust
        let mut s = String::from("hello");

        let r1 = &s;  // NO problem
        let r2 = &s;  // NO problem
        let r3 = &mut s;  // BIG PROBLEM
      #+END_SRC
      With compile the error:
      =error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable=

    - _A_ /mutable reference/ is EXCLUSIVE with the other /references/ (both
      mutable or immutable).

      Any /immutable reference/ are compatible with the other
      /immutable references/.

      This is reasonable. Users of an _immutable references_ don't expect the
      value to suddenly change out from under them.

      On the other hand, ONLY multiple /immutable references/ have NO problem.

*** DONE Dangling References - 74
    CLOSED: [2017-08-25 Fri 01:09]
    - /a dangling pointer/ :: a pointer that references a location in memory that
         may have been given to someone else, by freeing some memory while
         preserving a pointer to that memory.

    - Rust compiler guarantees that references will _NEVER_ be /dangling
      references/: if we have a reference to some data, the compiler will ensure
      that the data will not go out of scope before the reference to the data
      does.

    - Example of trying to create a /dangling reference/ (but fail when compile):
      #+BEGIN_SRC rust
        fn main() {
            let references_to_nothing = dangle();
        }

        fn dangle() -> &String {
            let s = String::from("hello");
            &s
        }
      #+END_SRC

      The error message:
      #+BEGIN_SRC text
        error[E0106]: missing lifetime specifier
         --> dangle.rs:5:16
          |
        5 | fn dangle() -> &String {
          |                ^^^^^^^
          |
          = help: this function's return type contains a borrowed value, but there is no
            value for it to be borrowed from
          = help: consider giving it a 'static lifetime

        error: aborting due to previous error
      #+END_SRC

      + This error message refers to a feature /lifetimes/ which will be covered
        in Chapter 10.
        =TODO=
        Just disregard this, and read the =help= part, we can know what happened.

      + The way to correct this error:
        #+BEGIN_SRC rust
          fn no_dangle() -> String {
              let s = String::from("hello");
              s
          }
        #+END_SRC

*** DONE The Rules of References - 75
    CLOSED: [2017-08-18 Fri 03:54]
    1. At any given time, you can have either but NOT both of:
       + One mutable /reference/.
       + Any number of immutable /references/.

    2. /References/ must always be valid.

    Next, we'll look at a different kind of /reference/: /slices/.
** DONE The Slice Type - 75
   CLOSED: [2017-08-19 Sat 00:31]
   - Another data type that does _NOT_ have ownership is the /slice/.

   - /slices/ let you reference a contiguous sequence of elements in a collection
     rather than the whole collection.

   - Write a small program to get the first word of a string.
     Since we don't want the ownership of the string, we pass a reference.

     What should we return?
     Since we don't really have a way to talk about part of a string, we choose
     to return the index of the end of the word.

     #+BEGIN_SRC rust
       fn first_word(s: &String) -> usize {
           let bytes = a.as_bytes();

           for (i, &item) in bytes.itre().enumerate() {
               if item == b' ' {
                   return i;
               }
           }

           s.len()
       }
     #+END_SRC

     There is a potential bug: the returned value can be available even the
     refered string is no longer there (for a mutable string).
     #+BEGIN_SRC rust
       fn main() {
           let mut s = String::from("hello world");
           let word = first_word(&s);
           s.clear();

           // operate `s` with `word` can lead to a crash.
       }
     #+END_SRC

*** DONE String Slices - 77
    CLOSED: [2017-08-19 Sat 00:31]
    #+BEGIN_SRC rust
      let s = String::from("hello world");
      let hello = &s[0..5];
      let hello_ = &s[..5]; // for short
      let world = &s[6..11];
      let world_ = &s[6..]; // for short
    #+END_SRC

    - Then, let's re-write the ~first_word~ function ("string slice" is written
      as ~&str~):
      #+BEGIN_SRC rust
        fn first_word(s: &String) -> &str {
            let bytes = a.as_bytes();

            for (i, &item) in bytes.itre().enumerate() {
                if item == b' ' {
                    return &s[0..i];
                }
            }

            &s[..]
        }
      #+END_SRC

    - With the help of /slice/, invalid code cannot be compiled:
      #+BEGIN_SRC rust
        fn main() {
            let mut s = String::from("hello world");
            let word = first_word(&s);
            s.clear(); // ERROR!
        }
      #+END_SRC

      + The error message is:
        #+BEGIN_SRC text
          17:6 error: cannot borrow `s` as mutable because it is also borrowed as
                      immutable [E0502]
              s.clear(); // Error!
              ^
          15:29 note: previous borrow of `s` occurs here; the immutable borrow prevents
                      subsequent moves or mutable borrows of `s` until the borrow ends
              let word = first_word(&s);
                                     ^
          18:2 note: previous borrow ends here
          fn main() {

          }
          ^
        #+END_SRC

      + Explanation to the error message:
        ~clear~ needs to truncate the ~String~, it tries to take a /mutable
        reference/, which fails due to the rule that if we have an /immutable
        reference/ to a variable, we _CANNOT_ also take a /mutable reference/.

**** DONE String Literals Are Slices
     CLOSED: [2017-08-19 Sat 00:19]
     Recall that we talked about /string literals/ being stored inside the
     binary. Now that we know about /slices/, we can properly understand /string
     literals/: ~let s = "Hello, world!";~
     The type of s here is ~&str~:
     it's a slice pointing to that specific point of the binary. This is also why
     string literals are immutable; ~&str~ is an ~immutable reference~.

**** DONE String Slices as Parameters
     CLOSED: [2017-08-19 Sat 00:27]
     One move improvement on ~first_word~:
     change its type signature to ~fn first_word(s: &str) -> &str {~

     This change makes our API more general and useful without losing any
     functionality:
     #+BEGIN_SRC rust
       fn main() {
           let my_string = String::from("hello world");

           // first_word works on slices of `String`s
           let word_1 = first_word(&my_string[..]);

           let my_string_literal = "hello world";

           // first_word works on slices of string literals
           let word_2 = first_word(&my_string_literal[..]);

           // since string literals *are* string slices already,
           // this works too, without the slice syntax!
           let word_3 = first_word(my_string_literal);
       }
     #+END_SRC
**** DONE Other Slices
     CLOSED: [2017-08-19 Sat 00:29]
     For example,
     #+BEGIN_SRC rust
       let a = [1, 2, 3, 4, 5];
       let slice = &a[1..3];
     #+END_SRC

     Here the type of ~slice~ is ~&[i32]~.

     =TODO= Chapter 8

*** DONE Other Slices - 81

** DONE Summary - 81
   CLOSED: [2017-08-19 Sat 00:30]

* DONE 5. Using Structs to Structure Related Data - 83
  CLOSED: [2017-08-19 Sat 23:48]
  - ~struct~ :: a custom data type that lets us name and package together
                multiple related values that make up a meaningful group.

  - If you're familiar with an object-oriented language, a /struct/ is like an
    object's data attributes.

  - In this chapter, we'll
    + compare and contrast /tuples/ with /structs/, demonstrate how to use /structs/,

    + discuss how to define /methods/ and /associated functions on structs/ to
      specify behavior associated with a struct's data.

  - The /struct/ and /enum/ (which is discussed in Chapter 6) concepts are the
    building blocks for creasing new types in your program's domain to take full
    advantage of Rust's compile time type checking.

** DONE Defining and Instantiating Structs - 83
   CLOSED: [2017-08-19 Sat 04:55]
   #+BEGIN_SRC rust
     struct User {
         username: String,
         email: String,
         sign_in_count: u64,
         active: bool,
     }
   #+END_SRC

   - Create an /instance/ of a /struct/ by specifying concrete values for each of
     the fields. The order of fields is not important.
     #+BEGIN_SRC rust
       let user1 = User {
           email: String::from("someone@example.com"),
           username: String::from("someusername123"),
           active: true,
           sign_in_count: 1,
       };
     #+END_SRC

   - Dot notation:
     + get the value of a field:
       ~user1.email~

     + if the field is mutable:
       ~user1.email = String::from("someone-else@example.com");~

*** DONE Using the Field Init Shorthand when Variables and Fields Have the Same Name - 85
    CLOSED: [2017-08-19 Sat 04:32]
    If some variables have the same names as struct fields, we can do
    /field init shorthand/
    #+BEGIN_SRC rust
      fn build_user(email: String, username: String) -> User {
          User {
              email,
              username,
              active: true,
              sign_in_count: 1,
          }
      }
    #+END_SRC

*** DONE Creating Instances from Other Instances With Struct Update Syntax - 86
    CLOSED: [2017-08-19 Sat 04:32]
    #+BEGIN_SRC rust
      // Suppose `user1` is in scope, and
      // the `active` field and `sign_in_count` of `user2` are the same as `user1`
      let user2 = User {
          email: String::from("another@example.com"),
          username: String::from("anotherusername567"),
          ..user1
      };
    #+END_SRC
*** DONE Using Tuple Structs Without Named Fields to Create Different Types - 86
    CLOSED: [2017-08-19 Sat 04:38]
    /tuple struct/
    #+BEGIN_SRC rust
      struct Color(i32, i32, i32);
      struct Point(i32, i32, i32);

      // The types in the definitions of `Color` and `Point` are the same,
      // but we can use the *name* to differentiate them.
      let black = Color(0, 0, 0);
      let origin = Point(0, 0, 0);
    #+END_SRC

*** DONE Unit-Like Structs Without Any Fields - 87
    CLOSED: [2017-08-19 Sat 04:55]
    - /unit-like struct/
      + it behave similarly to ~()~, the unit type.

      + it is useful in situations such as when you need to implement a trait on
        some type, but you don't have any data you want to store in the type
        itself. =TODO= CHAPTER 10

    - *Ownership of Struct Data*
      + in the examples above, when we define a /struct/, for its field, we
        chose ~String~ rather than ~&str~. This means for the cases here, we want
        instances of this /struct/ to own all of its data and for that data to
        be valid for as long as the entire struct is valid.

      + if we use reference type for a field, we need to specify /lifetime/.
        =TODO= CHAPTER 10.
        For now, we just not use reference.

** DONE An Example Program Using Structs - 88
   CLOSED: [2017-08-19 Sat 06:24]
   The evalution of a example (finally) with a ~struct~
   #+BEGIN_SRC rust
     // Ver 1
     fn main() {
         let length1 = 50;
         let width1 = 30;

         println!(
             "The area of the rectangle is {} square pixels.",
             area(length1, width1)
         );
     }

     fn area(length: u32, width: u32) -> u32 {
         length * width
     }
   #+END_SRC

*** DONE Refactoring with Tuples - 89
    CLOSED: [2017-08-19 Sat 05:56]
    #+BEGIN_SRC rust
      fn main() {
          let rect1 = (50, 30);

          println!(
              "The area of the rectangle is {} square pixels.",
              area(rect1)
          );
      }

      fn area(dimensions: (u32, u32)) -> u32 {
          dimensions.0 * dimensions.1
      }
    #+END_SRC

*** DONE Refactoring with Structs: Adding More Meaning - 89
    CLOSED: [2017-08-19 Sat 05:59]
    #+BEGIN_SRC rust
      struct Rectangle {
          length: u32,
          width: u32,
      }

      fn main() {
          let rect1 = Rectangle { length: 50, width: 30 };

          println!(
              "The area of the rectangle is {} square pixels.",
              area(&rect1)
          );
      }

      fn area(rectangle: &Rectangle) -> u32 {
          rectangle.length * rectangle.width
      }
    #+END_SRC

*** TODO Adding Useful Functionality with Derived Traits - 90
    If we try to print the struct we defined with
    ~println!("rect1 is {}", rect1);~
    , we will receive an error message:
    =error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied=

    Read the message below the last line, we can get some hints:
    =note: `Rectangle` cannot be formatted with the default formatter; try using=
    =`:?` instead if you are using a format string=

    Then try ~println!("rect1 is {:?}", rect1);~
    This output format is called ~Debug~. ~Debug~ is a trait that enables us to
    print out our struct in a way that is useful for developers so we can see its
    value while we're debugging our code.

    We see =error: the trait bound `Rectangle: std::fmt::Debug` is not satisfied=
    But we also see
    =note: `Rectangle` cannot be formatted using `:?`; if it is defined in your=
    =crate, add `#[derive(Debug)]` or manually implement it=

    #+BEGIN_SRC rust
      #[derive(Debug)]

      struct Rectangle {
          length: u32,
          width: u32,
      }

      fn main() {
          let rect1 = Rectangle { length: 50, width: 30 };

          println!("rect1 is {:?}", rect1);
      }
    #+END_SRC

    The output is =rect1 is Rectangle { length: 50, width: 30 }=
    Use ~{:#?}~ instead of ~{:?}~, we can a different style of print:
    #+BEGIN_SRC text
      rect1 is Rectangle {
          length: 50,
          width: 30
      }
    #+END_SRC

** DONE Method Syntax - 92
   CLOSED: [2017-08-19 Sat 23:48]
   /methods/ are different from /functions/ in that they're defined within the
   context of
   + a struct
   + an enum =TODO= Chapter 6
   + a trait object =TODO= Chapter 17

   Their first parameter is always ~self~, which represents the instance of the
   /struct/ the method is being called on.

*** TODO Defining Methods - 92
    =RE-READ=
    Re-write the example in the last section, make ~area~ a method of the
    ~Rectangle~ struct.
    #+BEGIN_SRC rust
      #[derive(Debug)]
      struct Rectangle {
          length: u32,
          width: u32,
      }

      impl Rectangle {
          fn area(&self) -> u32 {
              self.length * self.width
          }
      }

      fn main() {
          let rect1 = Rectangle { length: 50, width: 30 };

          println!(
              "The area of the rectangle is {} square pixels.",
              rect1.area()
          );
      }
    #+END_SRC

    - ~impl~ block.

    - Methods can, just like any other parameter,
      + take ownership of ~self~,
      + borrow ~self~ immutably as we've done here,
      + borrow ~self~ mutably.

    - Having a method that takes ownership of the instance by using just self as
      the first parameter is _RARE_;
      this technique is usually used when the method transforms ~self~ into
      something else and we want to prevent the caller from using the original
      instance after the transformation.
      =TODO= you can imagine -- it's rare to call a method and then the passed in
      object is no longer valid. Of course, this method can return a new object
      and disable the old one (=FROM Jian= a functional way, but I doubt if this
      is often used in Rust).

    - *Where's the -> Operator?* =TODO=
      + In C++, if ~object~ is a pointer, there are two ways to call a method:
        - ~object->something()~
        - ~(*object).something()~

      + Rust does NOT have an equivalent to the ~->~ operator;
        Rust has a feature called /automatic referencing and dereferencing/.
        Calling methods is one of the few places in Rust that has this behavior.

        =TODO= BAD example ...
        This means the usually method call form is ~object.something()~.
          Rust automatically adds in ~&~, ~&mut~, or ~*~ so ~object~ matches the
        signatue of the method. In other words, the following are the same:
        * ~p1.distance(&p2);~
        * ~(&p1).distance(&p2);~

      + The first one looks much cleaner.
        This automatic referencing behavior works because methods have a clear
        receiver -- the type of ~self~. Given the receiver and name of a method,
        Rust can figure out definitively whether the method is reading
        (~&self~), mutating (~&mut self~), or consuming (~self~). The fact that
        Rust makes borrowing implicit for method receivers is a big part of
        making ownership ergonomic in practice.

*** DONE Methods with More Parameters - 94
    CLOSED: [2017-08-19 Sat 23:19]
    #+BEGIN_SRC rust
      impl Rectangle {
          fn area(&self) -> u32 {
              self.length * self.width
          }

          fn can_hold() -> bool {
              self.length > other.length && self.width > other.width
          }
      }

      fn main() {
          let rect1 = Rectangle { length: 50, width: 30 };
          let rect2 = Rectangle { length: 40, width: 10 };
          let rect3 = Rectangle { length: 45, width: 60 };

          println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));  // true
          println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));  // false
      }
    #+END_SRC
*** DONE Associated Functions - 95
    CLOSED: [2017-08-19 Sat 23:46]
    - /associated functions/: functions that don't take ~self~ as the first
      parameter.

    - I think this is the /static methods/ in the other OOP languages.

    - Example:
      #+BEGIN_SRC rust
        impl Rectangle {
            fn square(size: u32) -> Rectangle {
                Rectangle { length: size, width: size }
            }
        }
      #+END_SRC

      Call /associated functions/ with the syntax like ~Rectangle::square(3);~

    - The ~::~ syntax is used for both associated functions and namespaces crated
      by modules.
      =From Jian=
        From the point of view of semantics, ~Rectangle~ is essentially a
      namespace for ~square~.

*** TODO Multiple ~impl~ Blocks - 96

** DONE Summary - 96
   CLOSED: [2017-08-19 Sat 23:48]
   - Structs ... =TODO=

   - Structs are NOT the only way we can create custom types: let's turn to
     Rust's _enum_ feature to add another tool to our toolbox.

* DONE 6. Enums and Pattern Matching - 97
  CLOSED: [2017-08-20 Sun 04:56]
  - /enums/ :: define a type by enumerating its possible values.
** DONE Defining an Enum - 98
   CLOSED: [2017-08-20 Sun 04:24]
   For example, define a data type that can be used to anotate all IP v4 and
   IP v6 addresses.
   #+BEGIN_SRC rust
     enum IpAddrKind {
         V4,
         V6,
     }
   #+END_SRC

*** DONE Enum Values - 98
    CLOSED: [2017-08-20 Sun 03:41]
    - The above example is too simple! It only show the type and NO address info,
      which is not very useful. We can combine it with a /struct/:
      #+BEGIN_SRC rust
        // The definition of `IpAddrKind` is in scope

        struct IpAddr {
            kind: IpAddrKind,
            address: String,
        }

        let home = IpAddr {
            kind: IpAddrKind::V4,
            address: String::from("127.0.0.1"),
        };

        let loopback = IpAddr {
            kind: IpAddrKind::V6,
            address: String::from("::1"),
        };
      #+END_SRC

    - Usually we don't use /enums/ in the way above.
      Here is a concise and practical way to use /enums/ only (with its usages):
      #+BEGIN_SRC rust
        enum IpAddr {
            V4(String),
            V6(String),
        }

        let home = IpAddr::V4(String::from("127.0.0.1"));
        let loopback = IpAddr::V6(String::from("::1"));
      #+END_SRC

      + This better than the way of composing ~enum~ and ~struct~ together:
        * more concise
        * No limitations about the address info
          #+BEGIN_SRC rust
            // We can do
            enum IpAddr {
                V4(u8, u8, u8, u8),
                V6(String),
            }
            let home = IpAddr::V4(127, 0, 0, 1);
            let loopback = IpAddr::V6(String::from("::1"));

            // BUT we CANNOT specify two types of data for the `address` field of structs in
            // a concise way.
          #+END_SRC

      + The standard library ~std::new~ has a /enum/ ~IpAddr~, its definition is:
        #+BEGIN_SRC rust
          struct Ipv4Addr {
              // details elided
          }

          struct Ipv4Addr {
              // details elided
          }

          enum IpAddr {
              V4(Ipv4Addr),
              V6(Ipv6Addr),
          }
        #+END_SRC

    - Another example:
      #+BEGIN_SRC rust
        // Use `enum`, all variants have the same type.
        // Write a function with this type of parameter(s) is simple.
        enum Message {
            Quit,
            Move { x: i32, y: i32 },
            Write(String),
            ChangeColor(i32, i32, i32),
        }

        // Use `struct`'s. Four types.
        // To Write a function for all of these types, we need polymorphism.
        struct QuitMessage; // unit struct
        struct MoveMessage {
            x: i32,
            y: i32,
        }
        struct WriteMessage(String); // tuple struct
        struct ChangeColorMessage(i32, i32, i32); // tuple struct
      #+END_SRC

*** DONE The ~Option~ Enum and Its Advantages Over Null Values - 101
    CLOSED: [2017-08-20 Sun 04:23]
    #+BEGIN_SRC rust
      // Defined in the standard library (the prelude).
      // NO `Option::` prefix required.
      enum Option<T> {
          Some(T),
          None,
      }
    #+END_SRC

    - The ~<T>~ part, generics, =TODO= Chapter 10

    - If we use ~None~ rahter than ~Some~, we need to tell Rust what type of
      ~Option<T>~ we have, because the compiler _CANNOT_ infer the type that the
      type that the ~Some~ variant will hold by looking only at a ~None~ value.

** DONE The ~match~ Control Flow Operator - 104
   CLOSED: [2017-08-20 Sun 04:56]
   =TODO= Chapter 18 will cover all the different kinds of patterns and what they do.

   - Example:
     #+BEGIN_SRC rust
       enum Coin {
           Penny,
           Nickel,
           Dime,
           Quarter,
       }

       fn value_in_cents(coin: Coin) -> i32 {
           match coin {
               Coin::Penny => 1,
               Coin::Nickel => 5,
               Coin::Dime => 10,
               Coin::Quarter => 25,
           }
       }
     #+END_SRC
     Curly braces is only used when you want multiple lines in a match arm.

*** DONE Patterns That Bind to Values - 106
    CLOSED: [2017-08-20 Sun 04:44]
    #+BEGIN_SRC rust
      #[derive(Debug)] // So we can inspect the state in a minute

      enum UsState {
          Alabama,
          Alaska,
          // ... etc
      }

      enum Coin {
          Penny,
          Nickel,
          Dime,
          Quarter(UsState),
      }

      fn value_in_cents(coin: Coin) -> i32 {
          match coin {
              Coin::Penny => 1,
              Coin::Nickel => 5,
              Coin::Dime => 10,
              Coin::Quarter(state) => {
                  println!("State quarter from {:?}!", state);
                  25
              },
          }
      }
    #+END_SRC

*** DONE Matching with ~Option<T>~ - 107
    CLOSED: [2017-08-20 Sun 04:46]
    =From Jian= In other languages, pattern match is usually NOT the best (the
    most concise) way to process ~Option<T>~ type values.
    How about Rust????? =TODO=

    #+BEGIN_SRC rust
      fn plus_one(x: Option<i32>) -> Option<i32> {
          match x {
              None => None,
              Some(i) => Some(i + 1),
          }
      }

      let five = Some(5);
      let six = plus_one(five);
      let none = plus_one(None);
    #+END_SRC

*** DONE Matches Are Exhaustive - 108
    CLOSED: [2017-08-20 Sun 04:53]
    Rust Compiler has /exhaustive check/ for pattern matching.
    Non-exhaustive result in an error, rather than warning as in other languages.
    #+BEGIN_SRC rust
      fn plus_one(x: Option<i32>) -> Option<i32> {
          match x {
              Some(i) => Some(i + 1),
          }
      }

      // error[E0004]: non-exhaustive patterns: `None` not covered.
      //  -->
      //   |
      // 6 |         match x {
      //   |               ^ pattern `None` not covered
    #+END_SRC

*** DONE The ~_~ Placeholder - 108
    CLOSED: [2017-08-20 Sun 04:56]
    ~_~ is a pattern that can match any value, and it always shows up as the last
    pattern (or other patterns can never be matched).

** DONE Concise Control Flow with ~if let~ - 109
   CLOSED: [2017-08-20 Sun 04:38]
   The ~if let~ syntax lets you combine ~if~ and ~let~ into a less verbose way to
   handle values that match one pattern and ignore the rest.
   #+BEGIN_SRC rust
     let some_u8_value = Some(0u8);
     match some_u8_value {
         Some(3) => println!("three"),
         _ => (),
     }

     // With `if let`
     if let Some(3) = some_u8_value {
         println!("three");
     }
   #+END_SRC
   + With ~if let~ we lose exhaustive checking, but more concise.
     Choose ~if let~ or ~match~ is a trade-off.

   + ~if let~ can have an ~else~ branch.
     #+BEGIN_SRC rust
       let mut count = 0;
       match coin {
           Coin::Quarter(state) => println!("State quarter from {:?}!", state),
           _ => count += 1,
       }
     #+END_SRC

     Or use ~if let~ and ~else~

     #+BEGIN_SRC rust
       let mut count = 0;
       if let Coin::Quarter(state) = coin {
           println!("State quarter from {:?}!", state);
       } else {
           count += 1;
       }
     #+END_SRC

** DONE Summary - 110
   CLOSED: [2017-08-20 Sun 04:38]

* DONE 7. Managing Growing Projects with Packages, Crates, and Modules - 111
  CLOSED: [2017-08-21 Mon 22:41]
  =Old-Title=: _Using Modules to Reuse and Orgnize Code_

  - A /module/ :: a /namespace/ that contains definitions of functions or types,
                  and you can choose whether those definitions are visible
                  outside their module (public) or not (private).

  - An overview of how modules work:
    + The ~mod~ keyword declares a new module.
      Code within the module appears
      + either immediately following this declaration within curly braces
        or
      + in another file. =TODO= =???=

    + _By default_, functions, types, constants, and modules are _private_. The
      ~pub~ keyword makes an item public and therefore visible outside its
      namespace.

    + The ~use~ keyword brings modules, or the definitions inside modules, into
      scope so it's easier to refer to them.

** Packages and Crates - 112
** Defining Modules to Control Scope and Privacy - 113
** Paths for Referring to an Item in the Module Tree - 115
*** Exposing Paths with the ~pub~ Keyword - 117
*** Starting Relative Paths with ~super~ - 119
*** Making Structs and Enums Public - 120

** Bringing Paths into Scope with the ~use~ Keyword - 121
*** Creating Idiomatic ~use~ Paths - 123
*** Providing New Names with the ~as~ Keyword - 124
*** Re-exporting Names with ~pub use~ - 124
*** Using External Packages - 125
*** Using Nested Paths to Clean Up Large ~use~ Lists - 126
*** The Glob Operator - 127

** Separating Modules into Different Files - 127
** Summary - 128

* TODO 8. Common Collections - 131
** DONE Storing Lists of Values with Vectors - 132
   CLOSED: [2017-08-20 Sun 05:26]
   - /vector/ :: ~Vec<T>~.

   - /Vectors/ allow us to store more than one value in a single data structure
     that puts _all the values next to each other in memory_.

   - Vectors can _ONLY_ store values of the _same type_.
     /homogeneous/

   - They are useful in situations where you have a list of items,

*** DONE Creating a New Vector - 132
    CLOSED: [2017-08-20 Sun 05:03]
    - Create an empty /vector/: ~let v: Vec<i32> = Vec::new();~
      The type annotation is required.

    - Use macro ~vec!~ to create a /vector/ with initial values:
      ~let v = vec![1, 2, 3];~

*** DONE Updating a Vector - 132
    CLOSED: [2017-08-20 Sun 05:05]
    #+BEGIN_SRC rust
      let mut v = Vec::new();

      v.push(5);
      v.push(6);
      // Rust can infer that the type of `v` is `Vec<i32>`
    #+END_SRC

    The ~mut~ is for the inside of this vector.
    (=From Jian= The book doesn't mention if this ~mut~ is for the ~v~ itself.
     However, since Rust has /shadow/ feature, I'm pretty sure that ~mut~ is NOT
     for ~v~ itself)

*** DONE Dropping a Vector Drops its Elements - 133
    CLOSED: [2017-08-20 Sun 05:09]
    #+BEGIN_SRC rust
      {
          let v = vec![1, 2, 3, 4];

          // do stuff with `v`

      }  // <- `v` goes out of scope and is freed here
    #+END_SRC
    =TODO=
    This may seem like a straightforward point, but can get a little more
    complicated once we start to introduce references to the elements of the
    vector. Let’s tackle that next!

*** DONE Reading Elements of Vectors - 133
    CLOSED: [2017-08-20 Sun 05:19]
    #+BEGIN_SRC rust
      let v = vec![1, 2, 3, 4, 5];

      let third: &i32 = &v[2];
      let third_opt: Option<&i32> = v.get(2);
    #+END_SRC
*** TODO Iterating over the Values in a Vector - 135
*** TODO Using an Enum to Store Multiple Types - 136

** TODO Storing UTF-8 Encoded Text with Strings - 137
   Strings are an area that new Rustaceans commonly get stuck on.
   This is due to a combination of three things:  =???= =TODO=
   + Rust's propensity for making sure to expose possible errors,
   + strings being a more complicated data structure than many programmers give
     them credit for, and
   + UTF-8

*** DONE What Is a String? - 137
    CLOSED: [2017-08-22 Tue 00:01]
   Rust _actually_ only has one string type in the core language itself: ~str~,
   the /string slice/, which is usually seen in its borrowed form, ~&str~.

   - ~String~ is provided in the standard library of Rust, rather than coded into
     the core language, and is a _growable_, _mutable_, _owned_, _UTF-8 encoded_
     string type.

   - When Rustaceans talk about "strings", they usually mean both the ~String~
     and the string slice ~&str~ types.

   - Both ~String~ and /string slices/ are UTF-8 encoded.

   - =TODO= Read the API doc to get more details about the other string types,
     + standard library: ~0sString~, ~0sStr~, ~CString~, and ~CStr~.

     + library crates: ....

     + Similar to the ~*String~ / ~*Str~ naming =TODO=, =???=, they often provide
       an owned and borrowed variant, just like ~String~ / ~&str~.

*** DONE Creating a New String - 137
    CLOSED: [2017-08-22 Tue 00:01]
    - ~let mut s = String::new();~

    - string literal to ~String~.
      ~let s = "initial contents".to_string();~
      ~let s = String::from("initial contents")~

*** DONE Updating a String - 138
    CLOSED: [2017-08-22 Tue 00:26]
**** TODO Appending to a String with ~push_str~ and ~push~ - 139
     #+BEGIN_SRC rust
       let mut s = String::from("foo");
       s.push_str("bar");

       let mut s1 = String::from("foo");
       let s2 = String::from("bar");
       s1.push_str(&s2);
       // s2 is still valid

       let mut s3 = String::from("lo");
       s.push('l');
     #+END_SRC

**** DONE Concatenation with the ~+~ Operator or the ~format!~ Macro - 139
     CLOSED: [2017-08-22 Tue 00:26]
     #+BEGIN_SRC rust
       let s1 = String::from("Hello, ");
       let s2 = String::from("world!");
       let s3 = s1 + &s2; // Note that s1 has been moved here and can no longer be used.
       // this is due to what doese `+` do under the hood
       // `fn add(self, s: &str) -> String`.
     #+END_SRC

     - The ~&s2~ is ~&String~, and the ~add~ method requires ~&str~.
       Q: What happened makes this right?
       A: A ~&String~ argument can be /coerced/ into a ~&str~ - when the ~add~
          function is called, Rust uses /deref coercion/.

     - /deref coercion/: you could think of _here_ as turning ~&s2~ into ~s2[..]~
       for use in the ~add~ function.
       =TODO= chapter 15

     - Concatenate multiple strings:
       ~let s = format!("{}-{}-{}", s1, s2, s3);~
       This doesn't take ownership of any of its parameters.

*** TODO Indexing into Strings - 141
    Try the indexing operation (as in other languages).
    You'll get an error message:
    #+BEGIN_SRC text
      error: the trait bound `std::string::String: std::ops::Index<_>` is not
      satisfied [--explain E0277]
        |>
        |>     let h = s1[0];
        |>             ^^^^^
      note: the type `std::string::String` cannot be indexed by `_`
    #+END_SRC

    This indicate that Rust strings do NOT support indexing.

    WHY?
    In order to answer that, we have to talk a bit about how Rust stores strings
    in memory.

**** DONE Internal Representation - 141
     CLOSED: [2017-08-22 Tue 00:35]
     A ~String~ is a wrapper over a ~Vec<u8>~.
     However, one UTF-8 character can take two bytes. If there is indexing, the
     returned value can be a number of no sense if considered as a character.

     For example,
     ~let hello = "Здравствуйте";~, of which ~hello.len()~ is 24, rather than 12.
     If ~&hello[0]~ is workable, it should be 208, which is NOT a valid
     character on its own.

**** TODO Bytes and Scalar Values and Grapheme Clusters! Oh my! - 142

*** TODO Slicing Strings - 142
*** TODO Methods for Iterating over Strings - 143
*** TODO Strings Are Not So Simple - 144

** TODO Storing Keys with Associated Values in Hash Maps - 144
   ~HashMap<K, V>~
*** TODO Creating a New Hash Map - 144
    #+BEGIN_SRC rust
      use std::collections::HashMap;

      let mut scores = HashMap::new();

      scores.insert(String::from("Blue"), 10);
      scores.insert(String::from("Yellow"), 50);
    #+END_SRC

    Of the three collections, hash map is the least often used, so it's NOT
    included in the features imported automatically in the prelude.
    Hash maps also have less support from the standard library; for example,
    hash maps have no built-in macro to construct them.

    #+BEGIN_SRC rust
      use std::collections::HashMap;

      let teams = vec![String::from("Blue"), String::from("Yellow")];
      let initial_scores = vec![10, 50];

      let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();
    #+END_SRC

*** DONE Hash Maps and Ownership - 145
    CLOSED: [2017-08-22 Tue 00:58]
    For types that implement the ~Copy~ trait, like ~i32~, the values are copied
    into the hash map.
      For owned values like String, the values will be moved and the hash map
    will be the owner of those values:

    #+BEGIN_SRC rust
      use std::collections::HashMap;

      let field_name = String::from("Favorite color");
      let field_value = String::from("Blue");

      let mut map = HashMap::new();
      map.insert(field_name, field_value);
      // `field_name` and `field_value` are invalid at this point.
      // The _move_ is done by the `insert` method.
    #+END_SRC

*** DONE Accessing Values in a Hash Map - 146
    CLOSED: [2017-08-22 Tue 01:06]
    #+BEGIN_SRC rust
      use std::collections::HashMap;

      let mut scores = HashMap::new();

      scores.insert(String::from("Blue"), 10);
      scores.insert(String::from("Yellow"), 50);

      // #1. The `get` method (the return value is `Option<&V>`):
      let team_name = String::from("Blue");
      let score = scores.get(&team_name);

      // #2. Iterate over each key/value pair in a hash map in a similar manner
      //     as we do with vectors:
      for (key, value) in &scores {
          println!("{}: {}", key, value);
      }
    #+END_SRC

*** TODO Updating a Hash Map - 147
**** DONE Overwriting a Value - 147
     CLOSED: [2017-08-22 Tue 01:09]
     Do ~insert~ more than one times for one key.

**** DONE Only Inserting a Value If the Key Has No Value - 147
     CLOSED: [2017-08-22 Tue 01:21]
     #+BEGIN_SRC rust
       use std::collections::HashMap;

       let mut scores = HashMap::new();
       scores.insert(String::from("Blue"), 10);

       scores.entry(String::from("Yellow")).or_insert(50);
       scores.entry(String::from("Blue")).or_insert(50);

       println!("{:?}", scores);
       // Only "Blue" and its value
     #+END_SRC

     - ~entry~ returan a value of enum, ~Entry~.

     - The ~or_insert~ method on ~Entry~ returns
       + the value for the corresponding ~Entry~ key if it exists, and
       + if not, inserts its argument as the new value for this key and returns
         the modified ~Entry~.

       This is much cleaner than writing the logic ourselves, and in addition,
       plays more nicely with the borrow checker.

**** DONE Updating a Value Based on the Old Value - 148
     CLOSED: [2017-08-22 Tue 01:21]
     #+BEGIN_SRC rust
       use std::collections::HashMap;

       let text = "hello world wonderful world";

       let mut map = HashMap::new();

       for word in text.split_whitespace() {
           let count = map.entry(word).or_insert(0);
           *count += 1;
       }

       println!("{:?}", map);
     #+END_SRC

     - The ~or_insert~ method actually returns a mutable reference (~&mut V~).
       We save it in the ~count~ variable, so in order to assign to that value
       we must first dereference ~count~ using the ~*~.

**** DONE Hashing Functions - 149
     CLOSED: [2017-08-22 Tue 01:21]
     - _By default_, ~HashMap~ uses a cryptographically secure hashing function
       that can provide resistance to Denial of Service (DoS) attacks.

       _This is not the fastest hashing algorithm out there_, but the tradeoff
       for _better security_ that comes with the drop in performance is worth it.

       You can switch to another function by specifying a different /hasher/.

     - A /hasher/ :: a type that implements the ~BuildHasher~ trait.

** TODO Summary - 149
   - Given a list of integers, use a vector and return the mean (average),
     median (when sorted, the value in the middle position), and mode (the
     value that occurs most often; a hash map will be helpful here) of the
     list.
     =TODO=

   - Convert strings to Pig Latin, where the first consonant of each word is
     moved to the end of the word with an added “ay”, so “first” becomes
     “irst-fay”. Words that start with a vowel get “hay” added to the end
     instead (“apple” becomes “apple-hay”). Remember about UTF-8 encoding!
     =TODO=

   - Using a hash map and vectors, create a text interface to allow a user to
     add employee names to a department in the company. For example, “Add
     Sally to Engineering” or “Add Amir to Sales”. Then let the user retrieve
     a list of all people in a department or all people in the company by
     department, sorted alphabetically.
     =TODO=

* TODO 9. Error Handling - 151
  - Rust groups errors into two major categories:
    + recoverable errors
    + unrecoverable errors

  - Rust doesn't have exceptions.
    Instead, it has
    + the value ~Result<T, E>~ for recoverable errors.
    + the ~panic!~ macro that stops execution when it encounters unrecoverable
      errors.

** DONE Unrecoverable Errors with ~panic!~ - 152
   CLOSED: [2017-08-22 Tue 15:34]
   - When this macro executes, your program will:
     1. print a failure message
     2. unwind and clean up the stack
     3. quit

   - *Unwinding the Stack Versus Aborting on Panic*
     + /unwinding/ :: walks back up the stack and cleans up the data from each
                      function it encounters, but this walking and cleanup is a
                      lot of work.


     + the alternative is to _immediately abort_. No cleanup by the program.
       Memory need to be cleaned up by the OS.

     + If you want to make your resulting binary as small as possible, you can
       switch from /unwinding/ to /aborting/ on panic by adding
       ~panic = 'abort'~ to the appropriate ~[profile]~ sections in the
       =Cargo.toml=.
       #+BEGIN_SRC toml
         [profile.release]
         panic = 'abort'
       #+END_SRC

    - We can use the backtrace of the functions the ~panic!~ call came from to
      figure this out.

*** DONE Using a ~panic!~ Backtrace - 153
    CLOSED: [2017-08-22 Tue 15:34]
    - /buffer overread/

    - A example:
      #+BEGIN_SRC rust
        fn main() {
            let v = vec![1, 2, 3];

            v[100];
        }
      #+END_SRC

      + ~cargo run~
        #+BEGIN_SRC text
             Compiling panic v0.1.0 (file:///projects/panic)
              Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
               Running `target/debug/panic`
          thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
          100', /stable-dist-rustc/build/src/libcollections/vec.rs:1362
          note: Run with `RUST_BACKTRACE=1` for a backtrace.
          error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
        #+END_SRC

      + ~RUST_BAKTRACE=1 cargo run~
        #+BEGIN_SRC text
              Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
               Running `target/debug/panic`
          thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 100', /stable-dist-rustc/build/src/libcollections/vec.rs:1392
          stack backtrace:
             1:     0x560ed90ec04c - std::sys::imp::backtrace::tracing::imp::write::hf33ae72d0baa11ed
                                  at /stable-dist-rustc/build/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:42
             2:     0x560ed90ee03e - std::panicking::default_hook::{{closure}}::h59672b733cc6a455
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:351
             3:     0x560ed90edc44 - std::panicking::default_hook::h1670459d2f3f8843
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:367
             4:     0x560ed90ee41b - std::panicking::rust_panic_with_hook::hcf0ddb069e7abcd7
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:555
             5:     0x560ed90ee2b4 - std::panicking::begin_panic::hd6eb68e27bdf6140
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:517
             6:     0x560ed90ee1d9 - std::panicking::begin_panic_fmt::abcd5965948b877f8
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:501
             7:     0x560ed90ee167 - rust_begin_unwind
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:477
             8:     0x560ed911401d - core::panicking::panic_fmt::hc0f6d7b2c300cdd9
                                  at /stable-dist-rustc/build/src/libcore/panicking.rs:69
             9:     0x560ed9113fc8 - core::panicking::panic_bounds_check::h02a4af86d01b3e96
                                  at /stable-dist-rustc/build/src/libcore/panicking.rs:56
            10:     0x560ed90e71c5 - <collections::vec::Vec<T> as core::ops::Index<usize>>::index::h98abcd4e2a74c41
                                  at /stable-dist-rustc/build/src/libcollections/vec.rs:1392
            11:     0x560ed90e727a - panic::main::h5d6b77c20526bc35
                                  at /home/you/projects/panic/src/main.rs:4
            12:     0x560ed90f5d6a - __rust_maybe_catch_panic
                                  at /stable-dist-rustc/build/src/libpanic_unwind/lib.rs:98
            13:     0x560ed90ee926 - std::rt::lang_start::hd7c880a37a646e81
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:436
                                  at /stable-dist-rustc/build/src/libstd/panic.rs:361
                                  at /stable-dist-rustc/build/src/libstd/rt.rs:57
            14:     0x560ed90e7302 - main
            15:     0x7f0d53f16400 - __libc_start_main
            16:     0x560ed90e6659 - _start
            17:                0x0 - <unknown>
        #+END_SRC

    - A /backtrace/ :: a list of all the functions that have been called to get
                       to this point.

    - /Backtraces/ in Rust work like they do in other languages:
      the key to reading the backtrace is to _start from_ the top and read _until_
      you see files you wrote.

      The lines above the lines mentioning your files are code that your code
      called;
      the lines below are code that called your code.

** DONE Recoverable Errors with ~Result~ - 155
   CLOSED: [2017-08-23 Wed 13:00]
   - Definition
     #+BEGIN_SRC rust
       enum Result<T, E> {
           Ok(T),
           Err(E),
       }
     #+END_SRC

*** DONE Matching on Different Errors - 158
    CLOSED: [2017-08-22 Tue 15:58]
    #+BEGIN_SRC rust
      use std::fs::File;
      use std::io::ErrorKind;

      fn main() {
          let f = File::open("hello.txt");

          let f = match f {
              Ok(file) => file,
              Err(ref error) if error.kind() == ErrorKind::NotFound => {
                  match File::create("hello.txt") {
                      Ok(fc) => fc,
                      Err(e) => {
                          panic!(
                              "Tried to create file but there was a problem: {:?}",
                              e
                          )
                      },
                  }
              },
              Err(error) => {
                  panic!(
                      "There was a problem opening the file: {:?}",
                      error
                  )
              },
          };
      }
    #+END_SRC

    - /match guard/ :: for example, the ~if error.kind() == ErrorKind::NotFound~
                       above.
    - The ~ref~ in the pattern is needed so that ~error~ is NOT _moved_ into the
      guard condition but is mearly referenced by it.

    - =TODO=
      The reason ~ref~ is used to take a reference in a pattern instead of ~&~ will
      be covered in detail in Chapter 18.
      In short, in the context of a pattern,
      + ~&~ matches a reference and gives us its value,
      + but ~ref~ matches a value and gives us a reference to it.

*** DONE Shortcuts for Panic on Error: ~unwrap~ and ~expect~ - 159
    CLOSED: [2017-08-22 Tue 16:11]
    Pattern matching is NOT always concise and communicate intent well.

    - ~unwrap~:
      ~let f = File::open("hello.txt").unwrap();~
      If the value is the ~Ok~ variant, the inside value will be returned.
      If the value is the ~Err~ variant, a ~panic!~ macro will be called.

    - ~expect~:
      Similar as ~unwrap~, but can take a message for the ~panic!~
      ~let f = File::open("hello.txt").expect("Failed to open hello.txt");~

*** DONE Propagating Errors - 160
    CLOSED: [2017-08-22 Tue 16:26]
    Propagate errors, and give the control to the caller:

    - Example:
      #+BEGIN_SRC rust
        use std::io;
        use std::io::Read;
        use std::fs::File;

        fn read_username_from_file() -> Result<String, io::Error> {
            let f= File::open("hello.txt");

            let mut f = match f {
                Ok(file) => file,
                Err(e) => return Err(e),
            };

            let mut s = String::new();

            match f.read_to_string(&mut s) {
                Ok(_) => Ok(s),
                Err(e) => Err(e),
            }
        }
      #+END_SRC

      + The ~return~ above is imporatant!
        If NO ~return~, that ~Err(e)~ will be assigned to ~f~, rather than being
        returned. With this ~return~, we achieve "propagating errors".

    - This pattern of propagating errors is so common in Rust that there is
      _dedicated syntax to make this easier_: ~?~.

**** DONE A Shortcut for Propagating Errors: ~?~ Operator - 162
     CLOSED: [2017-08-23 Wed 12:55]
     #+BEGIN_SRC rust
       use std::io;
       use std::io::Read;
       use std::fs::File;

       fn read_username_from_file() -> Result<String, io::Error> {
           let mut f = File::open("hello.txt")?;
           let mut s = String::new();
           f.read_to_string(&mut s)?;
           Ok(s)
       }
     #+END_SRC

     ~?~ expressions can be chained
     #+BEGIN_SRC rust
       use std::io;
       use std::io::Read;
       use std::fs::File;

       fn read_username_from_file() -> Result<String, io::Error> {
           let mut s = String::new();
           File::open("hello.txt")?.read_to_string(&mut s)?;
           Ok(s)
       }
     #+END_SRC

**** DONE The ~?~ Operator Can Only Be Used in Functions That Return ~Result~ - 163
     CLOSED: [2017-08-23 Wed 13:00]
     Since one of a ~?~ expression result is to immediately return the ~Err~ value.

** TODO To ~panic!~ or Not To ~panic!~ - 164
*** DONE Examples, Prototype Code, and Tests - 165
    CLOSED: [2017-08-23 Wed 17:59]
    + Have a robust error handling code in these situations can make them less
      clear.

    + Use ~panic!~ (we should be no tolerance in these kind of development), and
      you can repalce them with ~Result~ later when you think handle these errors
      is resonable in some situation.

*** DONE Cases in Which You Have More Information Than The Compiler -  165
    CLOSED: [2017-08-23 Wed 18:13]
    When you are sure your ~Result~ type value can only be ~Ok~, just use ~unwrap~.
    #+BEGIN_SRC rust
      use std::net::IpAddr;
      let home = "127.0.0.1".parse::<IpAddr>().unwrap();
    #+END_SRC

    However, when the data is from the input, there is no promise to ~Ok~.

*** DONE Guidelines for Error Handling - 166
    CLOSED: [2017-08-23 Wed 18:24]
    =TODO= Re-Do
*** TODO Creating Custom Types for Validation - 167
    =TODO= Re-Read

** DONE Summary - 169
   CLOSED: [2017-08-23 Wed 18:46]

* TODO 10. Generic Types, Traits, and Lifetimes - 171
** DONE Removing Duplication by Extracting a Function - 172
   CLOSED: [2017-08-23 Wed 21:48]
** DONE Generic Data Types - 174
   CLOSED: [2017-08-23 Wed 22:23]
*** DONE In Function Definitions - 174
    CLOSED: [2017-08-23 Wed 21:36]
    - The function signature of the generic ~largest~ function we're going to
      define will look like this:
      ~fn largest<T>(list: &[T]) -> T {~

      We would read this as:
      the function ~largest~ is generic over some type ~T~. It has one parameter
      named ~list~, and the type of ~list~ is a slice of values of type ~T~. The
      ~largest~ function will return a value of the same type ~T~.

    - =TODO=
      ~<T>~ is not enough in most scenario, some /traits/ required.
      Talk about this later.

*** DONE In Struct Definitions - 177
    CLOSED: [2017-08-23 Wed 21:46]
    - Single type variable
      #+BEGIN_SRC rust
        struct Point<T> {
            x: T,
            y: T,
        }

        fn main() {
            let integer = Point { x: 5, y: 10 };
            let float = Point { x: 1.0, y: 4.0 };
        }
      #+END_SRC

    - Double type variables
      #+BEGIN_SRC rust
        struct Point<T, U> {
            x: T,
            y: U,
        }

        fn main() {
            let both_integer = Point { x: 5, y: 10 };
            let both_float = Point { x: 1.0, y: 4.0 };
            let integer_and_float = Point { x: 5, y: 4.0 };
        }
      #+END_SRC

*** DONE In Enum Definitions - 178
    CLOSED: [2017-08-23 Wed 21:49]
    #+BEGIN_SRC rust
      enum Option<T> {
          Some(T),
          None,
      }

      enum Result<T, E> {
          Ok(T),
          Err(E),
      }
    #+END_SRC

*** DONE In Method Definitions - 179
    CLOSED: [2017-08-23 Wed 21:59]
    #+BEGIN_SRC rust
      struct Point<T> {
          x: T,
          y: T,
      }

      // TODO: Why there is NO syntactic sugar???
      impl<T> Point<T> {
          fn x(&self) -> &T {
              &self.x
          }
      }

      fn main() {
          let p = Point { x: 5, y: 10 };
          println!("p.x = {}", p.x());
      }
    #+END_SRC

    The methods can have different generic types:
    #+BEGIN_SRC rust
      // src/main.rs

      struct Point<T, U> {
          x: T,
          y: U,
      }

      impl<T, U> Point<T, U> {
          fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
              Point {
                  x: self.x,
                  y: other.y,
              }
          }
      }

      fn main() {
          let p1 = Point { x: 5, y: 10.4 };
          let p2 = Point { x: "Hello", y: 'c' };

          let p3 = p1.mixup(p2);

          println!("p3.x = {}, p3.y ={}", p3.x, p3.y);
      }
    #+END_SRC

*** DONE Performance of Code Using Generics - 181
    CLOSED: [2017-08-23 Wed 22:22]
    - Rust generics has no runtime cost if you had specified concrete types.

      =From Jian=: always specify concrete types for generics if the concrete
      type(s) can be infered (??? NOT sure).

    - /monomorphization/ :: the process of turning generic code into specific
         code with the concrete types that are actually used filled in.
      #+BEGIN_SRC rust
        // You write the code below in `main`:
        //
        // let integer = Some(5);
        // let float = Some(5.0);

        enum Option_i32 {
            Some(i32),
            None,
        }

        enum Option_f64 {
            Some(f64),
            None,
        }

        fn main() {
            let integer = Option_i32::Some(5);
            let float = Option_f64::Some(5.0);
        }
      #+END_SRC

** TODO Traits: Defining Shared Behavior - 182
   - /traits/ :: =TODO=

   - /trait bounds/

*** DONE Defining a Trait - 182
    CLOSED: [2017-08-23 Wed 22:54]
    - Description:
      #+BEGIN_SRC rust
        pub trait Summarizable {
            fn summary(&self) -> String;
        }
      #+END_SRC
*** TODO Implementing a Trait on a Type - 183
    #+BEGIN_SRC rust
      // lib.rs
      pub struct NewsArticle {
          pub headline: String,
          pub location: String,
          pub author: String,
          pub content: String,
      }

      impl Summarizable for NewsArticle {
          fn summary(&self) -> String {
              format!("{}, by {} ({})", self.headline, self.author, self.location)
          }
      }

      pub struct Tweet {
          pub username: String,
          pub content: String,
          pub reply: bool,
          pub retweet: bool,
      }

      impl Summarizable for Tweet {
          fn summary(&self) -> String {
              format!("{}: {}", self.username, self.content)
          }
      }
    #+END_SRC

    - ::

    - _Restriction_: =IMPORTANT=
      We may implement a trait on a type as long as
      _either_ the trait _or_ the type are local to our crate.

      This restriction is _part of_ what's called the /orphan rule/
      (a concept in /type theory/): the parent type is not present.

    - _WITHOUT_ this /orphan rule/, =IMPORTANT=
      two crates could implement the same trait for the same type, and the two
      implementations would conflict: Rust wouldn't know which implementation to
      use. Because Rust enforces the orphan rule, other people's code can't
      break your code and vice versa.

*** TODO Default Implementations - 185
    The trait definition can include a /default implemention/,
    #+BEGIN_SRC rust
      pub trait Summarizable {
          fn summary(&self) -> String {
              String::from("(Read more...)")
          }
      }
    #+END_SRC

    When we implement a trait for a type, we can use the
    /default implementation/: ~impl Summarizable for NewsArticle {}~

    - the syntax for overriding a default implementation is exactly _the same as_
      the syntax for implementing a trait method that doesn't have a default
      implementation.

    - Default implementations are allowed to call the other methods in the same
      trait, even if those other methods don't have a default implementation. In
      this way, a trait can provide a lot of useful functionality and only
      require implementers to specify a small part of it.
      #+BEGIN_SRC rust
        pub trait Summarizable {
            fn author_summary(&self) -> String;

            fn summary(&self) -> String {
                format!("(Read more from {}...)", self.author_summary())
            }
        }
      #+END_SRC
      In order to use this version of ~Summarizable~, we're _only_ required to
      define ~author_summary~ when we implement the trait on a type:
      #+BEGIN_SRC rust
        impl Summarizable for Tweet {
            fn author_summary(&self) -> String {
                format!("@{}", self.username)
            }
        }
      #+END_SRC

    - Note:
      that it is _not possible_ to call the default implementation from an
      overriding implementation.
      =TODO=
      _Kind of reasonable, but not always good. Why with this restriction???_

*** TODO Trait as Parameters - 186
**** TODO Trait Bound Syntax  - 187
**** TODO Specifying Multiple Trait Bound with the + Syntax  - 187
**** TODO Clearer Trait Bounds with where Clauses - 188
**** TODO Returning Types that Implement Traits - 188
     _specifying /trait bound(s)/ on a generic type_

     - Example:
       #+BEGIN_SRC rust
         pub fn notify<T: Summarizable>(item: T) {
             println!("Breaking news! {}", item.summary());
         }
       #+END_SRC

     - Specify _multiple_ /trait bounds/ on a generic type by using ~+~.
       For example: ~T: Summarizable + Display~

     - Clearer (less cluttered, category different info) alternative syntax for
       specifying /trait bound(s)/ (use ~where~):
       #+BEGIN_SRC rust
         fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {
             // ...
         }

         //------------------
         // is equivalent to
         //------------------

         fn some_function<T, U>(t: T, u: U) -> i32
             where T: Display + Clone,
                   U: Clone + Debug
         {
             //...
         }
       #+END_SRC

*** DONE Fixing the ~largest~ Function with Trait Bounds - 189
    CLOSED: [2017-08-26 Sat 12:35]
    - Wrong version:
      + Without the trait bounds ~std::cmp::PartialOrd~

      + Only ~std::cmp::PartialOrd~ is OK, but the type signature should be
        ~&[T] -> &T~ and some change(s) should be make to the body of this
        function (Check the last implementation in this section of this note,
        which is not given in this book).

    - ~+ Copy~ version
      #+BEGIN_SRC rust
        use std::cmp::PartialOrd;

        fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
            let mut largest = list[0];

            for &item in list.iter() {
                if item > largest {
                    largest = item;
                }
            }

            largest
        }

        fn main() {
            let numbers = vec![34, 50, 25, 100, 65];

            let result = largest(&numbers);
            println!("The largest number is {}", result);

            let chars = vec!['y', 'm', 'a', 'q'];

            let result = largest(&chars);
            println!("The largest char is {}", result);
        }
      #+END_SRC

    - ~+ Clone~ version

    - return ~&T~ version (least /trait bounds/):
      #+BEGIN_SRC rust
        fn largest<T: PartialOrd>(list: &[T]) -> &T {
            let mut largest_item = &list[0];
            // 1. precedence:
            //    `&list[0]` means `&(list[0])` (type `&T`)
            //    rather than `(&list)[0]` (type `T`).
            //
            // 2. Use `&` ONLY here is the simplest way to implement a function
            //    of this type signature.

            for item in list.iter() {
            // `iter()` of a &[T] returns `&T`, which is the type of `item`
                if item > largest_item {
                    largest_item = item;
                }
            }

            largest_item
        }
      #+END_SRC

*** DONE Using Trait Bounds to Conditionally Implement Methods - 191
** DONE Validating References with Lifetimes - 192
   CLOSED: [2017-08-27 Sun 00:16]
   - Every reference in Rust has a /lifetime/, which is the scope for which that
     reference is valid.

   - Most of the time /lifetimes/ are _implict_ and _inferred_, just like most of
     the time /types/ are inferred.

   - Since there are cases that the /lifetimes/ of references could be related in
     a few different ways, Rust needs us to annotate the relationships using
     /generic lifetime parameters/ so that it can make sure the actual references
     used at runtime will definitely be valid.

   - =TODO= Chapter 19

*** DONE Preventing Dangling References with Lifetimes - 193
    CLOSED: [2017-08-26 Sat 13:03]
    - Example:
      #+BEGIN_SRC rust
        // code snippet cannot be compiled.
        {
            let r;

            {
                let x = 5;
                r = &x;
            }

            println!("r: {}", r);
        }

        // error: `x` does not live long enough
        //    |
        // 6  |         r = &x;
        //    |              - borrow occurs here
        // 7  |     }
        //    |     ^ `x` dropped here while still borrowed
        // ...
        // 10 | }
        //    | - borrowed value needs to live until here
      #+END_SRC

    - *Uninitialized Variables Cannot Be Used*

*** DONE The Borrow Checker - 194
    CLOSED: [2017-08-26 Sat 13:33]
    - /borrow checker/ :: a part of the Rust compiler. It compares scopes to
         determine that all borrows are valid.

    - An example of lifetime:
      #+BEGIN_SRC rust
        {
            let r;         // -------+-- 'a
                           //        |
            {              //        |
                let x = 5; // -+-----+-- 'b
                r = &x;    //  |     |
            }              // -+     |
                           //        |
            println!("r: {}", r); // |
                           //        |
                           // -------+
        }
      #+END_SRC

    - Fix the example above by removing the inner scope boundary:
      #+BEGIN_SRC rust
        {
            let x = 5;            // -----+-- 'b
                                  //      |
            let r = &x;           // --+--+-- 'a
                                  //   |  |
            println!("r: {}", r); //   |  |
                                  // --+  |
        }                         // -----+
      #+END_SRC

*** DONE Generic Lifetimes in Functions - 195
    CLOSED: [2017-08-26 Sat 13:48]
    #+BEGIN_SRC rust
      // NOT compilable
      fn longest(x: &str, y: &str) -> &str {
          if x.len() > y.len() {
              x
          } else {
              y
          }
      }

      // error[E0106]: missing lifetime specifier
      //    |
      // 1  | fn longest(x: &str, y: &str) -> &str {
      //    |                                 ^ expected lifetime parameter
      //    |
      //    = help: this function's return type contains a borrowed value, but the
      //    signature does not say whether it is borrowed from `x` or `y`
    #+END_SRC

    We need to add generic lifetime parameters that will define the relationship
    between the references so that the borrow checker can perform its analysis.

*** DONE Lifetime Annotation Syntax - 196
    CLOSED: [2017-08-26 Sat 14:21]
    - /Lifetime/ annotations DO NOT change how long any of the references
      involved live.
        What lifetime annotations do is relate the lifetimes of multiple
      references to each other.

    - In the same way that functions can accept any type when the signature
      specifies a generic type parameter, functions can accept references with
      any lifetime when the signature specifies a generic lifetime parameter.

    - Lifetime annotation syntax:
      + start with ~'~
      + usually all lowercase
      + usually very short
      + after the ~&~ of a reference, and a space separates the lifetime
        annotation from the reference's type.

    - Example:
      + a reference: ~&i32~
      + a reference with an explicit lifetime: ~&'a i32~
      + a mutable reference with an explicit lifetime: ~&'a mut i32~

*** DONE Lifetime Annotations in Function Signatures - 197
    CLOSED: [2017-08-26 Sat 15:23]
    The /lifetime/ annotation tell Rust about for the references in the
    parameters and the return value is that they all must have the same lifetime.
    #+BEGIN_SRC rust
      fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
          if x.len() > y.len() {
              x
          } else {
              y
          }
      }
    #+END_SRC

    - The /lifetime annotations/ are only in the function signature, and NOT in
      any of the code in the function body.

      Rationale:
      Except the passed in references, Rust is able to analyze the code within
      the function without any help. On the other hand, the lifetimes of the
      arguments or return values will potentially be different each time the
      function is called. Analyze them would be incredibly costly and often
      impossible.

    - Since the scopes always nest, the generic lifetime ~'a~ will get the
      concrete /lifetime/ equal to the smaller of the concrete lifetime of an
      argument, which is reasonable.

      + Example:
        #+BEGIN_SRC rust
          fn main() {
              let string1 = String::from("long string is long");

              {
                  let string2 = String::from("xyz");
                  let result = longest(string1.as_str(), string2.as_str());
                  println!("The longest string is {}", result);
              }

              // println!("The longest string is {}", result);
              //
              // // According to the lifetime annotation of the `longest` function,
              // // `result` should be invalid here.
              // //
              // // WHEN COMPILE:
              // // error: `string2` does not live long enough
              // //    |
              // // 6  |         result = longest(string1.as_str(), string2.as_str());
              // //    |                                            ------- borrow occurs here
              // // 7  |     }
              // //    |     ^ `string2` dropped here while still borrowed
              // // 8  |     println!("The longest string is {}", result);
              // // 9  | }
              // //    | - borrowed value needs to live until here}
        #+END_SRC

*** DONE Thinking in Terms of Lifetimes - 199
    CLOSED: [2017-08-24 Thu 10:34]
    - If the result is only related to some parameters, just annotate those
      parameters.
      #+BEGIN_SRC rust
        // Of course, `y` does NOT have any relationship with the lifetime of `x`
        // or the return value.
        fn longest<'a>(x: &'a str, y: &str) -> &'a str {
            x
        }
      #+END_SRC

      Actually, you CANNOT annotate the unrelated lifetime:
      ~fn longest<'a>(x: &'a str, y: &'b str) -> &'a str {~ cannot be accepted by
      the compiler.

    - You _CANNOT_ do this:
      #+BEGIN_SRC rust
        fn longest<'a>(x: &str, y: &str) -> &'a str {
            let result = String::from("really long string");
            result.as_str()  // this is a string slice
        }
      #+END_SRC

    - Ultimately, lifetime syntax is about connecting the lifetimes of various
      arguments and return values of functions. Once they're connected, Rust has
      enough information to allow memory-safe operations and disallow operations
      that would create dangling pointers or otherwise violate memory safety.

*** DONE Lifetime Annotations in Struct Definitions - 200
    CLOSED: [2017-08-24 Thu 11:13]
    _Up until now_, we've only defined _/structs/ to hold owned types_.

    It is possible for /structs/ to hold /references/, but we need to add a lifetime
    annotation on every reference in the struct's definition.

    #+BEGIN_SRC rust
      struct ImportantExcerpt<'a> {
          part: &'a str,
      }

      fn main() {
          let novel = String::from("Call me Ishmael. Some years ago...");
          let first_sentence = novel.split('.')
              .next()
              .expect("Could not find a '.'");
          let i = ImportantExcerpt { part: first_sentence };
      }
    #+END_SRC

*** DONE Lifetime Elision - 201
    CLOSED: [2017-08-26 Sat 23:05]
    - Every reference has a lifetime, and we need to specify lifetime
      parameters for functions or structs that use references.
        However, in Chapter 4 we had a function in the "String Slices" section,
      shown again in Listing 10-25, that compiled without lifetime annotations:
      #+BEGIN_SRC rust
        fn first_word(s: &str) -> &str {
            let bytes = s.as_bytes();

            for (i, &item) in bytes.iter().enumerate() {
                if item == b' ' {
                    return &s[0..i];
                }
            }

            &s[..]
        }
      #+END_SRC

      Pre-1.0 Rust wouldn't have this program compiled. Every reference needed an
      explicit lifetime.

    - /lifetime elision rules/ :: a set of particular cases that the compiler
         will consider, and if your code fits these cases, you don't need to
         write the lifetimes explicitly.

    - The /elision rules/ do NOT provide full inference: if there is still
      ambiguity after applying these rules, Rust will issue an error.

    - /input lifetimes/: lifetimes on function parameters or method parameters.

    - /output lifetimes/: lifetimes on return values.

    - Now, on to the rules that the compiler uses to figure out what lifetimes
      references have when there aren't explicit annotations.

      The first rule applies to /input lifetimes/, and
      the second two rules apply to /output lifetimes/.

      If the compiler gets to the end of the three rules and there are still
      references that it can't figure out lifetimes for, the compiler will stop
      with an error.

      1. Each parameter that is a reference gets its own lifetime parameter. In
         other words, a function with one parameter gets one lifetime parameter:
         ~fn foo<'a>(x: &'a i32)~, a function with two arguments gets two
         separate lifetime parameters: ~fn foo<'a, 'b>(x: &'a i32, y: &'b i32)~,
         and so on.

      2. If there is exactly one input lifetime parameter, that lifetime is
         assigned to all output lifetime parameters:
         ~fn foo<'a>(x: &'a i32) -> &'a i32~.

      3. If there are multiple input lifetime parameters, but one of them is
         ~&self~ or ~&mut self~ because this is a method, then the lifetime of
         ~self~ is assigned to all output lifetime parameters. This makes
         writing methods much nicer.

    - Try to apply these rules to ~fn first_word(s: str) -> &str {~
      rule 1 - ~fn first_word<'a>(s: &'a str) -> &str {~
      rule 2 - ~fn first_word<'a>(s: &'a str) -> &'a str {~
      rule 3 - NOT a method

    - The /lifetimes/ of ~fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {~
      CANNOT be figured out through applying the /lifetime elision rules/.

    - =TODO= Because the third rule only really applied in method signatures,
      let's look at lifetimes in that context now, and see why the third rule
      means we don't have to annotate lifetimes in method signatures very often.

*** DONE Lifetime Annotations in Method Definitions - 203
    CLOSED: [2017-08-26 Sat 22:41]
    - Apply rule 1
      #+BEGIN_SRC rust
        // The lifetime parameter declaration
        // after `impl` and
        // use after the type name is required, but we're not required to
        // annotate the lifetime of the first elition rule.
        //
        // first elison rule
        impl<'a> ImportantExcerpt<'a> {
            fn level(&self) -> i32 {
                3
            }
        }
      #+END_SRC

    - Apply rule 3
      #+BEGIN_SRC rust
        impl<'a> ImportantExcerpt<'a> {
            fn announce_and_return_part(&self, announcement: &str) -> &str {
                pinntln!("Attention please: {}", announcement);
                self.part
            }
        }
      #+END_SRC

*** DONE The Static Lifetime - 204
    CLOSED: [2017-08-26 Sat 22:52]
    - ~'stack~ :: the entire duration of the program.

    - Example: ~let s: &'static str = "I have a static lifetime";~
      The text of this string is stored directly in the binary of your program
      and the binary of your program is always available.
      Therefore, the lifetime of all /string literals/ is ~'static~.

    - Sometimes compiler suggest you use ~'static~ somewhere.

      Most of the time, the REAL solution is _NOT_ just use ~'static~.
        The problem in the code is an attempt to create a dangling references or
      mismatch of the available lifettimes, and the solution is fixing those
      problems, NOT specifying the ~'static~ lifetime.

** DONE Generic Type Parameters, Trait Bounds, and Lifetimes Together - 205
   CLOSED: [2017-08-26 Sat 23:05]
   #+BEGIN_SRC rust
     use std::fmt::Display;

     fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
         where T: Display
     {
         println!("Announcement! {}", ann);
         if x.len() > y.len() {
             x
         } else {
             y
         }
     }
   #+END_SRC

** DONE Summary - 205
   CLOSED: [2017-08-27 Sun 00:16]

* DONE 11. Writing Automated Tests - 207
  CLOSED: [2017-08-29 Tue 20:26]
** DONE How to Write Tests - 208
   CLOSED: [2017-08-28 Mon 20:47]
   The features Rust provides specifically for writing tests:
   - the ~test~ attribute
   - a few macros
   - the ~should_panic~ attribute.

*** DONE The Anatomy of a Test Function - 208
    CLOSED: [2017-08-28 Mon 14:21]
    - /attributes/ :: metadata about pieces of Rust code.

    - TEST
      1. Use ~cargo new ~addr~ to
         create a new library project called ~adder~.

         Then in the =src/lib.rs=
         #+BEGIN_SRC rust
           #[cfg(test)]
           mod tests {
               #[test]
               fn it_works() {
               }
           }
         #+END_SRC
         + For now, ignore the first twolines and focus on the function to see how
           it works.

         + The ~#[test]~ /attribute/ indicates this is a test function.
             There are non-test functions in the ~tests~ module to help do some
           common things, so we need to indicate which functions are tests with
           the ~#[test]~ attribute.

      2. Use ~cargo test~ to run the test(s).
         + test 1
           #+BEGIN_SRC rust
             #[cfg(test)]
             mod tests {
                 #[test]
                 fn exploration() {
                 }
             }

             // running 1 test
             // test tests::exploration ... ok
             //
             // test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
           #+END_SRC
           =TODO= Talk about the _ignored_ later.

         + test 2
           #+BEGIN_SRC rust
             #[cfg(test)]
             mod tests {
                 #[test]
                 fn exploration() {
                 }

                 #[test]
                 fn another() {
                     panic!("Make this test fail");
                 }
             }

             // running 2 tests
             // test tests::exploration ... ok
             // test tests::another ... FAILED
             //
             // failures:
             //
             // ---- tests::another stdout ----
             //     thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:9
             // note: Run with `RUST_BACKTRACE=1` for a backtrace.
             //
             // failures:
             //     tests::another
             //
             // test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured
             //
             // error: test failed
           #+END_SRC

*** DONE Checking Results with the ~assert!~ Macro - 211
    CLOSED: [2017-08-28 Mon 14:32]
    - It is useful when you want to ensure that some condition in a test
      evaluates to ~true~.
      + If is ~true~, do nothing
      + If is ~false~, it calls the ~panic!~

    - In =src/lib.rs=:
      #+BEGIN_SRC rust
        #[derive(Debug)]
        pub struct Rectangle {
            length: u32,
            width: u32,
        }

        impl Rectangle {
            pub fn can_hold(&self, other: &Rectangle) -> bool {
                self.length > other.length && self.width > other.width
            }
        }

        #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            fn larger_can_hold_smaller() {
                let larger = Rectangle { length: 8, width: 7 };
                let smaller = Rectangle { length: 5, width: 1 };

                assert!(larger.can_hold(&smaller));
            }
        }

        // running 1 test
        // test tests::larger_can_hold_smaller ... ok
        //
        // test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
      #+END_SRC

*** DONE Testing Equality with the ~assert_eq!~ and ~assert_ne!~ Macros - 214
    CLOSED: [2017-08-28 Mon 19:39]
    - ~assert_eq!~ is like combine ~assert!~ and ~==~, though it will print out
      more import when it fails.

      ~assert_ne!~ is its opposite.

    - They print out their two argument values when the assertion fails.

    - Example:
      #+BEGIN_SRC rust
        pub fn add_two(a: i32) -> i32 {
            a + 2
        }

        #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            fn it_adds_two() {
                assert_eq!(4, add_two(2));
            }
        }

        // running 1 test
        // test tests::it_adds_two ... ok
        //
        // test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
      #+END_SRC

    - ~assert_eq!~ and ~assert_ne!~ take arguments with no order constraints (
      In some languages test framework, there is ~expected~ and ~actual~, while
      Rust doesn't).

    - Under the surface, the ~assert_eq!~ and ~assert_ne!~ macros use the
      operators ~==~ and ~!=~ (the ~PartialEq~ trait is required), respectively.
      When assertions fail, these macros print their arguments using _debug
      formatting_ (the ~Debug~ trait is required).

      All of the primitive types and most of the standard library types
      implement these traits.

      Both of these two traits are derivable traits, we can use
      ~#[derive(PartialEq, Debug)]~ annotation to your struct or enum definition.
      =TODO= See Appendix C.
    -

*** DONE Adding Custom Failure Messages - 216
    CLOSED: [2017-08-28 Mon 19:47]
    - Additional optional arguments can be passed to ~assert!~, ~assert_eq!~, and
      ~assert_ne!~. this argument will be passed to ~format!~ macro, so we can
      use the syntax of ~{}~ placeholders.

    - Example:
      #+BEGIN_SRC rust
        pub fn greeting(name: &str) -> String {
            format!("Hello {}!", name)
        }

        #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            fn greeting_contains_name() {
                let result = greeting("Carol");
                assert!(
                    result.constants("Carol"),
                    "Greeting did not contain name, value was `{}`", result
                );
            }
        }
      #+END_SRC

*** DONE Checking for Panics with ~should_panic~ - 218
    CLOSED: [2017-08-28 Mon 20:47]
    #+BEGIN_SRC rust
      struct Guess {
          value: u32,
      }

      impl Guess {
          pub fn new(value: u32) -> Guess {
              if value < 1 || value > 100 {
                  panic!("Guess value must be between 1 and 100, got {}", value);
              }

              Guess {
                  value
              }
          }
      }

      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          #[should_panic]
          fn greater_than_100() {
              Guess::new(200);
          }
      }
    #+END_SRC

    - ~#[should_panic]~ goes after ~#[test]~ and before the function

    - If we remove the ~|| value > 100~ part, the test will fail.

    - The above ~should_panic~  can be imprecise: any panic can satisfy it, even
      though it's not what we expect. We can add an optional ~expected~ parameter
      to the ~should_panic~ attribute. A substring of the panic message is
      enough.
      #+BEGIN_SRC rust
        struct Guess {
            value: u32,
        }

        impl Guess {
            pub fn new(value: u32) -> Guess {
                if value < 1 {
                    panic!("Guess value must be greater than or equal to 1, got {}.",
                           value);
                } else value > 100 {
                    panic!("Guess value must be less than or equal to 100, got {}.",
                           value);
                }

                Guess {
                    value
                }
            }
        }

        #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            #[should_panic(expected = "Guess value must be less than or equal to 100")]
            fn greater_than_100() {
                Guess::new(200);
            }
        }
      #+END_SRC

*** Using ~Result<T, E>~ in Tests - 221

** DONE Controlling How Tests Are Run - 221
   CLOSED: [2017-08-28 Mon 22:35]
*** DONE Running Tests in Parallel or Consecutively - 222
    CLOSED: [2017-08-28 Mon 21:09]
    - When multiple tests are run,
      _by default they run in parallel using threads_.

      Ruslt:
      + finish running faster.
      + get faster feedback.

    - =IMPORTANT=
      Since test are running in parallel, you should take care that
      + your tests do not depend on each other

      + your tests do not depend on on any shared state, including a shared
        environment such as the current working directory or environment
        variables (=From Jian= immutable things are OK)

    - If you don't want to run the tests in parallel,
      or
      if you want more fine-grained control over the number of threads used,
      =TODO= HOW?

      you can send the ~--test-threads~ flag and the number of threads you want
      to use to the test binary. For example:
      ~$ cargo test -- --test-threads=1~ does not use any parallelism.
      ~$ cargo test -- --test-threads=2~

*** DONE Showing Function Output - 222
    CLOSED: [2017-08-28 Mon 21:17]
    - If a test passes, all its to standard output prints will be captured.

    - Disable the output capture of tests, use ~--nocapture~.
      ~$ cargo test -- --nocapture~
      We usually don't use this option alone -- since the default parallelism,
      the output will be interleaved.

      Use ~$ cargo test -- --nocapture --test-threads=1~

*** DONE Running a Subset of Tests by Name - 224
    CLOSED: [2017-08-28 Mon 22:31]
    You can choose which test(s) to run by passing ~cargo test~ the name or names
    of the test(s) you want to run as an argument.
    #+BEGIN_SRC rust
      // src/lib.rs

      pub fn add_two(a: i32) -> i32 {
          a + 2
      }

      #[cfg(test)]
      mod tests {
          use super::*;

          #[test]
          fn add_two_and_two() {
              assert_eq!(4, add_two(2));
          }

          #[test]
          fn add_three_and_two() {
              assert_eq!(5, add_two(3));
          }

          #[test]
          fn one_hundred() {
              assert_eq!(102, add_two(100));
          }
      }
    #+END_SRC

**** DONE Running Single Tests - 225
     CLOSED: [2017-08-28 Mon 22:27]
     ~$ cargo test one_hundred~

**** DONE Filtering to Run Multiple Tests - 225
     CLOSED: [2017-08-28 Mon 22:27]
     Specify part of a test name, multiple tests will run if they share this
     specified word.
     ~$ cargo test add~ will run the ~add_two_and_two~ and ~add_three_and_two~
     above.

*** DONE Ignore Some Tests Unless Specifically Requested - 226
    CLOSED: [2017-08-28 Mon 22:35]
    - Use the ~#[ignore]~ attribute after ~#[test]~ and before the function.

    - If you want to run only the ignored tests, run ~$ cargo test -- --ignored~

    - Use ~--all~ option to run all tests.

** DONE Test Organization - 227
   CLOSED: [2017-08-29 Tue 20:26]
   The Rust community tends to think about tests in terms of two main categories:
   + /unit tests/

   + /integration tests/ (=From Jian= In Haskell, I think we also call it
     /property tests/)

*** DONE Unit Tests - 227
    CLOSED: [2017-08-29 Tue 15:43]
    - We put /unit tests/ in the =src= directory, in each file with the code that
      they're testing.

    - _CONVENTION_: create a module named ~tests~ in each file to contain the
      test functions, and we annotate the module with ~cfg(test)~.

**** DONE The Tests Module and ~#[cfg(test)]~ - 227
     CLOSED: [2017-08-29 Tue 15:39]
     - The ~#[cfg(test)]~ annotation on the tests module tells Rust to compile
       and run the test code _ONLY_ when we run ~cargo test~, and not when we run
       ~cargo build~.

     - /integration tests/ go in a different directory, they don't need the
       ~[cfg(test)]~ annotation.

**** DONE Testing Private Functions - 227
     CLOSED: [2017-08-29 Tue 15:43]
     =IMPORTANT=
     Rust's Privacy rules do allow you to test private functions directly.
     For example,
     #+BEGIN_SRC rust
       pub fn add_two(a: i32) -> i32 {
           internal_adder(a, 2)
       }

       // a function is *private* by default
       fn internal_adder(a: i32, b: i32) -> i32 {
           a + b
       }

       #[cfg(test)]
       mod tests {
           use super::*;

           #[test]
           fn internal() {
               assert_eq!(4, internal_adder(2, 2))
           }
       }
     #+END_SRC

*** DONE Integration Tests - 228
    CLOSED: [2017-08-29 Tue 20:25]
    In Rust, integration tests are _entirely external_ to your library -- they
    use your library in the same way any other code would, which means they can
    only call functions that are part of your library's public API.

    =From Jian= This is reasonable: test the private functions should be done by
    unit tests, rather than integration tests.

**** DONE The =tests= Directory - 229
     CLOSED: [2017-08-29 Tue 16:08]
     - Make a =tests= directory in the top level of your project.

       Cargo knows to look for integration test files in this directory.

       We can make multiple files inside this directory, and Cargo will compile
       each of the files as an individual crate.

     - ~cargo test~ output has three sections:
       + the unit test
       + the integration tests
       + the doc tests

     - ~cargo test --test integration_test~
       + Run particular integration test function by specifying the test
         function's name as an argument to ~cargo test~.

       + To run all of the tests in a particular integration test file, use the
         ~--test~ argument of ~cargo test~ followed by the name of the file:
         ~cargo test --test integration_test~

**** DONE Submodules in integration Tests - 230
     CLOSED: [2017-08-29 Tue 19:46]
     Sometimes you want to extract some common functions into a file, and the
     other /integration tests/ (in multiple files) use it.
     + If you put it in a file (assume its name is =common.rs=) directly in
       =tests=, Cargo will consider it as a /integration tests/ and output the
       something about it when you run ~cargo test~ -- this is usually NOT what
       we want.

     + Rather than =common.rs=, we should put the comman code into
       =projectName/tests/common/mod.rs=, and then ~cargo test~ won't run it.

     + Example:
       #+BEGIN_SRC rust
         extern crate adder;

         mod common;

         #[test]
         fn it_adds_two() {
             common::setup();
             assert_eq!(4, adder::add_two(2));
         }
       #+END_SRC

**** DONE Integration Tests for Binary Crates - 232
     CLOSED: [2017-08-29 Tue 20:25]
     - If our project is a binary crate that _ONLY_ contains a =src/main.rs= and
       does not have a =src/lib.rs=, we are _NOT able_ to create integration tests
       in the tests directory and use extern crate to import functions defined in
       =src/main.rs=.

     - Only library crates expose functions that other crates are able to call
       and use; binary crates are meant to be run on their own.

       This is one of the reasons Rust projects that provide a binary have a
       straightforward =src/main.rs= that calls logic that lives in =src/lib.rs=.
       With that structure, integration tests can test the library crate by
       using extern crate to cover the important functionality. If the important
       functionality works, the small amount of code in =src/main.rs= will work
       as well, and that small amount of code does not need to be tested.

       =From Jian= Keep your =src/main.rs= simple!!!

** DONE Summary - 232
   CLOSED: [2017-08-29 Tue 20:26]

* TODO 12. An I/O Project: Building a Command Line Program - 233
  _OLD TITLE_ An I/O Project
  - This chapter is both
    + a recap of many skills
    + an exploration of a few more standard library features

  - Make our own version of the classic command line tool ~grep~ (Globally search
    a Regular Expression and Print).

  - In the simplest use case, ~grep~ searches a specified file for a specified
    string using the following steps:
    + Take as arguments a filename and a string.
    + Read the file.
    + Find lines in the file that contain the string argument.
    + Print out those lines.

  - We'll also show how to use environment variables and print to standard error
    instead of standard out; these tech are commonly used in command line tools.

  - ~ripgrep~ is a fully-featured and faster version of ~grep~ implemented by
    Andrew Gallant by using Rust.

  - This project will bring together a number of concepts you've learned so far:
    + Organizing code (using what we learned in modules, _Chapter 7_)
    + Using vectors and strings (collections, _Chapter 8_)
    + Handling errors (_Chapter 9_)
    + Using traits and lifetimes where appropriate (_Chapter 10_)
    + Writing tests (_Chapter 11_)

  - We'll also briefly introduce /closures/, /iterators/, and /trait objects/,
    which Chapter 13 and 17 will cover in detail =TODO=.

  - ~cargo new --bin greprs~

** DONE Accepting Command Line Arguments - 234
   CLOSED: [2017-08-27 Sun 18:48]
   Our first task is to make ~greprs~ able to accept its two command line
   arguments:
   + the file name
   + a string to search for.

   The result is we can use a command of the pattern
   ~cargo run searchstring example-filename.txt~

*** DONE Reading the Argument Values - 234
    CLOSED: [2017-08-27 Sun 18:44]
    Use Rust standard library ~std::env::args~, which returns an /iterator/ of
    the command line arguments that were given to our program.

    - =TODO= /iterator/ will be fully covered in Chapter 13.

    - For now, two things we need to know about the /iterator/:
      1. Iterator produce a series of values
      2. We can call the ~collect~ function on iterator to turn it into a vector
         containing all of the elements the iterator produces.

    - Example (use /iterator/):
      #+BEGIN_SRC rust
        use std::env;

        fn main() {
            let args: Vec<String> = env::args().collect();
            println!("{:?}", args);
        }
      #+END_SRC
      + As we talked about in Chapter 7,
        in cases where the desired function is nested in more than one module,
        it's CONVENTIONAL to _bring the parent module into scope_, rather than
        the function itself.

      + ~std::env::args~ will panic if any argument containts invalid Unicode.

      + To take arguments with invalid Unicode, use ~std::env::args_os~, which
        returns ~OsString~.

          ~OsString~ values differ per-platform and are more complex to work
        with than ~String~ values.

      + Run:
        #+BEGIN_SRC bash
          cargo run
          # ["target/debug/greprs"]

          cargo run needle haystack
          # ...snip...
          # ["target/debug/greprs", "needle", "haystack"]
        #+END_SRC

*** DONE Saving the Argument Values in Variables - 236
    CLOSED: [2017-08-27 Sun 18:48]
    #+BEGIN_SRC rust
      use std::env;

      fn main() {
          let args: Vec<String> = env::args().collect();

          let query = &args[1];
          let filename = &args[2];

          println!("Searching for {}", query);
          println!("In file {}", filename);
      }
    #+END_SRC

    - =TODO= Later we'll add some error handling to deal with situations like no
      argument.
** DONE Reading a File - 237
   CLOSED: [2017-08-27 Sun 20:05]
   #+BEGIN_SRC rust
     use std::env;
     use std::fs::File;
     use std::io::prelude::*;

     fn main() {
         let args: Vec<String> = env::args().collect();

         let query = &args[1];
         let filename = &args[2];

         println!("Searching for {}", query);
         println!("In file {}", filename);

         let mut f = File::open(filename).expect("file not found");

         let mut contents = String::new();
         f.read_to_string(&mut contents).expect("something went wrong reading the file");

         println!("With text:\n{}", contents);
     }
   #+END_SRC

   - ~std::io::prelude::*~ contains various traits taht are useful when doing
     I/O, including file I/O.

   - Don't be confused with /prelude/
     + Here we use ~std::io::prelude::*~
     + There is also a general ~prelude~ which is always brought in
       automatically, unless you disable it (=From Jian= HOW TO???).

   - We've got a few flaws though:
     + the ~main~ function has multiple responsibilities
     + we're not handling errors as well as we could be.

   - While our program is still small, these flaws aren't a big problem, but as
     our program grows, it will be harder to fix them cleanly.

     _Refactor earlier is good, while optimize earlier is bad_
     It's good practice to begin _refactoring early_ on when developing a
     program, as it's much easier to refactor smaller amounts of code, so we'll
     do that now.

** DONE Refactoring to Improve Modularity and Error Handling - 238
   CLOSED: [2017-08-28 Mon 02:19]
   - _OLD TITLE_: Improving Error Handling and Modularity

   - There are _FOUR_ problems that we'd like to fix to improve our program, they
     have to do with:
     + the way the program is structured
     + how it's handling potential errors

   - Problem 1 :: ~main~ contains more than one tasks:
     1. parse arguments
     2. open up files.

   - Solution to P1 :: It's better to separate out functionality so that each
                      function is responsible for one task.

   - Problem 2 :: If later we have more configuration variables (like ~filename~,
                  ~contents~), it will become hard to track them.

   - Solution to P2 :: It's better to group the configuration variables into one
                       structure to make their purpose clear.

   - Problem 3 :: If there is an error when opening up the given file, the
                       error message is always =file not found=, which should NOT
                       always the case.

   - Solution to P3 :: Find a way to give right advices through the error
                       message.

   - Problem 4 :: It would be better if all our error handling code was in
                  one place so that future maintainers only have on place
                  to consult in the code if the error handling logic needs to
                  change.

   - Solution to P4 :: Put them together.

*** DONE Separation of Concerns for Binary Projects - 239
    CLOSED: [2017-08-27 Sun 21:43]
    - The organizational guidelines has the following steps:
      1. Split your program into both a ~main.rs~ and a ~lib.rs~ and move your
         program's logic into ~lib.rs~.

      2. While your command line parsing logic is small, it can remain in
         ~main.rs~.

      3. When the command line parsing logic starts getting complicated, extract
         it from ~main.rs~ into ~lib.rs~ as well.

      4. The responsibilities that remain in the ~main~ function after this
         process should be:
         + Calling the command line parsing logic with the argument values
         + Setting up any other configuration
         + Calling a ~run~ function in ~lib.rs~
         + If ~run~ returns an error, handling that error

    - This pattern is all about separating concerns:
      + ~main.rs~ handles running the program
      + ~lib.rs~ handles all of the logic of the task at hand.

      Because we can't test the ~main~ function directly, this structure lets us
      test all of our program's logic by moving it into functions in ~lib.rs~.
      The only code that remains in ~main.rs~ will be small enough to verify its
      correctness by reading it. Let's re-work our program by following this
      process.

**** DONE Extracting the Argument Parser - 240
     CLOSED: [2017-08-27 Sun 21:48]
     #+BEGIN_SRC rust
       // src/main.rs
       fn main() {
           let args: Vec<String> = env::args().collect();
           let (query, filename) = parse_config(&args);
           // ...snip...
       }

       fn parse_config(args: &[String]) -> (&str, &str) {
           let query = &args[1];
           let filename = &args[2];
           (query, filename)
       }
     #+END_SRC

**** DONE Grouping Configuration Values - 240
     CLOSED: [2017-08-27 Sun 23:29]
     - A sign that we don't have the right abstraction yet:
         We're returning a tuple, but when we immediately break that tuple up into
       individual parts again.

     - Another indicator:
       The two values we return are related and are both part of one configuration
       value. We're not currently conveying this meaning in the structure of the
       data other than grouping the two values into a tuple -- the can be a
       stronger structure -- ~struct~.

       This will make it easier for future maintainers of this code to understand
       how the different values relate to each other and what their purpose is.

     - /primitive obsession/ :: using primitive values when a complex type would
          be more appropriate.

     - Refactored Code:
       #+BEGIN_SRC rust
         fn main() {
             let args: Vec<String> = env::args().collect();
             let config = parse_config(&args);

             println!("Searching for {}", config.query);
             println!("In file {}", config.filename);

             let mut f = File::open(config.filename).expect("file not found");
             // ...snip...
         }

         struct Config {
             query: String,
             filename: String,
         }

         fn parse_config(args: &[String]) -> Config {
             let query = args[1].clone();
             let filename = args[2].clone();
             Config { query, filename }
         }
       #+END_SRC

       + It's simple to give the ownership of a vector to a parameter of a
         function, but =Jian= don't know a simple way to use the elements of this
         vector. An error =cannot move out of indexed content= will happen.

         This is why we pass ~&args~ to ~parse_config~.

       + The ~clone~ is the most straightforward way, though in this circumstance
         giveing up a little performance.

       + Another way to write this code (=From Jian=):
         #+BEGIN_SRC rust
           fn main() {
               let args: Vec<String> = env::args().collect();
               let config = parse_config(&args);

               println!("Searching for {}", config.query);
               println!("In file {}", config.filename);

               let mut f = File::open(config.filename).expect("file not found");
               // ...snip...
           }

           // Hope the compiler can simplify this in the future
           struct Config<'a> {
               query: &'a str,
               filename: &'a str,
           }

           fn parse_config(args: &[String]) -> Config {
               let query = &args[1];
               let filename = &args[2];
               Config { query, filename }
           }
         #+END_SRC

     - *The Tradeoffs of Using* ~clone~
       =TODO= In Chapter 13 on iterators,
       you'll learn how to use more efficient methods in this kind of situation,
       but for now, it's okay to copy a few strings to keep making progress since
       we'll only make these copies once, and our filename and query string are
       both very small.

**** DONE Creating a Constructor for ~Config~ - 242
     CLOSED: [2017-08-28 Mon 01:15]
     The function ~parse_config~ is used to create the instances of ~Config~.
     Why not make it an associated function of of ~Config~, and change it name to
     ~new~. This is an idiomatic: it essentially a constructor.
     #+BEGIN_SRC rust
       fn main() {
           let args: Vec<String> = env::args().collect();
           let config = Config::new(&args);

           // ...snip...
       }

       // ...snip...

       impl Config {
           fn new(args: &[String]) -> Config {
               let query = args[1].clone();
               let filename = args[2].clone();

               Config { query, filename }
           }
       }
     #+END_SRC

*** DONE Fixing the Error Handling - 243
    CLOSED: [2017-08-28 Mon 01:43]
    - =TODO=
**** DONE Improving the Error Message - 243
     CLOSED: [2017-08-28 Mon 01:35]
     #+BEGIN_SRC rust
       // ...snip...
       fn new(args: &[String]) -> Config {
           if args.len() < 3 {
               panic!("not enought arguments");
           }
           // ...snip...
       }
     #+END_SRC
     The output of NO enough argument is better now, but there is still noise.
     ~panic!~ is GOOD for programming, but it's not good for users.

     Try to use ~Result~ type values.

**** DONE Returning a ~Result~ from ~new~ Instead of Calling ~panic!~ - 244
     CLOSED: [2017-08-28 Mon 01:38]
     #+BEGIN_SRC rust
       impl Config {
           fn new(args: &[String]) -> Rssult<Config, &'static str> {
               if args.len() < 3 {
                   return Err("not enough arguments");
               }

               let query = args[1].clone();
               let filename = args[2].clone();

               Ok(Config { query, filename })
           }
       }
     #+END_SRC
**** DONE Calling ~Config::new~ and Handling Errors - 245
     CLOSED: [2017-08-28 Mon 01:42]
     #+BEGIN_SRC rust
       use std::process;

       fn main() {
           let args: Vec<String> = env::args().collect();

           let config = Config::new(&args).unwrap_or_else(|err| {
               println!("Problem parsing arguemnts: {}", err);
               process::exit(1);
           });

           // ...snip...
       }
     #+END_SRC

     - The ~unwrap_or_else~ method of a ~Result~ type value.

     - /closure/

*** DONE Extracting Logic from main - 246
    CLOSED: [2017-08-28 Mon 02:11]
    #+BEGIN_SRC rust
      fn main() {
          // ...snip...

          println!("Searching for {}", config.query);
          println!("In file {}", config.filename);

          run(config);
      }

      fn run(config: Config) {
          let mut f = File::open(config.filename).expect("file not found");

          let mut contents = String::new();
          f.read_to_string(&mut contents).expect("something went wrong reading the file");

          println!("With text:\n{}", contents);
      }

      // ...snip...
    #+END_SRC

**** DONE Returning Errors from the ~run~ Function - 247
     CLOSED: [2017-08-28 Mon 02:07]
     #+BEGIN_SRC rust
       use std::error::Error;

       // ...snip...

       fn run(config: Config) -> Result<(), Box<Error>> {
           let mut f = File::open(config.filename)?;

           let mut contents = String::new();
           f.read_to_string(&mut contents)?;

           println!("With text:\n{}", contents);

           Ok(())
       }
     #+END_SRC

     - The body of old ~run~ was the body of ~main~, which returns ~()~, now we
       make it return ~Result<(), Box<Error>>~

     - ~Box<Error>~ is a /trait object/. Here it means the returned type should
       have implemented the ~Error~ trait (but no specific type is given).
       =TODO= Chapter 17

     -

**** DONE Handling Errors Returned from ~run~ in ~main~ - 248
     CLOSED: [2017-08-28 Mon 02:11]
     #+BEGIN_SRC rust
       fn main() {
           // ...snip...

           println!("Searching for {}", config.query);
           println!("In file {}", config.filename);

           if let Err(e) = run(config) {
               println!("Application error: {}", e);

               process::exit(1f;)
           }
       }
     #+END_SRC
*** DONE Splitting Code into a Library Crate - 248
    CLOSED: [2017-08-28 Mon 02:14]
    - The following pieces of code will be moved to =src/lib.rs=:
      + The ~run~ function definition
      + The relevant ~use~ statements
      + The difinition of ~Config~
      + The ~Config::new~ function definition

    - The =src/lib.rs=:
      #+BEGIN_SRC rust
        use std::error::Error;
        use std::fs::File;
        use std::io::prelude::*;

        pub struct Config {
            pub query: String,
            pub filename: String,
        }

        impl Config {
            pub fn new(args: &[String]) -> Result<Config, &'static str> {
                if args.len() < 3 {
                    return Err("not enough arguments");
                }

                let query = args[1].clone();
                let filename = args[2].clone();

                Ok(Config { query, filename })
            }
        }

        pub fn run(config: Config) -> Result<(), Box<Error>>{
            let mut f = File::open(config.filename)?;

            let mut contents = String::new();
            f.read_to_string(&mut contents)?;

            println!("With text:\n{}", contents);

            Ok(())
        }
      #+END_SRC

**** DONE Calling the Library Crate from the Binary Crate
     CLOSED: [2017-08-28 Mon 02:19]
     #+BEGIN_SRC rust
       extern crate greprs;

       use std::env;
       use std::process;

       use greprs::Config;

       fn main() {
           let args: Vec<String> = env::args().collect();

           let config = Config::new(&args).unwrap_or_else(|err| {
               println!("Problem parsing arguments: {}", err);
               process::exit(1);
           });

           println!("Searching for {}", config.query);
           println!("In file {}", config.filename);

           if let Err(e) = greps::run(config) {
               println!("Application error: {}", e);

               process::exit(1);
           }
       }
     #+END_SRC

** DONE Developing the Library's Functionality with Test-Driven Development - 250 =TODO=
   CLOSED: [2017-08-30 Wed 05:23]
   - =TODO=
*** TODO Writing a Failing Test - 250
*** TODO Writing Code to Pass the Test - 253
**** TODO Iterating Through Lines with the ~lines~ Method - 253
**** TODO Searching Each Line for the Query - 253
**** TODO Storing Matching Lines - 254
**** TODO Using the ~search~ Function in the ~run~ Function - 254

** DONE Working with Environment Variables - 255 =TODO=
   CLOSED: [2017-08-30 Wed 05:39]
   - x
*** TODO Writing a Failing Test for the Case-Insensitive ~search~ Function - 255
*** TODO Implementing the ~search_case_insensitive~ Function - 257
** TODO Writing Error Message to Standard Error Instead of Standard Output - 260
*** Checking Where Errors Are Written - 260
*** Printing Errors to Standard Error - 261
    - ~println!~ is ONLY capable of printing to standard out (~stdout~).

    - Exmaple:
      Listing 12-23: Writing error messages to ~stderr~ instead of ~stdout~ using
      ~writeln!~
      #+BEGIN_SRC rust
        extern crate greprs;

        use std::env;
        use std::process;
        use std::io::prelude::*;

        use greprs::Config;

        fn main() {
            let args: Vec<String> = env::args().collect();
            let mut stderr = std::io::stderr();

            let config = Config::new(&args).unwrap_or_else(|err| {
                writeln!(
                    &mut stderr,
                    "Problem parsing arguments: {}",
                    err
                ).expect("Could not write to stderr");
                process::exit(1);
            });

            if let Err(e) = greprs::run(config) {
                writeln!(
                    &mut stderr,
                    "Application error: {}",
                    e
                ).expect("Could not write to stderr");

                process::exit(1);
            }
        }
      #+END_SRC

      + we need ~stderr~ to be /mutable/ so we can write to it!

** DONE Summary - 262
   CLOSED: [2017-08-30 Wed 05:32]

* DONE 13. Functional Language Features: Iterators and Closures - 263
  CLOSED: [2017-08-30 Wed 20:36]
** DONE Closures: Anonymous Functions That Can Capture Their Environment - 264
   CLOSED: [2017-08-29 Tue 21:58]
   Rust /closures/ are _allowed_ to capture values from the scope in which they
   are called.

   Rust /functions/ are _NOT allowed_ to capture values from the scope in which
   they are called, which is _different_ from most of they other languages.

*** DONE Creating an Abstraction of Behavior with Closure - 264
    CLOSED: [2017-08-29 Tue 20:50]
**** Refactoring Using Functions - 266
**** Refactoring with Closures to Store Code - 267

*** DONE Closure Type Inference and Annotation - 269
    CLOSED: [2017-08-29 Tue 20:50]
    - The curly braces are _optional_ if the closure body only has one line.

*** DONE Storing Closures Using Generic Parameters and the ~Fn~ Traits - 270
    CLOSED: [2017-08-29 Tue 21:03]
    - Type annotations are required on /functions/ because they're are part of an
      explicit interface exposed to your users.
        Defining this interface rigidly is important for ensuring that everyone
      agrees on what types of values a function uses and returns.

    - /Closures/ aren't used in an exposed interface like this, though: they
      might be stored in variables and used without naming them and exposing them
      to be invoked by users of our library.

    - Add type some annotation(s) to a /closure/:
      #+BEGIN_SRC rust
        // // NO type annotation version:
        // let expensive_closure = |num| {
        // ...

        let expensive_closure = |num: i32| -> i32 {
            println!("calculating slowly...");
            thread::sleep(Duration::from_secs(2));
            num
        };
      #+END_SRC

    - Until now (2017-08-29), a /closure generics/ _CANNOT_ be created and binded
      to a variable (of course, you CAN create it in place and use, but you
      CANNOT bind it).

      This means you'll get an error when compile the code below:
      #+BEGIN_SRC rust
        let example_closure = |x| x;

        let s = example_closure(String::from("hello"));
        let s = example_closure(5);

        // error[E0308]: mismatched types
        //  --> src/main.rs
        //   |
        //   | let n = example_closure(5);
        //   |                         ^ expected struct `std::string::String`, found
        //   integral variable
        //   |
        //   = note: expected type `std::string::String`
        //              found type `{integer}`
      #+END_SRC

      After analysising the first use, the compiler will infer that
      ~example_closure~ has a type of ~String -> String~, and then when it
      analysis the second use, it found a confliction.

*** DONE Limitations of the Cacher Implementation - 273
    CLOSED: [2017-08-29 Tue 21:58]
    - /memoization/ or /lazy evaluation/ (=From Jian= I don't think _or_ is
      proper).

    - _Each closure instance has its own unique anonymous type_:
      that is, even if two closures have the same signature, their types are
      still considered to be different.
        In order to define structs, enums, or function parameters that use
      closures, we use generics and trait bounds like we discussed in
      Chapter 10.

    - All closures implement one of the traits (=TODO= discussed in the next
      section):
      + ~Fn~
      + ~FnMut~
      + ~FnOnce~

    - If a closure has a parameter of type ~i32~ and returns an ~i32~, the trait
      bound we specify is ~Fn(i32) -> i32~.

      For example,
      #+BEGIN_SRC rust
        // src/main.rs
        struct Cacher<T>
            where T: Fn(i32) -> i32
        {
            calculation: T,
            value: Option<i32>,
        }
      #+END_SRC

    - The logic around the ~value~ field that we've just described is defined as:
      #+BEGIN_SRC rust
        // src/main.rs
        impl<T> Cacher<T>
            where T: Fn(i32) -> i32
        {
            fn new(calculation: T) -> Cacher<T> {
                Cacher {
                    calculation,
                    value: None,
                }
            }

            fn value(&mut self, arg: i32) -> i32 {
                match self.value {
                    Some(v) => v,
                    None => {
                        let v = (self.calculation)(arg);
                        self.value = Some(v);
                        v
                    },
                }
            }
        }
      #+END_SRC

      + The fields on the Cacher struct are private since we want Cacher to
        manage their values rather than letting the calling code potentially
        change the values in these fields directly.

      + Now we have the re-implemented ~generate_workout~:
        #+BEGIN_SRC rust
          fn generate_workout(intensity: i32, random_number: i32) {
              let mut expensive_result = Cacher::new(|num| {
                  println!("calculating slowly...");
                  thread::sleep(Duration::from_secs(2));
                  num
              });

              if intensity < 25 {
                  println!(
                      "Today, do {} pushups!",
                      expensive_result.value(intensity)
                  );
                  println!(
                      "Next, do {} situps!",
                      expensive_result.value(intensity)
                  );
              } else {
                  if random_number == 3 {
                      println!("Take a break today! Remember to stay hydrated!");
                  } else {
                      println!(
                          "Today, run for {} minutes!",
                          expensive_result.value(intensity)
                      );
                  }
              }
          }
        #+END_SRC

      + With the implementation of ~Cacher~, the test below will *FAIL*:
        #+BEGIN_SRC rust
          #[test]
          fn call_with_different_values() {
              let mut c = Cacher::new(|a| a);

              let v1 = c.value(1);
              let v2 = c.value(2);

              assert_eq!(v2, 2);
          }
        #+END_SRC

*** DONE Capturing  the Environment with Closures - 274
    CLOSED: [2017-08-29 Tue 21:58]
    - When a /closure/ captures a value from its environment, the /closure/ uses
      memory to store the values for use in the closure body. This use of memory
      is overhead that we don't want pay for in the more common case where we
      want to execute code that doesn't capture its environment.
        Because functions are never allowed to capture their environment,
      defining and using functions will never incur this overhead.

    - _Three_ ways (taking ownership, borrowing immutably, and borrowing
      mutably) of capturing values are encoded in the _three_ ~Fn~ traits as
      follows:
      + ~FnOnce~ _takes ownership_ of the variables it captures from the
        environment and moves those variables into the closure when the closure
        is defined. Therefore, a FnOnce closure cannot be called more than once
        in the same context.

      + ~Fn~ _borrows_ values from the environment _immutably_.

      + ~FnMut~ can change the environment since it _mutably borrows_ values.

    - If we want to FORCE the /closure/ to _take ownership_ of the values it uses
      in the environment, we can use the ~move~ keyword before the parameter
      list.

      _This is mostly useful when passing a closure to a new thread in order to
      move the data to be owned by the new thread._

      =TODO= We'll have more examples of move closures in Chapter 16 when we talk
      about concurrency.

    - For now here's the code with the ~move~ keyword added to the /closure/
      definition and using vectors instead of integers, since integers can be
      /copied/ rather than /moved/:
      #+BEGIN_SRC rust
        // src/main.rs

        fn main() {
            let x = vec![1, 2, 3];

            let equal_to_x = move |z| z == x;

            println!("can't use x here: {:?}", x);

            let y = vec![1, 2, 3];

            assert!(equal_to_x(y));
        }
      #+END_SRC
      This won't compile because of the ~println!~ line.

    - Most of the time when specifying one of the ~Fn~ trait bounds, you can
      start with ~Fn~ and the compiler will tell you if you need ~FnMut~ or
      ~FnOnce~ based on what happens in the closure body.

** DONE Processing a Series of Items with Iterators - 276
   CLOSED: [2017-08-29 Tue 23:10]
   - In Rust, iterators are /lazy/.

   - Example:
     #+BEGIN_SRC rust
       let v1 = vec![1, 2, 3];
       for val in  v1.iter() {
           println!("Got: {}" val);
       }
     #+END_SRC

*** DONE The ~Iterator~ Trait and the ~next~ Method - 277
    CLOSED: [2017-08-29 Tue 23:10]
    #+BEGIN_SRC rust
      trait Iterator {
          type Item;

          fn next(&mut self) => Option<Self::Item>;

          // methods with default implementations elided
      }
    #+END_SRC

    - ~type Item~ and ~Self::Item~.
      Define an associated type with this trait. =TODO= Chapter 19

    - ~next~
      #+BEGIN_SRC rust
        // src/lib.rs

        #[test]
        fn iterator_demostration() {
            let v1 = vec![1, 2, 3];

            let mut v1_iter = v1.iter();

            assert_eq!(v1_iter.next(), Some(&1));
            assert_eq!(v1_iter.next(), Some(&2));
            assert_eq!(v1_iter.next(), Some(&3));
            assert_eq!(v1_iter.next(), None);
        }
      #+END_SRC

*** DONE Methods That Consume the ~Iterator~ - 278
    CLOSED: [2017-08-29 Tue 22:42]
    - The methods that call the ~next~ method are called /consuming adaptors/,
      since calling them uses up the iterator.

    - Example:
      #+BEGIN_SRC rust
        // src/lib.rs

        #[test]
        fn iterator_sum() {
            let v1 = vec![1, 2, 3];

            let v1_iter = v1.iter();

            let total: i32 = v1_iter.sum();

            assert_eq!(total, 6);
        }
      #+END_SRC
      The ~sum~ method takes the ownership of ~v1_iter~, and ~v1_iter~ CANNOT be
      used after the ~let total~ line.

*** DONE Methods That Produce Other ~Iterator~ - 279
    CLOSED: [2017-08-29 Tue 22:50]
    - /iterator adaptor/ :: a method defined on the ~Iterator~ trait that
         produces other iterators.

    - /iterator adaptor/ ~map~
      #+BEGIN_SRC rust
        let v1: Vec<i32> = vec![1, 2, 3];
        v1.iter().map(|x| x + 1);
      #+END_SRC
      Compile this code, and a =warning= shows up do to the lazy feature of the
      iterators: if an iterator isn't consumed, it is not used.
        Use the ~collect~ method to force the value out ,and do something to it.

*** DONE Using Closures That Capture their Environment - 280
    CLOSED: [2017-08-29 Tue 22:57]
    #+BEGIN_SRC rust
      #[derive(PartialEq, Debug)]
      struct Shoe {
          size: i32,
          style: String,
      }

      fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: i32) -> Vec<Shoe> {
          shoes.into_iter()
              .filter(|s| s.size == shoe_size)
              .collect()
      }

      #[test]
      fn filters_by_size() {
          let shoes = vec![
              Shoe { size: 10, style: String::from("sneaker") },
              Shoe { size: 13, style: String::from("sandal") },
              Shoe { size: 10, style: String::from("boot") },
          ];

          let in_my_size = shoes_in_my_size(shoes, 10);

          assert_eq!(
              in_my_size,
              vec![
                  Shoe { size: 10, style: String::from("sneaker") },
                  Shoe { size: 10, style: String::from("boot") },
              ]
          );
      }
    #+END_SRC

    - ~into_iter~ method

*** DONE Creating Our Own Iterators with the ~Iterator~ Trait - 281
    CLOSED: [2017-08-29 Tue 23:10]
    #+BEGIN_SRC rust
      // src/lib.rs

      struct Counter {
          count: u32,
      }

      impl Counter {
          fn new() -> Counter {
              Counter { count: 0 }
          }
      }

      impl Iterator for Counter {
          type Item = u32;

          fn next(&mut self) -> Option<Self::Item> {
              self.count += 1;

              if self.count < 6 {
                  Some(self.count)
              } else {
                  None
              }
          }
      }
    #+END_SRC

**** DONE Using Our ~Counter~ Iterator's ~next~ Method - 282
     CLOSED: [2017-08-29 Tue 23:05]
     #+BEGIN_SRC rust
       #[test]
       fn calling_next_directly() {
           let mut counter = Counter::new();

           assert_eq!(counter.next(), Some(1));
           assert_eq!(counter.next(), Some(2));
           assert_eq!(counter.next(), Some(3));
           assert_eq!(counter.next(), Some(4));
           assert_eq!(counter.next(), Some(5));
           assert_eq!(counter.next(), None);
       }
     #+END_SRC

**** DONE Using Other ~Iterator~ Trait Methods - 282
     CLOSED: [2017-08-29 Tue 23:10]
     #+BEGIN_SRC rust
       #[test]
       fn using_other_iterator_trait_methods() {
           let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                        .map(|(a, b)| a * b)
                                        .filter(|x| x % 3 == 0)
                                        .sum();

           assert_eq!(18, sum);
       }
     #+END_SRC

     ~zip~ produces only four pairs -- ~(5, None)~ is never produced -- ~zip~
     returns ~None~ when either of its input iterators return ~None~.

** DONE Improving Our I/O Project - 283
   CLOSED: [2017-08-30 Wed 19:41]
   Use iterators to make places in the code clearer and more concise.

*** DONE Removing a ~clone~ Using an Iterator - 284
    CLOSED: [2017-08-30 Wed 19:41]
**** DONE Using the Returned Iterator Directly - 284
     CLOSED: [2017-08-30 Wed 12:36]
     - =src/main.rs=
       #+BEGIN_SRC rust
         fn main() {
             // delete
             // let args: Vec<String> = env::args().collect();
             let mut stderr = std::io::stderr();

             // delete
             // let config = Config::new(&args).unwrap_or_else(|err| {
             let config = Config::new(env::args()).unwrap_or_else(|err| {
                 writeln!(
                     &mut stderr,
                     "Problem parsing arguments: {}",
                     err
                 ).expect("Could not write to stderr");;
                 process::exit(1);
             });
             // ...snip...
         }
       #+END_SRC

     - =src/lib.rs=
       #+BEGIN_SRC rust
         impl Config {
             // Use `std::env::Args` instead of `&[String]`
             fn new(args: std::env::Args) -> Result<Config, &'static str> {
                 // ...snip...
             }
         }
       #+END_SRC

**** DONE Using ~Iterator~ Trait Methods Instead of Indexing - 285
     CLOSED: [2017-08-30 Wed 19:40]
     - =src/lib.rs=
       #+BEGIN_SRC rust
         impl Config {
             fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
                 args.next();

                 let query = match args.next() {
                     Some(arg) => arg,
                     None => return Err("Didn't get a query string"),
                 };

                 let filename = match args.next() {
                     Some(arg) => arg,
                     None => return Err("Didn't get a file name"),
                 };

                 Ok(Config {
                     query, filename
                 })
             }
         }
       #+END_SRC

*** DONE Making Code Clearer with Iterator Adaptors - 286
    CLOSED: [2017-08-30 Wed 19:41]
    Use /iterator adapter/ to eliminate the mutable variable.
    #+BEGIN_SRC rust
      fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
          contents.lines()
              .filter(|line| line.contains(query))
              .collect()
      }
    #+END_SRC

** DONE Comparing Performance: Loops vs. Iterators - 287
   CLOSED: [2017-08-30 Wed 20:36]
   - Benchmark by loading the entire contents of "The Adventures of Sherlock
     Holmes" by Sir Arthur Conan Doyle into a String and looking for the word
     =the= in the contents.

     The /iterator/ version is a little faster.

   - /Iterators/ are one of Rust's /zero-cost abstractions/.

   - /zero-cost abstractions/ :: (by Bjarne Stroustrup in "Foundations of C++")
        In general, C++ implementations obey the zero-overhead principle: What
        you don't use, you don't pay for. An further: What you do use, you
        couldn't hand code any better.

   - Example (from an audio decoder):
     The decoding algorithm uses the linear prediction mathematical operation to
     estimate future values based on a linear function of the previous samples.
     #+BEGIN_SRC rust
       let buffer: &mut [i32];
       let coefficients: [i64; 12];
       let qlp_shift: i16;

       for i in 12..buffer.len() {
           let prediction = coefficients.iter()
                                        .zip(&buffer[i - 12..i])
                                        .map(|(&c, &s)| c * s as i64)
                                        .sum::<i64>() >> qlp_shift;

           let delta = buffer[i];
           buffer[i] = prediction as i32 + delta;
       }
     #+END_SRC

** DONE Summary - 289
   CLOSED: [2017-08-30 Wed 19:53]

* TODO 14. More About Cargo and Crates.io - 291
** TODO Customizing Builds with Release Profiles - 292
** TODO Publishing a Crate to Crates.io - 293
*** TODO Making Useful Documentation Comments - 293
**** Commonly Used Sections - 294
**** Documentation Comments as Tests - 295
**** Commenting Contained Items - 295

*** TODO Exporting a Convenient Public API with ~pub use~ - 296
*** TODO Setting Up a Crates.io Account - 300
*** TODO Adding Metadata to a New Crate - 300
*** TODO Publishing to Crates.io - 301
*** TODO Publishing a New Version of an Existing Crate - 302
*** TODO Removing Versions from Crate.io with ~cargo yank~ - 302

** TODO Cargo Workspaces - 303
*** Creating a Workspace - 303
*** Creating the Second Crate in the Workspace - 304
**** Depending on an External Crate in a Workspace - 305
**** Adding a Test to a Workspace - 306

** TODO Installing Binaries from Crates.io with ~cargo install~ - 308
** TODO Extending Cargo with Custom Commands - 309
** TODO Summary - 309

* TODO 15. Smart Pointers - 311
  - /pointer/ :: a generic programming term for something that refers to a
                 location that stores some other data.

  - /smart pointers/ :: data structures that
    + act like a pointer
    + have additional metadata and capabilities, such as /reference counting/.

  - The /smart pointers/ pattern originated in C++.

  - In Rust, an additional difference between /plain references/ and
    /smart pointers/ is that
    + /references/ are a kind of pointer that ONLY borrow data;
    + by contrast, in many cases, /smart pointers/ own the data that they point to.

  - We've actually already encountered a few smart pointers in this book,
    even though we didn't call them that by name at the time.

    For example, ~String~ and ~Vec<T>~ are both /smart pointers/.

  - /smart pointers/
    + _own_ some memory and allow you to manipulate it,
    + have
      * metadata (like their /capacity/)
      * extra capabilities or guarantees (~String~ data will always be valid UTF-8).

  - The characteristics that distinguish a /smart pointer/ from an
    /ordinary struct/ are:
    /smart pointers/ implement the ~Deref~ and ~Drop~ traits, and in this chapter
    we'll be discussing both of those traits and why they're important to smart pointers.
    =TODO= _in this chapter_

  - There won't be complete coverage of all the features of the /smart pointer/
    pattern.

    The ones we cover here are the most common ones from the standard library:
    + ~Box<T>~, for allocating values on the /heap/.

    + ~Rc<T>~, a reference counted type so data can have multiple owners
      (=From Jian= as I know, reference count can solve /circular reference/
      =double check here=).

    + ~RefCell<T>~, which isn't a /smart pointer/ itself, but manages access to
      the /smart pointers/ ~Ref~ and ~RefMut~ to enforce the borrowing rules
      _at runtime_ instead of compile time.

    Along the way, we'll also cover:
    + The /interior mutability/ pattern where an immutable type exposes an API
      for mutating an interior value, and the borrowing rules apply _at runtime_
      instead of compile time.

    + Reference cycles, how they can leak memory, and how to prevent them.

** DONE Using ~Box<T>~ to Point to Data on the Heap - 312
   CLOSED: [2017-08-31 Thu 10:30]
*** Using a ~Box<T>~ to Store Data on the Heap - 313
*** Enabling Recursive Types with Boxes - 314
**** More Information About the Cons List - 314
**** Computing the Size of a Non-Recursive type - 315
**** Using ~Box<T>~ to Get a Recursive Type with a Known Size - 316
     - /box/ is the most straightforward smart pointer.
       Its type is written as ~Box<T>~.

     - Boxes allow you to put a single value on the /heap/.

     - Example (non-compilable):
       #+BEGIN_SRC rust
         enum List {
             Cons(i32, List),
             Nil,
         }

         fn main() {
             let list = Cons(1, Cons(2, Cons(3, Nil)));
         }
       #+END_SRC

     - *More Information About the Cons List*

     - Example (compilable):
       #+BEGIN_SRC rust
         enum List {
             Cons(i32, Box<List>),
             Nil,
         }

         use List::{Cons, Nil};

         fn main() {
             let list = Cons(1,
                             Box::new(Cons(2,
                                           Box::new(Cons(3,
                                                         Box::new(Nil))))));
         }
       #+END_SRC

     - The main area where /boxes/ are useful:
       breaking up an infinite data structure so that the compiler can know what
       size it is.

       =WHY need to know???=

** DONE Treating Smart Pointers Like Regular References with the ~Deref~ Trait - 317
   CLOSED: [2017-08-31 Thu 19:58]
*** Following the Pointer to the Value with the Dereference Operator - 318
*** Using ~Box<T>~ Like a Reference - 318
*** Defining Our Own Smart Pointer - 319
*** Treating a Type Like a Reference by Implementing the ~Deref~ Trait - 320
*** Implicit ~Deref~ Coercions with Functions and Methods - 321
*** How ~Deref~ Coercion Interacts with Mutability - 322

   - The ~Deref~ allows us to override ~*~ (the dereference operator).

   - Override ~*~ for smart pointers makes accessing the data behind the smart
     pointer convenient.
     + With /references/ that are _NOT_ /smart pointers/, there's _only one_
       value that the reference is pointing to, so the dereference operation is
       straightforward.

     + /Smart pointers/ can also store metadata about the pointer of the data.

       We usually do ONLY want the data, NOT the metadata. If we don't override
       the ~*~ (through implementing the ~Deref~ trait), we need to manually
       strip out the metadata.

   - =Review= /dereference operator/ was mentioned in Chapter 8.
     #+BEGIN_SRC rust
       let mut x = 5;
       {
           let y = &mut x;
           ,*y += 1
       }

       assert_eq!(6, x);
     #+END_SRC

   - Example:
     #+BEGIN_SRC rust
       use std::ops::Deref;

       struct Mp3 {
           audio: Vec<u8>,
           artist: Option<String>,
           title: Option<String>,
       }

       impl Deref for Mp3 {
           type Target = Vec<u8>;

           fn deref(&self) -> &Vec<u8> {
               &self.audio
           }
       }

       fn main() {
           let my_favorite_song = Mp3 {
               // we would read the actual audio data from an mp3 file
               audio: vec![1, 2, 3],
               artist: Some(String::from("Nirvana")),
               title: Some(String::from("Smells Like Teen Spirit")),
           };

           assert_eq!(vec![1, 2, 3], *my_favorite_song);
       }
     #+END_SRC

   - =TODO= =TODO=
     The ~type Target = T;~ syntax is defining an /associated type/, which is
     covered in more detail in _Chapter 19_. Don't worry about that part of the
     example too much; it is a slightly different way of declaring a generic
     parameter.

   - In order to get a ~&~ reference that ~*~ can dereference, the compiler
     expands ~*my_favorite_song~ to:
     ~*(my_favorite_song.deref())~

    - Rust tends to favor _explicitness_ over _implicitness_.

      One exception: /deref coercions/ of arguments to functions and methods.

    - A /deref coercion/ will automatically convert a reference to any pointer
      into a reference to that pointer's contents.

    - A /deref coercion/ happens when the reference type of the argument passed
      into the function _differs_ from the reference type of the parameter
      defined in that function's signature.

    - /Deref coercion/ was added to Rust to make calling functions and methods
      _NOT_ need as many explicit references and dereferences with ~&~ and ~*~.

    - Example:
      #+BEGIN_SRC rust
        fn compress_mp3(audio: &[u8]) -> Vec<u8> {
            // the actual implementation would go here
        }

        // If there is NOT *deref coercions*, we need
        compress_mp3(my_favorite_song.audio.as_slice());

        // Luckily that we have *deref coercions*
        compress_mp3(&my_favorite_song);
      #+END_SRC

    - Similar to how we use the ~Deref~ trait to override ~*~ on ~&T~'s, there is
      also a ~DerefMut~ trait for overriding ~*~ on ~&mut T~.

    - Rust does /deref coercion/ when it finds types and trait implementations in
      _three_ cases:
      + From ~&T~ to ~&U~ when ~T: Deref<Target=U>~.
      + From ~&mut T~ to ~&mut U~ when ~T: DerefMut<Target=U>~.
      + From ~&mut T~ to ~&U~ when ~T: Deref<Target=U>~.

** DONE Running Code on Cleanup with the ~Drop~ Trait - 323
   CLOSED: [2017-08-31 Thu 21:34]
*** Dropping a Value Early with ~std::mem::drop~ - 325
    - =TODO=

    - The ~Drop~ trait requires us to implement one method named ~drop~ that takes
      a /mutable reference/ to ~self~.

    - Example:
      #+BEGIN_SRC rust
        // Filename: src/main.rs

        struct CustomSmartPointer {
            data: String,
        }

        impl Drop for CustomSmartPointer {
            fn drop(&mut self) {
                println!("Dropping CustomSmartPointer!");
            }
        }

        fn main() {
            let c = CustomSmartPointer { data: String::from("some data") };
            println!("CustomSmartPointer created.");
            println!("Wait for it...");
        }

        // CustomSmartPointer created.
        // Wait for it...
        // Dropping CustomSmartPointer!
      #+END_SRC

    - Manually drop (use ~std::mem::drop~):
      #+BEGIN_SRC rust
        fn main() {
            let c = CustomSmartPointer { data: String::from("some data") };
            println!("CustomSmartPointer created.");
            drop(c);
            println!("Wait for it...");
        }

        // CustomSmartPointer created.
        // Dropping CustomSmartPointer!
        // Wait for it...
      #+END_SRC
      + We are NOT allowed to call the ~drop~ method that we defined (like
        ~c.drop~) directly. If we did it, the error message will be
        =explicit destructor calls not allowed=.

      + We are also NOT allowed to call ~Drop::drop~ directly because Rust inserts
        its call to ~Drop::drop~ automatically when the value goes out of scope,
        if we are allowed to do this manually, there will be doulbe (or multiple)
        free problem.

      + The definition of ~std::mem::drop~:
        #+BEGIN_SRC rust
          pub mod std {
              pub mod mem {
                  pub fn drop<T>(x: T) { }
              }
          }
        #+END_SRC
        NO function body. It only takes the ownership of ~x~.

    - We've gone over ~Box<T>~ and some of the characteristics of smart pointers.
      =TODO= let's talk about a few other smart pointers defined in the standard
      library that add different kinds of useful functionality.

** DONE ~Rc<T>~, the Reference Counted Smart Pointer - 326
   CLOSED: [2017-09-01 Fri 14:39]
   - Sometimes, you may actually need multiple owners.
     For this, use ~Rc<T>~, whose name is an abbr for /reference counting/.

   - ~Rc<T>~ is for use when we want to allocate some data on the /heap/ for
     multiple parts of our program to read, and we _CANNOT_ determine at compile
     time which part of our program using this data will finish using it last.

     (If we knew which part would finish last, we could make that part the owner
      of the data and the normal ownership rules enforced at compile time would
      kick in
      =FROM JIAN= I don't think this sentence is completely right.
      I think
      If we only know the last owner, and we don't know the order of operations,
      which may not be fixed everytime, ~Rc<T>~ is still useful.).

   - =IMPORTANT=
     ~Rc<T>~ is only for use in single-threaded scenarios. If you try to use
     ~Rc<T>~ with multiple threads, you'll get a compile-time error.
     =TODO=
     the next chapter on concurrency will cover how to do reference counting in
     multithreaded programs.

*** DONE Using ~Rc<T>~ to Share Data - 327
    CLOSED: [2017-09-01 Fri 14:38]
    - With ~Box<T>~ you cannot share data:
      #+BEGIN_SRC rust
        // src/main.rs
        enum List {
            Cons(i32, Box<List>),
            Nil,
        }

        use List::{Cons, Nil};

        fn main() {
            let a = Cons(5,
                         Box::new(Cons(10,
                                       Box::new(Nil))));

            let b = Cons(3, Box::new(a));
            let b = Cons(4, Box::new(a));
        }

        // error[E0382]: use of moved value: `a`
        //   --> src/main.rs:13:30
        //    |
        // 12 |     let b = Cons(3, Box::new(a));
        //    |                              - value moved here
        // 13 |     let c = Cons(4, Box::new(a));
        //    |                              ^ value used here after move
        //    |
        //    = note: move occurs because `a` has type `List`, which does not
        //    implement the `Copy` trait
      #+END_SRC

    - We could change the definition of ~Cons~ to hold references instead, but
      then we'd have to specify /lifetime/ parameters and we'd have to construct
      elements of a list such that every element lives at least as long as the
      list itself. Otherwise, the borrow checker won't even let us compile the
      code. =TODO=

    - Use ~Rc<T>~
      #+BEGIN_SRC rust
        // src/main.rs
        enum List {
            Cons(i32, Rc<List>),
            Nil,
        }

        use List::{Cons, Nil};
        use std::rc::Rc; // why here? why not before the `List` definition.

        fn main() {
            let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
            let b = Cons(3, a.clone());
            let b = Cons(4, a.clone());
        }
      #+END_SRC

*** DONE Cloning an ~Rc<T>~ Increases the Reference Count - 329
    CLOSED: [2017-09-01 Fri 14:38]
    - The ~clone~ method of the ~Rc<T>~ dosen't make a full copy, and it just
      increase the /reference count/.

    - Use ~Rc::strong_count~ to returns the /reference count/.
      For example,
      #+BEGIN_SRC rust
        fn main() {
            let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
            println!("rc = {}", Rc::strong_count(&a));
            let b = Cons(3, a.clone());
            println!("rc after creating b = {}", Rc::strong_count(&a));
            {
                let c = Cons(4, a.clone());
                println!("rc after creating c = {}", Rc::strong_count(&a));
            }
            println!("rc after c goes out of scope = {}", Rc::strong_count(&a));
        }

        // rc = 1
        // rc after creating b = 2
        // rc after creating c = 3
        // rc after c goes out of scope = 2
      #+END_SRC
      The ~Rc<T>~ implements the ~Drop~ trait, and that's why the /reference
      count/ of a ~Rc<T>~ value decreases when the variables include this ~Rc<T>~
      go out of their scopes.

    - ~Rc<T>~ only allows you to share data for multiple parts of your program to
      read through _immutable references_ to the ~T~ value the ~Rc<T>~ contains.

      This follows the requirement mentioned in Chapter 4:
      two mutable borrows to the same palce can cause data races and
      inconsistencies.

    - However, mutating data is very useful in some scenarios.
      =TODO= /interior mutability pattern/ and the ~RefCell<T>~ type that we can
      use in conjunction with an ~Rc<T>~ to work with this restriction on
      immutability.

** DONE ~RefCell<T>~ and the Interior Mutability Pattern - 330
   CLOSED: [2017-09-01 Fri 16:31]
   - interior mutability ::

*** Enforcing Borrowing Rules at Runtime with ~RefCell<T>~ - 330
*** DONE Interior Mutability: A Mutable Borrow to an Immutable Value - 331
**** A Use Case for Interior Mutability: Mock Objects - 332
**** Keeping Track of Borrows at Runtime with ~RefCell<T>~ - 336
    - Similarly to ~Rc<T>~, ~RefCell<T>~ is only for use in _single-threaded_
      scenarios.

      We'll talk about how to get the functionality of ~RefCell<T>~ in a multi-
      threaded program in the next chapter on concurrency =TODO=.

      For now, all you need to know is that if you try to use ~RefCell<T>~ in a
      multithreaded context, you'll get a compile time error.

    - With references, we use the ~&~ and ~&mut~ syntax to create references and
      mutable references, respectively.

      _But_ with ~RefCell<T>~, we use the ~borrow~ and ~borrow_mut~ methods, which
      are part of the _safe API_ that ~RefCell<T>~ has.
      + ~borrow~ returns the smart pointer type ~Ref~
      + ~borrow_mut~ returns the smart pointer type ~RefMut~.

     - Example:
       =NOTE=: ~data~ is immutable, though we change its inner value through
       ~RefCell<T>~.

       #+BEGIN_SRC rust
         // src/main.rs

         use std::cell::RefCell;

         fn a_fn_that_immutably_borrows(a: &i32) {
             println!("a is {}", a);
         }

         fn a_fn_that_mutably_borrows(b: &mut i32) {
             *b += 1;
         }

         fn demo(r: &RefCell<i32>) {
             a_fn_that_immutably_borrows(&r.borrow());
             a_fn_that_mutably_borrows(&mut r.borrow_mut());
             a_fn_that_immutably_borrows(&r.borrow());
         }

         fn main() {
             let data = RefCell::new(5);
             demo(&data);
         }

         // a is 5
         // a is 6
       #+END_SRC

*** Having Multiple Owners of Mutable Data by Combining ~Rc<T>~ and ~RefCell<T>~ - 337

** Reference Cycles Can Leak Memory - 339
*** Creating a Reference Cycle - 339
*** Preventing Reference Cycles: Turning an ~Rc<T>~ into a ~Weak<T>~ - 341
**** Creating a Tree Data Structure: a Node with Child Nodes - 342
**** Adding a Reference from a Child to Its Parent - 343
**** Visualizing Changes to ~strong_count~ and ~weak_count~ - 344

** Summary - 346

* TODO 16. Fearless Concurrency - 347
** TODO Using Threads to Run Code Simultaneously - 348
*** TODO Creating a New Thread with ~spawn~ - 350
*** TODO Waiting for All Threads to Finish Using ~join~ Handles - 351
*** TODO Using ~move~ Closures with Threads - 353

** TODO Using Message Passing to Transfer Data Between Threads - 355
*** TODO Channels and Ownership Transference - 358
*** TODO Sending Multiple Values and Seeing the Receiver Waiting - 359
*** TODO Create Multiple Producers by Cloning the Transmitter - 360

** TODO Shared-State Concurrency - 361
*** TODO Using Mutexes to Allow Access to Data from One Thread at a Time - 362
**** TODO The API of ~Mutex<T>~ - 362
**** TODO Sharing a ~Mutex<T>~ Between Multiple Threads - 363
**** TODO Multiple Ownership with Multiple Threads - 366
**** TODO Atomic Reference Counting with ~Arc<T>~ - 367

*** TODO Similarities Between ~RefCell<T>~ / ~Rc<T>~ and ~Mutex<T>~ / ~Arc<T>~ - 368

** TODO Extensible Concurrency with the ~Sync~ and ~Send~ Traits - 368
*** TODO Allowwing Transference of Ownership Between Threads with Send - 369
*** TODO Allowwing Access from Multiple Thread with Sync - 369
*** TODO Implementing ~Send~ and ~Sync~ Manually is Unsafe - 369

** TODO Summary - 370

* TODO 17. Object-Oriented Programming Features of Rust - 371
  - Object-Oriented Programming is a way of modeling programs that originated
    with *Simula* in the 1960s and became popular with *C++* in the 1990s.
    =From Jian= The milestones should be mentioned: *Smalltalk* and *Java*.

  - There are many _competing definitions_ for what OOP is:
    + under some definitions, Rust is object-oriented;
    + under other definitions, Rust is not.

    =From Jian= Let's see which parts is the good parts in OOP in Rust's point of
    view.

  - In this chapter, we'll explore
    + some characteristics that are commonly considered to be object-oriented.
    + how those characteristics translate to idiomatic Rust.

** DONE Characteristics of Object-Oriented Languages? - 371
   CLOSED: [2017-08-30 Wed 21:26]
   There isn't consensus in the programming community about the features a
   language needs to have in order to be called object-oriented.

*** DONE Objects Contain Data and Behavior - 372
    CLOSED: [2017-08-30 Wed 20:53]
    - "The Gang of Four book" defines OOP in this way:
       #+BEGIN_QUOTE
       Object-oriented programs are made up of /objects/.

       An object _packages_ both data and the procedures that operate on that
       data.

       The procedures are typically called /methods/ or /operations/.
       #+END_QUOTE

    - In Rust, /structs/ provide the same functionality as of /objects/, though
      we don't call them /objects/.

*** DONE Encapsulation That Hides Implementation Details - 372
    CLOSED: [2017-08-30 Wed 21:09]
    - /encapsulation/ :: the implementation details of an object aren't
         accessible to code using that object.

    - The public API is important. If the code is well encapsulated, and
      the API is fixed, it should let user fill the internal change when
      only considering the results (of course, things like speed can change).

    - Example:
      #+BEGIN_SRC rust
        pub struct AveragedCollection {
            list: Vec<i32>,
            average: f64,
        }

        impl AveragedCollection {
            pub fn add(&mut self, value: i32) {
                self.list.push(value);
                self.update_average();
            }

            pub fn remove(&mut self) -> Option<i32> {
                let result = self.list.pop();
                match result {
                    Some(value) => {
                        self.update_average();
                        Some(value)
                    },
                    None => None,
                }
            }

            pub fn average(&self) -> f64 {
                self.average
            }

            fn update_average(&mut self) {
                let total: i32 = self.list.iter().sum();
                self.average = total as f64 / self.list.len() as f64;
            }
        }
      #+END_SRC

      + The fields of ~AveragedCollection~ are private by default.
        The are not parts of the public API the object offers.

      + The public API are the parts with ~pub~ keywords.

      + Since the inner data structure is not a part of the public API, we can
        later change the type of the field ~list~ to the type of HashSet.

        As long as the signature of the ~add~, ~remove~, and ~average~ stay the
        same, code using ~AveragedCollection~ wouldn't need to change.

      + If we expose the ~list~ as public API (with ~pub~), not only the data
        structure change can change the API, but also the public API of the new
        data structure of the ~list~ is mixed into the public API.

        This can completely destory the /encapsulation/:
        * different type has different opertions.
        * detials that doesn't follow any common contract become parts of the
          public API.

        The result is all the code using ~AveragedCollection~ may need to be
        changed.

*** DONE Inheritance as a Type System and as Code Sharing - 374 =RE-READ=
    CLOSED: [2017-08-30 Wed 21:26]
    - Rust doesn't support /inheritance/.
      However, Rust use /traits/ (=From Jian= and /enums/, which I think should
      be mentioned in this section, though it is NOT) to do

    - While many people use "polymorphism" to describe inheritance, it's actually
      a specific kind of polymorphism, called "sub-type polymorphism."

      There are other forms as well;

      a generic parameter with a trait bound in Rust is also polymorphism, more
      specifically "parametric polymorphism."

      The exact details between the different kinds of polymorphism aren't
      crucial here (=TODO= =From Jian= BUT I want to know), so don't worry too
      much about the details:
      just know that
      _Rust has multiple polymorphism-related features, unlike many OOP languages_.
      =TODO=

** TODO Using Trait Objects That Allow for Values of Differnt Types - 375
   =RE-READ=
   /enums/ is a way we can use to hold some variants, and use them as one
   single data type.

   This is useful, but not enough -- it is closed, and we can't add variants
   to an /enum/ after its definition.

   /traits/ is a way to get rid of the _closed_ feature of /enums/.

   Example: In a GUI library, a lot of /structs/ need a ~draw~ method. We don't
   know how many /structs/ we have -- acutally, the number can increase.
   /enums/ CANNOT help, but /taits/ can.


*** DONE Defining a Trait for the Common Behavior - 375
    CLOSED: [2017-08-30 Wed 22:22]
    - In Rust, though, we can define a trait that we'll name ~Draw~ and that will
      have one method named ~draw~. Then we can define a vector that takes a
      /trait object/, which is _a trait behind some sort of pointer_, such as a
      ~&~ reference or a ~Box<T>~ smart pointer.

    - =TODO= We'll talk about the reason trait objects have to be behind a
      pointer in Chapter 19.

    - Example:
      #+BEGIN_SRC rust
        // src/lib.rs

        pub trait Draw {
            fn draw(&self);
        }

        pub struct Screen {
            pub components: Vec<Box<Draw>>,
        }

        impl Screen {
            pub fn run(&self) {
                for component in self.components.iter() {
                    component.draw();
                }
            }
        }
      #+END_SRC

      In the below code, the ~components~ can only be a _homogeneous_
      collections, which is not required in the above code:
      #+BEGIN_SRC rust
        pub struct Screen<T: Draw> {
            pub components: Vec<T>,
        }

        impl Screen<T>
            where T: Draw {
            pub fn run(&self) {
                for component in self.components.iter() {
                    component.draw();
                }
            }
        }
      #+END_SRC
*** DONE Implementations the Trait - 377
    CLOSED: [2017-08-30 Wed 22:30]
    #+BEGIN_SRC rust
      // src/lib.rs

      pub struct Button {
          pub width: u32,
          pub height: u32,
          pub label: String,
      }

      impl Draw for Button {
          fn draw(&self) {
              // Code to actually draw a button
          }
      }
    #+END_SRC

    #+BEGIN_SRC rust
      // src/main.rs

      extern crate rust_gui;
      use rust_gui::{Draw, Screen, Button};

      struct SelectBox {
          width: u32,
          height: u32,
          options: Vec<String>,
      }

      impl Draw for SelectBox {
          fn draw(&self) {
              // Code to acutally draw a select box
          }
      }

      fn main() {
          let screen = Screen {
              components: vec![
                  Box::new(SelectBox {
                      width: 75,
                      height: 10,
                      options: vec![
                          String::from("Yes"),
                          String::from("Maybe"),
                          String::from("No")
                      ],
                  }),
                  Box::new(Button {
                      width: 50,
                      height: 10,
                      label: String::from("OK"),
                  }),
              ],
          };

          screen.run();
      }
    #+END_SRC

    - /duck typing/

*** DONE Trait Objects Perform Dynamic Dispatch - 380
    CLOSED: [2017-08-30 Wed 22:43]
    - The code that results from /monomorphization/ is doing static dispatch:
      when the method is called, the code that goes with that method call
      _has been determined_ at compile time, and looking up that code is very
      _FAST_.

    - When we use trait objects, the compiler can't perform /monomorphization/.
      Rust can figure it out when a method is called at /runtime/ (of course,
      there is runtime cost).
        This is called /dynamic dispatch/.

    - Dynamic dispatch also _prevents_ the compiler from choosing to /inline/ a
      method's code, which _prevents some optimizations_.

      Tradeoff between performance (extra runtime cost) and extra flexibility.

*** TODO Object Safety is Required for Trait Objects - 380 =RE-READ= =HARD=
    =MORE EXAMPLES REQUIRED=
    NOT all /traits/ can be made into /trait objects/; ONLY /object safe/
    /traits/ can.

    - The requirements of /object safe/:
      + The trait does NOT require ~Self~ to be ~Sized~
      + All of the trait's methods are /object safe/.

    - ~Self~ :: a keyword that is an alias for the type that we're implementing
                traits or methods on.

    - ~Sized~ :: a marker trait like the ~Send~ and ~Sync~ traits that we talked
                 about in Chapter 16 =TODO=.

    - ~Sized~ is automatically implemented on types that have a known size at
      compile time, such as ~i32~ and references.

      Types that do NOT have a known size include slices(~[T]~) and
      /trait objects/.

    - ~Sized~ is an implicit trait bound on all generic type parameters by
      default. Most useful operations in Rust require a type to be ~Sized~, so
      making ~Sized~ a default requirement on trait bounds means we don't have
      to write ~T: Sized~ with most every use of generics. If we want to be able
      to use a trait on slices, however, we need to opt out of the ~Sized~ trait
      bound, and we can do that by specifying ~T: ?Sized~ as a trait bound.
      =TODO=

    - /supertraits/ =TODO= CHAPTER 19

    - The reason a trait like ~Foo~ that requires ~Self~ to be ~Sized~ is
      _NOT allowed_ to be a /trait object/ is that it would be impossible to
      implement the trait ~Foo~ for the /trait object/ ~Foo~:
      /trait objects/ are NOT sized, but ~Foo~ requires ~Self~ to be ~Sized~.

      _A type can't be both sized and unsized at the same time!_

    - A method is /object safe/ if either:
      + It requires ~Self~ to be ~Sized~ or

      + It meets _ALL_ three of the following:
        * It _MUST NOT_ have any generic type parameters

        * Its first argument _MUST_ be
          - of type ~Self~
            or
          - a type that dereferences to the ~Self~ type (that is, it must be a
            method rather than an associated function and have ~self~, ~&self~,
            or ~&mut self~ as the first argument)

        * It _MUST NOT_ use ~Self~ anywhere else in the signature except for the
          first argument.

** TODO Implementating on Object-Oriented Design Pattern - 382
*** TODO Defining Post and Creating a New Instance in the Draft State - 383
*** TODO Storing the Text of the Post Content - 384
*** TODO Ensuring the Content of a Draft Post Is Empty - 384
*** TODO Requesting a Review of the Post Changes its State - 385
*** TODO Adding the approve Method that Changes the Behavior of ~content~ - 386
*** TODO Trade-offs of the State Pattern - 389
**** TODO Encoding States and Behavior as Types
**** TODO Implementing Transitions as Transformations into Different Types

** TODO Summary - 393

* DONE 18. Patterns and Maching - 395
  CLOSED: [2017-08-30 Wed 04:43]
  - =TODO= the difference between /refutable/ and /irrefutable/ patterns,
** DONE All the Places Patterns May be Used - 396
   CLOSED: [2017-08-30 Wed 00:58]
*** DONE ~match~ Arms - 396
    CLOSED: [2017-08-29 Tue 23:15]
*** DONE Conditional ~if let~ Expressions - 396
    CLOSED: [2017-08-29 Tue 23:22]
    It's possbile to mix and match ~if let~, ~else if~, and ~else if let~.
    =IMPORTANT= NOT like ~match~!!! NO exhaustiveness check!!!

    #+BEGIN_SRC rust
      fn main() {
          let favorite_color: Option<&str> = None;
          let is_tuesday = false;
          let age: Result<u8, _> = "34".parse();

          if let Some(color) = favorite_color {
              println!("Using your favorite color, {}, as the background", color);
          } else if is_tuesday {
              println!("Tuesday is green day!");
          } else if let Ok(age) = age {
              // shadowed variables !!!
              if age > 30 {
                  println!("Using purple as the background color");
              } else {
                  println!("Using orange as the background color");
              }
          } else {
              println!("Using blue as the background color");
          }
      }
    #+END_SRC

*** DONE ~while let~ Conditional Loops - 398
    CLOSED: [2017-08-30 Wed 00:43]
    #+BEGIN_SRC rust
      let mut stack = Vec::new();

      stack.push(1);
      stack.push(2);
      stack.push(3);

      while let Some(top) = stack.pop() {
          println!("{}", top);
      }
    #+END_SRC

*** DONE ~for~ loops - 398
    CLOSED: [2017-08-30 Wed 00:44]
    #+BEGIN_SRC rust
      let v = vec![1, 2, 3];

      for (index, value) in v.iter().enumerate() {
          println!("{} is at index {}", value, index);
      }
    #+END_SRC

*** DONE ~let~ Statements - 399
    CLOSED: [2017-08-30 Wed 00:45]
    =TODO=We saw another example of destructuring a tuple in _Chapter 16_,
    Listing 16-6, where we destructured the return value of ~mpsc::channel()~
    into the ~tx~ (transmitter) and ~rx~ (receiver) parts.

*** DONE Function Parameters - 400
    CLOSED: [2017-08-30 Wed 00:58]
    #+BEGIN_SRC rust
      // src/main.rs

      fn print_coordinates(&(x, y): &(i32, i32)) {
          println!("Current location: ({}, {})", x, y);
      }

      fn main() {
          let point = (3, 5);
          print_coordinates(&point);
      }
    #+END_SRC

    - =IMPORTANT=
      One difference between the places we can use patterns is that with
      + ~for~ loops
      + ~let~
      + in function parameters
      the patterns must be /irrefutable/. =TODO= next section.

** DONE Refutability: Whether a Pattern Might Fail to Match - 401
   CLOSED: [2017-08-30 Wed 01:10]
   - Patterns come in _two_ forms:
     + /refutable/: patterns which can fail to match for some possible value.

     + /irrefutable/: patterns which CANNOT fail to match for any possible value.

   - ~let~ statements, function parameters, and ~for~ loops are restricted to
     _ONLY accept_ /irrefutable patterns/,

     since there's nothing correct the program could do if the pattern fails to
     match.

   - ~if let~, and ~while let~ expressions are restricted to _ONLY accept_
     /refutable patterns/,

     since they're made to handle possible failure and we wouldn't need their
     functionality if the pattern could never fail.

   - When we use these two concepts, nothing complicated.

     What we really need to know is that when these concepts show up in an error
     message, which should know what do they mean.

   - For example,
     #+BEGIN_SRC rust
       let Some(x) = some_option_value; // Can be `None`

       // error[E0005]: refutable pattern in local binding: `None` not covered
       //  --> <anon>:3:5
       //   |
       // 3 | let Some(x) = some_option_value;
       //   |     ^^^^^^^ pattern `None` not covered
     #+END_SRC

     Solution:
     #+BEGIN_SRC rust
       if let Some(x) = some_option_value {
           println!("{}", x);
       }
     #+END_SRC

   - For example,
     #+BEGIN_SRC rust
       if let x = 5 {
           println!("{}", x);
       };

       // error[E0162]: irrefutable if-let pattern
       //  --> <anon>:2:8
       //   |
       // 2 | if let x = 5 {
       //   |        ^ irrefutable pattern
     #+END_SRC

     Solution: ~let x = 5; println!("{}", x);~ or just ~println!("{}", x);~

** DONE Pattern Syntax - 402
   CLOSED: [2017-08-30 Wed 04:43]
*** DONE Matching Literals - 402
    CLOSED: [2017-08-30 Wed 01:12]
    #+BEGIN_SRC rust
      // Suppose `x` is a number

      match x {
          1 => println!("one"),
          2 => println!("two"),
          3 => println!("three"),
          _ => println!("anything"),
      }
    #+END_SRC
    This is like a non-fall-through switch in C/C++/Java.

*** DONE Matching Named Variables - 403
    CLOSED: [2017-08-30 Wed 01:19]
    - Named variables are irrefutable patterns that match any value.
      For example, if an arm of ~match~ is ~Some(y)~, here ~y~ is the named
      variables.

    - In order to make a ~match~ expression that compares the values of the outer
      ~x~ and ~y~ rather than introducing a shadowed variable, we would need to
      use a /match guard/ conditional instead.

      =TODO= We'll be talking about match guards later in this section.

*** DONE Multiple Patterns - 404
    CLOSED: [2017-08-30 Wed 01:19]
    Use ~|~
    #+BEGIN_SRC rust
      match x {
          1 | 2 => println!("one or two"),
          3 => println!("three"),
          _ => println!("anything"),
      }
    #+END_SRC

*** DONE Matching Ranges of Values with the ~...~ Syntax - 404
    CLOSED: [2017-08-30 Wed 01:23]
    - ~...~ is used to match an _inclusive_ range.

    - Ranges are only allowed with
      + numeric values (=TODO= =From Jian= CANNOT be Flotaing, Right???)
      + ~char~ values

    - Example:
      #+BEGIN_SRC rust
        // Suppose `x` is number
        match x {
            1 ... 5 => println!("one through five"),
            _ => println!("something else"),
        }
      #+END_SRC

      #+BEGIN_SRC rust
        match x {
            'a' ... 'j' => println!("early ASCII letter"),
            'k' ... 'z' => println!("late ASCII letter"),
            _ => println!("something else"),
        }
      #+END_SRC

*** DONE Destructuring to Break Apart Values - 405
    CLOSED: [2017-08-30 Wed 01:30]
    - Patterns can be used to _destructure_
      + structs
      + enums
      + tuples
      + references

    - Example:
      #+BEGIN_SRC rust
        struct Point {
            x: i32,
            y: i32,
        }

        fn main() {
            let p = Point { x: 0, y: 7 };

            let Point { x, y } = p;
            assert_eq!(0, x);
            assert_eq!(7, y);

            // The below code is also available:
            //
            // let Point { x: a, y: b } = p;
            // assert_eq!(0, a);
            // assert_eq!(7, b);
        }
      #+END_SRC

    - Example:
      #+BEGIN_SRC rust
        fn main() {
            let p = Point { x: 0, y: 7 };

            match p {
                Point { x, y: 0 } => println!("On the x axis at {}", x),
                Point { x: 0, y } => println!("On the y axis at {}", y),
                Point { x, y } => println!("On neither axis: ({}, {})", x, y),
            }
        }
      #+END_SRC

    - Example:
      #+BEGIN_SRC rust
        let points = vec![
            Point { x: 0, y: 0 },
            Point { x: 1, y: 5 },
            Point { x: 10, y: -3 },
        ];

        let sum_of_squares: i32 = points
            .iter()
            .map(|&Point {x, y}| x * x + y * y)
            .sum();


        // If we forget the `&`
        //
        // The error message is:
        // error[E0308]: mismatched types
        //   -->
        //    |
        // 14 |         .map(|Point {x, y}| x * x + y * y)
        //    |               ^^^^^^^^^^^^ expected &Point, found struct `Point`
        //    |
        //    = note: expected type `&Point`
        //               found type `Point`
      #+END_SRC

*** DONE Ignoring Values in a Pattern - 409
    CLOSED: [2017-08-30 Wed 01:48]
    ~_~ and ~..~

**** DONE Ignoring an Entire Value with ~_~
     CLOSED: [2017-08-30 Wed 01:33]
     - Example:
       #+BEGIN_SRC rust
         fn foo(_: i32) {
             // code goes here
         }
       #+END_SRC

     - In cases such as implementing a /trait/, where you need a certain type
       signature, using an underscore lets you ignore a parameter, and the
       compiler won't warn about unused function parameters like it would if we
       had used a name instead.

       _Use underscore to avoid that the compiler warns you about unused function
       parameters_

**** DONE Ignoring Parts of a Value with a Nested ~_~
     CLOSED: [2017-08-30 Wed 01:35]
     #+BEGIN_SRC rust
       match x {
           Some(_) => println!("got a Some and I don't care what's inside"),
           None => (),
       }


       // let numbers = (2, 4, 8, 16, 32);

       match numbers {
           (first, _, third, _, fifth) => {
               println!("Some numbers: {}, {}, {}", first, third, fifth)
           },
       }
     #+END_SRC

**** DONE Ignoring an Unused Variable by Starting its Name with an Underscore
     CLOSED: [2017-08-30 Wed 01:48]
     - The difference between ~_x~ and ~_~:
       + ~_x~ still binds the value, though there is no warning when ~_x~ is
         unused.

       + ~_~ doesn't bind at all.

     - Underscore prefixed variables are useful when you want to /move/ a
       variable when do pattern matchings -- disable that variable.

       #+BEGIN_SRC rust
         let s = Some(String::from("Hello!"));

         if let Some(_s) = s {
             println!("found a string");
         }

         // If there is a
         //
         // `println!("{:?}", s);`
         //
         // there will be a compiling error.
       #+END_SRC

**** DONE Ignoring Remaining Parts of a Value with ~..~
     CLOSED: [2017-08-30 Wed 01:48]
     - Example:
       #+BEGIN_SRC rust
         struct Point {
             x: i32,
             y: i32,
             z: i32,
         }

         let origin = Point { x: 0, y: 0, z: 0 };

         match origin {
             Point { x, .. } => println!("x is {}", x),
         }
       #+END_SRC

       Using ~..~ is shorter to type than having to list out ~y: _~ and ~z: _~.

       =IMPORTANT=
       The ~..~ pattern is especially useful when working with structs that have
       lots of fields in situations where only one or two fields are relevant.

     - ~..~ will expand to _as many values as it needs to be_.
       #+BEGIN_SRC rust
         fn main() {
             let numbers = (2, 4, 8, 16, 32);

             match numbers {
                 (first, .., last) => {
                     println!("Some numbers: {}, {}", first, last);
                 },
             }
         }
       #+END_SRC

     - ~..~ mustn't be ambiguous.
       For example, one arm of ~match~ CANNOT be ~(.., second, ..)~

     - =From Jian=
       ~..~ syntax should be expanded, and people can specify the number of
       elements they indicate.

*** DONE Extra Conditionals with March Guards - 413
    CLOSED: [2017-08-30 Wed 02:10]
    #+BEGIN_SRC rust
      let num = Some(4);

      match num {
          Some(x) if x < 5 => println!("less than five: {}", x),
          Some(x) => println!("{}", x),
          None => (),
      }
    #+END_SRC

    - Example (fight against shadowning):
      #+BEGIN_SRC rust
        fn main() {
            let x = Some(5);
            let y = 10;

            match x {
                Some(50) => println!("Got 50"),
                Some(n) if n == y => println!("Matched, n = {:?}", n),
                _ => println!("Default case, x = {:?}", x),
            }

            println!("at the end: x = {:?}, y = {:?}", x, y);
        }
      #+END_SRC

      The ~y~ shows up ONLY in the guard part, which makes it clear that this ~y~
      should be the one in the outside scope.

      =NOTE= You definitely cannot write like ~Some(y) if y == y => ...~.

    - Example (guard that should be applied to all the ~|~ separated patterns):
      #+BEGIN_SRC rust
        // let x = 4;
        // let y = false;

        match x {
            4 | 5 | 6 if y => println!("yes"),
            _ => println!("no"),
        }
      #+END_SRC

      In other words,
      + it is ~(4 | 5 | 6) if y => ...~
      + it is NOT ~4 | 5 | (6 if y) => ...~, though this is NOT compilable.

    - If you just want to use guard when only part of the ~|~ patterns match,
      just split and re-group the patterns.

*** DONE ~@~ Bindings - 415
    CLOSED: [2017-08-30 Wed 04:43]
    #+BEGIN_SRC rust
      enum Message {
          Hello { id: i32 },
      }

      let msg = Message::Hello { id: 5 };

      match msg {
          Message::Hello { id: id @ 3...7 } => {
              println!("Found an id in range: {}", id)
          },
          Message::Hello { id: 10...12 } => {
              println!("Found an id in another range")
          },
          Message::Hello { id } => {
              println!("Found some other id: {}", id)
          },
      }
    #+END_SRC

    - The first arm:
      we bind the exact value of the ~id~ of ~msg~ to the ~id~ after ~:~, and
      also test if it is in the range of ~3...7~.

    - The second arm:
      match a range of numbers, but no binding.

    - The third arm:
      bind the value of the ~id~ field of a ~Message~ instance to the variable
      ~id~.

** DONE Summary - 416
   CLOSED: [2017-08-30 Wed 04:43]

* TODO 19. Advanced Features - 417
** TODO Unsafe Rust - 418
*** TODO Unsafe Superpowers - 418
*** TODO Dereferencing a Raw Pointer - 419
*** TODO Calling an Unsafe Function or Method - 421
**** TODO creating a Safe Abstraction Over Unsafe Code
**** TODO ~extern~ Functions for Calling External Code are Unsafe
**** TODO Calling Rust Functions from Other Languages

*** TODO Accessing or Modifying a Mutable Static Variable - 425
*** TODO Implementing an Unsafe Trait - 426
*** TODO When to Use Unsafe Code - 427

** TODO Advanced Traits - 427
*** TODO Specifying Placeholder Types in Trait Definitions with Associated Types - 427
**** TODO Associated Types Versus Generics
**** TODO Trait Objects with Associated Types

*** TODO Default Generic Type Parameters and Operator Overloading - 429
*** TODO Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name - 431
*** TODO Using Supertraits to Require One Trait's Functionality Within Another Trait - 434
*** TODO Using the Newtype Pattern to Implement External Traits on External Types - 436

** TODO Advanced Types - 437
*** TODO Using the Newtype Pattern for Type Safety and Abstraction - 437
*** TODO Creating Type Synonyms with Type Aliases - 438
*** TODO The Never Type That Never Returns - 440
*** TODO Dynamically Sized Types and ~Sized~ Trait - 441
**** TODO The ~Sized~ Trait

** TODO Advanced Functions and Closures - 443
*** TODO Function Pointers - 443
*** TODO Returning Closures - 445

** TODO Macros - 446
*** The Difference Between Macros and Functions - 446
*** Declarative Macros with macro_rules! for General Metaprogramming - 446
*** Procedural Macros for Generating Code from Attributes - 449
*** How to Write a Custom derive Macro - 449
*** Attribute-like macros - 454
*** Function-like macros - 455

** TODO Summary - 455

* TODO 20. Final Project: Building a Multithreaded Web Server - 457
** TODO Building a Single-Threaded Web Server - 458
*** TODO Listening to the TCP Connection - 458
*** TODO Reading the Request - 460
*** TODO A Closer Look at an HTTP Request - 462
*** TODO Writing a Response - 463
*** TODO Returning Real HTML - 464
*** TODO Validating the Request and Selectively Responding - 465
*** TODO A Touch of Refactoring - 466

** TODO Turning Our Single-Threaded Server into a Multithreaded Server - 468
*** TODO Simulating a Slow Request in the Current Server Implementation - 468
*** TODO Improving Throughput with a Thread Pool - 469
**** Code Structure If We Could Spawn a Thread for Each Request - 470
**** Creating a Similar Interface for a Finite Number of Threads - 470
**** Building the ThreadPool Struct Using Compiler-Driven Development - 471
**** Validating the Number of Threads in new - 474
**** Creating Space to Store the Threads - 475
**** A Worker Struct Responsible for Sending Code from the ThreadPool to a Thread - 476
**** Sending Requests to Threads via Channels - 478
**** Implementing the execute Method - 481

** TODO Graceful Shutdown and Cleanup - 487
*** TODO Implementing the ~Drop~ Trait on ThreadPool - 487
*** TODO Signaling to the Threads to Stop Listening for Jobs - 489

** TODO Summary - 493

* TODO Appendix A: Keywords - 495
** TODO Keywords Currently in Use - 495
** TODO Keywords Reserved for Future Use - 497
** TODO Raw Identifiers - 497

* TODO Appendix B: Operators and Symbols - 499
** TODO Operators - 499
** TODO Non-operator Symbols - 501

* TODO Appendix C: Derivable Traits - 507
** ~Debug~ for Programmer Output - 508
** ~PartialEq~ and ~Eq~ for Equality Comparisons - 508
** ~PartialOrd~ and ~Ord~ for Ordering Comparisons - 509
** ~Clone~ and ~Copy~ for Duplicating Values - 509
** ~Hash~ for Mapping a Value to a Value of Fixed Size - 510
** ~Default~ for Default Values - 510

* TODO Appendix D: Useful Development Tools - 511
** Automatic Formatting with rustfmt - 511
** Fix Your Code with rustfix - 512
** More Lints with Clippy - 513
** IDE Integration Using the Rust Language Server - 514

* TODO Appendix E: Editions - 515
