#+TITLE: The Rust Programming Language
#+VERSION: 2nd
#+AUTHOR: Community
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[1. Introduction][1. Introduction]]
  - [[1.1. Installation][1.1. Installation]]
    - [[Installing on Linux or Mac][Installing on Linux or Mac]]
    - [[Installing on Windows][Installing on Windows]]
    - [[Custom installations][Custom installations]]
    - [[Updating][Updating]]
    - [[Uninstalling][Uninstalling]]
    - [[Troubleshooting][Troubleshooting]]
    - [[Local documentation][Local documentation]]
  - [[1.2. Hello, World!][1.2. Hello, World!]]
    - [[Creating a Project Directory][Creating a Project Directory]]
    - [[Writing and Running a Rust Program][Writing and Running a Rust Program]]
    - [[Anatomy of a Rust Program][Anatomy of a Rust Program]]
    - [[Compiling and Running Are Separate Steps][Compiling and Running Are Separate Steps]]
    - [[Hello, Cargo!][Hello, Cargo!]]
      - [[Creating a Project with Cargo][Creating a Project with Cargo]]
      - [[Building and Running a Cargo Project][Building and Running a Cargo Project]]
      - [[Building for Release][Building for Release]]
      - [[Cargo as Convention][Cargo as Convention]]
- [[2. Guessing Game Tutorial][2. Guessing Game Tutorial]]
  - [[Setting Up a New Project][Setting Up a New Project]]
    - [[Processing a Guess][Processing a Guess]]
    - [[Storing Values with Variables][Storing Values with Variables]]
    - [[Handling Potential Failure with the ~Result~ Type][Handling Potential Failure with the ~Result~ Type]]
    - [[Printing Values with ~println!~ Placeholders][Printing Values with ~println!~ Placeholders]]
    - [[Testing the First Part][Testing the First Part]]
  - [[Generating a Secret Number][Generating a Secret Number]]
    - [[Using a Crate to Get More Functionality][Using a Crate to Get More Functionality]]
    - [[The =Cargo.lock= File Ensures Reproducible Builds][The =Cargo.lock= File Ensures Reproducible Builds]]
    - [[Updating a Crate to Get a New Version][Updating a Crate to Get a New Version]]
    - [[Generating a Random Number][Generating a Random Number]]
  - [[Comparing the Guess to the Secret Number][Comparing the Guess to the Secret Number]]
  - [[Allowing Multiple Guesses with Looping][Allowing Multiple Guesses with Looping]]
    - [[Quitting After a Correct Guess][Quitting After a Correct Guess]]
    - [[Handling Invalid Input][Handling Invalid Input]]
  - [[Summary][Summary]]
- [[3. Common Programming Concepts][3. Common Programming Concepts]]
  - [[3.1. Variables and Mutability][3.1. Variables and Mutability]]
    - [[Differences Between Variables and Constants][Differences Between Variables and Constants]]
    - [[Shadowing][Shadowing]]
  - [[3.2. Data Types][3.2. Data Types]]
    - [[Scalar Types][Scalar Types]]
      - [[Integer Types][Integer Types]]
      - [[Floating-Point Types][Floating-Point Types]]
      - [[Numeric Operations][Numeric Operations]]
      - [[The Boolean Type][The Boolean Type]]
      - [[The Character Type][The Character Type]]
    - [[Compound Types][Compound Types]]
      - [[Grouping Values into Tuples][Grouping Values into Tuples]]
      - [[Arrays][Arrays]]
  - [[3.3. How Functions Work][3.3. How Functions Work]]
    - [[Function Parameters][Function Parameters]]
    - [[Function Bodies][Function Bodies]]
    - [[Statements and Expressions][Statements and Expressions]]
    - [[Functions with Return Values][Functions with Return Values]]
  - [[3.4. Comments][3.4. Comments]]
  - [[3.5. Control Flow][3.5. Control Flow]]
    - [[~if~ Expressions][~if~ Expressions]]
    - [[Multiple Conditions with ~else if~][Multiple Conditions with ~else if~]]
    - [[Using ~if~ in a ~let~ statement][Using ~if~ in a ~let~ statement]]
    - [[Repetition with Loops][Repetition with Loops]]
      - [[Repeating Code with ~loop~][Repeating Code with ~loop~]]
      - [[Conditional Loops with ~while~][Conditional Loops with ~while~]]
      - [[Looping Through a Collection with ~for~][Looping Through a Collection with ~for~]]
    - [[Summary][Summary]]
- [[4. Understanding Ownership][4. Understanding Ownership]]
  - [[4.1. What is Ownership?][4.1. What is Ownership?]]
    - [[Ownership Rules][Ownership Rules]]
    - [[Variable Scope][Variable Scope]]
    - [[The ~String~ Type][The ~String~ Type]]
    - [[Memory and Allocation][Memory and Allocation]]
      - [[Ways Variables and Data Interact: /Move/][Ways Variables and Data Interact: /Move/]]
      - [[Ways Variables and Data Interact: /Clone/][Ways Variables and Data Interact: /Clone/]]
      - [[Stack-Only Data: /Copy/][Stack-Only Data: /Copy/]]
    - [[Ownership and Functions][Ownership and Functions]]
    - [[Return Values and Scope][Return Values and Scope]]
  - [[4.2. References & Borrowing][4.2. References & Borrowing]]
    - [[Mutable References][Mutable References]]
    - [[Dangling References][Dangling References]]
    - [[The Rules of References][The Rules of References]]
  - [[4.3. Slices][4.3. Slices]]
    - [[String Slices][String Slices]]
    - [[String Literals Are Slices][String Literals Are Slices]]
    - [[String Slices as Parameters][String Slices as Parameters]]
    - [[Other Slices][Other Slices]]
    - [[Summary][Summary]]
- [[5. Using Structs to Structure Related Data][5. Using Structs to Structure Related Data]]
  - [[5.1. Defining and Instantiating Structs][5.1. Defining and Instantiating Structs]]
    - [[Field Init Shorthand when Variables Have the Same Name as Fields][Field Init Shorthand when Variables Have the Same Name as Fields]]
    - [[Creating Instances From Other Instances With Struct Update Syntax][Creating Instances From Other Instances With Struct Update Syntax]]
    - [[Tuple Structs without Named Fields to Create Different Types][Tuple Structs without Named Fields to Create Different Types]]
    - [[Unit-Like Structs without Any Fields][Unit-Like Structs without Any Fields]]
  - [[5.2. An Example Program Using Structs][5.2. An Example Program Using Structs]]
    - [[Refactoring with Tuples][Refactoring with Tuples]]
    - [[Refactoring with Structs: Adding More Meaning][Refactoring with Structs: Adding More Meaning]]
    - [[Adding Useful Functionality with Derived Traits][Adding Useful Functionality with Derived Traits]]
  - [[5.3. Method Syntax][5.3. Method Syntax]]
    - [[Defining Methods][Defining Methods]]
    - [[Methods with More Parameters][Methods with More Parameters]]
    - [[Associated Functions][Associated Functions]]
    - [[Summary][Summary]]
- [[6. Enums and Pattern Match][6. Enums and Pattern Match]]
  - [[6.1. Defining an Enum][6.1. Defining an Enum]]
    - [[Enum Values][Enum Values]]
    - [[The ~Option~ Enum and Its Advantages Over Null Values][The ~Option~ Enum and Its Advantages Over Null Values]]
  - [[6.2. The ~match~ Control Flow Operator][6.2. The ~match~ Control Flow Operator]]
    - [[Patterns that Bind to Values][Patterns that Bind to Values]]
    - [[Matching with ~Option<T>~][Matching with ~Option<T>~]]
      - [[Matching ~Some(T)~][Matching ~Some(T)~]]
      - [[Matching ~None~][Matching ~None~]]
    - [[Matches Are Exhaustive][Matches Are Exhaustive]]
    - [[The ~_~ Placeholder][The ~_~ Placeholder]]
  - [[6.3. Concise Control Flow with ~if let~][6.3. Concise Control Flow with ~if let~]]
    - [[Summary][Summary]]
- [[7. Modules][7. Modules]]
  - [[7.1. ~mod~ and the Filesystem][7.1. ~mod~ and the Filesystem]]
    - [[Module Definitions][Module Definitions]]
    - [[Moving Modules to Other Files][Moving Modules to Other Files]]
    - [[Rules of Module Filesystems][Rules of Module Filesystems]]
  - [[7.2. Controlling Visibility with ~pub~][7.2. Controlling Visibility with ~pub~]]
    - [[Making a Function Public][Making a Function Public]]
    - [[Privacy Rules][Privacy Rules]]
    - [[Privacy Examples][Privacy Examples]]
      - [[Looking at the Errors][Looking at the Errors]]
      - [[Fixing the Errors][Fixing the Errors]]
  - [[7.3. Importing Names with use][7.3. Importing Names with use]]
    - [[Concise Imports with ~use~][Concise Imports with ~use~]]
    - [[Glob Imports with ~*~][Glob Imports with ~*~]]
    - [[Using ~super~ to Access a Parent Module][Using ~super~ to Access a Parent Module]]
    - [[Summary][Summary]]
- [[8. Common Collections -- In progress][8. Common Collections -- In progress]]
  - [[8.1. Vectors][8.1. Vectors]]
    - [[Creating a New Vector][Creating a New Vector]]
    - [[Updating a Vector][Updating a Vector]]
    - [[Dropping a Vector Drops its Elements][Dropping a Vector Drops its Elements]]
    - [[Reading Elements of Vectors][Reading Elements of Vectors]]
      - [[Invalid References][Invalid References]]
    - [[Using an Enum to Store Multiple Types][Using an Enum to Store Multiple Types]]
  - [[8.2. Strings][8.2. Strings]]
    - [[What is a String?][What is a String?]]
    - [[Creating a New String][Creating a New String]]
    - [[Updating a String][Updating a String]]
      - [[Appending to a String with Push][Appending to a String with Push]]
      - [[Concatenation with the ~+~ Operator or the ~format!~ Macro][Concatenation with the ~+~ Operator or the ~format!~ Macro]]
    - [[Indexing into String][Indexing into String]]
      - [[Internal Representation][Internal Representation]]
      - [[Bytes and Scalar Values and Grapheme Clusters! Oh my!][Bytes and Scalar Values and Grapheme Clusters! Oh my!]]
      - [[Slicing Strings][Slicing Strings]]
      - [[Methods for Iterating Over Strings][Methods for Iterating Over Strings]]
      - [[Strings are Not so Simple][Strings are Not so Simple]]
  - [[8.3. Hash Maps][8.3. Hash Maps]]
    - [[Creating a New Hash Map][Creating a New Hash Map]]
    - [[Hash Maps and Ownership][Hash Maps and Ownership]]
    - [[Accessing Values in a Hash Map][Accessing Values in a Hash Map]]
    - [[Updating a Hash Map][Updating a Hash Map]]
      - [[Overwriting a Value][Overwriting a Value]]
      - [[Only Insert If the Key Has No Value][Only Insert If the Key Has No Value]]
      - [[Update a Value Based on the Old Value][Update a Value Based on the Old Value]]
      - [[Hashing Function][Hashing Function]]
      - [[Summary][Summary]]
- [[9. Error Handling -- In progress][9. Error Handling -- In progress]]
  - [[9.1. Unrecoverable Errors with ~panic!~][9.1. Unrecoverable Errors with ~panic!~]]
    - [[Using a ~panic!~ Backtrace][Using a ~panic!~ Backtrace]]
  - [[9.2. Recoverable Errors with ~Result~][9.2. Recoverable Errors with ~Result~]]
    - [[Matching on Different Errors][Matching on Different Errors]]
    - [[Shortcuts for Panic on Error: ~unwrap~ and ~expect~][Shortcuts for Panic on Error: ~unwrap~ and ~expect~]]
    - [[Propagating Errors][Propagating Errors]]
    - [[A Shortcut for Propagating Errors: ~?~][A Shortcut for Propagating Errors: ~?~]]
    - [[~?~ Can Only Be Used in Functions That Return ~Result~][~?~ Can Only Be Used in Functions That Return ~Result~]]
  - [[9.3. To ~panic!~ or Not To ~panic!~][9.3. To ~panic!~ or Not To ~panic!~]]
    - [[Examples, Prototype Code, and Tests: Perfectly Fine to Panic][Examples, Prototype Code, and Tests: Perfectly Fine to Panic]]
    - [[Cases When You Have More Information Than The Compiler][Cases When You Have More Information Than The Compiler]]
    - [[Guidelines for Error Handling][Guidelines for Error Handling]]
    - [[Creating Custom Types for Validation][Creating Custom Types for Validation]]
    - [[Summary][Summary]]
- [[10. Generic Types, Traits, and Lifetimes][10. Generic Types, Traits, and Lifetimes]]
    - [[Removing Duplication by Extracting a Function][Removing Duplication by Extracting a Function]]
  - [[10.1. Generic Data Types][10.1. Generic Data Types]]
    - [[Using Generic Data Types in Function Definitions][Using Generic Data Types in Function Definitions]]
    - [[Using Generic Data Types in Struct Definitions][Using Generic Data Types in Struct Definitions]]
    - [[Using Generic Data Types in Enum Definitions][Using Generic Data Types in Enum Definitions]]
    - [[Using Generic Data Types in Method Definitions][Using Generic Data Types in Method Definitions]]
    - [[Performance of Code Using Generics][Performance of Code Using Generics]]
  - [[10.2. Traits: Defining Shared Behavior][10.2. Traits: Defining Shared Behavior]]
    - [[Defining a Trait][Defining a Trait]]
    - [[Implementing a Trait on a Type][Implementing a Trait on a Type]]
    - [[Default Implementations][Default Implementations]]
    - [[Trait Bounds][Trait Bounds]]
    - [[Fixing the ~largest~ Function with Trait Bounds][Fixing the ~largest~ Function with Trait Bounds]]
  - [[10.3. Validating References with Lifetimes][10.3. Validating References with Lifetimes]]
    - [[Lifetimes Prevent Dangling References][Lifetimes Prevent Dangling References]]
    - [[The Borrow Checker][The Borrow Checker]]
    - [[Generic Lifetimes in Functions][Generic Lifetimes in Functions]]
    - [[Lifetime Annotation Syntax][Lifetime Annotation Syntax]]
    - [[Lifetime Annotations in Function Signatures][Lifetime Annotations in Function Signatures]]
    - [[Thinking in Terms of Lifetimes][Thinking in Terms of Lifetimes]]
    - [[Lifetime Annotations in Struct Definitions][Lifetime Annotations in Struct Definitions]]
    - [[Lifetime Elision][Lifetime Elision]]
    - [[Lifetime Annotations in Method Definitions][Lifetime Annotations in Method Definitions]]
    - [[The Static Lifetime][The Static Lifetime]]
    - [[Generic Type Parameters, Trait Bounds, and Lifetimes Together][Generic Type Parameters, Trait Bounds, and Lifetimes Together]]
    - [[Summary][Summary]]
- [[11. Testing][11. Testing]]
  - [[11.1. How to Write Tests][11.1. How to Write Tests]]
    - [[The Anatomy of a Test Function][The Anatomy of a Test Function]]
    - [[Checking Results with the ~assert!~ Macro][Checking Results with the ~assert!~ Macro]]
    - [[Testing Equality with the ~assert_eq!~ and ~assert_ne!~ Macros][Testing Equality with the ~assert_eq!~ and ~assert_ne!~ Macros]]
    - [[Custom Failure Messages][Custom Failure Messages]]
    - [[Checking for Panics with ~should_panic~][Checking for Panics with ~should_panic~]]
  - [[11.2. Controlling How Tests are Run][11.2. Controlling How Tests are Run]]
    - [[Running Tests in Parallel or Consecutively][Running Tests in Parallel or Consecutively]]
    - [[Showing Function Output][Showing Function Output]]
    - [[Running a Subset of Tests by Name][Running a Subset of Tests by Name]]
      - [[Running Single Tests][Running Single Tests]]
      - [[Filtering to Run Multiple][Filtering to Run Multiple]]
      - [[Ignore Some Tests Unless Specifically Requested][Ignore Some Tests Unless Specifically Requested]]
  - [[11.3. Test Organization][11.3. Test Organization]]
    - [[Unit Tests][Unit Tests]]
      - [[The Tests Module and ~#[cfg(test)]~][The Tests Module and ~#[cfg(test)]~]]
      - [[Testing Private Functions][Testing Private Functions]]
    - [[Integration Tests][Integration Tests]]
      - [[The =tests= Directory][The =tests= Directory]]
      - [[Submodules in integration Tests][Submodules in integration Tests]]
      - [[Integration Tests for Binary Crates][Integration Tests for Binary Crates]]
    - [[Summary][Summary]]
- [[12. An I/O Project Building a Small Grep][12. An I/O Project Building a Small Grep]]
  - [[12.1. Accepting Command Line Arguments][12.1. Accepting Command Line Arguments]]
    - [[Reading the Argument Values][Reading the Argument Values]]
    - [[Saving the Argument Values in Variables][Saving the Argument Values in Variables]]
  - [[12.2. Reading a File][12.2. Reading a File]]
  - [[12.3. Refactoring to Improve Modularity and Error Handling][12.3. Refactoring to Improve Modularity and Error Handling]]
      - [[Separation of Concerns for Binary Projects][Separation of Concerns for Binary Projects]]
      - [[Extracting the Argument Parser][Extracting the Argument Parser]]
      - [[Grouping Configuration Values][Grouping Configuration Values]]
      - [[Creating a Constructor for ~Config~][Creating a Constructor for ~Config~]]
      - [[Fixing the Error Handling][Fixing the Error Handling]]
      - [[Extracting a ~run~ Function][Extracting a ~run~ Function]]
      - [[Split Code into a Library Crate][Split Code into a Library Crate]]
      - [[Calling the Library Crate from the Binary Crate][Calling the Library Crate from the Binary Crate]]
  - [[12.4. Testing the Library's Functionality][12.4. Testing the Library's Functionality]]
    - [[Writing a Failing Test][Writing a Failing Test]]
    - [[Writing Code that Gets the Test to Pass][Writing Code that Gets the Test to Pass]]
      - [[Iterating Through Lines with the ~lines~ method][Iterating Through Lines with the ~lines~ method]]
      - [[Searching Each Line for the Query][Searching Each Line for the Query]]
      - [[Storing Matching Lines][Storing Matching Lines]]
      - [[Using the ~search~ Function in the ~run~ Function][Using the ~search~ Function in the ~run~ Function]]
  - [[12.5. Working with Environment Variables][12.5. Working with Environment Variables]]
    - [[Writing a Failing Test for the Case-Insensitive search Function][Writing a Failing Test for the Case-Insensitive search Function]]
    - [[Implementing the ~search_case_insensitive~ Function][Implementing the ~search_case_insensitive~ Function]]
  - [[12.6. Writing to ~stderr~ instead of ~stdout~][12.6. Writing to ~stderr~ instead of ~stdout~]]
    - [[Summary][Summary]]
- [[13. Functional Language Features in Rust][13. Functional Language Features in Rust]]
  - [[13.1. Closures: Anonymous Functions that can Capture their Environment][13.1. Closures: Anonymous Functions that can Capture their Environment]]
    - [[Creating an Abstraction of Behavior Using a Closure][Creating an Abstraction of Behavior Using a Closure]]
    - [[Closures Store Code to be Extracted Later][Closures Store Code to be Extracted Later]]
    - [[Closures Type Inference and Annotation][Closures Type Inference and Annotation]]
    - [[Using Closures with Generic Parameters and the ~Fn~ Traits][Using Closures with Generic Parameters and the ~Fn~ Traits]]
    - [[Closures Can Capture Their Environment][Closures Can Capture Their Environment]]
  - [[13.2. Processing a Series of Items with Iterators][13.2. Processing a Series of Items with Iterators]]
    - [[The ~Iterator~ trait and the ~next~ method][The ~Iterator~ trait and the ~next~ method]]
    - [[Methods in the ~Iterator~ Trait that Consume the Iterator][Methods in the ~Iterator~ Trait that Consume the Iterator]]
    - [[Methods in the ~Iterator~ Trait that Produce Other Iterators][Methods in the ~Iterator~ Trait that Produce Other Iterators]]
    - [[Using Closures that Capture their Environment with Iterators][Using Closures that Capture their Environment with Iterators]]
    - [[Implementing the ~Iterator~ Trait to Create Our Own Iterators][Implementing the ~Iterator~ Trait to Create Our Own Iterators]]
      - [[Using Our ~Counter~ Iterator's ~next~ Method][Using Our ~Counter~ Iterator's ~next~ Method]]
      - [[Using Other ~Iterator~ Trait Methods on Our Iterator][Using Other ~Iterator~ Trait Methods on Our Iterator]]
  - [[13.3. Improving our I/O Project][13.3. Improving our I/O Project]]
    - [[Removing a ~clone~ Using an Iterator][Removing a ~clone~ Using an Iterator]]
      - [[Using the Iterator Returned by ~env::args~ Directly][Using the Iterator Returned by ~env::args~ Directly]]
      - [[Using ~Iterator~ Trait Methods Instead of Indexing][Using ~Iterator~ Trait Methods Instead of Indexing]]
    - [[Making Code Clearer with Iterator Adaptors][Making Code Clearer with Iterator Adaptors]]
  - [[13.4. Comparing Performance: Loops versus Iterators][13.4. Comparing Performance: Loops versus Iterators]]
    - [[Summary][Summary]]
- [[14. More about Cargo and Crates.io][14. More about Cargo and Crates.io]]
  - [[14.1. Release Profiles][14.1. Release Profiles]]
  - [[14.2. Publishing a Crate to Crates.io][14.2. Publishing a Crate to Crates.io]]
    - [[Documentation Comments][Documentation Comments]]
    - [[Exporting a Convenient Public API with ~pub use~][Exporting a Convenient Public API with ~pub use~]]
    - [[Before Your First Publish][Before Your First Publish]]
    - [[Before Publishing a New Crate][Before Publishing a New Crate]]
    - [[Publishing to Crates.io][Publishing to Crates.io]]
    - [[Publishing a New Version of an Existing Crate][Publishing a New Version of an Existing Crate]]
    - [[Removing Versions from Crate.io with ~cargo yank~][Removing Versions from Crate.io with ~cargo yank~]]
  - [[14.3. Cargo Workspaces][14.3. Cargo Workspaces]]
  - [[14.4. Installing Binaries from Crates.io with ~cargo install~][14.4. Installing Binaries from Crates.io with ~cargo install~]]
  - [[14.5. Extending Cargo with Custom Commands][14.5. Extending Cargo with Custom Commands]]
    - [[Summary][Summary]]
- [[15. Smart Pointers][15. Smart Pointers]]
  - [[15.1. ~Box<T>~ Points to Data on the Heap and Has a Known Size][15.1. ~Box<T>~ Points to Data on the Heap and Has a Known Size]]
  - [[15.2. The ~Deref~ Trait Allows Access to the Data Through a Reference][15.2. The ~Deref~ Trait Allows Access to the Data Through a Reference]]
    - [[Implicit Deref Coercions with Functions and Methods][Implicit Deref Coercions with Functions and Methods]]
  - [[15.3. The ~Drop~ Trait Runs Code on Cleanup][15.3. The ~Drop~ Trait Runs Code on Cleanup]]
  - [[15.4. ~Rc<T>~, the Reference Counted Smart Pointer][15.4. ~Rc<T>~, the Reference Counted Smart Pointer]]
    - [[Using ~Rc<T>~ to Share Data][Using ~Rc<T>~ to Share Data]]
    - [[Cloning an ~Rc<T>~ Increases the Reference Count][Cloning an ~Rc<T>~ Increases the Reference Count]]
  - [[15.5. ~RefCell<T>~ and the Interior Mutability Pattern][15.5. ~RefCell<T>~ and the Interior Mutability Pattern]]
    - [[~RefCell<T>~ has Interior Mutability][~RefCell<T>~ has Interior Mutability]]
    - [[Borrowing Rules are Checked at Runtime on ~RefCell<T>~][Borrowing Rules are Checked at Runtime on ~RefCell<T>~]]
    - [[Multiple Owners of Mutable Data by Combining ~Rc<T>~ and ~RefCell<T>~][Multiple Owners of Mutable Data by Combining ~Rc<T>~ and ~RefCell<T>~]]
  - [[15.6. Creating Reference Cycles and Leaking Memory is Safe][15.6. Creating Reference Cycles and Leaking Memory is Safe]]
    - [[Prevent Reference Cycles: Turn an ~Rc<T>~ into a ~Weak<T>~][Prevent Reference Cycles: Turn an ~Rc<T>~ into a ~Weak<T>~]]
    - [[Summary][Summary]]
- [[16. Fearless Concurrency][16. Fearless Concurrency]]
  - [[16.1. Using Threads to Run Code Simultaneously][16.1. Using Threads to Run Code Simultaneously]]
    - [[Creating a New Thread with ~spawn~][Creating a New Thread with ~spawn~]]
    - [[Waiting for All Threads to Finish Using ~join~ Handles][Waiting for All Threads to Finish Using ~join~ Handles]]
    - [[Using ~move~ Closures with Threads][Using ~move~ Closures with Threads]]
  - [[16.2. Message Passing to Transfer Data Between Threads][16.2. Message Passing to Transfer Data Between Threads]]
    - [[How Channels Interact with Ownership][How Channels Interact with Ownership]]
    - [[Sending Multiple Values and Seeing the Receiver Waiting][Sending Multiple Values and Seeing the Receiver Waiting]]
    - [[Create Multiple Producers by Cloning the Transmitter][Create Multiple Producers by Cloning the Transmitter]]
  - [[16.3. Shared State Concurrency][16.3. Shared State Concurrency]]
    - [[Mutexes Allow Access to Data from One Thread at a Time][Mutexes Allow Access to Data from One Thread at a Time]]
    - [[The API of ~Mutex<T>~][The API of ~Mutex<T>~]]
    - [[Sharing a ~Mutex<T>~ Between Multiple Threads][Sharing a ~Mutex<T>~ Between Multiple Threads]]
    - [[Multiple Ownership with Multiple Threads][Multiple Ownership with Multiple Threads]]
    - [[Atomic Reference Counting with ~Arc<T>~][Atomic Reference Counting with ~Arc<T>~]]
  - [[16.4. Extensible Concurrency with the ~Sync~ and ~Send~ Traits][16.4. Extensible Concurrency with the ~Sync~ and ~Send~ Traits]]
    - [[~Send~ for Indicating Ownership May Be Transferred to Another Thread][~Send~ for Indicating Ownership May Be Transferred to Another Thread]]
    - [[~Sync~ for Indicating Access from Multiple Threads is Safe][~Sync~ for Indicating Access from Multiple Threads is Safe]]
    - [[Implementing ~Send~ and ~Sync~ Manually is Unsafe][Implementing ~Send~ and ~Sync~ Manually is Unsafe]]
    - [[Summary][Summary]]
- [[17. Is Rust an Object-Oriented Programming Language?][17. Is Rust an Object-Oriented Programming Language?]]
  - [[17.1. What Does Object-Oriented Mean?][17.1. What Does Object-Oriented Mean?]]
    - [[Objects Contain Data and Behavior][Objects Contain Data and Behavior]]
    - [[Encapsulation that Hides Implementation Details][Encapsulation that Hides Implementation Details]]
    - [[Inheritance as a Type System and as Code Sharing][Inheritance as a Type System and as Code Sharing]]
  - [[17.2. Trait Objects for Using Values of Different Types][17.2. Trait Objects for Using Values of Different Types]]
    - [[Defining a Trait for the Common Behavior][Defining a Trait for the Common Behavior]]
    - [[Implementations of the Trait from Us or Library Users][Implementations of the Trait from Us or Library Users]]
    - [[Trait Objects Perform Dynamic Dispatch][Trait Objects Perform Dynamic Dispatch]]
    - [[Object Safety is Required for Trait Objects][Object Safety is Required for Trait Objects]]
  - [[17.3. Object-Oriented Design Pattern Implementations][17.3. Object-Oriented Design Pattern Implementations]]
    - [[Defining Post and Creating a New Instance in the Draft State][Defining Post and Creating a New Instance in the Draft State]]
    - [[Storing the Text of the Post Content][Storing the Text of the Post Content]]
    - [[Content of a Draft Post is Empty][Content of a Draft Post is Empty]]
    - [[Requesting a Review of the Post Changes its State][Requesting a Review of the Post Changes its State]]
    - [[Approving a Post Changes the Behavior of ~content~][Approving a Post Changes the Behavior of ~content~]]
    - [[Tradeoffs of the State Pattern][Tradeoffs of the State Pattern]]
      - [[Encoding States and Behavior as Types][Encoding States and Behavior as Types]]
      - [[Implementing Transitions as Transformations into Different Types][Implementing Transitions as Transformations into Different Types]]
    - [[Summary][Summary]]
- [[18. Patterns Match the Structure of Values][18. Patterns Match the Structure of Values]]
  - [[18.1. All the Places Patterns May be Used][18.1. All the Places Patterns May be Used]]
    - [[~match~ Arms][~match~ Arms]]
    - [[Exhaustiveness and the Default Pattern ~_~][Exhaustiveness and the Default Pattern ~_~]]
    - [[~if let~ Expressions][~if let~ Expressions]]
    - [[~while let~][~while let~]]
    - [[~for~ loops][~for~ loops]]
    - [[~let~ Statements][~let~ Statements]]
    - [[Function Parameters][Function Parameters]]
  - [[18.2. Refutability: Whether a Pattern Might Fail to Match][18.2. Refutability: Whether a Pattern Might Fail to Match]]
  - [[18.3. All the Pattern Syntax][18.3. All the Pattern Syntax]]
    - [[Literals][Literals]]
    - [[Named Variables][Named Variables]]
    - [[Multiple patterns][Multiple patterns]]
    - [[Matching Ranges of Values with ~...~][Matching Ranges of Values with ~...~]]
    - [[Destructuring to Break Apart Values][Destructuring to Break Apart Values]]
    - [[Ignoring Values in a Pattern][Ignoring Values in a Pattern]]
      - [[Ignoring an Entire Value with ~_~][Ignoring an Entire Value with ~_~]]
      - [[Ignoring Parts of a Value with a Nested ~_~][Ignoring Parts of a Value with a Nested ~_~]]
      - [[Ignoring an Unused Variable by Starting its Name with an Underscore][Ignoring an Unused Variable by Starting its Name with an Underscore]]
      - [[Ignoring Remaining Parts of a Value with ~..~][Ignoring Remaining Parts of a Value with ~..~]]
    - [[~ref~ and ~ref mut~ to Create References in Patterns][~ref~ and ~ref mut~ to Create References in Patterns]]
    - [[Extra Conditionals with March Guards][Extra Conditionals with March Guards]]
    - [[~@~ Bindings][~@~ Bindings]]
    - [[Summary][Summary]]
- [[19. Advanced Features][19. Advanced Features]]
  - [[19.1. Unsafe Rust][19.1. Unsafe Rust]]
    - [[Unsafe Superpowers][Unsafe Superpowers]]
    - [[Dereferencing a Raw Pointer][Dereferencing a Raw Pointer]]
    - [[Calling an Unsafe Function or Method][Calling an Unsafe Function or Method]]
      - [[creating a Safe Abstraction Over Unsafe Code][creating a Safe Abstraction Over Unsafe Code]]
      - [[~extern~ Functions for Calling External Code are Unsafe][~extern~ Functions for Calling External Code are Unsafe]]
      - [[Calling Rust Functions from Other Languages][Calling Rust Functions from Other Languages]]
    - [[Accessing or Modifying a Mutable Static Variable][Accessing or Modifying a Mutable Static Variable]]
    - [[Implementing an Unsafe Trait][Implementing an Unsafe Trait]]
  - [[19.2. Advanced Lifetimes][19.2. Advanced Lifetimes]]
    - [[Lifetime Subtyping][Lifetime Subtyping]]
    - [[Lifetime Bounds][Lifetime Bounds]]
    - [[Trait Object Lifetimes][Trait Object Lifetimes]]
  - [[19.3. Advanced Traits][19.3. Advanced Traits]]
    - [[Associated Types][Associated Types]]
      - [[Associated Types Versus Generics][Associated Types Versus Generics]]
      - [[Trait Objects with Associated Types][Trait Objects with Associated Types]]
    - [[Operator Overloading and Default Type Parameters][Operator Overloading and Default Type Parameters]]
    - [[Fully Qualified Syntax for Disambiguation][Fully Qualified Syntax for Disambiguation]]
    - [[Supertraits to Use One Trait's Functionality Within Another Trait][Supertraits to Use One Trait's Functionality Within Another Trait]]
    - [[The Newtype Pattern to Implement External Traits on External Types][The Newtype Pattern to Implement External Traits on External Types]]
  - [[19.4. Advanced Types][19.4. Advanced Types]]
    - [[Using the Newtype Pattern for Type Safety and Abstraction][Using the Newtype Pattern for Type Safety and Abstraction]]
    - [[Type Aliases Create Type Synonyms][Type Aliases Create Type Synonyms]]
    - [[The Never Type, ~!~, that Never Returns][The Never Type, ~!~, that Never Returns]]
    - [[Dynamically Sized Types & ~Sized~][Dynamically Sized Types & ~Sized~]]
      - [[The ~Sized~ Trait][The ~Sized~ Trait]]
  - [[19.5. Advanced Functions & Closures][19.5. Advanced Functions & Closures]]
    - [[Function pointers][Function pointers]]
    - [[Returning Closures][Returning Closures]]
    - [[Summary][Summary]]
- [[20. Final Project: Building a Multithreaded Web Server][20. Final Project: Building a Multithreaded Web Server]]
  - [[20.1. A Single Threaded Web Server][20.1. A Single Threaded Web Server]]
    - [[Reading the Request][Reading the Request]]
    - [[Writing a Response][Writing a Response]]
    - [[Returning Real HTML][Returning Real HTML]]
    - [[Validating the Request and Selectively Responding][Validating the Request and Selectively Responding]]
  - [[20.2. How Slow Requests Affect Throughput][20.2. How Slow Requests Affect Throughput]]
    - [[Simulating a Slow Request in the Current Server Implementation][Simulating a Slow Request in the Current Server Implementation]]
    - [[Improving Throughput with a Thread Pool][Improving Throughput with a Thread Pool]]
  - [[20.3. Designing the Thread Pool Interface][20.3. Designing the Thread Pool Interface]]
    - [[Code Structure if We Could Use ~thread::spawn~][Code Structure if We Could Use ~thread::spawn~]]
    - [[Creating a Similar Interface for ~ThreadPool~][Creating a Similar Interface for ~ThreadPool~]]
    - [[Compiler Driven Development to Get the API Compiling][Compiler Driven Development to Get the API Compiling]]
  - [[20.4. Creating the Thread Pool and Storing Threads][20.4. Creating the Thread Pool and Storing Threads]]
    - [[Validating the Number of Threads in the Pool][Validating the Number of Threads in the Pool]]
    - [[Storing Threads in the Pool][Storing Threads in the Pool]]
  - [[20.5. Sending Requests to Threads Via Channels][20.5. Sending Requests to Threads Via Channels]]
  - [[20.6. Graceful Shutdown and Cleanup][20.6. Graceful Shutdown and Cleanup]]
    - [[Summary][Summary]]
- [[21. Appendix][21. Appendix]]
  - [[21.1. A - Keywords][21.1. A - Keywords]]
    - [[Keywords Currently in Use][Keywords Currently in Use]]
    - [[Keywords Reserved for Future Use][Keywords Reserved for Future Use]]
  - [[21.2. B - Operators][21.2. B - Operators]]
    - [[Unary operator expressions][Unary operator expressions]]
    - [[Binary Operator expressions][Binary Operator expressions]]
      - [[Arithmetic operators][Arithmetic operators]]
      - [[Bitwise operators][Bitwise operators]]
      - [[Lazy boolean operators][Lazy boolean operators]]
      - [[Comparison operators][Comparison operators]]
      - [[Type cast expressions][Type cast expressions]]
      - [[Assignment expressions][Assignment expressions]]
      - [[Compound assignment expressions][Compound assignment expressions]]
      - [[Operator precedence][Operator precedence]]
  - [[21.3. C - Derivable Traits][21.3. C - Derivable Traits]]
  - [[21.4. D - Nightly Rust][21.4. D - Nightly Rust]]
  - [[21.5. E - Macros][21.5. E - Macros]]
  - [[21.6. F - Translations][21.6. F - Translations]]
  - [[21.7. G - Newest Features][21.7. G - Newest Features]]
    - [[Field init shorthand][Field init shorthand]]
    - [[Returning from loops][Returning from loops]]

* DONE 1. Introduction
  CLOSED: [2017-08-16 Wed 01:46]
  - Rust package registry site, [[https://crates.io/][crates.io]]

** DONE 1.1. Installation
   CLOSED: [2017-08-16 Wed 00:43]
   - Convention: =$= prompt means normal user, and =#= means super user.

*** DONE Installing on Linux or Mac
    CLOSED: [2017-08-16 Wed 00:35]
    ~$ curl https://sh.rustup.rs -sSf | sh~

*** TODO Installing on Windows
*** TODO Custom installations
*** DONE Updating
    CLOSED: [2017-08-16 Wed 00:37]
    ~$ rustup update~

*** DONE Uninstalling
    CLOSED: [2017-08-16 Wed 00:37]
    ~$ rustup self uninstall~

*** DONE Troubleshooting
    - Rust version info:
      ~$ rustc --version~
      The output is like:
      =rustc v.subv.subsubv (abcabcabc yyyy-mm-dd)=

    - =Useful= Where you can get help
      + IRC channel: irc.mozilla.org
        This can be accessed through *Mibbit* (a website).

      + the Users forum

    - A silly nickname for rust users: *Rustaceans*

*** DONE Local documentation
    Run ~rustup doc~ to open the local documentation in your browser.

** DONE 1.2. Hello, World!
   CLOSED: [2017-08-16 Wed 00:53]
*** DONE Creating a Project Directory
    CLOSED: [2017-08-16 Wed 00:48]
*** DONE Writing and Running a Rust Program
    CLOSED: [2017-08-16 Wed 00:53]
    The source code:
    #+BEGIN_SRC rust
      // main.rs
      fn main() {
          println!("Hello, world!");
      }
    #+END_SRC

    ~$ rustc main.rs~

    ~$ ./main~
    =From Jian=: NOT ~a.out~ anymore!!!
    The output is ="Hello, world!"=

*** DONE Anatomy of a Rust Program
    CLOSED: [2017-08-16 Wed 00:53]
    - ~println!~ is a /Rust macro/.
      =TODO= Discuss Rust macros in more details in Appendix E.
      ~!~ means you're calling a macro instead of a normal function.

*** DONE Compiling and Running Are Separate Steps
    CLOSED: [2017-08-16 Wed 00:53]
    The command is mentioned in the _Writing and Running a Rust Program_ section.

*** DONE Hello, Cargo!
    CLOSED: [2017-08-16 Wed 01:46]
    If you installed Rust with the given command (Section 1.1)
    ~$ curl https://sh.rustup.rs -sSf | sh~, *Cargo* should have been installed. 
     
**** DONE Creating a Project with Cargo
     CLOSED: [2017-08-16 Wed 01:14]
     ~cargo new hello_cargo --bin~
     - ~--bin~ argument (to ~cargo new~):
       make an _executable application_, as opposed to a _library_.

     - The new project contains two visible files:
       + =Cargo.toml=: a structured plain text file.
       + =src= folder

     - The new project is also initialized as a _git repository_ with a
       =.gitignore= file.
         You can change this to use a different version control system, or no
       version control system, by using the =-vcs= flag.

     - This simple =Cargo.toml= file:
       #+BEGIN_SRC toml
         [package]
         name = "hello_cargo"
         version = "0.1.0"
         authors = ["Your Name <you@example.com>"]

         [dependencies]
       #+END_SRC
       This file is the *TOML* (Tom's Obvious, Minimal Language) format.
       *TOML* is similar to *INI* but has some extra goodies and is used as
       Cargo's configuration format.

     - The =src/main.rs= file is initialized as a simple _hello world_ program.

     - Cargo expects your source files to live inside the =src= directory
       so that top-level project directory is just for
       + =READMEs=
       + license info
       + configuration files
       + anything else not related to your code

     - The first step of converting a non-Cargo Rust project to a Cargo Rust
       project is to move all the source code to the =src= folder.

**** DONE Building and Running a Cargo Project
     CLOSED: [2017-08-16 Wed 01:34]
     - Building:
       ~$ cargo build~

       The output:
       =Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)=

     - This should have created an executable file in =target/debug/hello_cargo=.

     - Running:
       ~$ ./target/debug/hello_cargo~

       The output:
       ="Hello, world!"=

     - The first time you run ~cargo build~ in a project, a =Cargo.lock= file
       will be added in the top level of this project.
       #+BEGIN_SRC toml
         [root]
         name = "hello_cargo"
         version = "0.1.0"
       #+END_SRC

     - Building and Running:
       ~$ cargo run~

     - With the help of Cargo, we can use OS independent instructions to work
       with Rust.
       
**** DONE Building for Release
     CLOSED: [2017-08-16 Wed 01:44]
     Run ~cargo build --release~, and optimizations will be applied to the
     compilation process. The executable will be save to the =./target/release=
     folder.

     - NO flag ~cargo build~ is for quick compile. That's why the output
       executable is save in a =debug= folder -- it is used for debugging and
       continuing development.

     - With the ~--release~ flag.
       To release, the developer should use the send the optimized version (good
       performance) to the end users, who don't care about the length of the
       compilation time.
         This is what ~--release~ do: to get a good performance, compile with
       optimizations, it can be a slower compilation.

**** DONE Cargo as Convention
     CLOSED: [2017-08-16 Wed 01:45]
     You can always expect to do this:
     ~$ git clone someurl.com/someproject~
     ~$ cd someproject~
     ~$ cargo build~

* DONE 2. Guessing Game Tutorial
  CLOSED: [2017-08-16 Wed 23:32]
  Generate a random integer between 1 and 100.
  Try to guess.
  The program tells you if it is right, too low, or to high?
  If not right keep guessing.
  If right print congratulations and exit.

** DONE Setting Up a New Project
   CLOSED: [2017-08-16 Wed 04:08]
   ~$ cargo new guessing_game --bin~
   ~$ cd guessing_game~
*** DONE Processing a Guess
    CLOSED: [2017-08-16 Wed 03:47]
    #+BEGIN_SRC rust
      // src/main.rs

      use std::io;

      fn main() {
          println!("Guess the number!");

          println!("Please input your guess.");

          let mut guess = String::new();

          io::stdin().read_line(&mut guess)
              .expect("Failed to read line");

          println!("You guessed: {}", guess);
      }
    #+END_SRC

    - ~std~ means the standard library. ~io~ library comes from the standard
      library.

    - Use ~use~ when the required libraries are not in the /prelude/.

*** DONE Storing Values with Variables
    CLOSED: [2017-08-16 Wed 03:47]
    - ~String~ is a string type provided by the standard library that is a
      growable, UTF-8 encoded bit of text.

      + The ~::~ syntax in the ~::new~ line indicates that new is an /associated
        function/ of the ~String~ type.

      + /an associated function/ :: a function that is implemented _on a type_, in
           this case ~String~, _rather than on a particular instance_ of a ~String~
           (Some languages call this a static method).

      + ~String::new~ create a new empty string.

    - ~io::stdin~ should be written as ~std::io::stdin~ if you did NOT
      ~use std::io~.

    - ~read_line(&mut guess)~
      + A ~read_line~ requires a place to save the string it reads in.
        That's why ~&~ and ~mut~ are there.
      + ~&~ indicate that this argument is a /reference/.
      + ~mut~ gives the permission to make changes to the reference (=??= content).

    - /references/ give you a way to let multiple parts of your code access one
      piece of data without needing to copy that data into memory multiple
      times.
      =TODO=

      + /reference/ is a COMPLEX feature,
        and
        one of Rust's major advantages advantages is how safe and easy it is to
        use /references/.
        =TODO= Chapter 4

*** DONE Handling Potential Failure with the ~Result~ Type
    CLOSED: [2017-08-16 Wed 04:05]
    - ~read_line~ also returns a value -- an ~io::Result~ typed value.

    - Rust has a number of types named ~Result~ in its standard library:
      a generic ~Rusult~ as well as
      specific versions for submodules, such as ~io::Result~.

    - The ~Result~ types are /enumerations/, often referred to as ~enums~.

      An enumeration is a type that can have a fixed set of values, and those
      values are called the enum's /variants/.

      =TODO= CHAPTER 6

    - For ~Result~, the variants are ~Ok~ or ~Err~.
      + ~Ok~ indicates the operation was successful, and it contains the success-
        fully generated value.

      + ~Err~ indicates the operation was failed, and it contains info about
        _how_ and _why_ the operation failed.

    - ~io::Result~ has an ~expect~ method that you can call.
      + With an ~Err~ value, ~expect~ will cause the program to crash and
        display the message that you passed as an argument to ~expect~.

      + With an ~Ok~ value, ~expect~ will take the return value that ~Ok~ is
        holding and return just the value to you.

    - If you have a ~Result~ type value, and you don't use ~expect~ method or try
      to catch the error (=TODO= CHAPTER 9), The compiler will issue a warning.

*** DONE Printing Values with ~println!~ Placeholders
    CLOSED: [2017-08-16 Wed 04:07]
    The ~{}~ syntax for ~println!~ ......
*** DONE Testing the First Part
    CLOSED: [2017-08-16 Wed 04:08]
    ~cargo run~ and try it (we currently only finished the input part).
** DONE Generating a Secret Number
   CLOSED: [2017-08-16 Wed 21:26]
   =This section should re-write=
   Rust does NOT yet include random number functionality in its standard library.
   However, the Rust team does provide a ~rand~ crate.

*** DONE Using a Crate to Get More Functionality
    CLOSED: [2017-08-16 Wed 16:38]
    - /crate/ is a package of Rust code.

      + The project we've been building is a /binary crate/, which is an
        executable.

      + The ~rand~ crate is a /library crate/, which contains code intended to be
        used in other programs.

    - To use a crate in a Rust project, we need to modify the =Cargo.toml= -- add
      a dependency:
      #+BEGIN_SRC toml
        [dependencies]
        rand = "0.3.14"
      #+END_SRC

    - Cargo understand [[http://semver.org][Semantic Versioning]] (/SemVer/ for short), which is a
      standard for writing version numbers.
        The =0.3.14= is a shorthand for =^0.3.14=, which means "any version that
      has

    - /Crates.io/ :: a place people in the Rust ecosystem post their open source
                     Rust projects for others to use.

    - /registry/ :: a copy of data from Crates.io.

    - Now that we have an _external dependency_,
      Cargo fetches the latest versions of everything from the /registry/.

    - ~$ cargo build~
      The output is:
      #+BEGIN_SRC text
            Updating registry `https://github.com/rust-lang/crates.io-index`
           Compiling libc v0.2.29
           Compiling rand v0.3.16
           Compiling guessing_game v0.3.16 (file:///path_to_your_project_folder_location/guessing_game)
            Finished dev [unoptimized + debuginfo] target(s) in 3.37 secs
      #+END_SRC

      =IMPORTANT=:
      We write the version info as 0.3.14 in =Cargo.toml=.
      However, when we run ~$ cargo build~, Cargo automatically find and use the
      latest version that can fit -- according to the SemVer, the =14= and =16=
      represent version =0.13= with patches with patches, and there shouldn't be
      API differences.
      
*** DONE The =Cargo.lock= File Ensures Reproducible Builds
    CLOSED: [2017-08-16 Wed 21:26]
    The first time you run ~$ cargo build~ (or ~$cargo run~) Cargo tries to
    figure out the versions of the dependencies that fit the criteria and then
    writes them to the =Cargo.lock= file.

    When you build in the future, Cargo will read =Cargo.lock= rather then tries
    to figure out the verions of dependencies again through parsing =Cargo.toml=.

    _Remember_: the acutally used versions of dependencies (info is in
    =Cargo.lock=) are different from the ones written in =Cargo.toml= -- Cargo
    may choose a higher but fit version.

*** DONE Updating a Crate to Get a New Version
    CLOSED: [2017-08-16 Wed 21:00]
    - ~$ cargo update~ will help you to update the dependencies to the lastest
      fit version.

    - Remember! When you the first time run ~$ cargo build~, Cargo will find the
      latest fit version. The later build won't change this. If you want to use a
      newer version, use ~$ cargo update~.

    - If the first time you run ~$ cargo build~ it used version 0.13.14, the
      later ~$ cargo update~ will choose version _exclusively_ between 0.13.14
      and 0.4.0.

      If you want a higher version, you must manually update the =Cargo.toml=
      file.

*** DONE Generating a Random Number
    CLOSED: [2017-08-16 Wed 21:19]
    Use ~rand~ and update the =src/main.rs=.

    #+BEGIN_SRC rust
      extern crate rand;

      use std::io;
      use rand::Rng;

      fn main() {
          println!("Guess the number!");

          let secret_number = rand::thread_rng().gen_range(1, 101);

          println!("The secret number is: {}", secret_number);

          println!("Please input your guess.");

          let mut guess = String::new();

          io::stdin().read_line(&mut guess)
              .expect("Failed to read line");

          println!("You guessed: {}", guess);
      }
    #+END_SRC

    - ~Rng~ is a /trait/ that defines methods that random number generators
      implement, and this /trait/ must be in scope for us to use those methods.

      =TODO= CHAPTER 10

    - ~rand::thread_rng~ function will give us the particular random number
      generator to be used:
      one that is
      + local to the current thread of execution
      + seeded by the operating system.

    - The ~gen_range~ method is defined by the ~Rng~ trait.

    - Run the ~cargo doc --open~ command that will build documentation provided
      by all of your dependencies locally and open it in your browser.
      =IMPORTANT= Then you know what /traits/ you should ~use~.

** DONE Comparing the Guess to the Secret Number
   CLOSED: [2017-08-16 Wed 23:06]
   #+BEGIN_SRC rust
     extern crate rand;

     use std::io;
     use std::cmp::Ordering;
     use rand::Rng;

     fn main() {
         println!("Guess the number!");
         let secret_number = rand::thread_rng().gen_range(1, 101);
         println!("The secret number is: {}", secret_number);
         println!("Please input your guess.");
         let mut guess = String::new();

         io::stdin().read_line(&mut guess)
             .expect("Failed to read line");

         println!("You guessed: {}", guess);

         match guess.cmp(&secret_number) {
             Ordering::Less    => println!("Too small!"),
             Ordering::Greater => println!("Too big!"),
             Ordering::Equal   => println!("You win!"),
         }
     }
   #+END_SRC

   - ~Ordering~ is a type, and it has three variants:
     ~Less~, ~Greater~, and ~Equal~.

   - A ~match~ expression is made up of /arms/.

   - An /arm/ consists of a /pattern/ and the code that should be run when
     pattern matching can be applied.

   - The code above CANNOT be compiled -- type mismatching:
     ~guess~ should be a number if we want to compare it with ~secret_number~.

   - Integer types: ~i32~, ~u32~, ~i64~.
     Rust defaults to an ~i32~, which is the type of ~secret_number~.
     Here, ~u32~ is more reasonable.

   - The corrected code:
     #+BEGIN_SRC rust
       extern crate rand;

       use std::io;
       use std::cmp::Ordering;
       use rand::Rng;

       fn main() {
           println!("Guess the number!");
           let secret_number = rand::thread_rng().gen_range(1, 101);
           println!("The secret number is: {}", secret_number);
           println!("Please input your guess.");

           let mut guess = String::new();

           io::stdin().read_line(&mut guess)
               .expect("Failed to read line");

           println!("You guessed: {}", guess);

           let guess: u32 = guess.trim().parse()
               .expect("Please type a number!");

           match guess.cmp(&secret_number) {
               Ordering::Less    => println!("Too small!"),
               Ordering::Greater => println!("Too big!"),
               Ordering::Equal   => println!("You win!"),
           }
       }
     #+END_SRC

     + I DO NOT like the /shadow/ feature. Here is what I prefered:
       =TODO= CHAPTER 3 - about the /shadow/ feature.
       #+BEGIN_SRC rust
         extern crate rand;

         use std::io;
         use std::cmp::Ordering;
         use rand::Rng;

         fn main() {
             println!("Guess the number!");
             let secret_number = rand::thread_rng().gen_range(1, 101);
             println!("The secret number is: {}", secret_number);
             println!("Please input your guess.");

             // `line` can be an alternative name.
             let mut input = String::new();

             io::stdin().read_line(&mut input)
                 .expect("Failed to read line");

             println!("You guessed: {}", input);

             let guess: u32 = input.trim().parse()
                 .expect("Please type a number!");

             match guess.cmp(&secret_number) {
                 Ordering::Less    => println!("Too small!"),
                 Ordering::Greater => println!("Too big!"),
                 Ordering::Equal   => println!("You win!"),
             }
         }
       #+END_SRC

     + ~trim~ eliminate any whitespace at the beginning and end.

     + with the help of ~u32~, ~parse~ knows what's essential type (_essential_
       here means the cotent of the ~Result~ value) of its result.

** DONE Allowing Multiple Guesses with Looping
   CLOSED: [2017-08-16 Wed 23:09]
   Make a simple forever loop with ~loop~
   #+BEGIN_SRC rust
     extern crate rand;

     use std::io;
     use std::cmp::Ordering;
     use rand::Rng;

     fn main() {
         println!("Guess the number!");
         let secret_number = rand::thread_rng().gen_range(1, 101);
         println!("The secret number is: {}", secret_number);

         loop {
             println!("Please input your guess.");

             // `line` can be an alternative name.
             let mut input = String::new();

             io::stdin().read_line(&mut input)
                 .expect("Failed to read line");

             println!("You guessed: {}", input);

             let guess: u32 = input.trim().parse()
                 .expect("Please type a number!");

             match guess.cmp(&secret_number) {
                 Ordering::Less    => println!("Too small!"),
                 Ordering::Greater => println!("Too big!"),
                 Ordering::Equal   => println!("You win!"),
             }
         }
     }
   #+END_SRC

*** DONE Quitting After a Correct Guess
    CLOSED: [2017-08-16 Wed 23:11]
    ~break~ when ="You win!"=.

   #+BEGIN_SRC rust
     extern crate rand;

     use std::io;
     use std::cmp::Ordering;
     use rand::Rng;

     fn main() {
         println!("Guess the number!");
         let secret_number = rand::thread_rng().gen_range(1, 101);
         println!("The secret number is: {}", secret_number);

         loop {
             println!("Please input your guess.");

             // `line` can be an alternative name.
             let mut input = String::new();

             io::stdin().read_line(&mut input)
                 .expect("Failed to read line");

             println!("You guessed: {}", input);

             let guess: u32 = input.trim().parse()
                 .expect("Please type a number!");

             match guess.cmp(&secret_number) {
                 Ordering::Less    => println!("Too small!"),
                 Ordering::Greater => println!("Too big!"),
                 Ordering::Equal   => {
                     println!("You win!");
                     break;
                 }
             }
         }
     }
   #+END_SRC

*** TODO Handling Invalid Input
    Change the ~let guess: u32~ line.
    The final version is:
    #+BEGIN_SRC rust
      extern crate rand;

      use std::io;
      use std::cmp::Ordering;
      use rand::Rng;

      fn main() {
          println!("Guess the positive integer number!");

          let secret_number = rand::thread_rng().gen_range(1, 101);

          loop {
              println!("Please input your guess.");

              let mut input = String::new();

              io::stdin().read_line(&mut input)
                  .expect("Failed to read line");

              let guess: u32 = match input.trim().parse() {
                  Ok(num) => num,
                  Err(_) => {
                      println!("NOT a unsigned integer number!");
                      continue;
                  }
              };

              println!("You guessed: {}", guess);

              match guess.cmp(&secret_number) {
                  Ordering::Less    => println!("Too small!"),
                  Ordering::Greater => println!("Too big!"),
                  Ordering::Equal   => {
                      println!("You win!");
                      break;
                  }
              }
          }
      }
    #+END_SRC

** DONE Summary
   CLOSED: [2017-08-16 Wed 23:32]
* DONE 3. Common Programming Concepts
  CLOSED: [2017-08-17 Thu 23:57]
  *Keywords* See Appendix A =TODO=
** DONE 3.1. Variables and Mutability
   CLOSED: [2017-08-17 Thu 00:51]
*** DONE Differences Between Variables and Constants
    CLOSED: [2017-08-17 Thu 00:41]
    - Rust has ~const~ keyword.

    - Constants are NOT only immutable by default, they're always immutable.

    - The type of constant (declared with ~const~) _must_ be annotated.

    - Constants can be declared in any scope, including the global scope.

    - A constant can ONLY be set to a constant expression,
      NOT
      + the result of a function call
        or
      + any other value that could only be computed at runtime.

    - ~_~'s are allowed when you write a number, and they will be ignored when do
      evaluation.

*** DONE Shadowing
    CLOSED: [2017-08-17 Thu 00:44]
    _I the /shadowing/ feature is BAD._

    =From Jian=
    From my point of view, the only natural way of shadowing is in embeded scope.
    I don't want to see shadowing happend in a flat structure.

    There should a feature to let you write down the transition of types of
    a varaible, and this transition only describes the type transition in the
    local scope.
** DONE 3.2. Data Types
   CLOSED: [2017-08-17 Thu 21:53]
   Sometime the type CANNOT be inferred, you must add the type annotation.

   For example, ~parse~ below need to know the type of its result, or it does NOT
   know what to do: ~let guess: u32 = "42".parse().expect("Not a number!");~

*** DONE Scalar Types
    CLOSED: [2017-08-17 Thu 21:53]
    - /scala types/ :: The types of some single values.

    - Four primary scalar types in Rust:
      + integers
      + floating-point numbers
      + booleans
      + characters

**** DONE Integer Types
     CLOSED: [2017-08-17 Thu 04:15]
     Table 3-1: Integer Types in Rust

     | Length | Signed | Unsigned |
     |--------+--------+----------|
     | 8-bit  | i8     | u8       |
     | 16-bit | i16    | u16      |
     | 32-bit | i32    | u32      |
     | 64-bit | i64    | u64      |
     | arch   | isize  | usize    |

     - signed numbers range: -(2 ^ (n-1)) to (2 ^ (n-1)) - 1 inclusive.

     - unsigned variants can store numbers from 0 to 2^n - 1

     - ~isize~ and ~usize~ depend on the architectures:
       32-bit for 32-bit architecture;
       64-bit for 64-bit architecture.

     - All number literals _except the byte literal_ allow a /type suffix/, for
       example: ~57u8~
       =IMPORTANT=

     - ~_~ as a visual separator, such as ~1_000~. You can put the ~_~ anywhere
       in numbers.

     - Table 3-2: Integer Literals in Rust
       | Number literals | Example     |
       |-----------------+-------------|
       | Decimal         | 98\under222      |
       | Hex             | 0xff        |
       | Octal           | 0o77        |
       | Binary          | 0b1111\under0000 |
       | Byte(~u8~ only) | b'A'        |

     - If you don't know which type of integer to use, use the default ~i32~.
       It is generally the fastest, even on 64-bit systems.

     - The primary situation in which you'd use ~isize~ or ~usize~ is when
       indexing some sort of collection.
       =From Jian= This sounds like the ~size_t~ type in C.

**** DONE Floating-Point Types
     CLOSED: [2017-08-17 Thu 21:50]
     ~f32~ (IEEE-754 single-precision) and ~f64~ (IEEE-754 double-precision).
     The performance of ~f32~ is bettern in the 32bit systems.
     The performance of ~f64~ is bettern in the 64bit systems.
     #+BEGIN_SRC rust
       fn main() {
           let x = 2.0; // f64
           let y: f32 = 3.0; // f32
       }
     #+END_SRC

**** DONE Numeric Operations
     CLOSED: [2017-08-17 Thu 21:51]
     ~+~, ~-~, ~*~, ~/~, ~%~
     Read Appendix B.

**** DONE The Boolean Type
     CLOSED: [2017-08-17 Thu 21:53]
     Type name ~bool~. Its values: ~true~ and ~false~.

**** DONE The Character Type
     CLOSED: [2017-08-17 Thu 04:19]
     In Rust, ~char~ type values are Unicode Scalar Values.
     Range: from =U+0000= to =U+D7FF= and =U+E000= to =U+10FFFF= inclusive.

     However, a "character" is NOT really a concept in Unicode, so your human
     intuition for what a "charactr" is may NOT match up with what a ~char~ is in
     Rust.
     =TODO= Chapter 8

*** DONE Compound Types
    CLOSED: [2017-08-17 Thu 03:57]
**** DONE Grouping Values into Tuples
     CLOSED: [2017-08-17 Thu 00:54]
    - ~let tup: (i32, f64, u8) = (500, 6.4, 1);~
      + Pattern matching is a good way to extract value(s) from a tuple.
        ~let (x, y, z) = tup;~

      + ~.~ syntax
        ~tup.0~ is ~(500 : i32)~.

**** DONE Arrays
     CLOSED: [2017-08-17 Thu 03:57]
     Rust /arrays/ have a fixed length: once declared, they CANNOT grow or shrink
     in size.
     ~let a = [1, 2, 3, 4, 5];~

     - Arrays are useful
       + when you want your data allocated on the /stack/ _rather than_ the
         /heap/ (=TODO= we will discuss the /stack/ and the /heap/ more in
         Chapter 4),
         or
       + when you want to ensure you always have a fixed number of elements.

***** DONE Accessing Array Elements
      CLOSED: [2017-08-17 Thu 03:57]
      ~a[0]~
***** DONE Invalid Array Element Access
      CLOSED: [2017-08-17 Thu 03:57]
      - When this happens, compilation wouldn't produce any errors, but the
        program would result in a /runtime error/.

      - /panic/ :: a program exits with an error.

      - =TODO= Chapter 9 error handling.

** DONE 3.3. How Functions Work
   CLOSED: [2017-08-17 Thu 22:30]
   /snake case/: all letters are lowercase and underscores separate words.

*** DONE Function Parameters
    CLOSED: [2017-08-17 Thu 22:14]
    - Technically, the concrete values are called /arguments/.

    - In casual conversation people tend to use the words "parameter" and
      "argument" interchangeably.

    - Example:
      #+BEGIN_SRC rust
        // src/main.rs
        fn main() {
            another_function(5, 6);
        }

        fun another_function(x: i32, y: i32) {
            println!("The value of x is: {}", x);
            println!("The vlaue of y is: {}", y);
        }
      #+END_SRC

*** DONE Function Bodies
    CLOSED: [2017-08-17 Thu 22:15]
*** DONE Statements and Expressions
    CLOSED: [2017-08-17 Thu 22:29]
    - /statements/ :: instructions that perform some action and do not return a
                      value.

    - /expressions/ :: evaluate to a resulting value.

    - Calling a _function_ is an expression.

    - Calling a _macro_ is an expression.

    - The _block_ that we use to create new scopes, {}, is an expression.
      #+BEGIN_SRC rust
        let y = {
            let x = 3;
            x + 1
        };
      #+END_SRC

    - =IMPORTANT=
      Expressions do NOT include ending semicolons.
      If you add a semicolon to the end of an expression, you turn it into a
      statement, which _will then NOT return a value_.

*** DONE Functions with Return Values
    CLOSED: [2017-08-17 Thu 22:29]
    - Anotate the return value type of a function:
      #+BEGIN_SRC rust
        fn plus_one(x: i32) -> i32 {
            x + 1
            // NO ;
        }

        fn main() {
            let x = plus_one(5);
            println!("The value of x is: {}", x);
        }
      #+END_SRC

** DONE 3.4. Comments
   CLOSED: [2017-08-17 Thu 21:53]
   ~//~
** DONE 3.5. Control Flow
   CLOSED: [2017-08-17 Thu 23:57]
*** DONE ~if~ Expressions
    CLOSED: [2017-08-17 Thu 22:33]
    #+BEGIN_SRC rust
      if number < 5 {
          println!("condition was true");
      } else {
          println!("condition was false");
      }
    #+END_SRC

    The branches of a ~if ... else~ structure is also called /arms/.

*** DONE Multiple Conditions with ~else if~
    CLOSED: [2017-08-17 Thu 22:34]
    In many cases, ~match~ is a better way.
    =TODO= CHAPTER 6
*** DONE Using ~if~ in a ~let~ statement
    CLOSED: [2017-08-17 Thu 22:35]
*** DONE Repetition with Loops
    CLOSED: [2017-08-17 Thu 23:57]
**** DONE Repeating Code with ~loop~
     CLOSED: [2017-08-17 Thu 22:37]
     ~loop~ is like the ~while(true)~ in the C programming language.

**** DONE Conditional Loops with ~while~
     CLOSED: [2017-08-17 Thu 22:38]
     #+BEGIN_SRC rust
       while number != 0 {
           println!("{}!", number);
           number = number - 1;
       }
     #+END_SRC

**** DONE Looping Through a Collection with ~for~
     CLOSED: [2017-08-17 Thu 22:42]
     #+BEGIN_SRC rust
       fn main() {
           let a = [10, 20, 30, 40, 50];

           for element in a.iter() {
               println!("the value is: {}", element);
           }
       }
     #+END_SRC

     We prefer ~for~ to ~while~. We use ~for~ to iterate a collection of data,
     and no boundary check is needed.

     Use type ~Range~ values:
     #+BEGIN_SRC rust
       fn main() {
           for number in (1..4).rev() {
               println!("{}!", number);
           }
           println!("LIFTOFF!!!");
       }
     #+END_SRC

*** DONE Summary
    CLOSED: [2017-08-17 Thu 23:57]
* DONE 4. Understanding Ownership
  CLOSED: [2017-08-19 Sat 00:31]
  /ownership/ is the most unique feature of Rust,
  and
  it enables Rust to make memory safety guarantees _without_ needing a garbage
  collector.

  This chapter will talk about several related features:
  - /borrowing/
  - /slice/
  - how Rust lays data out in memory.
    
** DONE 4.1. What is Ownership?
   CLOSED: [2017-08-18 Fri 01:15]
   - ~ownership~ is the central feature of Rust.

   - _Most languages_ can be group to _TWO_ categories if considering the ways
     they manage memory:
     + With garbage collector
     + Explicitly call _allocate_ and _deallocate (free)_ operations to manage
       the memory.

     However, Rust is different from these two categories -- it has its own
     approach to manage memory:
       Memory is managed through a system of /ownership/ with a set of rules that
     the compiler checks at compile time.
       _NO run-time costs_ are incurred for any of the ownership features.

       =From Jian= I think this can be considered as a semi-automatic approach,
     you need to annotate something to make the compiler know what to do, but you
     don't need to manually and explicitly use a _deallocation/free_ operation.

   - =TODO= This chapter we work through some examples to learn how /ownership/
     works. The examples focus on a very common data structure: _strings_.

   - *The Stack and the Heap*
     - In a systems programming language like Rust, whether a value is on the
       /stack/ or the /heap/ has _more of an effect on_

       + how the language behaves

       + why we have to make certain decision.

     - Here is a brief explanation in preparation
       (We'll describe parts of /ownership/ in relation to the /stack/ and the
        /heap/ _later_ in this chapter).

       + Both the /stack/ and the /heap/ are parts of memory that is available to
         your code _at runtime_.

       + /stack/ -- LIFO.
         /push on to/ and /pop off/

       + Use the dat in /stack/ is fast:
         * no need to search
         * fixed size

       + The process of get space from /heap/ is called /allocating on the heap/.

       + /pointers/ (rather than the data it points to, some of which can be
         fixed size but not all) are known and have fixed size. They can be
         stored on the /stack/.

       + Keeping track of what parts of code are using what data on the /heap/,
         _minimizing the amount of duplicate data_ on the /heap/,
         and /cleaning up/ unused data on the /heap/ so we don't run out of space
         are all problems that /ownership/ addresses.
         =IMPORTANT=

         Once you understand /ownership/, you won't need to think about the /stack/
         and the /heap/ very often, but knowing that managing /heap/ data is why
         /ownership/ exists can help explain why it works the way it does.

*** DONE Ownership Rules
    CLOSED: [2017-08-18 Fri 01:17]
    1. _EACH_ value in Rust has a variable that's called its /owner/.
       (/owner/ is one variable)

    2. There can ONLY be ONE /owner/ at a time.

    3. When the /owner/ goes out of scope, the value will be dropped.

*** DONE Variable Scope
    CLOSED: [2017-08-18 Fri 01:20]
    As in C/C++, the boundaries of a scope is marked with a pair of curly braces.
*** DONE The ~String~ Type
    CLOSED: [2017-08-18 Fri 01:41]
    To illustrate the rules of /ownership/, we need data that stored on the
    /heap/. The data type we mentioned in Chapter 3 are all stored on the
    /stack/ (they will be popped off the /stack/ when their scope is over, NO
    need for /ownership/).

    - String literals are not enough.
      String literals are immutable, and they have known size (of course,
      "literal" indicates they are hard coded, and hard coded things are always
      of known sizes).

      What if we want _immutable_, and _unknow size_ space to store a sequence of
      characters? Then we need ~String~ variables.

    - WHY ~String~ CAN be mutated but literals CANNOT?
      #+BEGIN_SRC rust
        let mut s = String::from("hello");
        s.push_str(", world!");
        println!("{}", s);  // This will print "hello, world!"
      #+END_SRC

      _The difference is how these two types deal with memory._ 
      
*** DONE Memory and Allocation
    CLOSED: [2017-08-18 Fri 03:41]
    - WHY /string literals/ are immutable?

      All the info about string literals are fixed, they are hardcoded directly
      into the final executable (saved in the /stack/), making string literals
      fast and efficient. These properties only come from its immutability.

    - For ~String~, we need /heap/:
      + /allocation/ :: The memory must be requested from the operating system at
                        runtime.

      + /deallocation/ :: We need a way of returning this memory to the operating
                          system when we're done with our ~String~.

    - /allocation/ is done when we call ~String::from~.
      This is pretty much universal in programming languages.

    - /deallocation/ is different.
      + Some languages use GC.

      + Without GC, it is usually hard
        * if we forget, we'll waste memory.
          =From Jian= ??? _memory leak_

        * if we do it too early, we'll have an invalid variable. =TODO= segFault???

        * if we do it twice (or more), that's a but too. This happens frequently.

    - We need to pair exactly one ~allocate~ with exactly one ~free~.

    - Rust does NOT use GC, but it also takes a different path from the tradition
      way of explicitly using /allocation/ and /deallocation/:
        the memory is automatically returned once the variable that owns it goes
      out of scope.

      Rust calls the special function ~drop~ automatically and implicitly at the
      closing ~}~.

    - Note: =TODO=
      In C++, this pattern of deallocating resources at the end of an item's
      lifetime is sometimes called /Resource Acquisition Is Initialization (RAII)/.

      The ~drop~ function in Rust will be familiar to you if you've used RAII
      patterns.

    - =IMPORTANT=
      The Rust way seems simple, but it can be unexpected in more complicated
      situations when we want to have multiple variables use the data we've
      allocated on the /heap/.

**** DONE Ways Variables and Data Interact: /Move/
     CLOSED: [2017-08-18 Fri 03:25]
     #+BEGIN_SRC rust
       let s1 = String::from("hello");
       let s2 = s1;
     #+END_SRC

     - A ~String~ basic info is made up of three parts:
       + a pointer to the (/heap/) memory that holds the contents of the string,
       + a length
       + a capacity.

       This group of data is stored on the /stack/.

     - /length/ :: how much memory, in bytes, the contents of the ~String~ is
                   currently using.

     - /capacity/ :: the total amount of memory, in bytes, that the ~String~ has
                     received from the OS.

     - The _different_ between /length/ and /capacity/ matters,
       BUT _NOT in the context_, so for now, it's fine to ignore the /capacity/.

     - When we _assign_ ~s1~ to ~s2~, the ~String~ info data is copied, meaning
       we copy the /pointer/, the /length/, and the /capacity/ that are on the
       /stack/.

       We do _NOT_ copy the data on the /heap/ that the pointer refers to.

     - For the example above, if ~drop~ is naive, there will be a
       /double free error/, and it is one of the memory safety bugs.

     - Complie the code below
       #+BEGIN_SRC rust
         let s1 = String::from("hello");
         let s2 = s1;

         println!("{}", s1);
       #+END_SRC
       You'll get an error message that tells you the ~s1~ in the ~println!~ line
       is =value used here after move=.

     - /move/ :: when do operations like assignment,
       1. copy the meta info (in /stack/) of a variable,
          and
       2. invalidate the old one

       The 1. is just like the "shallow copy" concept as you know, BUT now we
       also have the step 2, that's why we have this new concept /move/.

     - In addition, there’s a design choice that’s implied by this:
       Rust will _NEVER automatically_ create “deep” copies of your data.

       Therefore, any automatic copying can be assumed to be _inexpensive_ in
       terms of runtime performance.

**** DONE Ways Variables and Data Interact: /Clone/
     CLOSED: [2017-08-18 Fri 03:25]
     If you DO want to copy the heap data of the ~String~:
     #+BEGIN_SRC rust
       let s1 = String::from("hello");
       let s2 = s1.clone();

       println!("s1 = {}, s2 = {}", s1, s2);
     #+END_SRC

     This is called /clone/, which might be _expensive_.

**** DONE Stack-Only Data: /Copy/
     CLOSED: [2017-08-18 Fri 03:41]
     #+BEGIN_SRC rust
       let x = 5;
       let y = x;

       println!("x = {}, y = {}", x, y);
     #+END_SRC

     - No compile error, ~x~ is still valid in the ~println!~ line.

     - Values of types like integer are stored on /stack/.
       Copy a value in /stack/ is NOT expensive (even in the /move/ operation, we
       copy the data in /stack/ which is cheap, we just DID NOT copy the data in
       /heap/ which can be expensive).
       Thus, NO reason to prevent ~x~ from being valid after we create ~y~.

     - ~Copy~ trait:
       + If a type has the ~Copy~ trait, an older variable is still usable after
         assignment.

       + Rust WON'T let us annotate a type with the ~Copy~ trait if the type, or
         any of its parts, has implemented the ~Drop~ trait (The _exclusive_
         property between the ~Copy~ trait and the ~Drop~ trait).

       + If the type needs something special to happen when the value goes out of
         scope and we add the ~Copy~ annotation to that type, we'll get a
         compile time error.

         =TODO= see Appendix C on Derivable Traits to learn about how to add the
         ~Copy~ annotation to your type.

     - Examples of the types that are ~Copy~:
       + All integer types
       + The boolean type
       + All floating point types
       + Tuples, but ONLY if they contain types that are also ~Copy~:
         Values of type ~(i32, i32)~ are ~Copy~.
         Values of type ~(i32, String)~ are _NOT_.

*** DONE Ownership and Functions
    CLOSED: [2017-08-18 Fri 03:44]
    The semantics for passing a value to a function are similar to assigning a
    value to a variable -- /move/ or /copy/.

*** DONE Return Values and Scope
    CLOSED: [2017-08-18 Fri 03:52]
    Returning values can also transfer ownership.

    - ~drop~ won't touch variables whose values have been /moved/.
      This is about the "content" of this variable, which is in the /heap/.

      For the meta data of this variable in /stack/, no need to pay attention,
      no matter this is a mechanism of GC or NOT, /stack/ will pop and push as
      the program run, and the programmer should almost always never touch it
      manually.

    - If we pass the value of a variable into a function and we still want to use
      this value after this call, we can return this value back:
      #+BEGIN_SRC rust
        fn main() {
            let s1 = String::from("hello");

            let (s2, len) = calculate_length(s1);

            println!("The length of '{}' is {}.", s2, len);
        }

        fn calculate_length(s: String) -> (String, usize) {
            let length = s.len(); // len() returns the length of a String.

            (s, length)
        }
      #+END_SRC

      However, this is tedious. Luckily for us, Rust has a feature called
      /references/.

** DONE 4.2. References & Borrowing
   CLOSED: [2017-08-18 Fri 18:23]
   The last example of the last section, with the help of /reference/:
   #+BEGIN_SRC rust
     fn main() {
         let s1 = String::from("hello");
         let len = calculate_length(&s1);
         println!("The length of '{}' is {}.", s1, len);
     }

     fn calculate_length(s: &String) -> usize {
         s.len()
     }
   #+END_SRC

   - These _ampersands_ above are /references/.

   - A /reference/ is essentially a pointer points to the basic info data (a
     pointer, string length, and its capacity) of ~s1~.

   - The name /reference/ indicates _NOT OWN_. NO ~drop~ will be applied to the
     data it refers to when ~s~ goes out of scope.
       On the other hand, since pointers are on /stack/, they will be poped out
     automatically.

   - We call having references as function parameters /borrowing/ -- when it's
     done, give it back.

   - If you try to modify the borrowed value, the compiler will issue an error
     =error: cannot borrow immutable borrowed content `*some_string` as mutable=
     Just as variables are immutable by default, so are references.

*** DONE Mutable References
    CLOSED: [2017-08-18 Fri 04:29]
    #+BEGIN_SRC rust
      fn main() {
          let mut s = String::from("hello");
          change(&mut s);
      }

      fn change(some_string: &mut String) {
          some_string.push_str(", world");
      }
    #+END_SRC
    
    =IMPORATN=
    ONE big _restriction_ to /mutable references/:
    you can only have _one_ /mutable reference/ to a particular piece of data
    _in a particular scope_.

    - Example of fail (CANNOT be compiled):
      =error[E0499]: cannot borrow `s` as mutable more than once at a time=
      #+BEGIN_SRC rust
        let mut s = String::from("hello");

        let r1 = &mut s;
        let r2 = &mut s;
      #+END_SRC

    - This restriction allows for mutation but _in a very controlled fashion_.
      + pros: Rust can prevent data races at compile time.
      + cons: new Rustaceans struggle with this restriction -- NOT a real cons

    - A /data race/ is a particular type of race condition in which these three
      behaviors occur:
      1. Two or more pointers access the same data at the same time.
      2. At least one of the pointers is being used to write to the data.
      3. There's no mechanism being used to synchronize access to the data.

    - Data races cause undefined behavior and can be difficult to diagnose and
      fix when you're trying to track them down at runtime;

      Rust prevents this problem from happening because it won't even compile
      code with data races!

    - As always, we can use curly brackets to create a new scope, allowing for
      multiple mutable references, just NOT simultaneous ones:
      #+BEGIN_SRC rust
        let mut s = String::from("hello");

        {
            let r1 = &mut s;
        } // r1 goes out of scope here, so we can make a new reference with no problems.

        let r2 = &mut s;
      #+END_SRC

    - A similar rule exists for combining mutable and immutable references.
      #+BEGIN_SRC rust
        let mut s = String::from("hello");

        let r1 = &s;  // NO problem
        let r2 = &s;  // NO problem
        let r3 = &mut s;  // BIG PROBLEM
      #+END_SRC
      With compile the error:
      =error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable=

    - _A_ /mutable reference/ is EXCLUSIVE with the other /references/ (both
      mutable or immutable).

      Any /immutable reference/ are compatible with the other
      /immutable references/.

      This is reasonable. Users of an _immutable references_ don't expect the
      value to suddenly change out from under them.

      On the other hand, ONLY multiple /immutable references/ have NO problem.

*** DONE Dangling References
    CLOSED: [2017-08-25 Fri 01:09]
    - /a dangling pointer/ :: a pointer that references a location in memory that
         may have been given to someone else, by freeing some memory while
         preserving a pointer to that memory.

    - Rust compiler guarantees that references will _NEVER_ be /dangling
      references/: if we have a reference to some data, the compiler will ensure
      that the data will not go out of scope before the reference to the data
      does.

    - Example of trying to create a /dangling reference/ (but fail when compile):
      #+BEGIN_SRC rust
        fn main() {
            let references_to_nothing = dangle();
        }

        fn dangle() -> &String {
            let s = String::from("hello");
            &s
        }
      #+END_SRC

      The error message:
      #+BEGIN_SRC text
        error[E0106]: missing lifetime specifier
         --> dangle.rs:5:16
          |
        5 | fn dangle() -> &String {
          |                ^^^^^^^
          |
          = help: this function's return type contains a borrowed value, but there is no
            value for it to be borrowed from
          = help: consider giving it a 'static lifetime

        error: aborting due to previous error
      #+END_SRC

      + This error message refers to a feature /lifetimes/ which will be covered
        in Chapter 10.
        =TODO=
        Just disregard this, and read the =help= part, we can know what happened.

      + The way to correct this error:
        #+BEGIN_SRC rust
          fn no_dangle() -> String {
              let s = String::from("hello");
              s
          }
        #+END_SRC

*** DONE The Rules of References
    CLOSED: [2017-08-18 Fri 03:54]
    1. At any given time, you can have either but NOT both of:
       + One mutable /reference/.
       + Any number of immutable /references/.

    2. /References/ must always be valid.

    Next, we'll look at a different kind of /reference/: /slices/.
** DONE 4.3. Slices
   CLOSED: [2017-08-19 Sat 00:31]
   - Another data type that does _NOT_ have ownership is the /slice/.

   - /slices/ let you reference a contiguous sequence of elements in a collection
     rather than the whole collection.

   - Write a small program to get the first word of a string.
     Since we don't want the ownership of the string, we pass a reference.

     What should we return?
     Since we don't really have a way to talk about part of a string, we choose
     to return the index of the end of the word.

     #+BEGIN_SRC rust
       fn first_word(s: &String) -> usize {
           let bytes = a.as_bytes();

           for (i, &item) in bytes.itre().enumerate() {
               if item == b' ' {
                   return i;
               }
           }

           s.len()
       }
     #+END_SRC

     There is a potential bug: the returned value can be available even the
     refered string is no longer there (for a mutable string).
     #+BEGIN_SRC rust
       fn main() {
           let mut s = String::from("hello world");
           let word = first_word(&s);
           s.clear();

           // operate `s` with `word` can lead to a crash.
       }
     #+END_SRC

*** DONE String Slices
    CLOSED: [2017-08-19 Sat 00:31]
    #+BEGIN_SRC rust
      let s = String::from("hello world");
      let hello = &s[0..5];
      let hello_ = &s[..5]; // for short
      let world = &s[6..11];
      let world_ = &s[6..]; // for short
    #+END_SRC

    - Then, let's re-write the ~first_word~ function ("string slice" is written
      as ~&str~):
      #+BEGIN_SRC rust
        fn first_word(s: &String) -> &str {
            let bytes = a.as_bytes();

            for (i, &item) in bytes.itre().enumerate() {
                if item == b' ' {
                    return &s[0..i];
                }
            }

            &s[..]
        }
      #+END_SRC

    - With the help of /slice/, invalid code cannot be compiled:
      #+BEGIN_SRC rust
        fn main() {
            let mut s = String::from("hello world");
            let word = first_word(&s);
            s.clear(); // ERROR!
        }
      #+END_SRC

      + The error message is:
        #+BEGIN_SRC text
          17:6 error: cannot borrow `s` as mutable because it is also borrowed as
                      immutable [E0502]
              s.clear(); // Error!
              ^
          15:29 note: previous borrow of `s` occurs here; the immutable borrow prevents
                      subsequent moves or mutable borrows of `s` until the borrow ends
              let word = first_word(&s);
                                     ^
          18:2 note: previous borrow ends here
          fn main() {

          }
          ^
        #+END_SRC

      + Explanation to the error message:
        ~clear~ needs to truncate the ~String~, it tries to take a /mutable
        reference/, which fails due to the rule that if we have an /immutable
        reference/ to a variable, we _CANNOT_ also take a /mutable reference/.

*** DONE String Literals Are Slices
    CLOSED: [2017-08-19 Sat 00:19]
    Recall that we talked about /string literals/ being stored inside the
    binary. Now that we know about /slices/, we can properly understand /string
    literals/: ~let s = "Hello, world!";~
    The type of s here is ~&str~:
    it's a slice pointing to that specific point of the binary. This is also why
    string literals are immutable; ~&str~ is an ~immutable reference~.

*** DONE String Slices as Parameters
    CLOSED: [2017-08-19 Sat 00:27]
    One move improvement on ~first_word~:
    change its type signature to ~fn first_word(s: &str) -> &str {~

    This change makes our API more general and useful without losing any
    functionality:
    #+BEGIN_SRC rust
      fn main() {
          let my_string = String::from("hello world");

          // first_word works on slices of `String`s
          let word_1 = first_word(&my_string[..]);

          let my_string_literal = "hello world";

          // first_word works on slices of string literals
          let word_2 = first_word(&my_string_literal[..]);

          // since string literals *are* string slices already,
          // this works too, without the slice syntax!
          let word_3 = first_word(my_string_literal);
      }
    #+END_SRC
*** DONE Other Slices
    CLOSED: [2017-08-19 Sat 00:29]
    For example,
    #+BEGIN_SRC rust
      let a = [1, 2, 3, 4, 5];
      let slice = &a[1..3];
    #+END_SRC

    Here the type of ~slice~ is ~&[i32]~.

    =TODO= Chapter 8

*** DONE Summary
    CLOSED: [2017-08-19 Sat 00:30]
* DONE 5. Using Structs to Structure Related Data
  CLOSED: [2017-08-19 Sat 23:48]
  - ~struct~ :: a custom data type that lets us name and package together
                multiple related values that make up a meaningful group.

  - If you're familiar with an object-oriented language, a /struct/ is like an
    object's data attributes.

  - In this chapter, we'll
    + compare and contrast /tuples/ with /structs/, demonstrate how to use /structs/,

    + discuss how to define /methods/ and /associated functions on structs/ to
      specify behavior associated with a struct's data.

  - The /struct/ and /enum/ (which is discussed in Chapter 6) concepts are the
    building blocks for creasing new types in your program's domain to take full
    advantage of Rust's compile time type checking.

** DONE 5.1. Defining and Instantiating Structs
   CLOSED: [2017-08-19 Sat 04:55]
   #+BEGIN_SRC rust
     struct User {
         username: String,
         email: String,
         sign_in_count: u64,
         active: bool,
     }
   #+END_SRC

   - Create an /instance/ of a /struct/ by specifying concrete values for each of
     the fields. The order of fields is not important.
     #+BEGIN_SRC rust
       let user1 = User {
           email: String::from("someone@example.com"),
           username: String::from("someusername123"),
           active: true,
           sign_in_count: 1,
       };
     #+END_SRC

   - Dot notation:
     + get the value of a field:
       ~user1.email~

     + if the field is mutable:
       ~user1.email = String::from("someone-else@example.com");~

*** DONE Field Init Shorthand when Variables Have the Same Name as Fields
    CLOSED: [2017-08-19 Sat 04:32]
    If some variables have the same names as struct fields, we can do
    /field init shorthand/
    #+BEGIN_SRC rust
      fn build_user(email: String, username: String) -> User {
          User {
              email,
              username,
              active: true,
              sign_in_count: 1,
          }
      }
    #+END_SRC

*** DONE Creating Instances From Other Instances With Struct Update Syntax
    CLOSED: [2017-08-19 Sat 04:32]
    #+BEGIN_SRC rust
      // Suppose `user1` is in scope, and
      // the `active` field and `sign_in_count` of `user2` are the same as `user1`
      let user2 = User {
          email: String::from("another@example.com"),
          username: String::from("anotherusername567"),
          ..user1
      };
    #+END_SRC
*** DONE Tuple Structs without Named Fields to Create Different Types
    CLOSED: [2017-08-19 Sat 04:38]
    /tuple struct/
    #+BEGIN_SRC rust
      struct Color(i32, i32, i32);
      struct Point(i32, i32, i32);

      // The types in the definitions of `Color` and `Point` are the same,
      // but we can use the *name* to differentiate them.
      let black = Color(0, 0, 0);
      let origin = Point(0, 0, 0);
    #+END_SRC

*** DONE Unit-Like Structs without Any Fields
    CLOSED: [2017-08-19 Sat 04:55]
    - /unit-like struct/
      + it behave similarly to ~()~, the unit type.

      + it is useful in situations such as when you need to implement a trait on
        some type, but you don't have any data you want to store in the type
        itself. =TODO= CHAPTER 10

    - *Ownership of Struct Data*
      + in the examples above, when we define a /struct/, for its field, we
        chose ~String~ rather than ~&str~. This means for the cases here, we want
        instances of this /struct/ to own all of its data and for that data to
        be valid for as long as the entire struct is valid.

      + if we use reference type for a field, we need to specify /lifetime/.
        =TODO= CHAPTER 10.
        For now, we just not use reference.

** DONE 5.2. An Example Program Using Structs
   CLOSED: [2017-08-19 Sat 06:24]
   The evalution of a example (finally) with a ~struct~
   #+BEGIN_SRC rust
     // Ver 1
     fn main() {
         let length1 = 50;
         let width1 = 30;

         println!(
             "The area of the rectangle is {} square pixels.",
             area(length1, width1)
         );
     }

     fn area(length: u32, width: u32) -> u32 {
         length * width
     }
   #+END_SRC

*** DONE Refactoring with Tuples
    CLOSED: [2017-08-19 Sat 05:56]
    #+BEGIN_SRC rust
      fn main() {
          let rect1 = (50, 30);

          println!(
              "The area of the rectangle is {} square pixels.",
              area(rect1)
          );
      }

      fn area(dimensions: (u32, u32)) -> u32 {
          dimensions.0 * dimensions.1
      }
    #+END_SRC

*** DONE Refactoring with Structs: Adding More Meaning
    CLOSED: [2017-08-19 Sat 05:59]
    #+BEGIN_SRC rust
      struct Rectangle {
          length: u32,
          width: u32,
      }

      fn main() {
          let rect1 = Rectangle { length: 50, width: 30 };

          println!(
              "The area of the rectangle is {} square pixels.",
              area(&rect1)
          );
      }

      fn area(rectangle: &Rectangle) -> u32 {
          rectangle.length * rectangle.width
      }
    #+END_SRC

*** TODO Adding Useful Functionality with Derived Traits
    If we try to print the struct we defined with
    ~println!("rect1 is {}", rect1);~
    , we will receive an error message:
    =error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied=

    Read the message below the last line, we can get some hints:
    =note: `Rectangle` cannot be formatted with the default formatter; try using=
    =`:?` instead if you are using a format string=

    Then try ~println!("rect1 is {:?}", rect1);~
    This output format is called ~Debug~. ~Debug~ is a trait that enables us to
    print out our struct in a way that is useful for developers so we can see its
    value while we're debugging our code.

    We see =error: the trait bound `Rectangle: std::fmt::Debug` is not satisfied=
    But we also see
    =note: `Rectangle` cannot be formatted using `:?`; if it is defined in your=
    =crate, add `#[derive(Debug)]` or manually implement it=

    #+BEGIN_SRC rust
      #[derive(Debug)]

      struct Rectangle {
          length: u32,
          width: u32,
      }

      fn main() {
          let rect1 = Rectangle { length: 50, width: 30 };

          println!("rect1 is {:?}", rect1);
      }
    #+END_SRC

    The output is =rect1 is Rectangle { length: 50, width: 30 }=
    Use ~{:#?}~ instead of ~{:?}~, we can a different style of print:
    #+BEGIN_SRC text
      rect1 is Rectangle {
          length: 50,
          width: 30
      }
    #+END_SRC

** DONE 5.3. Method Syntax
   CLOSED: [2017-08-19 Sat 23:48]
   /methods/ are different from /functions/ in that they're defined within the
   context of
   + a struct
   + an enum =TODO= Chapter 6
   + a trait object =TODO= Chapter 17

   Their first parameter is always ~self~, which represents the instance of the
   /struct/ the method is being called on.

*** TODO Defining Methods
    =RE-READ=
    Re-write the example in the last section, make ~area~ a method of the
    ~Rectangle~ struct.
    #+BEGIN_SRC rust
      #[derive(Debug)]
      struct Rectangle {
          length: u32,
          width: u32,
      }

      impl Rectangle {
          fn area(&self) -> u32 {
              self.length * self.width
          }
      }

      fn main() {
          let rect1 = Rectangle { length: 50, width: 30 };

          println!(
              "The area of the rectangle is {} square pixels.",
              rect1.area()
          );
      }
    #+END_SRC

    - ~impl~ block.

    - Methods can, just like any other parameter,
      + take ownership of ~self~,
      + borrow ~self~ immutably as we've done here,
      + borrow ~self~ mutably.

    - Having a method that takes ownership of the instance by using just self as
      the first parameter is _RARE_;
      this technique is usually used when the method transforms ~self~ into
      something else and we want to prevent the caller from using the original
      instance after the transformation.
      =TODO= you can imagine -- it's rare to call a method and then the passed in
      object is no longer valid. Of course, this method can return a new object
      and disable the old one (=FROM Jian= a functional way, but I doubt if this
      is often used in Rust).

    - *Where's the -> Operator?* =TODO=
      + In C++, if ~object~ is a pointer, there are two ways to call a method:
        - ~object->something()~
        - ~(*object).something()~

      + Rust does NOT have an equivalent to the ~->~ operator;
        Rust has a feature called /automatic referencing and dereferencing/.
        Calling methods is one of the few places in Rust that has this behavior.

        =TODO= BAD example ...
        This means the usually method call form is ~object.something()~.
          Rust automatically adds in ~&~, ~&mut~, or ~*~ so ~object~ matches the
        signatue of the method. In other words, the following are the same:
        * ~p1.distance(&p2);~
        * ~(&p1).distance(&p2);~

      + The first one looks much cleaner.
        This automatic referencing behavior works because methods have a clear
        receiver -- the type of ~self~. Given the receiver and name of a method,
        Rust can figure out definitively whether the method is reading
        (~&self~), mutating (~&mut self~), or consuming (~self~). The fact that
        Rust makes borrowing implicit for method receivers is a big part of
        making ownership ergonomic in practice.

*** DONE Methods with More Parameters
    CLOSED: [2017-08-19 Sat 23:19]
    #+BEGIN_SRC rust
      impl Rectangle {
          fn area(&self) -> u32 {
              self.length * self.width
          }

          fn can_hold() -> bool {
              self.length > other.length && self.width > other.width
          }
      }

      fn main() {
          let rect1 = Rectangle { length: 50, width: 30 };
          let rect2 = Rectangle { length: 40, width: 10 };
          let rect3 = Rectangle { length: 45, width: 60 };

          println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));  // true
          println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));  // false
      }
    #+END_SRC
*** DONE Associated Functions
    CLOSED: [2017-08-19 Sat 23:46]
    - /associated functions/: functions that don't take ~self~ as the first
      parameter.

    - I think this is the /static methods/ in the other OOP languages.

    - Example:
      #+BEGIN_SRC rust
        impl Rectangle {
            fn square(size: u32) -> Rectangle {
                Rectangle { length: size, width: size }
            }
        }
      #+END_SRC

      Call /associated functions/ with the syntax like ~Rectangle::square(3);~

    - The ~::~ syntax is used for both associated functions and namespaces crated
      by modules.
      =From Jian=
        From the point of view of semantics, ~Rectangle~ is essentially a
      namespace for ~square~.

*** DONE Summary
    CLOSED: [2017-08-19 Sat 23:48]
    - Structs ... =TODO=

    - Structs are NOT the only way we can create custom types: let's turn to
      Rust's _enum_ feature to add another tool to our toolbox.

* DONE 6. Enums and Pattern Match
  CLOSED: [2017-08-20 Sun 04:56]
  - /enums/ :: define a type by enumerating its possible values.
** DONE 6.1. Defining an Enum
   CLOSED: [2017-08-20 Sun 04:24]
   For example, define a data type that can be used to anotate all IP v4 and
   IP v6 addresses.
   #+BEGIN_SRC rust
     enum IpAddrKind {
         V4,
         V6,
     }
   #+END_SRC

*** DONE Enum Values
    CLOSED: [2017-08-20 Sun 03:41]
    - The above example is too simple! It only show the type and NO address info,
      which is not very useful. We can combine it with a /struct/:
      #+BEGIN_SRC rust
        // The definition of `IpAddrKind` is in scope

        struct IpAddr {
            kind: IpAddrKind,
            address: String,
        }

        let home = IpAddr {
            kind: IpAddrKind::V4,
            address: String::from("127.0.0.1"),
        };

        let loopback = IpAddr {
            kind: IpAddrKind::V6,
            address: String::from("::1"),
        };
      #+END_SRC

    - Usually we don't use /enums/ in the way above.
      Here is a concise and practical way to use /enums/ only (with its usages):
      #+BEGIN_SRC rust
        enum IpAddr {
            V4(String),
            V6(String),
        }

        let home = IpAddr::V4(String::from("127.0.0.1"));
        let loopback = IpAddr::V6(String::from("::1"));
      #+END_SRC

      + This better than the way of composing ~enum~ and ~struct~ together: 
        * more concise
        * No limitations about the address info
          #+BEGIN_SRC rust
            // We can do
            enum IpAddr {
                V4(u8, u8, u8, u8),
                V6(String),
            }
            let home = IpAddr::V4(127, 0, 0, 1);
            let loopback = IpAddr::V6(String::from("::1"));

            // BUT we CANNOT specify two types of data for the `address` field of structs in
            // a concise way.
          #+END_SRC

      + The standard library ~std::new~ has a /enum/ ~IpAddr~, its definition is:
        #+BEGIN_SRC rust
          struct Ipv4Addr {
              // details elided
          }

          struct Ipv4Addr {
              // details elided
          }

          enum IpAddr {
              V4(Ipv4Addr),
              V6(Ipv6Addr),
          }
        #+END_SRC

    - Another example:
      #+BEGIN_SRC rust
        // Use `enum`, all variants have the same type.
        // Write a function with this type of parameter(s) is simple.
        enum Message {
            Quit,
            Move { x: i32, y: i32 },
            Write(String),
            ChangeColor(i32, i32, i32),
        }

        // Use `struct`'s. Four types.
        // To Write a function for all of these types, we need polymorphism.
        struct QuitMessage; // unit struct
        struct MoveMessage {
            x: i32,
            y: i32,
        }
        struct WriteMessage(String); // tuple struct
        struct ChangeColorMessage(i32, i32, i32); // tuple struct
      #+END_SRC

*** DONE The ~Option~ Enum and Its Advantages Over Null Values
    CLOSED: [2017-08-20 Sun 04:23]
    #+BEGIN_SRC rust
      // Defined in the standard library (the prelude).
      // NO `Option::` prefix required.
      enum Option<T> {
          Some(T),
          None,
      }
    #+END_SRC

    - The ~<T>~ part, generics, =TODO= Chapter 10

    - If we use ~None~ rahter than ~Some~, we need to tell Rust what type of
      ~Option<T>~ we have, because the compiler _CANNOT_ infer the type that the
      type that the ~Some~ variant will hold by looking only at a ~None~ value.

** DONE 6.2. The ~match~ Control Flow Operator
   CLOSED: [2017-08-20 Sun 04:56]
   =TODO= Chapter 18 will cover all the different kinds of patterns and what they do.

   - Example:
     #+BEGIN_SRC rust
       enum Coin {
           Penny,
           Nickel,
           Dime,
           Quarter,
       }

       fn value_in_cents(coin: Coin) -> i32 {
           match coin {
               Coin::Penny => 1,
               Coin::Nickel => 5,
               Coin::Dime => 10,
               Coin::Quarter => 25,
           }
       }
     #+END_SRC
     Curly braces is only used when you want multiple lines in a match arm.

*** DONE Patterns that Bind to Values
    CLOSED: [2017-08-20 Sun 04:44]
    #+BEGIN_SRC rust
      #[derive(Debug)] // So we can inspect the state in a minute

      enum UsState {
          Alabama,
          Alaska,
          // ... etc
      }

      enum Coin {
          Penny,
          Nickel,
          Dime,
          Quarter(UsState),
      }

      fn value_in_cents(coin: Coin) -> i32 {
          match coin {
              Coin::Penny => 1,
              Coin::Nickel => 5,
              Coin::Dime => 10,
              Coin::Quarter(state) => {
                  println!("State quarter from {:?}!", state);
                  25
              },
          }
      }
    #+END_SRC

*** DONE Matching with ~Option<T>~
    CLOSED: [2017-08-20 Sun 04:46]
    =From Jian= In other languages, pattern match is usually NOT the best (the
    most concise) way to process ~Option<T>~ type values.
    How about Rust????? =TODO=

    #+BEGIN_SRC rust
      fn plus_one(x: Option<i32>) -> Option<i32> {
          match x {
              None => None,
              Some(i) => Some(i + 1),
          }
      }

      let five = Some(5);
      let six = plus_one(five);
      let none = plus_one(None);
    #+END_SRC
**** DONE Matching ~Some(T)~
     CLOSED: [2017-08-20 Sun 04:47]
**** DONE Matching ~None~
     CLOSED: [2017-08-20 Sun 04:47]
*** DONE Matches Are Exhaustive
    CLOSED: [2017-08-20 Sun 04:53]
    Rust Compiler has /exhaustive check/ for pattern matching.
    Non-exhaustive result in an error, rather than warning as in other languages.
    #+BEGIN_SRC rust
      fn plus_one(x: Option<i32>) -> Option<i32> {
          match x {
              Some(i) => Some(i + 1),
          }
      }

      // error[E0004]: non-exhaustive patterns: `None` not covered.
      //  -->
      //   |
      // 6 |         match x {
      //   |               ^ pattern `None` not covered
    #+END_SRC

*** DONE The ~_~ Placeholder
    CLOSED: [2017-08-20 Sun 04:56]
    ~_~ is a pattern that can match any value, and it always shows up as the last
    pattern (or other patterns can never be matched).

** DONE 6.3. Concise Control Flow with ~if let~
   CLOSED: [2017-08-20 Sun 04:38]
   The ~if let~ syntax lets you combine ~if~ and ~let~ into a less verbose way to
   handle values that match one pattern and ignore the rest.
   #+BEGIN_SRC rust
     let some_u8_value = Some(0u8);
     match some_u8_value {
         Some(3) => println!("three"),
         _ => (),
     }

     // With `if let`
     if let Some(3) = some_u8_value {
         println!("three");
     }
   #+END_SRC
   + With ~if let~ we lose exhaustive checking, but more concise.
     Choose ~if let~ or ~match~ is a trade-off.

   + ~if let~ can have an ~else~ branch.
     #+BEGIN_SRC rust
       let mut count = 0;
       match coin {
           Coin::Quarter(state) => println!("State quarter from {:?}!", state),
           _ => count += 1,
       }
     #+END_SRC

     Or use ~if let~ and ~else~

     #+BEGIN_SRC rust
       let mut count = 0;
       if let Coin::Quarter(state) = coin {
           println!("State quarter from {:?}!", state);
       } else {
           count += 1;
       }
     #+END_SRC

*** DONE Summary
    CLOSED: [2017-08-20 Sun 04:38]
* DONE 7. Modules
  CLOSED: [2017-08-21 Mon 22:41]
  =Old-Title=: _Using Modules to Reuse and Orgnize Code_

  - A /module/ :: a /namespace/ that contains definitions of functions or types,
                  and you can choose whether those definitions are visible
                  outside their module (public) or not (private).

  - An overview of how modules work:
    + The ~mod~ keyword declares a new module.
      Code within the module appears
      + either immediately following this declaration within curly braces
        or
      + in another file. =TODO= =???=

    + _By default_, functions, types, constants, and modules are _private_. The
      ~pub~ keyword makes an item public and therefore visible outside its
      namespace.

    + The ~use~ keyword brings modules, or the definitions inside modules, into
      scope so it's easier to refer to them.

** DONE 7.1. ~mod~ and the Filesystem
   CLOSED: [2017-08-21 Mon 11:09]
   - Create a library project named =communicator= (just use the ~cargo~ command
     we used before, and drop the ~--bin~ option):
     ~cargo new communicator~

   - The initialized library project has a source file of =src/lib.rs=:
     #+BEGIN_SRC rust
       #[cfg(test)]
       mod tests {
           #[test]
           fn it_works() {
           }
       }
     #+END_SRC

     + It's clear that ~cargo~ helped you creating a =tests= ~mod~.

     + =TODO= The ~#[...~ part will be talked about later in the "Using super to
       Access a Parent Module" section.

   - There's nothing for Cargo to execute with the ~cargo run~ command (no
     =src/main.rs= file). To build this kind of project, use ~cargo build~ rather
     than ~cargo run~.

*** DONE Module Definitions
    CLOSED: [2017-08-21 Mon 10:34]
    #+BEGIN_SRC rust
      mod network {
          fn connect() {
          }

          mod client {
              fn connect() {
              }
          }
      }
    #+END_SRC

    - Everything in a ~mod~ block is inside its namespace.

    - /modules/ can be embedded.

*** DONE Moving Modules to Other Files
    CLOSED: [2017-08-21 Mon 11:04]
    - The original code is (if ignore the =tests= mod):
      #+BEGIN_SRC rust
        // src/lib.rs
        mod client {
            fn connect() {
            }
        }

        mod network {
            fn connect() {
            }

            mod server {
                fn connect() {
                }
            }
        }
      #+END_SRC

    - Its module Hierarchy:

      communicator
       |-- client
       |-- network
           |-- server

    - First, factor out the (non-embedded) ~client~ module.
      #+BEGIN_SRC rust
        // src/lib.rs
        mod client;

        // src/client.rs
        fn connect() {
        }
      #+END_SRC

      Run ~cargo build~, and you'll see three _warnings_.
      =TODO= Address this later in this chapter.

    - Second, factor out the (embedded) ~network~ module (partially).
      #+BEGIN_SRC rust
        // src/lib.rs
        mod network;

        // src/network.rs
        fn connect() {
        }

        mod server {
            fn connect() {
            }
        }
      #+END_SRC

    - Three, factor out the ~server~ module from the =network.rs=.
      + Wrong way:
        #+BEGIN_SRC rust
          // src/network.rs
          fn connect() {
          }

          mod server;

          // src/server.rs
          fn connect() {
          }
        #+END_SRC

        Run ~cargo build~, and you'll see error messages.
        There is some useful information:
        =note: maybe move this module `network` to its own directory via `network/mod.rs`=

      + Right way (based on the WRONG way):
        From the top-level of this project
        ~mkdir src/network~
        ~mv src/network.rs src/network/mod.rs~
        ~mv src/server.rs src/network~

        The corresponding file layout now looks like this (only the =src= folder):
        src
         |-- client.rs
         |-- lib.rs
         |-- network
             |-- mod.rs
             |-- server.rs

*** DONE Rules of Module Filesystems
    CLOSED: [2017-08-21 Mon 11:09]
    - Let's summarize the rules of modules with regard to files:
      + If a module named ~foo~ has _NO_ submodules, you should put the
        declarations for ~foo~ in a file named =foo.rs=.

      + If a module named ~foo~ _does have_ submodules, you should put the
        declarations for ~foo~ in a file named =foo/mod.rs=.
        Then put the submodules inside =foo=.

** DONE 7.2. Controlling Visibility with ~pub~
   CLOSED: [2017-08-21 Mon 22:41]
   There are _function is never used_ warnings in the last section:
   - Functions in a module is default private. If you never use them, the
     compiler will think you may made some mistakes.

   - Use the ~pub~ keyword to make declaration.
     Do not use a ~pub~ function is reasonable, and the compiler won't issue
     warnings anymore.

   - =TODO=

   - /root module/ =TODO=

*** DONE Making a Function Public
    CLOSED: [2017-08-21 Mon 11:28]
    To tell Rust to make something public, we add the ~pub~ keyword to the start
    of the declaration of the item we want to make public.
    #+BEGIN_SRC rust
      // src/lib.rs
      pub mod client;
      mod network;
    #+END_SRC

    This is not enough for us to use ~client::connect~, and we'll see an error
    message when we build this project.

    Also use ~pub~ for the function:
    #+BEGIN_SRC rust
      // src/client.rs
      pub fn connect() {
      }


      // src/network/mod.rs
      pub fn connect() {
      }

      // src/lib.rs
      pub mod client;
      pub mod network;

      // src/network/server.rs
      pub fn connect() {
      }
    #+END_SRC

*** DONE Privacy Rules
    CLOSED: [2017-08-21 Mon 11:29]
    Overall, these are the rules for item visibility:
    - If an item is public, it can be accessed through any of its parent modules.

    - If an item is private, it can be accessed only by the current module and
      its child modules. 

*** DONE Privacy Examples
    CLOSED: [2017-08-21 Mon 20:48]
    Create a new project with the code below
    #+BEGIN_SRC rust
      // src/lib.rs
      mod outermost {
          pub fn middle_function() {}

          fn middle_secret_function() {}

          mod inside {
              pub fn inner_function() {}

              fn secret_function() {}
          }
      }

      fn try_me() {
          outermost::middle_function();
          outermost::middle_secret_function();
          outermost::inside::inner_function();
          outermost::inside::secret_function();
      }
    #+END_SRC

    There are errors inside this code. Please try to find out.

**** DONE Looking at the Errors
     CLOSED: [2017-08-21 Mon 21:57]
     - ~try_me~ and ~outermost~ are in the same module,
       therefore, accroding to the 2nd rule, ~try_me~ can access _non-public_
       ~outermost~.

     - The ~middle_secret_function~ should be ~pub~, or else the call will fail
       to be compiled.

     - The ~inside~ module should be ~pub~, only make ~inner_function~ public
       won't guarantee ~outermost::inside::inner_function()~ to be compiled.

       function ~secret_function~ should be ~pub~.

**** DONE Fixing the Errors
     CLOSED: [2017-08-21 Mon 22:41]
     In the body of ~inner_function()~ call
     ~::outermost::middle_secret_function()~ has NO error.
     _Rule 2_
     
** DONE 7.3. Importing Names with use
   CLOSED: [2017-08-21 Mon 21:33]
*** DONE Concise Imports with ~use~
    CLOSED: [2017-08-21 Mon 20:59]
    - One ~use~ example
      #+BEGIN_SRC rust
        pub mod a {
            pub mod series {
                pub mod of {
                    pub fn nested_modules() {}
                }
            }
        }
  
        use a::series::of;
  
        fn main() {
            // If there is no `use` line above,
            // we need to write `a::series::of::nested_modules();`
            of::nested_modules();
        }
      #+END_SRC

    - /enums/ also form a sort of namespace like modules, we can import the
      variants of an /enum/ as well.
        If you're importing multiple items from one namespace, you can list them
      using curly braces and commas in the last position, like so:
      #+BEGIN_SRC rust
        enum TrafficLight {
            Red,
            Yellow,
            Green,
        }

        use TrafficLight::{Red, Yellow};

        fn main() {
            let red = Red;
            let yellow = Yellow;
            // you didn't `use TrafficLight::Green` above
            let green = TrafficLight::Green;
        }
      #+END_SRC

*** DONE Glob Imports with ~*~
    CLOSED: [2017-08-21 Mon 21:06]
    In the example of the last section, we can do ~use TrafficLight::*;~, and
    then we import all the things in ~TrafficLight~. After doing this, the last
    line can be ~let green = Green;~

    - ~*~ is convenient

    - Use ~*~ improperly often results in names conflictions.
      =From Jian= Always ask yourself if there is a strong enough reason, with
      which you think you should use ~*~.

*** DONE Using ~super~ to Access a Parent Module
    CLOSED: [2017-08-21 Mon 21:33]
    Let's go into more detail about the ~tests~ module, which is created
    automatically by Cargo.

    - =TODO= More in Chapter 11

    - The module hierarchy looks like this:
      communicator
       |-- client
       |-- network
       |   |-- client
       |
       |-- tests

      + Right examples:
        * #1
          #+BEGIN_SRC rust
            #[cfg(test)]
            mod tests {
                use super::client;

                #[test]
                fn it_works() {
                    client::connect();
                }
            }
          #+END_SRC

        * #2
          #+BEGIN_SRC rust
            #[cfg(test)]
            mod tests {

                #[test]
                fn it_works() {
                    ::client::connect();
                    // OR
                    // super::client::connect();
                }
            }
          #+END_SRC

      + These two options in the #2 example don't look that different,
        but if you're deeper in a module hierarchy, starting from the root every
        time would make your code lengthy.

        In those cases, using `super` to get from the current module to sibling
        modules is a good shortcut.

        Plus, if you've specified the path from the _root_ in many places in your
        code and then you rearrange your modules by moving a subtree to another
        place, you'd end up needing to update the path in several places, which
        would be tedious. Comparing to this, the relations between modules and
        their one level up siblings are relatively stable, and they usually NOT
        change when people refactor their code.

    - =TODO= =From Jian= Can we use a ~super~ stack (~super::super::...~) to
      level up?

*** DONE Summary
    CLOSED: [2017-08-21 Mon 21:33]
* TODO 8. Common Collections -- In progress
** DONE 8.1. Vectors
   CLOSED: [2017-08-20 Sun 05:26]
   - /vector/ :: ~Vec<T>~.

   - /Vectors/ allow us to store more than one value in a single data structure
     that puts _all the values next to each other in memory_.

   - Vectors can _ONLY_ store values of the _same type_.
     /homogeneous/

   - They are useful in situations where you have a list of items,

*** DONE Creating a New Vector
    CLOSED: [2017-08-20 Sun 05:03]
    - Create an empty /vector/: ~let v: Vec<i32> = Vec::new();~
      The type annotation is required.

    - Use macro ~vec!~ to create a /vector/ with initial values:
      ~let v = vec![1, 2, 3];~

*** DONE Updating a Vector
    CLOSED: [2017-08-20 Sun 05:05]
    #+BEGIN_SRC rust
      let mut v = Vec::new();

      v.push(5);
      v.push(6);
      // Rust can infer that the type of `v` is `Vec<i32>`
    #+END_SRC

    The ~mut~ is for the inside of this vector.
    (=From Jian= The book doesn't mention if this ~mut~ is for the ~v~ itself.
     However, since Rust has /shadow/ feature, I'm pretty sure that ~mut~ is NOT
     for ~v~ itself)
     
*** DONE Dropping a Vector Drops its Elements
    CLOSED: [2017-08-20 Sun 05:09]
    #+BEGIN_SRC rust
      {
          let v = vec![1, 2, 3, 4];

          // do stuff with `v`

      }  // <- `v` goes out of scope and is freed here
    #+END_SRC
    =TODO=
    This may seem like a straightforward point, but can get a little more
    complicated once we start to introduce references to the elements of the
    vector. Let’s tackle that next!

*** DONE Reading Elements of Vectors
    CLOSED: [2017-08-20 Sun 05:19]
    #+BEGIN_SRC rust
      let v = vec![1, 2, 3, 4, 5];

      let third: &i32 = &v[2];
      let third_opt: Option<&i32> = v.get(2);
    #+END_SRC
**** DONE Invalid References
     CLOSED: [2017-08-20 Sun 05:19]
     #+BEGIN_SRC rust
       let mut v = vec![1, 2, 3, 4, 5];

       let first = &v[0];

       v.push(6);
     #+END_SRC

     The code above seems should work, but it DOESN'T!!!
     #+BEGIN_SRC text
       error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
       immutable
         |
       4 | let first = &v[0];
         |              - immutable borrow occurs here
       5 |
       6 | v.push(6);
         | ^ mutable borrow occurs here
       7 | }
         | - immutable borrow ends here
     #+END_SRC

     =IMPORTANT= =IMPORTANT= =IMPORTANT=
     _The error is essentially related to the layout of vectors in memory_:
     Adding a new element onto the end of the vector might require allocating
     new memory and copying the old elements over to the new space, in the
     circumstance that there isn't enough room to put all the elements next to
     each other where the vector was. In that case, the reference to the first
     element would be pointing to deallocated memory. The borrowing rules
     prevent programs from ending up in that situation.

     NOTE: For more on this, see the Nomicon at
           https://doc.rust-lang.org/stable/nomicon/vec.html.

*** DONE Using an Enum to Store Multiple Types
    CLOSED: [2017-08-20 Sun 05:26]
    - With the help of /enums/, /vectors/ can store values with de facto
      different types, though they have the same type as variants of a /enum/.
      #+BEGIN_SRC rust
        enum SpreadsheetCell {
            Int(i32),
            Float(f64),
            Text(String),
        }

        let row = vec![
            SpreadsheetCell::Int(3),
            SpreadsheetCell::Text(String::from("blue")),
            SpreadsheetCell::Float(10.12),
        ];
      #+END_SRC

    - =TODO=
      If you don't know at the time that you're writing a program the exhaustive
      set of types the program will get at runtime to store in a vector, the
      enum technique won't work. Instead, you can use a trait object, which
      we'll cover in _Chapter 17_.

    - Both ~push~ and ~pop~ do thing to the end of ~Vec~.
** TODO 8.2. Strings
   Strings are an area that new Rustaceans commonly get stuck on.
   This is due to a combination of three things:  =???= =TODO=
   + Rust's propensity for making sure to expose possible errors,
   + strings being a more complicated data structure than many programmers give
     them credit for, and
   + UTF-8

*** DONE What is a String?
    CLOSED: [2017-08-22 Tue 00:01]
   Rust _actually_ only has one string type in the core language itself: ~str~,
   the /string slice/, which is usually seen in its borrowed form, ~&str~.
   
   - ~String~ is provided in the standard library of Rust, rather than coded into
     the core language, and is a _growable_, _mutable_, _owned_, _UTF-8 encoded_
     string type.

   - When Rustaceans talk about "strings", they usually mean both the ~String~
     and the string slice ~&str~ types.

   - Both ~String~ and /string slices/ are UTF-8 encoded.

   - =TODO= Read the API doc to get more details about the other string types,
     + standard library: ~0sString~, ~0sStr~, ~CString~, and ~CStr~.

     + library crates: ....

     + Similar to the ~*String~ / ~*Str~ naming =TODO=, =???=, they often provide
       an owned and borrowed variant, just like ~String~ / ~&str~. 

*** DONE Creating a New String
    CLOSED: [2017-08-22 Tue 00:01]
    - ~let mut s = String::new();~

    - string literal to ~String~.
      ~let s = "initial contents".to_string();~
      ~let s = String::from("initial contents")~

*** DONE Updating a String
    CLOSED: [2017-08-22 Tue 00:26]
**** DONE Appending to a String with Push
     CLOSED: [2017-08-22 Tue 00:05]
     #+BEGIN_SRC rust
       let mut s = String::from("foo");
       s.push_str("bar");

       let mut s1 = String::from("foo");
       let s2 = String::from("bar");
       s1.push_str(&s2);
       // s2 is still valid

       let mut s3 = String::from("lo");
       s.push('l');
     #+END_SRC

**** DONE Concatenation with the ~+~ Operator or the ~format!~ Macro
     CLOSED: [2017-08-22 Tue 00:26]
     #+BEGIN_SRC rust
       let s1 = String::from("Hello, ");
       let s2 = String::from("world!");
       let s3 = s1 + &s2; // Note that s1 has been moved here and can no longer be used.
       // this is due to what doese `+` do under the hood
       // `fn add(self, s: &str) -> String`.
     #+END_SRC

     - The ~&s2~ is ~&String~, and the ~add~ method requires ~&str~.
       Q: What happened makes this right?
       A: A ~&String~ argument can be /coerced/ into a ~&str~ - when the ~add~
          function is called, Rust uses /deref coercion/. 

     - /deref coercion/: you could think of _here_ as turning ~&s2~ into ~s2[..]~
       for use in the ~add~ function.
       =TODO= chapter 15

     - Concatenate multiple strings:
       ~let s = format!("{}-{}-{}", s1, s2, s3);~
       This doesn't take ownership of any of its parameters.

*** TODO Indexing into String
    Try the indexing operation (as in other languages).
    You'll get an error message:
    #+BEGIN_SRC text
      error: the trait bound `std::string::String: std::ops::Index<_>` is not
      satisfied [--explain E0277]
        |>
        |>     let h = s1[0];
        |>             ^^^^^
      note: the type `std::string::String` cannot be indexed by `_`
    #+END_SRC

    This indicate that Rust strings do NOT support indexing.

    WHY?
    In order to answer that, we have to talk a bit about how Rust stores strings
    in memory.

**** DONE Internal Representation
     CLOSED: [2017-08-22 Tue 00:35]
     A ~String~ is a wrapper over a ~Vec<u8>~.
     However, one UTF-8 character can take two bytes. If there is indexing, the
     returned value can be a number of no sense if considered as a character.

     For example,
     ~let hello = "Здравствуйте";~, of which ~hello.len()~ is 24, rather than 12.
     If ~&hello[0]~ is workable, it should be 208, which is NOT a valid
     character on its own.

**** TODO Bytes and Scalar Values and Grapheme Clusters! Oh my!
**** TODO Slicing Strings
**** TODO Methods for Iterating Over Strings
**** TODO Strings are Not so Simple
** TODO 8.3. Hash Maps
   ~HashMap<K, V>~
*** TODO Creating a New Hash Map
    #+BEGIN_SRC rust
      use std::collections::HashMap;

      let mut scores = HashMap::new();

      scores.insert(String::from("Blue"), 10);
      scores.insert(String::from("Yellow"), 50);
    #+END_SRC

    Of the three collections, hash map is the least often used, so it's NOT
    included in the features imported automatically in the prelude.
    Hash maps also have less support from the standard library; for example,
    hash maps have no built-in macro to construct them.

    #+BEGIN_SRC rust
      use std::collections::HashMap;

      let teams = vec![String::from("Blue"), String::from("Yellow")];
      let initial_scores = vec![10, 50];

      let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();
    #+END_SRC

*** DONE Hash Maps and Ownership
    CLOSED: [2017-08-22 Tue 00:58]
    For types that implement the ~Copy~ trait, like ~i32~, the values are copied
    into the hash map.
      For owned values like String, the values will be moved and the hash map
    will be the owner of those values:

    #+BEGIN_SRC rust
      use std::collections::HashMap;

      let field_name = String::from("Favorite color");
      let field_value = String::from("Blue");

      let mut map = HashMap::new();
      map.insert(field_name, field_value);
      // `field_name` and `field_value` are invalid at this point.
      // The _move_ is done by the `insert` method.
    #+END_SRC

*** DONE Accessing Values in a Hash Map
    CLOSED: [2017-08-22 Tue 01:06]
    #+BEGIN_SRC rust
      use std::collections::HashMap;

      let mut scores = HashMap::new();

      scores.insert(String::from("Blue"), 10);
      scores.insert(String::from("Yellow"), 50);

      // #1. The `get` method (the return value is `Option<&V>`):
      let team_name = String::from("Blue");
      let score = scores.get(&team_name);

      // #2. Iterate over each key/value pair in a hash map in a similar manner
      //     as we do with vectors:
      for (key, value) in &scores {
          println!("{}: {}", key, value);
      }
    #+END_SRC

*** TODO Updating a Hash Map
**** DONE Overwriting a Value
     CLOSED: [2017-08-22 Tue 01:09]
     Do ~insert~ more than one times for one key.

**** DONE Only Insert If the Key Has No Value
     CLOSED: [2017-08-22 Tue 01:21]
     #+BEGIN_SRC rust
       use std::collections::HashMap;

       let mut scores = HashMap::new();
       scores.insert(String::from("Blue"), 10);

       scores.entry(String::from("Yellow")).or_insert(50);
       scores.entry(String::from("Blue")).or_insert(50);

       println!("{:?}", scores);
       // Only "Blue" and its value
     #+END_SRC

     - ~entry~ returan a value of enum, ~Entry~.

     - The ~or_insert~ method on ~Entry~ returns
       + the value for the corresponding ~Entry~ key if it exists, and
       + if not, inserts its argument as the new value for this key and returns
         the modified ~Entry~.

       This is much cleaner than writing the logic ourselves, and in addition,
       plays more nicely with the borrow checker.

**** DONE Update a Value Based on the Old Value
     CLOSED: [2017-08-22 Tue 01:21]
     #+BEGIN_SRC rust
       use std::collections::HashMap;

       let text = "hello world wonderful world";

       let mut map = HashMap::new();

       for word in text.split_whitespace() {
           let count = map.entry(word).or_insert(0);
           *count += 1;
       }

       println!("{:?}", map);
     #+END_SRC

     - The ~or_insert~ method actually returns a mutable reference (~&mut V~).
       We save it in the ~count~ variable, so in order to assign to that value
       we must first dereference ~count~ using the ~*~.

**** DONE Hashing Function
     CLOSED: [2017-08-22 Tue 01:21]
     - _By default_, ~HashMap~ uses a cryptographically secure hashing function
       that can provide resistance to Denial of Service (DoS) attacks.

       _This is not the fastest hashing algorithm out there_, but the tradeoff
       for _better security_ that comes with the drop in performance is worth it.

       You can switch to another function by specifying a different /hasher/.

     - A /hasher/ :: a type that implements the ~BuildHasher~ trait.

**** TODO Summary
     - Given a list of integers, use a vector and return the mean (average),
       median (when sorted, the value in the middle position), and mode (the
       value that occurs most often; a hash map will be helpful here) of the
       list.
       =TODO=

     - Convert strings to Pig Latin, where the first consonant of each word is
       moved to the end of the word with an added “ay”, so “first” becomes
       “irst-fay”. Words that start with a vowel get “hay” added to the end
       instead (“apple” becomes “apple-hay”). Remember about UTF-8 encoding!
       =TODO=

     - Using a hash map and vectors, create a text interface to allow a user to
       add employee names to a department in the company. For example, “Add
       Sally to Engineering” or “Add Amir to Sales”. Then let the user retrieve
       a list of all people in a department or all people in the company by
       department, sorted alphabetically.
       =TODO=

* TODO 9. Error Handling -- In progress
  - Rust groups errors into two major categories:
    + recoverable errors
    + unrecoverable errors

  - Rust doesn't have exceptions.
    Instead, it has
    + the value ~Result<T, E>~ for recoverable errors.
    + the ~panic!~ macro that stops execution when it encounters unrecoverable
      errors.

** DONE 9.1. Unrecoverable Errors with ~panic!~
   CLOSED: [2017-08-22 Tue 15:34]
   - When this macro executes, your program will:
     1. print a failure message
     2. unwind and clean up the stack
     3. quit

   - *Unwinding the Stack Versus Aborting on Panic*
     + /unwinding/ :: walks back up the stack and cleans up the data from each
                      function it encounters, but this walking and cleanup is a
                      lot of work.


     + the alternative is to _immediately abort_. No cleanup by the program.
       Memory need to be cleaned up by the OS.

     + If you want to make your resulting binary as small as possible, you can
       switch from /unwinding/ to /aborting/ on panic by adding
       ~panic = 'abort'~ to the appropriate ~[profile]~ sections in the
       =Cargo.toml=.
       #+BEGIN_SRC toml
         [profile.release]
         panic = 'abort'
       #+END_SRC

    - We can use the backtrace of the functions the ~panic!~ call came from to
      figure this out. 

*** DONE Using a ~panic!~ Backtrace
    CLOSED: [2017-08-22 Tue 15:34]
    - /buffer overread/

    - A example:
      #+BEGIN_SRC rust
        fn main() {
            let v = vec![1, 2, 3];

            v[100];
        }
      #+END_SRC

      + ~cargo run~
        #+BEGIN_SRC text
             Compiling panic v0.1.0 (file:///projects/panic)
              Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
               Running `target/debug/panic`
          thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
          100', /stable-dist-rustc/build/src/libcollections/vec.rs:1362
          note: Run with `RUST_BACKTRACE=1` for a backtrace.
          error: Process didn't exit successfully: `target/debug/panic` (exit code: 101)
        #+END_SRC

      + ~RUST_BAKTRACE=1 cargo run~
        #+BEGIN_SRC text
              Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
               Running `target/debug/panic`
          thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 100', /stable-dist-rustc/build/src/libcollections/vec.rs:1392
          stack backtrace:
             1:     0x560ed90ec04c - std::sys::imp::backtrace::tracing::imp::write::hf33ae72d0baa11ed
                                  at /stable-dist-rustc/build/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:42
             2:     0x560ed90ee03e - std::panicking::default_hook::{{closure}}::h59672b733cc6a455
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:351
             3:     0x560ed90edc44 - std::panicking::default_hook::h1670459d2f3f8843
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:367
             4:     0x560ed90ee41b - std::panicking::rust_panic_with_hook::hcf0ddb069e7abcd7
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:555
             5:     0x560ed90ee2b4 - std::panicking::begin_panic::hd6eb68e27bdf6140
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:517
             6:     0x560ed90ee1d9 - std::panicking::begin_panic_fmt::abcd5965948b877f8
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:501
             7:     0x560ed90ee167 - rust_begin_unwind
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:477
             8:     0x560ed911401d - core::panicking::panic_fmt::hc0f6d7b2c300cdd9
                                  at /stable-dist-rustc/build/src/libcore/panicking.rs:69
             9:     0x560ed9113fc8 - core::panicking::panic_bounds_check::h02a4af86d01b3e96
                                  at /stable-dist-rustc/build/src/libcore/panicking.rs:56
            10:     0x560ed90e71c5 - <collections::vec::Vec<T> as core::ops::Index<usize>>::index::h98abcd4e2a74c41
                                  at /stable-dist-rustc/build/src/libcollections/vec.rs:1392
            11:     0x560ed90e727a - panic::main::h5d6b77c20526bc35
                                  at /home/you/projects/panic/src/main.rs:4
            12:     0x560ed90f5d6a - __rust_maybe_catch_panic
                                  at /stable-dist-rustc/build/src/libpanic_unwind/lib.rs:98
            13:     0x560ed90ee926 - std::rt::lang_start::hd7c880a37a646e81
                                  at /stable-dist-rustc/build/src/libstd/panicking.rs:436
                                  at /stable-dist-rustc/build/src/libstd/panic.rs:361
                                  at /stable-dist-rustc/build/src/libstd/rt.rs:57
            14:     0x560ed90e7302 - main
            15:     0x7f0d53f16400 - __libc_start_main
            16:     0x560ed90e6659 - _start
            17:                0x0 - <unknown>
        #+END_SRC

    - A /backtrace/ :: a list of all the functions that have been called to get
                       to this point.

    - /Backtraces/ in Rust work like they do in other languages:
      the key to reading the backtrace is to _start from_ the top and read _until_
      you see files you wrote.

      The lines above the lines mentioning your files are code that your code
      called;
      the lines below are code that called your code.

** DONE 9.2. Recoverable Errors with ~Result~
   CLOSED: [2017-08-23 Wed 13:00]
   - Definition
     #+BEGIN_SRC rust
       enum Result<T, E> {
           Ok(T),
           Err(E),
       }
     #+END_SRC

*** DONE Matching on Different Errors
    CLOSED: [2017-08-22 Tue 15:58]
    #+BEGIN_SRC rust
      use std::fs::File;
      use std::io::ErrorKind;

      fn main() {
          let f = File::open("hello.txt");

          let f = match f {
              Ok(file) => file,
              Err(ref error) if error.kind() == ErrorKind::NotFound => {
                  match File::create("hello.txt") {
                      Ok(fc) => fc,
                      Err(e) => {
                          panic!(
                              "Tried to create file but there was a problem: {:?}",
                              e
                          )
                      },
                  }
              },
              Err(error) => {
                  panic!(
                      "There was a problem opening the file: {:?}",
                      error
                  )
              },
          };
      }
    #+END_SRC

    - /match guard/ :: for example, the ~if error.kind() == ErrorKind::NotFound~
                       above.
    - The ~ref~ in the pattern is needed so that ~error~ is NOT _moved_ into the
      guard condition but is mearly referenced by it.

    - =TODO=
      The reason ~ref~ is used to take a reference in a pattern instead of ~&~ will
      be covered in detail in Chapter 18.
      In short, in the context of a pattern,
      + ~&~ matches a reference and gives us its value,
      + but ~ref~ matches a value and gives us a reference to it.

*** DONE Shortcuts for Panic on Error: ~unwrap~ and ~expect~
    CLOSED: [2017-08-22 Tue 16:11]
    Pattern matching is NOT always concise and communicate intent well.

    - ~unwrap~:
      ~let f = File::open("hello.txt").unwrap();~
      If the value is the ~Ok~ variant, the inside value will be returned.
      If the value is the ~Err~ variant, a ~panic!~ macro will be called.

    - ~expect~:
      Similar as ~unwrap~, but can take a message for the ~panic!~
      ~let f = File::open("hello.txt").expect("Failed to open hello.txt");~

*** DONE Propagating Errors
    CLOSED: [2017-08-22 Tue 16:26]
    Propagate errors, and give the control to the caller:

    - Example:
      #+BEGIN_SRC rust
        use std::io;
        use std::io::Read;
        use std::fs::File;

        fn read_username_from_file() -> Result<String, io::Error> {
            let f= File::open("hello.txt");

            let mut f = match f {
                Ok(file) => file,
                Err(e) => return Err(e),
            };

            let mut s = String::new();

            match f.read_to_string(&mut s) {
                Ok(_) => Ok(s),
                Err(e) => Err(e),
            }
        }
      #+END_SRC

      + The ~return~ above is imporatant! 
        If NO ~return~, that ~Err(e)~ will be assigned to ~f~, rather than being
        returned. With this ~return~, we achieve "propagating errors".

    - This pattern of propagating errors is so common in Rust that there is
      _dedicated syntax to make this easier_: ~?~.

*** DONE A Shortcut for Propagating Errors: ~?~
    CLOSED: [2017-08-23 Wed 12:55]
    #+BEGIN_SRC rust
      use std::io;
      use std::io::Read;
      use std::fs::File;

      fn read_username_from_file() -> Result<String, io::Error> {
          let mut f = File::open("hello.txt")?;
          let mut s = String::new();
          f.read_to_string(&mut s)?;
          Ok(s)
      }
    #+END_SRC

    ~?~ expressions can be chained
    #+BEGIN_SRC rust
      use std::io;
      use std::io::Read;
      use std::fs::File;

      fn read_username_from_file() -> Result<String, io::Error> {
          let mut s = String::new();
          File::open("hello.txt")?.read_to_string(&mut s)?;
          Ok(s)
      }
    #+END_SRC

*** DONE ~?~ Can Only Be Used in Functions That Return ~Result~
    CLOSED: [2017-08-23 Wed 13:00]
    Since one of a ~?~ expression result is to immediately return the ~Err~ value.

** TODO 9.3. To ~panic!~ or Not To ~panic!~
*** DONE Examples, Prototype Code, and Tests: Perfectly Fine to Panic
    CLOSED: [2017-08-23 Wed 17:59]
    + Have a robust error handling code in these situations can make them less
      clear.

    + Use ~panic!~ (we should be no tolerance in these kind of development), and
      you can repalce them with ~Result~ later when you think handle these errors
      is resonable in some situation.

*** DONE Cases When You Have More Information Than The Compiler
    CLOSED: [2017-08-23 Wed 18:13]
    When you are sure your ~Result~ type value can only be ~Ok~, just use ~unwrap~.
    #+BEGIN_SRC rust
      use std::net::IpAddr;
      let home = "127.0.0.1".parse::<IpAddr>().unwrap();
    #+END_SRC

    However, when the data is from the input, there is no promise to ~Ok~.

*** DONE Guidelines for Error Handling
    CLOSED: [2017-08-23 Wed 18:24]
    =TODO= Re-Do
*** TODO Creating Custom Types for Validation
    =TODO= Re-Read
*** DONE Summary
    CLOSED: [2017-08-23 Wed 18:46]
* TODO 10. Generic Types, Traits, and Lifetimes
*** DONE Removing Duplication by Extracting a Function
    CLOSED: [2017-08-23 Wed 21:48]
** DONE 10.1. Generic Data Types
   CLOSED: [2017-08-23 Wed 22:23]
*** DONE Using Generic Data Types in Function Definitions
    CLOSED: [2017-08-23 Wed 21:36]
    - The function signature of the generic ~largest~ function we're going to
      define will look like this:
      ~fn largest<T>(list: &[T]) -> T {~

      We would read this as:
      the function ~largest~ is generic over some type ~T~. It has one parameter
      named ~list~, and the type of ~list~ is a slice of values of type ~T~. The
      ~largest~ function will return a value of the same type ~T~.

    - =TODO=
      ~<T>~ is not enough in most scenario, some /traits/ required.
      Talk about this later.

*** DONE Using Generic Data Types in Struct Definitions
    CLOSED: [2017-08-23 Wed 21:46]
    - Single type variable
      #+BEGIN_SRC rust
        struct Point<T> {
            x: T,
            y: T,
        }

        fn main() {
            let integer = Point { x: 5, y: 10 };
            let float = Point { x: 1.0, y: 4.0 };
        }
      #+END_SRC

    - Double type variables
      #+BEGIN_SRC rust
        struct Point<T, U> {
            x: T,
            y: U,
        }

        fn main() {
            let both_integer = Point { x: 5, y: 10 };
            let both_float = Point { x: 1.0, y: 4.0 };
            let integer_and_float = Point { x: 5, y: 4.0 };
        }
      #+END_SRC

*** DONE Using Generic Data Types in Enum Definitions
    CLOSED: [2017-08-23 Wed 21:49]
    #+BEGIN_SRC rust
      enum Option<T> {
          Some(T),
          None,
      }

      enum Result<T, E> {
          Ok(T),
          Err(E),
      }
    #+END_SRC

*** DONE Using Generic Data Types in Method Definitions
    CLOSED: [2017-08-23 Wed 21:59]
    #+BEGIN_SRC rust
      struct Point<T> {
          x: T,
          y: T,
      }

      // TODO: Why there is NO syntactic sugar???
      impl<T> Point<T> {
          fn x(&self) -> &T {
              &self.x
          }
      }

      fn main() {
          let p = Point { x: 5, y: 10 };
          println!("p.x = {}", p.x());
      }
    #+END_SRC

    The methods can have different generic types:
    #+BEGIN_SRC rust
      // src/main.rs

      struct Point<T, U> {
          x: T,
          y: U,
      }

      impl<T, U> Point<T, U> {
          fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
              Point {
                  x: self.x,
                  y: other.y,
              }
          }
      }

      fn main() {
          let p1 = Point { x: 5, y: 10.4 };
          let p2 = Point { x: "Hello", y: 'c' };

          let p3 = p1.mixup(p2);

          println!("p3.x = {}, p3.y ={}", p3.x, p3.y);
      }
    #+END_SRC

*** DONE Performance of Code Using Generics
    CLOSED: [2017-08-23 Wed 22:22]
    - Rust generics has no runtime cost if you had specified concrete types.

      =From Jian=: always specify concrete types for generics if the concrete
      type(s) can be infered (??? NOT sure).

    - /monomorphization/ :: the process of turning generic code into specific
         code with the concrete types that are actually used filled in.
      #+BEGIN_SRC rust
        // You write the code below in `main`:
        //
        // let integer = Some(5);
        // let float = Some(5.0);

        enum Option_i32 {
            Some(i32),
            None,
        }

        enum Option_f64 {
            Some(f64),
            None,
        }

        fn main() {
            let integer = Option_i32::Some(5);
            let float = Option_f64::Some(5.0);
        }
      #+END_SRC

** TODO 10.2. Traits: Defining Shared Behavior
   - /traits/ :: =TODO=

   - /trait bounds/

*** DONE Defining a Trait
    CLOSED: [2017-08-23 Wed 22:54]
    - Description:
      #+BEGIN_SRC rust
        pub trait Summarizable {
            fn summary(&self) -> String;
        }
      #+END_SRC
*** TODO Implementing a Trait on a Type
    #+BEGIN_SRC rust
      // lib.rs
      pub struct NewsArticle {
          pub headline: String,
          pub location: String,
          pub author: String,
          pub content: String,
      }

      impl Summarizable for NewsArticle {
          fn summary(&self) -> String {
              format!("{}, by {} ({})", self.headline, self.author, self.location)
          }
      }

      pub struct Tweet {
          pub username: String,
          pub content: String,
          pub reply: bool,
          pub retweet: bool,
      }

      impl Summarizable for Tweet {
          fn summary(&self) -> String {
              format!("{}: {}", self.username, self.content)
          }
      }
    #+END_SRC

    - :: 

    - _Restriction_: =IMPORTANT=
      We may implement a trait on a type as long as
      _either_ the trait _or_ the type are local to our crate. 

      This restriction is _part of_ what's called the /orphan rule/
      (a concept in /type theory/): the parent type is not present.

    - _WITHOUT_ this /orphan rule/, =IMPORTANT=
      two crates could implement the same trait for the same type, and the two
      implementations would conflict: Rust wouldn't know which implementation to
      use. Because Rust enforces the orphan rule, other people's code can't
      break your code and vice versa.

*** TODO Default Implementations
    The trait definition can include a /default implemention/, 
    #+BEGIN_SRC rust
      pub trait Summarizable {
          fn summary(&self) -> String {
              String::from("(Read more...)")
          }
      }
    #+END_SRC

    When we implement a trait for a type, we can use the
    /default implementation/: ~impl Summarizable for NewsArticle {}~

    - the syntax for overriding a default implementation is exactly _the same as_
      the syntax for implementing a trait method that doesn't have a default
      implementation.

    - Default implementations are allowed to call the other methods in the same
      trait, even if those other methods don't have a default implementation. In
      this way, a trait can provide a lot of useful functionality and only
      require implementers to specify a small part of it.
      #+BEGIN_SRC rust
        pub trait Summarizable {
            fn author_summary(&self) -> String;

            fn summary(&self) -> String {
                format!("(Read more from {}...)", self.author_summary())
            }
        }
      #+END_SRC
      In order to use this version of ~Summarizable~, we're _only_ required to
      define ~author_summary~ when we implement the trait on a type:
      #+BEGIN_SRC rust
        impl Summarizable for Tweet {
            fn author_summary(&self) -> String {
                format!("@{}", self.username)
            }
        }
      #+END_SRC

    - Note:
      that it is _not possible_ to call the default implementation from an
      overriding implementation.
      =TODO=
      _Kind of reasonable, but not always good. Why with this restriction???_

*** TODO Trait Bounds
    _specifying /trait bound(s)/ on a generic type_

    - Example:
      #+BEGIN_SRC rust
        pub fn notify<T: Summarizable>(item: T) {
            println!("Breaking news! {}", item.summary());
        }
      #+END_SRC

    - Specify _multiple_ /trait bounds/ on a generic type by using ~+~.
      For example: ~T: Summarizable + Display~

    - Clearer (less cluttered, category different info) alternative syntax for
      specifying /trait bound(s)/ (use ~where~):
      #+BEGIN_SRC rust
        fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {
            // ...
        }

        //------------------
        // is equivalent to
        //------------------

        fn some_function<T, U>(t: T, u: U) -> i32
            where T: Display + Clone,
                  U: Clone + Debug
        {
            //...
        }
      #+END_SRC

*** DONE Fixing the ~largest~ Function with Trait Bounds
    CLOSED: [2017-08-26 Sat 12:35]
    - Wrong version:
      + Without the trait bounds ~std::cmp::PartialOrd~

      + Only ~std::cmp::PartialOrd~ is OK, but the type signature should be
        ~&[T] -> &T~ and some change(s) should be make to the body of this
        function (Check the last implementation in this section of this note,
        which is not given in this book).

    - ~+ Copy~ version
      #+BEGIN_SRC rust
        use std::cmp::PartialOrd;

        fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
            let mut largest = list[0];

            for &item in list.iter() {
                if item > largest {
                    largest = item;
                }
            }

            largest
        }

        fn main() {
            let numbers = vec![34, 50, 25, 100, 65];

            let result = largest(&numbers);
            println!("The largest number is {}", result);

            let chars = vec!['y', 'm', 'a', 'q'];

            let result = largest(&chars);
            println!("The largest char is {}", result);
        }
      #+END_SRC

    - ~+ Clone~ version

    - return ~&T~ version (least /trait bounds/):
      #+BEGIN_SRC rust
        fn largest<T: PartialOrd>(list: &[T]) -> &T {
            let mut largest_item = &list[0];
            // 1. precedence: 
            //    `&list[0]` means `&(list[0])` (type `&T`)
            //    rather than `(&list)[0]` (type `T`).
            // 
            // 2. Use `&` ONLY here is the simplest way to implement a function
            //    of this type signature.

            for item in list.iter() {
            // `iter()` of a &[T] returns `&T`, which is the type of `item`
                if item > largest_item {
                    largest_item = item;
                }
            }

            largest_item
        }
      #+END_SRC

** DONE 10.3. Validating References with Lifetimes
   CLOSED: [2017-08-27 Sun 00:16]
   - Every reference in Rust has a /lifetime/, which is the scope for which that
     reference is valid.

   - Most of the time /lifetimes/ are _implict_ and _inferred_, just like most of
     the time /types/ are inferred.

   - Since there are cases that the /lifetimes/ of references could be related in
     a few different ways, Rust needs us to annotate the relationships using
     /generic lifetime parameters/ so that it can make sure the actual references
     used at runtime will definitely be valid.

   - =TODO= Chapter 19

*** DONE Lifetimes Prevent Dangling References
    CLOSED: [2017-08-26 Sat 13:03]
    - Example:
      #+BEGIN_SRC rust
        // code snippet cannot be compiled.
        {
            let r;

            {
                let x = 5;
                r = &x;
            }

            println!("r: {}", r);
        }

        // error: `x` does not live long enough
        //    |
        // 6  |         r = &x;
        //    |              - borrow occurs here
        // 7  |     }
        //    |     ^ `x` dropped here while still borrowed
        // ...
        // 10 | }
        //    | - borrowed value needs to live until here
      #+END_SRC

    - *Uninitialized Variables Cannot Be Used*

*** DONE The Borrow Checker
    CLOSED: [2017-08-26 Sat 13:33]
    - /borrow checker/ :: a part of the Rust compiler. It compares scopes to
         determine that all borrows are valid.

    - An example of lifetime:
      #+BEGIN_SRC rust
        {
            let r;         // -------+-- 'a
                           //        |
            {              //        |
                let x = 5; // -+-----+-- 'b
                r = &x;    //  |     |
            }              // -+     |
                           //        |
            println!("r: {}", r); // |
                           //        |
                           // -------+
        }
      #+END_SRC

    - Fix the example above by removing the inner scope boundary:
      #+BEGIN_SRC rust
        {
            let x = 5;            // -----+-- 'b
                                  //      |
            let r = &x;           // --+--+-- 'a
                                  //   |  |
            println!("r: {}", r); //   |  |
                                  // --+  |
        }                         // -----+
      #+END_SRC

*** DONE Generic Lifetimes in Functions
    CLOSED: [2017-08-26 Sat 13:48]
    #+BEGIN_SRC rust
      // NOT compilable
      fn longest(x: &str, y: &str) -> &str {
          if x.len() > y.len() {
              x
          } else {
              y
          }
      }

      // error[E0106]: missing lifetime specifier
      //    |
      // 1  | fn longest(x: &str, y: &str) -> &str {
      //    |                                 ^ expected lifetime parameter
      //    |
      //    = help: this function's return type contains a borrowed value, but the
      //    signature does not say whether it is borrowed from `x` or `y`
    #+END_SRC

    We need to add generic lifetime parameters that will define the relationship
    between the references so that the borrow checker can perform its analysis.

*** DONE Lifetime Annotation Syntax
    CLOSED: [2017-08-26 Sat 14:21]
    - /Lifetime/ annotations DO NOT change how long any of the references
      involved live.
        What lifetime annotations do is relate the lifetimes of multiple
      references to each other.

    - In the same way that functions can accept any type when the signature
      specifies a generic type parameter, functions can accept references with
      any lifetime when the signature specifies a generic lifetime parameter.

    - Lifetime annotation syntax:
      + start with ~'~
      + usually all lowercase
      + usually very short
      + after the ~&~ of a reference, and a space separates the lifetime
        annotation from the reference's type.

    - Example:
      + a reference: ~&i32~
      + a reference with an explicit lifetime: ~&'a i32~
      + a mutable reference with an explicit lifetime: ~&'a mut i32~

*** DONE Lifetime Annotations in Function Signatures
    CLOSED: [2017-08-26 Sat 15:23]
    The /lifetime/ annotation tell Rust about for the references in the
    parameters and the return value is that they all must have the same lifetime.
    #+BEGIN_SRC rust
      fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
          if x.len() > y.len() {
              x
          } else {
              y
          }
      }
    #+END_SRC

    - The /lifetime annotations/ are only in the function signature, and NOT in
      any of the code in the function body.

      Rationale:
      Except the passed in references, Rust is able to analyze the code within
      the function without any help. On the other hand, the lifetimes of the
      arguments or return values will potentially be different each time the
      function is called. Analyze them would be incredibly costly and often
      impossible.

    - Since the scopes always nest, the generic lifetime ~'a~ will get the
      concrete /lifetime/ equal to the smaller of the concrete lifetime of an
      argument, which is reasonable.

      + Example:
        #+BEGIN_SRC rust
          fn main() {
              let string1 = String::from("long string is long");

              {
                  let string2 = String::from("xyz");
                  let result = longest(string1.as_str(), string2.as_str());
                  println!("The longest string is {}", result);
              }

              // println!("The longest string is {}", result);
              //
              // // According to the lifetime annotation of the `longest` function,
              // // `result` should be invalid here.
              // //
              // // WHEN COMPILE:
              // // error: `string2` does not live long enough
              // //    |
              // // 6  |         result = longest(string1.as_str(), string2.as_str());
              // //    |                                            ------- borrow occurs here
              // // 7  |     }
              // //    |     ^ `string2` dropped here while still borrowed
              // // 8  |     println!("The longest string is {}", result);
              // // 9  | }
              // //    | - borrowed value needs to live until here}
        #+END_SRC

*** DONE Thinking in Terms of Lifetimes
    CLOSED: [2017-08-24 Thu 10:34]
    - If the result is only related to some parameters, just annotate those
      parameters.
      #+BEGIN_SRC rust
        // Of course, `y` does NOT have any relationship with the lifetime of `x`
        // or the return value.
        fn longest<'a>(x: &'a str, y: &str) -> &'a str {
            x
        }
      #+END_SRC

      Actually, you CANNOT annotate the unrelated lifetime:
      ~fn longest<'a>(x: &'a str, y: &'b str) -> &'a str {~ cannot be accepted by
      the compiler.

    - You _CANNOT_ do this:
      #+BEGIN_SRC rust
        fn longest<'a>(x: &str, y: &str) -> &'a str {
            let result = String::from("really long string");
            result.as_str()  // this is a string slice
        }
      #+END_SRC

    - Ultimately, lifetime syntax is about connecting the lifetimes of various
      arguments and return values of functions. Once they're connected, Rust has
      enough information to allow memory-safe operations and disallow operations
      that would create dangling pointers or otherwise violate memory safety.

*** DONE Lifetime Annotations in Struct Definitions
    CLOSED: [2017-08-24 Thu 11:13]
    _Up until now_, we've only defined _/structs/ to hold owned types_.

    It is possible for /structs/ to hold /references/, but we need to add a lifetime
    annotation on every reference in the struct's definition.

    #+BEGIN_SRC rust
      struct ImportantExcerpt<'a> {
          part: &'a str,
      }

      fn main() {
          let novel = String::from("Call me Ishmael. Some years ago...");
          let first_sentence = novel.split('.')
              .next()
              .expect("Could not find a '.'");
          let i = ImportantExcerpt { part: first_sentence };
      }
    #+END_SRC

*** DONE Lifetime Elision
    CLOSED: [2017-08-26 Sat 23:05]
    - Every reference has a lifetime, and we need to specify lifetime
      parameters for functions or structs that use references.
        However, in Chapter 4 we had a function in the "String Slices" section,
      shown again in Listing 10-25, that compiled without lifetime annotations:
      #+BEGIN_SRC rust
        fn first_word(s: &str) -> &str {
            let bytes = s.as_bytes();

            for (i, &item) in bytes.iter().enumerate() {
                if item == b' ' {
                    return &s[0..i];
                }
            }

            &s[..]
        }
      #+END_SRC

      Pre-1.0 Rust wouldn't have this program compiled. Every reference needed an
      explicit lifetime.

    - /lifetime elision rules/ :: a set of particular cases that the compiler
         will consider, and if your code fits these cases, you don't need to
         write the lifetimes explicitly.

    - The /elision rules/ do NOT provide full inference: if there is still
      ambiguity after applying these rules, Rust will issue an error.

    - /input lifetimes/: lifetimes on function parameters or method parameters.

    - /output lifetimes/: lifetimes on return values.

    - Now, on to the rules that the compiler uses to figure out what lifetimes
      references have when there aren't explicit annotations.

      The first rule applies to /input lifetimes/, and
      the second two rules apply to /output lifetimes/.

      If the compiler gets to the end of the three rules and there are still
      references that it can't figure out lifetimes for, the compiler will stop
      with an error.

      1. Each parameter that is a reference gets its own lifetime parameter. In
         other words, a function with one parameter gets one lifetime parameter:
         ~fn foo<'a>(x: &'a i32)~, a function with two arguments gets two
         separate lifetime parameters: ~fn foo<'a, 'b>(x: &'a i32, y: &'b i32)~,
         and so on.

      2. If there is exactly one input lifetime parameter, that lifetime is
         assigned to all output lifetime parameters:
         ~fn foo<'a>(x: &'a i32) -> &'a i32~.

      3. If there are multiple input lifetime parameters, but one of them is
         ~&self~ or ~&mut self~ because this is a method, then the lifetime of
         ~self~ is assigned to all output lifetime parameters. This makes
         writing methods much nicer.

    - Try to apply these rules to ~fn first_word(s: str) -> &str {~
      rule 1 - ~fn first_word<'a>(s: &'a str) -> &str {~
      rule 2 - ~fn first_word<'a>(s: &'a str) -> &'a str {~
      rule 3 - NOT a method

    - The /lifetimes/ of ~fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {~
      CANNOT be figured out through applying the /lifetime elision rules/.

    - =TODO= Because the third rule only really applied in method signatures,
      let's look at lifetimes in that context now, and see why the third rule
      means we don't have to annotate lifetimes in method signatures very often.

*** DONE Lifetime Annotations in Method Definitions
    CLOSED: [2017-08-26 Sat 22:41]
    - Apply rule 1
      #+BEGIN_SRC rust
        // The lifetime parameter declaration
        // after `impl` and
        // use after the type name is required, but we're not required to
        // annotate the lifetime of the first elition rule.
        //
        // first elison rule
        impl<'a> ImportantExcerpt<'a> {
            fn level(&self) -> i32 {
                3
            }
        }
      #+END_SRC

    - Apply rule 3
      #+BEGIN_SRC rust
        impl<'a> ImportantExcerpt<'a> {
            fn announce_and_return_part(&self, announcement: &str) -> &str {
                pinntln!("Attention please: {}", announcement);
                self.part
            }
        }
      #+END_SRC

*** DONE The Static Lifetime
    CLOSED: [2017-08-26 Sat 22:52]
    - ~'stack~ :: the entire duration of the program.

    - Example: ~let s: &'static str = "I have a static lifetime";~
      The text of this string is stored directly in the binary of your program
      and the binary of your program is always available.
      Therefore, the lifetime of all /string literals/ is ~'static~.

    - Sometimes compiler suggest you use ~'static~ somewhere.

      Most of the time, the REAL solution is _NOT_ just use ~'static~.
        The problem in the code is an attempt to create a dangling references or
      mismatch of the available lifettimes, and the solution is fixing those
      problems, NOT specifying the ~'static~ lifetime.

*** DONE Generic Type Parameters, Trait Bounds, and Lifetimes Together
    CLOSED: [2017-08-26 Sat 23:05]
    #+BEGIN_SRC rust
      use std::fmt::Display;

      fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
          where T: Display
      {
          println!("Announcement! {}", ann);
          if x.len() > y.len() {
              x
          } else {
              y
          }
      }
    #+END_SRC

*** DONE Summary
    CLOSED: [2017-08-27 Sun 00:16]

* TODO 11. Testing
** TODO 11.1. How to Write Tests
   The features Rust provides specifically for writing tests:
   - the ~test~ attribute
   - a few macros
   - the ~should_panic~ attribute.

*** TODO The Anatomy of a Test Function
    - /attributes/ :: metadata about pieces of Rust code.

    - To make a function into a test function, we add ~#[test]~ on the line
      before ~fn~.

    - TEST
      1. Use ~cargu new ~addr~ to
        create a new library project called ~adder~.

        Then in the =src/lib.rs=

    - =TODO=




*** TODO Checking Results with the ~assert!~ Macro
*** TODO Testing Equality with the ~assert_eq!~ and ~assert_ne!~ Macros
*** TODO Custom Failure Messages
*** TODO Checking for Panics with ~should_panic~

** TODO 11.2. Controlling How Tests are Run
*** TODO Running Tests in Parallel or Consecutively
*** TODO Showing Function Output
*** TODO Running a Subset of Tests by Name
**** TODO Running Single Tests
**** TODO Filtering to Run Multiple
**** TODO Ignore Some Tests Unless Specifically Requested

** TODO 11.3. Test Organization
*** TODO Unit Tests
**** TODO The Tests Module and ~#[cfg(test)]~
**** TODO Testing Private Functions

*** TODO Integration Tests
**** TODO The =tests= Directory
**** TODO Submodules in integration Tests
**** TODO Integration Tests for Binary Crates

*** TODO Summary

* TODO 12. An I/O Project Building a Small Grep
  _OLD TITLE_ An I/O Project
  - This chapter is both
    + a recap of many skills
    + an exploration of a few more standard library features

  - Make our own version of the classic command line tool ~grep~ (Globally search
    a Regular Expression and Print).

  - In the simplest use case, ~grep~ searches a specified file for a specified
    string using the following steps:
    + Take as arguments a filename and a string.
    + Read the file.
    + Find lines in the file that contain the string argument.
    + Print out those lines.

  - We'll also show how to use environment variables and print to standard error
    instead of standard out; these tech are commonly used in command line tools.

  - ~ripgrep~ is a fully-featured and faster version of ~grep~ implemented by
    Andrew Gallant by using Rust.

  - This project will bring together a number of concepts you've learned so far:
    + Organizing code (using what we learned in modules, _Chapter 7_)
    + Using vectors and strings (collections, _Chapter 8_)
    + Handling errors (_Chapter 9_)
    + Using traits and lifetimes where appropriate (_Chapter 10_)
    + Writing tests (_Chapter 11_)

  - We'll also briefly introduce /closures/, /iterators/, and /trait objects/,
    which Chapter 13 and 17 will cover in detail =TODO=.

  - ~cargo new --bin greprs~

** DONE 12.1. Accepting Command Line Arguments
   CLOSED: [2017-08-27 Sun 18:48]
   Our first task is to make ~greprs~ able to accept its two command line
   arguments:
   + the file name
   + a string to search for.

   The result is we can use a command of the pattern
   ~cargo run searchstring example-filename.txt~

*** DONE Reading the Argument Values
    CLOSED: [2017-08-27 Sun 18:44]
    Use Rust standard library ~std::env::args~, which returns an /iterator/ of
    the command line arguments that were given to our program.
    
    - =TODO= /iterator/ will be fully covered in Chapter 13.

    - For now, two things we need to know about the /iterator/:
      1. Iterator produce a series of values
      2. We can call the ~collect~ function on iterator to turn it into a vector
         containing all of the elements the iterator produces.

    - Example (use /iterator/):
      #+BEGIN_SRC rust
        use std::env;

        fn main() {
            let args: Vec<String> = env::args().collect();
            println!("{:?}", args);
        }
      #+END_SRC
      + As we talked about in Chapter 7,
        in cases where the desired function is nested in more than one module,
        it's CONVENTIONAL to _bring the parent module into scope_, rather than
        the function itself.

      + ~std::env::args~ will panic if any argument containts invalid Unicode.

      + To take arguments with invalid Unicode, use ~std::env::args_os~, which
        returns ~OsString~.

          ~OsString~ values differ per-platform and are more complex to work
        with than ~String~ values.

      + Run:
        #+BEGIN_SRC bash
          cargo run
          # ["target/debug/greprs"]

          cargo run needle haystack
          # ...snip...
          # ["target/debug/greprs", "needle", "haystack"]
        #+END_SRC

*** DONE Saving the Argument Values in Variables
    CLOSED: [2017-08-27 Sun 18:48]
    #+BEGIN_SRC rust
      use std::env;

      fn main() {
          let args: Vec<String> = env::args().collect();

          let query = &args[1];
          let filename = &args[2];

          println!("Searching for {}", query);
          println!("In file {}", filename);
      }
    #+END_SRC

    - =TODO= Later we'll add some error handling to deal with situations like no
      argument.
** TODO 12.2. Reading a File
   - x
** TODO 12.3. Refactoring to Improve Modularity and Error Handling
   - Improving Error Handling and Modularity
**** TODO Separation of Concerns for Binary Projects
**** TODO Extracting the Argument Parser
**** TODO Grouping Configuration Values
     *The Tradeoffs of Using* ~clone~
**** TODO Creating a Constructor for ~Config~
**** TODO Fixing the Error Handling
***** TODO Improving the Error Message
***** TODO Returning a ~Result~ from ~new~ Instead of Calling ~panic!~
***** TODO Calling ~Config::new~ and Handling Errors
**** TODO Extracting a ~run~ Function
***** TODO Returning Errors from the ~run~ Function
***** TODO Handling Errors Returned from ~run~ in ~main~
**** TODO Split Code into a Library Crate
**** TODO Calling the Library Crate from the Binary Crate

** TODO 12.4. Testing the Library's Functionality
   - x
*** TODO Writing a Failing Test
*** TODO Writing Code that Gets the Test to Pass
**** TODO Iterating Through Lines with the ~lines~ method
**** TODO Searching Each Line for the Query
**** TODO Storing Matching Lines
**** TODO Using the ~search~ Function in the ~run~ Function
** TODO 12.5. Working with Environment Variables
   - x
*** TODO Writing a Failing Test for the Case-Insensitive search Function
*** TODO Implementing the ~search_case_insensitive~ Function
** TODO 12.6. Writing to ~stderr~ instead of ~stdout~
   - x
*** TODO Summary
* TODO 13. Functional Language Features in Rust
** TODO 13.1. Closures: Anonymous Functions that can Capture their Environment
*** TODO Creating an Abstraction of Behavior Using a Closure
*** TODO Closures Store Code to be Extracted Later
*** TODO Closures Type Inference and Annotation
*** TODO Using Closures with Generic Parameters and the ~Fn~ Traits
*** TODO Closures Can Capture Their Environment
** TODO 13.2. Processing a Series of Items with Iterators
*** TODO The ~Iterator~ trait and the ~next~ method
*** TODO Methods in the ~Iterator~ Trait that Consume the Iterator
*** TODO Methods in the ~Iterator~ Trait that Produce Other Iterators
*** TODO Using Closures that Capture their Environment with Iterators
*** TODO Implementing the ~Iterator~ Trait to Create Our Own Iterators
**** TODO Using Our ~Counter~ Iterator's ~next~ Method
**** TODO Using Other ~Iterator~ Trait Methods on Our Iterator
** TODO 13.3. Improving our I/O Project
*** TODO Removing a ~clone~ Using an Iterator
**** TODO Using the Iterator Returned by ~env::args~ Directly
**** TODO Using ~Iterator~ Trait Methods Instead of Indexing
*** TODO Making Code Clearer with Iterator Adaptors
** TODO 13.4. Comparing Performance: Loops versus Iterators
*** TODO Summary
* TODO 14. More about Cargo and Crates.io
** TODO 14.1. Release Profiles
** TODO 14.2. Publishing a Crate to Crates.io
*** TODO Documentation Comments
*** TODO Exporting a Convenient Public API with ~pub use~
*** TODO Before Your First Publish
*** TODO Before Publishing a New Crate
*** TODO Publishing to Crates.io
*** TODO Publishing a New Version of an Existing Crate
*** TODO Removing Versions from Crate.io with ~cargo yank~
** TODO 14.3. Cargo Workspaces
** TODO 14.4. Installing Binaries from Crates.io with ~cargo install~
** TODO 14.5. Extending Cargo with Custom Commands
*** TODO Summary
* TODO 15. Smart Pointers
** TODO 15.1. ~Box<T>~ Points to Data on the Heap and Has a Known Size
   *More Information About the Cons List*
** TODO 15.2. The ~Deref~ Trait Allows Access to the Data Through a Reference
*** TODO Implicit Deref Coercions with Functions and Methods
** TODO 15.3. The ~Drop~ Trait Runs Code on Cleanup
** TODO 15.4. ~Rc<T>~, the Reference Counted Smart Pointer
*** TODO Using ~Rc<T>~ to Share Data
*** TODO Cloning an ~Rc<T>~ Increases the Reference Count
** TODO 15.5. ~RefCell<T>~ and the Interior Mutability Pattern
*** TODO ~RefCell<T>~ has Interior Mutability
*** TODO Borrowing Rules are Checked at Runtime on ~RefCell<T>~
*** TODO Multiple Owners of Mutable Data by Combining ~Rc<T>~ and ~RefCell<T>~
** TODO 15.6. Creating Reference Cycles and Leaking Memory is Safe
*** TODO Prevent Reference Cycles: Turn an ~Rc<T>~ into a ~Weak<T>~
*** TODO Summary
* TODO 16. Fearless Concurrency
** TODO 16.1. Using Threads to Run Code Simultaneously
   +Threads+
*** TODO Creating a New Thread with ~spawn~
*** TODO Waiting for All Threads to Finish Using ~join~ Handles
*** TODO Using ~move~ Closures with Threads
** TODO 16.2. Message Passing to Transfer Data Between Threads
   +Message Passing+
*** TODO How Channels Interact with Ownership
*** TODO Sending Multiple Values and Seeing the Receiver Waiting
*** TODO Create Multiple Producers by Cloning the Transmitter

** TODO 16.3. Shared State Concurrency
   +Shared State+
*** TODO Mutexes Allow Access to Data from One Thread at a Time
*** TODO The API of ~Mutex<T>~
*** TODO Sharing a ~Mutex<T>~ Between Multiple Threads
*** TODO Multiple Ownership with Multiple Threads
*** TODO Atomic Reference Counting with ~Arc<T>~
** TODO 16.4. Extensible Concurrency with the ~Sync~ and ~Send~ Traits
   +Extensible Concurrency: Sync and Send+
*** TODO ~Send~ for Indicating Ownership May Be Transferred to Another Thread
*** TODO ~Sync~ for Indicating Access from Multiple Threads is Safe
*** TODO Implementing ~Send~ and ~Sync~ Manually is Unsafe
*** TODO Summary
* TODO 17. Is Rust an Object-Oriented Programming Language?
** TODO 17.1. What Does Object-Oriented Mean?
*** TODO Objects Contain Data and Behavior
*** TODO Encapsulation that Hides Implementation Details
*** TODO Inheritance as a Type System and as Code Sharing

** TODO 17.2. Trait Objects for Using Values of Different Types
*** TODO Defining a Trait for the Common Behavior
*** TODO Implementations of the Trait from Us or Library Users
*** TODO Trait Objects Perform Dynamic Dispatch
*** TODO Object Safety is Required for Trait Objects

** TODO 17.3. Object-Oriented Design Pattern Implementations
*** TODO Defining Post and Creating a New Instance in the Draft State
*** TODO Storing the Text of the Post Content
*** TODO Content of a Draft Post is Empty
*** TODO Requesting a Review of the Post Changes its State
*** TODO Approving a Post Changes the Behavior of ~content~
*** TODO Tradeoffs of the State Pattern
**** TODO Encoding States and Behavior as Types
**** TODO Implementing Transitions as Transformations into Different Types
*** TODO Summary
* TODO 18. Patterns Match the Structure of Values
** TODO 18.1. All the Places Patterns May be Used
*** TODO ~match~ Arms
*** TODO Exhaustiveness and the Default Pattern ~_~
*** TODO ~if let~ Expressions
*** TODO ~while let~
*** TODO ~for~ loops
*** TODO ~let~ Statements
*** TODO Function Parameters
** TODO 18.2. Refutability: Whether a Pattern Might Fail to Match
** TODO 18.3. All the Pattern Syntax
*** TODO Literals
*** TODO Named Variables
*** TODO Multiple patterns
*** TODO Matching Ranges of Values with ~...~
*** TODO Destructuring to Break Apart Values
*** TODO Ignoring Values in a Pattern
**** TODO Ignoring an Entire Value with ~_~
**** TODO Ignoring Parts of a Value with a Nested ~_~
**** TODO Ignoring an Unused Variable by Starting its Name with an Underscore
**** TODO Ignoring Remaining Parts of a Value with ~..~
*** TODO ~ref~ and ~ref mut~ to Create References in Patterns
*** TODO Extra Conditionals with March Guards
*** TODO ~@~ Bindings
*** TODO Summary
* TODO 19. Advanced Features
** TODO 19.1. Unsafe Rust
*** TODO Unsafe Superpowers
*** TODO Dereferencing a Raw Pointer
*** TODO Calling an Unsafe Function or Method
**** TODO creating a Safe Abstraction Over Unsafe Code
**** TODO ~extern~ Functions for Calling External Code are Unsafe
**** TODO Calling Rust Functions from Other Languages
*** TODO Accessing or Modifying a Mutable Static Variable
*** TODO Implementing an Unsafe Trait
** TODO 19.2. Advanced Lifetimes
*** TODO Lifetime Subtyping
*** TODO Lifetime Bounds
*** TODO Trait Object Lifetimes
** TODO 19.3. Advanced Traits
*** TODO Associated Types
**** TODO Associated Types Versus Generics
**** TODO Trait Objects with Associated Types
*** TODO Operator Overloading and Default Type Parameters
*** TODO Fully Qualified Syntax for Disambiguation
*** TODO Supertraits to Use One Trait's Functionality Within Another Trait
*** TODO The Newtype Pattern to Implement External Traits on External Types

** TODO 19.4. Advanced Types
*** TODO Using the Newtype Pattern for Type Safety and Abstraction
*** TODO Type Aliases Create Type Synonyms
*** TODO The Never Type, ~!~, that Never Returns
*** TODO Dynamically Sized Types & ~Sized~
**** TODO The ~Sized~ Trait
** TODO 19.5. Advanced Functions & Closures
*** TODO Function pointers
*** TODO Returning Closures
*** TODO Summary
* TODO 20. Final Project: Building a Multithreaded Web Server
** TODO 20.1. A Single Threaded Web Server
*** TODO Reading the Request
*** TODO Writing a Response
*** TODO Returning Real HTML
*** TODO Validating the Request and Selectively Responding

** TODO 20.2. How Slow Requests Affect Throughput
*** TODO Simulating a Slow Request in the Current Server Implementation
*** TODO Improving Throughput with a Thread Pool
** TODO 20.3. Designing the Thread Pool Interface
*** TODO Code Structure if We Could Use ~thread::spawn~
*** TODO Creating a Similar Interface for ~ThreadPool~
*** TODO Compiler Driven Development to Get the API Compiling
** TODO 20.4. Creating the Thread Pool and Storing Threads
*** TODO Validating the Number of Threads in the Pool
*** TODO Storing Threads in the Pool
** TODO 20.5. Sending Requests to Threads Via Channels
** TODO 20.6. Graceful Shutdown and Cleanup
*** TODO Summary
* TODO 21. Appendix
** TODO 21.1. A - Keywords
*** TODO Keywords Currently in Use
*** TODO Keywords Reserved for Future Use
** TODO 21.2. B - Operators
*** TODO Unary operator expressions
*** TODO Binary Operator expressions
**** TODO Arithmetic operators
**** TODO Bitwise operators
**** TODO Lazy boolean operators
**** TODO Comparison operators
**** TODO Type cast expressions
**** TODO Assignment expressions
**** TODO Compound assignment expressions
**** TODO Operator precedence
** 21.3. C - Derivable Traits
   [in process]
** 21.4. D - Nightly Rust
   [in process]
** 21.5. E - Macros
   [in process]
** 21.6. F - Translations
   [in process]
** TODO 21.7. G - Newest Features
*** TODO Field init shorthand
*** TODO Returning from loops
