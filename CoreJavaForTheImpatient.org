#+TITLE: Core Java for The Impatient
#+VERSION: 2015, Covers Java SE 8
#+AUTHOR: Cay Horstmann
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
 - [[Preface][Preface]]
 - [[Acknowledgments][Acknowledgments]]
 - [[About the Author][About the Author]]
 - [[1 FUNDAMENTAL PROGRAMMING STRUCTURES  xxx PAGE 22 ~ 69][1 FUNDAMENTAL PROGRAMMING STRUCTURES  xxx PAGE 22 ~ 69]]
   - [[1.1 Our First Program][1.1 Our First Program]]
     - [[1.1.1 Dissecting the "Hello, World" Program][1.1.1 Dissecting the "Hello, World" Program]]
     - [[1.1.2 Compiling and Running a Java Program][1.1.2 Compiling and Running a Java Program]]
     - [[1.1.3 Method Calls][1.1.3 Method Calls]]
   - [[1.2 Primitive Types][1.2 Primitive Types]]
     - [[1.2.1 Integer Types][1.2.1 Integer Types]]
     - [[1.2.2 Floating-Point Types][1.2.2 Floating-Point Types]]
     - [[1.2.3 The ~char~ Type][1.2.3 The ~char~ Type]]
     - [[1.2.4 The ~boolean~ Type][1.2.4 The ~boolean~ Type]]
   - [[1.3 Variables][1.3 Variables]]
     - [[1.3.1 Variable Declarations][1.3.1 Variable Declarations]]
     - [[1.3.2 Names][1.3.2 Names]]
     - [[1.3.3 Initialization][1.3.3 Initialization]]
     - [[1.3.4 Constants][1.3.4 Constants]]
   - [[1.4 Arithmetic Operations][1.4 Arithmetic Operations]]
     - [[1.4.1 Assignment][1.4.1 Assignment]]
     - [[1.4.2 Basic Arithmetic][1.4.2 Basic Arithmetic]]
     - [[1.4.3 Mathematical Methods][1.4.3 Mathematical Methods]]
     - [[1.4.4 Number Type Conversions][1.4.4 Number Type Conversions]]
     - [[1.4.5 Relational and Logical Operators][1.4.5 Relational and Logical Operators]]
     - [[1.4.6 Big Numbers][1.4.6 Big Numbers]]
   - [[1.5 Strings][1.5 Strings]]
     - [[1.5.1 Concatenation][1.5.1 Concatenation]]
     - [[1.5.2 Substrings][1.5.2 Substrings]]
     - [[1.5.3 String Comparison][1.5.3 String Comparison]]
     - [[1.5.4 Converting Between Numbers and Strings Variables][1.5.4 Converting Between Numbers and Strings Variables]]
     - [[1.5.5 The String API][1.5.5 The String API]]
     - [[1.5.6 Code Points and Code Units][1.5.6 Code Points and Code Units]]
   - [[1.6 Input and Output][1.6 Input and Output]]
     - [[1.6.1 Reading Input][1.6.1 Reading Input]]
     - [[1.6.2 Formatted Output][1.6.2 Formatted Output]]
   - [[1.7 Control Flow][1.7 Control Flow]]
     - [[1.7.1 Branches][1.7.1 Branches]]
     - [[1.7.2 Loops][1.7.2 Loops]]
     - [[1.7.3 Breaking and Continuing][1.7.3 Breaking and Continuing]]
     - [[1.7.4 Local Variable Scope][1.7.4 Local Variable Scope]]
   - [[1.8 Arrays and Array Lists][1.8 Arrays and Array Lists]]
     - [[1.8.1 Working with Arrays][1.8.1 Working with Arrays]]
     - [[1.8.2 Array Construction][1.8.2 Array Construction]]
     - [[1.8.3 Array Lists][1.8.3 Array Lists]]
     - [[1.8.4 Wrapper Classes for Primitive Types][1.8.4 Wrapper Classes for Primitive Types]]
     - [[1.8.5 The Enhanced for Loop][1.8.5 The Enhanced for Loop]]
     - [[1.8.6 Copying Arrays and Array Lists][1.8.6 Copying Arrays and Array Lists]]
     - [[1.8.7 Array Algorithms][1.8.7 Array Algorithms]]
     - [[1.8.8 Command-Line Arguments][1.8.8 Command-Line Arguments]]
     - [[1.8.9 Multidimensional Arrays][1.8.9 Multidimensional Arrays]]
   - [[1.9 Functional Decomposition][1.9 Functional Decomposition]]
     - [[1.9.1 Declaring and Calling Static Methods][1.9.1 Declaring and Calling Static Methods]]
     - [[1.9.2 Array Parameters and Return Values][1.9.2 Array Parameters and Return Values]]
     - [[1.9.3 Variable Arguments][1.9.3 Variable Arguments]]
     - [[Exercises][Exercises]]
 - [[2 OBJECT-ORIENTED PROGRAMMING][2 OBJECT-ORIENTED PROGRAMMING]]
   - [[2.1 Working with Objects][2.1 Working with Objects]]
     - [[2.1.1 Accessor and Mutator Methods][2.1.1 Accessor and Mutator Methods]]
     - [[2.1.2 Object References][2.1.2 Object References]]
   - [[2.2 Implementing Classes][2.2 Implementing Classes]]
     - [[2.2.1 Instance Variables][2.2.1 Instance Variables]]
     - [[2.2.2 Method Headers][2.2.2 Method Headers]]
     - [[2.2.3 Method Bodies][2.2.3 Method Bodies]]
     - [[2.2.4 Instance Method Invocations][2.2.4 Instance Method Invocations]]
     - [[2.2.5 The ~this~ Reference][2.2.5 The ~this~ Reference]]
     - [[2.2.6 Call by Value][2.2.6 Call by Value]]
   - [[2.3 Object Construction][2.3 Object Construction]]
     - [[2.3.1 Implementing Constructors][2.3.1 Implementing Constructors]]
     - [[2.3.2 Overloading][2.3.2 Overloading]]
     - [[2.3.3 Calling One Constructor from Another][2.3.3 Calling One Constructor from Another]]
     - [[2.3.4 Default Initialization][2.3.4 Default Initialization]]
     - [[2.3.5 Instance Variable Initialization][2.3.5 Instance Variable Initialization]]
     - [[2.3.6 Final Instance Variables][2.3.6 Final Instance Variables]]
     - [[2.3.7 The Constructor with No Arguments][2.3.7 The Constructor with No Arguments]]
   - [[2.4 Static Variables and Methods][2.4 Static Variables and Methods]]
     - [[2.4.1 Static Variables][2.4.1 Static Variables]]
     - [[2.4.2 Static Constants][2.4.2 Static Constants]]
     - [[2.4.3 Static Initialization Blocks][2.4.3 Static Initialization Blocks]]
     - [[2.4.4 Static Methods][2.4.4 Static Methods]]
     - [[2.4.5 Factory Methods][2.4.5 Factory Methods]]
   - [[2.5 Packages][2.5 Packages]]
     - [[2.5.1 Package Declarations][2.5.1 Package Declarations]]
     - [[2.5.2 The Class Path][2.5.2 The Class Path]]
     - [[2.5.3 Package Scope][2.5.3 Package Scope]]
     - [[2.5.4 Importing Classes][2.5.4 Importing Classes]]
     - [[2.5.5 Static Imports][2.5.5 Static Imports]]
   - [[2.6 Nested Classes][2.6 Nested Classes]]
     - [[2.6.1 Static Nested Classes][2.6.1 Static Nested Classes]]
     - [[2.6.2 Inner Classes][2.6.2 Inner Classes]]
     - [[2.6.3 Special Syntax Rules for Inner Classes][2.6.3 Special Syntax Rules for Inner Classes]]
   - [[2.7 Documentation Comments][2.7 Documentation Comments]]
     - [[2.7.1 Comment Insertion][2.7.1 Comment Insertion]]
     - [[2.7.2 Class Comments][2.7.2 Class Comments]]
     - [[2.7.3 Method Comments][2.7.3 Method Comments]]
     - [[2.7.4 Variable Comments][2.7.4 Variable Comments]]
     - [[2.7.5 General Comments][2.7.5 General Comments]]
     - [[2.7.6 Links][2.7.6 Links]]
     - [[2.7.7 Package and Overview Comments][2.7.7 Package and Overview Comments]]
     - [[2.7.8 Comment Extraction][2.7.8 Comment Extraction]]
   - [[Exercises][Exercises]]
 - [[3 INTERFACES AND LAMBDA EXPRESSIONS - PAGE 107 ~ 138][3 INTERFACES AND LAMBDA EXPRESSIONS - PAGE 107 ~ 138]]
   - [[3.1 Interfaces][3.1 Interfaces]]
     - [[3.1.1 Declaring an Interface][3.1.1 Declaring an Interface]]
     - [[3.1.2 Implementing an Interface][3.1.2 Implementing an Interface]]
     - [[3.1.3 Converting to an Interface Type][3.1.3 Converting to an Interface Type]]
     - [[3.1.4 Casts and the instanceof Operator][3.1.4 Casts and the instanceof Operator]]
     - [[3.1.5 Extending Interfaces][3.1.5 Extending Interfaces]]
     - [[3.1.6 Implementing Multiple Interfaces][3.1.6 Implementing Multiple Interfaces]]
     - [[3.1.7 Constants][3.1.7 Constants]]
   - [[3.2 Static and Default Methods][3.2 Static and Default Methods]]
     - [[3.2.1 Static Methods][3.2.1 Static Methods]]
     - [[3.2.2 Default Methods][3.2.2 Default Methods]]
     - [[3.2.3 Resolving Default Method Conflicts][3.2.3 Resolving Default Method Conflicts]]
   - [[3.3 Examples of Interfaces][3.3 Examples of Interfaces]]
     - [[3.3.1 The ~Comparable~ Interface][3.3.1 The ~Comparable~ Interface]]
     - [[3.3.2 The ~Comparator~ Interface][3.3.2 The ~Comparator~ Interface]]
     - [[3.3.3 The ~Runnable~ Interface][3.3.3 The ~Runnable~ Interface]]
     - [[3.3.4 User Interface Callbacks][3.3.4 User Interface Callbacks]]
   - [[3.4 Lambda Expressions][3.4 Lambda Expressions]]
     - [[3.4.1 The Syntax of Lambda Expressions][3.4.1 The Syntax of Lambda Expressions]]
     - [[3.4.2 Functional Interfaces][3.4.2 Functional Interfaces]]
   - [[3.5 Method and Constructor References][3.5 Method and Constructor References]]
     - [[3.5.1 Method References][3.5.1 Method References]]
     - [[3.5.2 Constructor References][3.5.2 Constructor References]]
   - [[3.6 Processing Lambda Expressions][3.6 Processing Lambda Expressions]]
     - [[3.6.1 Implementing Deferred Execution][3.6.1 Implementing Deferred Execution]]
     - [[3.6.2 Choosing a Functional Interface][3.6.2 Choosing a Functional Interface]]
     - [[3.6.3 Implementing Your Own Functional Interfaces][3.6.3 Implementing Your Own Functional Interfaces]]
   - [[3.7 Lambda Expressions and Variable Scope][3.7 Lambda Expressions and Variable Scope]]
     - [[3.7.1 Scope of a Lambda Expression][3.7.1 Scope of a Lambda Expression]]
     - [[3.7.2 Accessing Variables from the Enclosing Scope][3.7.2 Accessing Variables from the Enclosing Scope]]
   - [[3.8 Higher-Order Functions][3.8 Higher-Order Functions]]
     - [[3.8.1 Methods that Return Functions][3.8.1 Methods that Return Functions]]
     - [[3.8.2 Methods That Modify Functions][3.8.2 Methods That Modify Functions]]
     - [[3.8.3 Comparator Methods][3.8.3 Comparator Methods]]
   - [[3.9 Local Inner Classes][3.9 Local Inner Classes]]
     - [[3.9.1 Local Classes][3.9.1 Local Classes]]
     - [[3.9.2 Anonymous Classes][3.9.2 Anonymous Classes]]
   - [[Exercises][Exercises]]
 - [[4 INHERITANCE AND REFLECTION - PAGE 139 ~ 179][4 INHERITANCE AND REFLECTION - PAGE 139 ~ 179]]
   - [[4.1 Extending a Class][4.1 Extending a Class]]
     - [[4.1.1 Super- and Subclasses][4.1.1 Super- and Subclasses]]
     - [[4.1.2 Defining and Inheriting Subclass Methods][4.1.2 Defining and Inheriting Subclass Methods]]
     - [[4.1.3 Method Overriding][4.1.3 Method Overriding]]
     - [[4.1.4 Subclass Construction][4.1.4 Subclass Construction]]
     - [[4.1.5 Superclass Assignments][4.1.5 Superclass Assignments]]
     - [[4.1.6 Casts][4.1.6 Casts]]
     - [[4.1.7 Final Methods and Classes][4.1.7 Final Methods and Classes]]
     - [[4.1.8 Abstract Methods and Classes][4.1.8 Abstract Methods and Classes]]
     - [[4.1.9 Protected Access][4.1.9 Protected Access]]
     - [[4.1.10 Anonymous Subclasses][4.1.10 Anonymous Subclasses]]
     - [[4.1.11 Inheritance and Default Methods][4.1.11 Inheritance and Default Methods]]
     - [[4.1.12 Method Expressions with ~super~][4.1.12 Method Expressions with ~super~]]
   - [[4.2 ~Object~: The Cosmic Superclass][4.2 ~Object~: The Cosmic Superclass]]
     - [[4.2.1 The ~toString~ Method][4.2.1 The ~toString~ Method]]
     - [[4.2.2 The ~equals~ Method][4.2.2 The ~equals~ Method]]
     - [[4.2.3 The ~hashCode~ Method][4.2.3 The ~hashCode~ Method]]
     - [[4.2.4 Cloning Objects][4.2.4 Cloning Objects]]
   - [[4.3 Enumerations][4.3 Enumerations]]
     - [[4.3.1 Methods of Enumerations][4.3.1 Methods of Enumerations]]
     - [[4.3.2 Constructors, Methods, and Fields][4.3.2 Constructors, Methods, and Fields]]
     - [[4.3.3 Bodies of Instances][4.3.3 Bodies of Instances]]
     - [[4.3.4 Static Members][4.3.4 Static Members]]
     - [[4.3.5 Switching on an Enumeration][4.3.5 Switching on an Enumeration]]
   - [[4.4 Runtime Type Information and Resources][4.4 Runtime Type Information and Resources]]
     - [[4.4.1 The Class Class][4.4.1 The Class Class]]
     - [[4.4.2 Loading Resources][4.4.2 Loading Resources]]
     - [[4.4.3 Class Loaders][4.4.3 Class Loaders]]
     - [[4.4.4 The Context Class Loader][4.4.4 The Context Class Loader]]
     - [[4.4.5 Service Loaders][4.4.5 Service Loaders]]
   - [[4.5 Reflection][4.5 Reflection]]
     - [[4.5.1 Enumerating Class Members][4.5.1 Enumerating Class Members]]
     - [[4.5.2 Inspecting Objects][4.5.2 Inspecting Objects]]
     - [[4.5.3 Invoking Methods][4.5.3 Invoking Methods]]
     - [[4.5.4 Constructing Objects][4.5.4 Constructing Objects]]
     - [[4.5.5 JavaBeans][4.5.5 JavaBeans]]
     - [[4.5.6 Working with Arrays][4.5.6 Working with Arrays]]
     - [[4.5.7 Proxies][4.5.7 Proxies]]
   - [[Exercises][Exercises]]
 - [[5 EXCEPTIONS, ASSERTIONS, AND LOGGING - PAGE 180 ~ 202][5 EXCEPTIONS, ASSERTIONS, AND LOGGING - PAGE 180 ~ 202]]
   - [[5.1 Exception Handling][5.1 Exception Handling]]
     - [[5.1.1 Throwing Exceptions][5.1.1 Throwing Exceptions]]
     - [[5.1.2 The Exception Hierarchy][5.1.2 The Exception Hierarchy]]
     - [[5.1.3 Declaring Checked Exceptions][5.1.3 Declaring Checked Exceptions]]
     - [[5.1.4 Catching Exceptions][5.1.4 Catching Exceptions]]
     - [[5.1.5 The Try-with-Resources Statement][5.1.5 The Try-with-Resources Statement]]
     - [[5.1.6 The finally Clause][5.1.6 The finally Clause]]
     - [[5.1.7 Rethrowing and Chaining Exceptions][5.1.7 Rethrowing and Chaining Exceptions]]
     - [[5.1.8 The Stack Trace][5.1.8 The Stack Trace]]
     - [[5.1.9 The ~Objects.requireNonNull~ Method][5.1.9 The ~Objects.requireNonNull~ Method]]
   - [[5.2 Assertions][5.2 Assertions]]
     - [[5.2.1 Using Assertions][5.2.1 Using Assertions]]
     - [[5.2.2 Enabling and Disabling Assertions][5.2.2 Enabling and Disabling Assertions]]
   - [[5.3 Logging][5.3 Logging]]
     - [[5.3.1 Using Loggers][5.3.1 Using Loggers]]
     - [[5.3.2 Loggers][5.3.2 Loggers]]
     - [[5.3.3 Logging Levels][5.3.3 Logging Levels]]
     - [[5.3.4 Other Logging Methods][5.3.4 Other Logging Methods]]
     - [[5.3.5 Logging Configuration][5.3.5 Logging Configuration]]
     - [[5.3.6 Log Handlers][5.3.6 Log Handlers]]
     - [[5.3.7 Filters and Formatters][5.3.7 Filters and Formatters]]
   - [[Exercises][Exercises]]
 - [[6 GENERIC PROGRAMMING - PAGE 203 ~ 227][6 GENERIC PROGRAMMING - PAGE 203 ~ 227]]
   - [[6.1 Generic Classes][6.1 Generic Classes]]
   - [[6.2 Generic Methods][6.2 Generic Methods]]
   - [[6.3 Type Bounds][6.3 Type Bounds]]
   - [[6.4 Type Variance and Wildcards][6.4 Type Variance and Wildcards]]
     - [[6.4.1 Subtype Wildcards][6.4.1 Subtype Wildcards]]
     - [[6.4.2 Supertype Wildcards][6.4.2 Supertype Wildcards]]
     - [[6.4.3 Wildcards with Type Variables][6.4.3 Wildcards with Type Variables]]
     - [[6.4.4 Unbounded Wildcards][6.4.4 Unbounded Wildcards]]
     - [[6.4.5 Wildcard Capture][6.4.5 Wildcard Capture]]
   - [[6.5 Generics in the Java Virtual Machine][6.5 Generics in the Java Virtual Machine]]
     - [[6.5.1 Type Erasure][6.5.1 Type Erasure]]
     - [[6.5.2 Cast Insertion][6.5.2 Cast Insertion]]
     - [[6.5.3 Bridge Methods][6.5.3 Bridge Methods]]
   - [[6.6 Restrictions on Generics][6.6 Restrictions on Generics]]
     - [[6.6.1 No Primitive Type Arguments][6.6.1 No Primitive Type Arguments]]
     - [[6.6.2 At Runtime, All Types Are Raw][6.6.2 At Runtime, All Types Are Raw]]
     - [[6.6.3 You Cannot Instantiate Type Variables][6.6.3 You Cannot Instantiate Type Variables]]
     - [[6.6.4 You Cannot Construct Arrays of Parameterized Types][6.6.4 You Cannot Construct Arrays of Parameterized Types]]
     - [[6.6.5 Class Type Variables Are Not Valid in Static Contexts][6.6.5 Class Type Variables Are Not Valid in Static Contexts]]
     - [[6.6.6 Methods May Not Clash after Erasure][6.6.6 Methods May Not Clash after Erasure]]
     - [[6.6.7 Exceptions and Generics][6.6.7 Exceptions and Generics]]
   - [[6.7 Reflection and Generics][6.7 Reflection and Generics]]
     - [[6.7.1 The Class<T> Class][6.7.1 The Class<T> Class]]
     - [[6.7.2 Generic Type Information in the Virtual Machine][6.7.2 Generic Type Information in the Virtual Machine]]
   - [[Exercises][Exercises]]
 - [[7 COLLECTIONS - PAGE 228 ~ 246][7 COLLECTIONS - PAGE 228 ~ 246]]
   - [[7.1 An Overview of the Collections Framework][7.1 An Overview of the Collections Framework]]
   - [[7.2 Iterators][7.2 Iterators]]
   - [[7.3 Sets][7.3 Sets]]
   - [[7.4 Maps][7.4 Maps]]
   - [[7.5 Other Collections][7.5 Other Collections]]
     - [[7.5.1 Properties][7.5.1 Properties]]
     - [[7.5.2 Bit Sets][7.5.2 Bit Sets]]
     - [[7.5.3 Enumeration Sets and Maps][7.5.3 Enumeration Sets and Maps]]
     - [[7.5.4 Stacks, Queues, Deques, and Priority Queues][7.5.4 Stacks, Queues, Deques, and Priority Queues]]
     - [[7.5.5 Weak Hash Maps][7.5.5 Weak Hash Maps]]
   - [[7.6 Views][7.6 Views]]
     - [[7.6.1 Ranges][7.6.1 Ranges]]
     - [[7.6.2 Empty and Singleton Views][7.6.2 Empty and Singleton Views]]
     - [[7.6.3 Unmodifiable Views][7.6.3 Unmodifiable Views]]
   - [[Exercises][Exercises]]
 - [[8 STREAMS - PAGE 247 ~ 260][8 STREAMS - PAGE 247 ~ 260]]
   - [[8.1 From Iterating to Stream Operations][8.1 From Iterating to Stream Operations]]
   - [[8.2 Stream Creation][8.2 Stream Creation]]
   - [[8.3 The filter, map, and flatMap Methods][8.3 The filter, map, and flatMap Methods]]
   - [[8.4 Extracting Substreams and Combining Streams][8.4 Extracting Substreams and Combining Streams]]
   - [[8.5 Other Stream Transformations][8.5 Other Stream Transformations]]
   - [[8.6 Simple Reductions][8.6 Simple Reductions]]
   - [[8.7 The Optional Type][8.7 The Optional Type]]
     - [[8.7.1 How to Work with Optional Values][8.7.1 How to Work with Optional Values]]
     - [[8.7.2 How Not to Work with Optional Values][8.7.2 How Not to Work with Optional Values]]
     - [[8.7.3 Creating Optional Values][8.7.3 Creating Optional Values]]
     - [[8.7.4 Composing Optional Value Functions with flatMap][8.7.4 Composing Optional Value Functions with flatMap]]
   - [[8.8 Collecting Results][8.8 Collecting Results]]
   - [[8.9 Collecting into Maps][8.9 Collecting into Maps]]
   - [[8.10 Grouping and Partitioning][8.10 Grouping and Partitioning]]
   - [[8.11 Downstream Collectors][8.11 Downstream Collectors]]
   - [[8.12 Reduction Operations][8.12 Reduction Operations]]
   - [[8.13 Primitive Type Streams][8.13 Primitive Type Streams]]
   - [[8.14 Parallel Streams][8.14 Parallel Streams]]
   - [[Exercises][Exercises]]
 - [[9 PROCESSING INPUT AND OUTPUT - PAGE 270 ~ 303][9 PROCESSING INPUT AND OUTPUT - PAGE 270 ~ 303]]
   - [[9.1 Input/Output Streams, Readers, and Writers][9.1 Input/Output Streams, Readers, and Writers]]
     - [[9.1.1 Obtaining Streams][9.1.1 Obtaining Streams]]
     - [[9.1.2 Reading Bytes][9.1.2 Reading Bytes]]
     - [[9.1.3 Writing Bytes][9.1.3 Writing Bytes]]
     - [[9.1.4 Character Encodings][9.1.4 Character Encodings]]
     - [[9.1.5 Text Input][9.1.5 Text Input]]
     - [[9.1.6 Text Output][9.1.6 Text Output]]
     - [[9.1.7 Reading and Writing Binary Data][9.1.7 Reading and Writing Binary Data]]
     - [[9.1.8 Random-Access Files][9.1.8 Random-Access Files]]
     - [[9.1.9 Memory-Mapped Files][9.1.9 Memory-Mapped Files]]
     - [[9.1.10 File Locking][9.1.10 File Locking]]
   - [[9.2 Paths, Files, and Directories][9.2 Paths, Files, and Directories]]
     - [[9.2.1 Paths][9.2.1 Paths]]
     - [[9.2.2 Creating Files and Directories][9.2.2 Creating Files and Directories]]
     - [[9.2.3 Copying, Moving, and Deleting Files][9.2.3 Copying, Moving, and Deleting Files]]
     - [[9.2.4 Visiting Directory Entries][9.2.4 Visiting Directory Entries]]
     - [[9.2.5 ZIP File Systems][9.2.5 ZIP File Systems]]
   - [[9.3 URL Connections][9.3 URL Connections]]
   - [[9.4 Regular Expressions][9.4 Regular Expressions]]
     - [[9.4.1 The Regular Expression Syntax][9.4.1 The Regular Expression Syntax]]
     - [[9.4.2 Finding One or All Matches][9.4.2 Finding One or All Matches]]
     - [[9.4.3 Groups][9.4.3 Groups]]
     - [[9.4.4 Removing or Replacing Matches][9.4.4 Removing or Replacing Matches]]
     - [[9.4.5 Flags][9.4.5 Flags]]
   - [[9.5 Serialization][9.5 Serialization]]
     - [[9.5.1 The Serializable Interface][9.5.1 The Serializable Interface]]
     - [[9.5.2 Transient Instance Variables][9.5.2 Transient Instance Variables]]
     - [[9.5.3 The readObject and writeObject Methods][9.5.3 The readObject and writeObject Methods]]
     - [[9.5.4 The readResolve and writeReplace Methods][9.5.4 The readResolve and writeReplace Methods]]
     - [[9.5.5 Versioning][9.5.5 Versioning]]
   - [[Exercises][Exercises]]
 - [[10 CONCURRENT PROGRAMMING - PAGE 304 ~ 343][10 CONCURRENT PROGRAMMING - PAGE 304 ~ 343]]
   - [[10.1 Concurrent Tasks][10.1 Concurrent Tasks]]
     - [[10.1.1 Running Tasks][10.1.1 Running Tasks]]
     - [[10.1.2 Futures and Executor Services][10.1.2 Futures and Executor Services]]
   - [[10.2 Thread Safety][10.2 Thread Safety]]
     - [[10.2.1 Visibility][10.2.1 Visibility]]
     - [[10.2.2 Race Conditions][10.2.2 Race Conditions]]
     - [[10.2.3 Strategies for Safe Concurrency][10.2.3 Strategies for Safe Concurrency]]
     - [[10.2.4 Immutable Classes][10.2.4 Immutable Classes]]
   - [[10.3 Parallel Algorithms][10.3 Parallel Algorithms]]
     - [[10.3.1 Parallel Streams][10.3.1 Parallel Streams]]
     - [[10.3.2 Parallel Array Operations][10.3.2 Parallel Array Operations]]
   - [[10.4 Threadsafe Data Structures][10.4 Threadsafe Data Structures]]
     - [[10.4.1 Concurrent Hash Maps][10.4.1 Concurrent Hash Maps]]
     - [[10.4.2 Blocking Queues][10.4.2 Blocking Queues]]
     - [[10.4.3 Other Threadsafe Data Structures][10.4.3 Other Threadsafe Data Structures]]
   - [[10.5 Atomic Values][10.5 Atomic Values]]
   - [[10.6 Locks][10.6 Locks]]
     - [[10.6.1 Reentrant Locks][10.6.1 Reentrant Locks]]
     - [[10.6.2 The synchronized Keyword][10.6.2 The synchronized Keyword]]
     - [[10.6.3 Waiting on Conditions][10.6.3 Waiting on Conditions]]
   - [[10.7 Threads][10.7 Threads]]
     - [[10.7.1 Starting a Thread][10.7.1 Starting a Thread]]
     - [[10.7.2 Thread Interruption][10.7.2 Thread Interruption]]
     - [[10.7.3 Thread-Local Variables][10.7.3 Thread-Local Variables]]
     - [[10.7.4 Miscellaneous Thread Properties][10.7.4 Miscellaneous Thread Properties]]
   - [[10.8 Asynchronous Computations][10.8 Asynchronous Computations]]
     - [[10.8.1 Long-Running Tasks in User Interface Callbacks][10.8.1 Long-Running Tasks in User Interface Callbacks]]
     - [[10.8.2 Completable Futures][10.8.2 Completable Futures]]
   - [[10.9 Processes][10.9 Processes]]
     - [[10.9.1 Building a Process][10.9.1 Building a Process]]
     - [[10.9.2 Running a Process][10.9.2 Running a Process]]
   - [[Exercises][Exercises]]
 - [[11 ANNOTATIONS - PAGE 344 ~ 364][11 ANNOTATIONS - PAGE 344 ~ 364]]
   - [[11.1 Using Annotations][11.1 Using Annotations]]
     - [[11.1.1 Annotation Elements][11.1.1 Annotation Elements]]
     - [[11.1.2 Multiple and Repeated Annotations][11.1.2 Multiple and Repeated Annotations]]
     - [[11.1.3 Annotating Declarations][11.1.3 Annotating Declarations]]
     - [[11.1.4 Annotating Type Uses][11.1.4 Annotating Type Uses]]
     - [[11.1.5 Making Receivers Explicit][11.1.5 Making Receivers Explicit]]
   - [[11.2 Defining Annotations][11.2 Defining Annotations]]
   - [[11.3 Standard Annotations][11.3 Standard Annotations]]
     - [[11.3.1 Annotations for Compilation][11.3.1 Annotations for Compilation]]
     - [[11.3.2 Annotations for Managing Resources][11.3.2 Annotations for Managing Resources]]
     - [[11.3.3 Meta-Annotations][11.3.3 Meta-Annotations]]
   - [[11.4 Processing Annotations at Runtime][11.4 Processing Annotations at Runtime]]
   - [[11.5 Source-Level Annotation Processing][11.5 Source-Level Annotation Processing]]
     - [[11.5.1 Annotation Processors][11.5.1 Annotation Processors]]
     - [[11.5.2 The Language Model API][11.5.2 The Language Model API]]
     - [[11.5.3 Using Annotations to Generate Source Code][11.5.3 Using Annotations to Generate Source Code]]
   - [[Exercises][Exercises]]
 - [[12 THE DATE AND TIME API - PAGE 365 ~ 380][12 THE DATE AND TIME API - PAGE 365 ~ 380]]
   - [[12.1 The Time Line][12.1 The Time Line]]
   - [[12.2 Local Dates][12.2 Local Dates]]
   - [[12.3 Date Adjusters][12.3 Date Adjusters]]
   - [[12.4 Local Time][12.4 Local Time]]
   - [[12.5 Zoned Time][12.5 Zoned Time]]
   - [[12.6 Formatting and Parsing][12.6 Formatting and Parsing]]
   - [[12.7 Interoperating with Legacy Code][12.7 Interoperating with Legacy Code]]
   - [[Exercises][Exercises]]
 - [[13 INTERNATIONALIZATION - PAGE 381 ~ 399][13 INTERNATIONALIZATION - PAGE 381 ~ 399]]
   - [[13.1 Locales][13.1 Locales]]
     - [[13.1.1 Specifying a Locale][13.1.1 Specifying a Locale]]
     - [[13.1.2 The Default Locale][13.1.2 The Default Locale]]
     - [[13.1.3 Display Names][13.1.3 Display Names]]
   - [[13.2 Number Formats][13.2 Number Formats]]
   - [[13.3 Currencies][13.3 Currencies]]
   - [[13.4 Date and Time Formatting][13.4 Date and Time Formatting]]
   - [[13.5 Collation and Normalization][13.5 Collation and Normalization]]
   - [[13.6 Message Formatting][13.6 Message Formatting]]
   - [[13.7 Resource Bundles][13.7 Resource Bundles]]
     - [[13.7.1 Organizing Resource Bundles][13.7.1 Organizing Resource Bundles]]
     - [[13.7.2 Bundle Classes][13.7.2 Bundle Classes]]
   - [[13.8 Character Encodings][13.8 Character Encodings]]
   - [[13.9 Preferences][13.9 Preferences]]
   - [[Exercises][Exercises]]
 - [[14 COMPILING AND SCRIPTING - PAGE 400 ~ 422][14 COMPILING AND SCRIPTING - PAGE 400 ~ 422]]
   - [[14.1 The Compiler API][14.1 The Compiler API]]
     - [[14.1.1 Invoking the Compiler][14.1.1 Invoking the Compiler]]
     - [[14.1.2 Launching a Compilation Task][14.1.2 Launching a Compilation Task]]
     - [[14.1.3 Reading Source Files from Memory][14.1.3 Reading Source Files from Memory]]
     - [[14.1.4 Writing Byte Codes to Memory][14.1.4 Writing Byte Codes to Memory]]
     - [[14.1.5 Capturing Diagnostics][14.1.5 Capturing Diagnostics]]
   - [[14.2 The Scripting API][14.2 The Scripting API]]
     - [[14.2.1 Getting a Scripting Engine][14.2.1 Getting a Scripting Engine]]
     - [[14.2.2 Bindings][14.2.2 Bindings]]
     - [[14.2.3 Redirecting Input and Output][14.2.3 Redirecting Input and Output]]
     - [[14.2.4 Calling Scripting Functions and Methods][14.2.4 Calling Scripting Functions and Methods]]
     - [[14.2.5 Compiling a Script][14.2.5 Compiling a Script]]
   - [[14.3 The Nashorn Scripting Engine][14.3 The Nashorn Scripting Engine]]
     - [[14.3.1 Running Nashorn from the Command Line][14.3.1 Running Nashorn from the Command Line]]
     - [[14.3.2 Invoking Getters, Setters, and Overloaded Methods][14.3.2 Invoking Getters, Setters, and Overloaded Methods]]
     - [[14.3.3 Constructing Java Objects][14.3.3 Constructing Java Objects]]
     - [[14.3.4 Strings in JavaScript and Java][14.3.4 Strings in JavaScript and Java]]
     - [[14.3.5 Numbers][14.3.5 Numbers]]
     - [[14.3.6 Working with Arrays][14.3.6 Working with Arrays]]
     - [[14.3.7 Lists and Maps][14.3.7 Lists and Maps]]
     - [[14.3.8 Lambdas][14.3.8 Lambdas]]
     - [[14.3.9 Extending Java Classes and Implementing Java Interfaces][14.3.9 Extending Java Classes and Implementing Java Interfaces]]
     - [[14.3.10 Exceptions][14.3.10 Exceptions]]
   - [[14.4 Shell Scripting with Nashorn][14.4 Shell Scripting with Nashorn]]
     - [[14.4.1 Executing Shell Commands][14.4.1 Executing Shell Commands]]
     - [[14.4.2 String Interpolation][14.4.2 String Interpolation]]
     - [[14.4.3 Script Inputs][14.4.3 Script Inputs]]
   - [[Exercises][Exercises]]
 - [[Tips][Tips]]

* Preface
* Acknowledgments
* About the Author
* 1 FUNDAMENTAL PROGRAMMING STRUCTURES  xxx PAGE 22 ~ 69
  The key points of this chapter are:
  1. In Java, all methods are declared in a class.
     You invoke a nonstatic method on an object of the class to which the method
     belongs.

  2. Static methods are not invoked on objects.
     Program execution starts with the static ~main~ method.

  3. Java has eight primitive types:
     + four integer types,
     + two floating-point
     + types,
     + char,
     + boolean.

  4. The Java operators and control structures are very similar to those of C or
     JavaScript.

  5. The Math class provides common mathematical functions.

  6. String objects are sequences of characters or, more precisely, Unicode code
     points in the UTF-16 encoding.

  7. With the System.out object, you can display output in a terminal window. A
     Scanner tied to System.in lets you read terminal input.

  8. Arrays and collections can be used to collect elements of the same type.

** 1.1 Our First Program
*** 1.1.1 Dissecting the "Hello, World" Program
    #+BEGIN_SRC java
    package ch01.sec01;
    
    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello, World!");
        }
    }
    #+END_SRC

    - The ~main~ method is the first method that is called when the program runs.

    - A function is declared as ~static~ does not operate on any objects.

    - =TODO= ~String[] args~

    - ~public~, ~private~

    - ~package~: A package is a set of related classes.

    - ~System.out~, ~System.out.println~

*** 1.1.2 Compiling and Running a Java Program
    #+BEGIN_SRC bash
    # 1. compiles the Java source code into Java byte codes;
    # 2. saves the byte codes into class files.
    javac ch01/sec01/HelloWorld.java

    # launches a virtual machine that loads the class files and excutes the
    # byte codes.
    java ch01.sec01.HelloWorld
    #+END_SRC

*** 1.1.3 Method Calls
    - ~System.out~ is an object, and it is an /instance/ of a class called
      ~PrintStream~ (has method ~println~, ~print~, etc.).

    - ~new Random().nextInt()~ means:
      construct a ~Random~ object, and then call the method ~nextInt()~
      =From Jian=: I think this is a bad syntax!
                   ~(new Random()).nextInt()~ is a much better one.

    - ~Random~ class is declared in the ~java.util~ package. To use it in your
      program, add an ~import~ statement: ~import java.util.Random;~.

** 1.2 Primitive Types
*** 1.2.1 Integer Types
    - Table 1-1 Java Integer Types
      | Type    | Storage requirement | Range(inclusive)                                        |
      |---------+---------------------+---------------------------------------------------------|
      | ~int~   | 4 bytes             | -2,147,483,648 to 2,147,483,647 (just over 2 billion)   |
      | ~long~  | 8 bytes             | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |
      | ~short~ | 2 bytes             | -32,768 to 32,767                                       |
      | ~byte~  | 1 byte              | -128 to 127                                             |

    - ~Integer~, ~Long~, ~Short~, and ~Byte~ classes have ~MIN_VALUE~ and
      ~MAX_VALUE~ constants.

    - =TODO= ~BigInteger~ class, See Section 1.4.6

    - ~long~ integer literals: add a suffix ~L~.

    - NO syntax for literals of type ~byte~ or ~short~. Use cast, for example:
      ~(byte) 127~.

    - Literals of numbers of different base:
      + Hexadecimal literals: prefix ~0x~
      + Binary literals: prefix ~0b~
      + Octal literals: prefix ~0~
 
    - You can add underscores to number literals. For example, ~1_000_000~
      They are for human eyes only, the Java compiler simply removes them.

    - _NOTE_:
      _Integer types in Java are signed_ (In CLR, integer can be unsigned).

        However, if you work with values that can never be negative and you
      really need _an additional bit_, you can use methods that interpret
      values as unsigned.

      For example,
      + Reuirement: a byte value ~b~ represent the range from -128 to 127, you
        may want a range from 0 to 255.

      + Solution: Store it in a ~byte~ type value, and
        =???= due to the nature of binary arithmetic, certain operations such as
        addition and subtraction will work.
        For other operations, call ~Byte.toUnsignedInt(b)~, and get an ~int~
        value between 0 and 255.

*** 1.2.2 Floating-Point Types
    - Table 1-2 Java Integer Types
      | Type     | Storage requirement | Range(inclusive)                                                        |
      |----------+---------------------+-------------------------------------------------------------------------|
      | ~float~  | 4 bytes             | Approximately +-3.40282347E+38F(6-7 significant decimal digits          |
      | ~double~ | 8 bytes             | Approximately +-1.79769313486231570E+308F(15 significant decimal digits |
      |          |                     |                                                                         |

    - Literals:
      + ~float~ number example: ~3.14F~
      + ~double~ number example: ~3.14~ or ~3.14D~

    - floating-point literals has hexadecimal form. For example:
      Decimal number 0.0009765625 can be written as (hex form) 0x1.0p-10.
      Since ~e~ is used in hex form, use ~p~ to denote the exmponent.
      + _Even in hex form, the exponent is written in decimal_
        
    - ~Double.POSITIVE_INFINITY~, ~Double.NEGATIVE_INFINITY~, and ~Double.NaN~.

    - All "not a number" values are considered to be distinct from each other.
      Use ~Double.isNaN(x)~ to test, rather than ~(x == Double.NaN)~ (which is
      always true). There are also
      + ~Double.isInfinite~ tests for ±∞
      + ~Double.isFinite~ tests is the floating-number is neither infinite nor
        NaN.

    - If you need precise numerical computations without roundoff errors, use the
      ~BigDecimal~ class, introduced in Section 1.4.6, “Big Numbers,” on p. 19.
      =TODO=

*** 1.2.3 The ~char~ Type
    - The char type describes "code units” in the _UTF-16 character_ encoding
      used by Java.

    - =TODO= The details are rather technical—see Section 1.5, “Strings,” on p. 20.

    - _You probably won't use the ~char~ type very much._

*** 1.2.4 The ~boolean~ Type
    ~boolean~ type is not a number type.
    There is _NO_ replationship between ~boolean~ values and the integers 0 and
    1. 

** 1.3 Variables
   _LEARN_
   how to _declare_ and _initialize_
   + variables
   + constants

*** DONE 1.3.1 Variable Declarations
    CLOSED: [2017-04-23 Sun 01:48]
    - Prefer to use separate declarations for _each_ variable.

    - Declare a variable and initialize it with a constructed object,
      the name of the object's class occurs _TWICE_:
      ~Random generator = new Random();~

*** DONE 1.3.2 Names
    CLOSED: [2017-04-23 Sun 01:49]
    - Java identifier rules:
      + MUST _begin_ with a letter.

      + Can consist of
        * any letters,
        * digits,
        * the symbols
        * ~_~ and ~$~.

      + HOWEVER,
        the ~$~ symbol is intended for automatically generated names,
        and
        you _should NOT_ use it.

*** DONE 1.3.3 Initialization
    CLOSED: [2017-04-23 Sun 01:50]
*** DONE 1.3.4 Constants
    CLOSED: [2017-04-23 Sun 15:39]
    - ~final~

    - Declare a constant _outside_ a method, using the ~static~ keyword:
      #+BEGIN_SRC scala
      public class Calendar {
        public static final int DAYS_PER_WEEK = 7;
      }
      #+END_SRC

    - _Note_:
      The System class declares a constant
      #+BEGIN_SRC scala
      public static final PrintStream out
      #+END_SRC
      that you can use anywhere as ~System.out~.

      _This is one of the few examples of a constant that is not written in
      uppercase._

    - It is legal to defer the initialization of a final variable, provided it is
      initialized exactly once before it is used for the first time. For example,
      the following is legal:
      #+BEGIN_SRC scala
      final int DAYS_IN_FEBRUARY;

      if (leapYear) {
        DAYS_IN_FEBRUARY = 29;
      } else {
        DAYS_IN_FEBRUARY = 28;
      }
      #+END_SRC

    - _Note_:
      + ~enum~ =TODO= Chapter 4

** 1.4 Arithmetic Operations
   - Table 1-3 Java Operators =IMPORTANT=

   - _Note_:
     In this table, operators are listed by _decreasing_ precedence.

*** 1.4.1 Assignment
*** 1.4.2 Basic Arithmetic
    - Always be careful using ~%~ with potentially _negative_ operands.

    - ~X % 12~ returns
      1. a _positive_ number between 0 and 11 (inclusive) _if_ ~X~ _is positive_
      2. a _negative_ number between -11 and -1 (inclusive) _if_ ~X~ _is negative_

    - ~Math.floorMod(X, 12)~ always returns a positive number between 0 and 11
      (inclusive).
      =COMMENT= The first two cases can be simplified as
                ~(X % 12 + 12) % 12~
      1. _if_ ~X~ _is positive_, it returns a result the same as ~X % 12~.
      2. _if_ ~X~ _is negative_, it returns a result the same as ~(X % 12) + 12~.
      3. _if_ the second argument (the divisor) is negative, the result is
         negative.
         This is usually NOT what we want, but fortunately, this situation
         doesn't often occur in practice.

    - _Note_:
      + One of the stated goals of the Java programming language is portability.

        A computation should yield the same results no matter which virtual
        machine executes it.

      + However, many modern processors use
        _floating-point registers with more than 64 bit_
        1. to add precision
           and
        2. reduce the risk of overflow in intermediate steps of a computation.
        Java allows these optimizations, since otherwise floatingpoint operations
        would be slower and less accurate.

      + For the small set of users who care about this issue, there is a
        ~strictfp~ modifier.
        When added (this modifier) to a method, all floating-point operations in
        the method are strictly portable.

*** 1.4.3 Mathematical Methods
    - ~Math.pow(x, y)~ (yields x^y),
      ~Math.sqrt(x)~,
      ~Math.min(x, y)~,
      ~Math.max(x, y)~,
      ~Math.PI~
      ~Math.E~

    - /static methods/

    - Due to overflows, ~Math.multiplyExact(1000000000, 3)~ throws an exception.
      There are also methods
      ~addExact~,
      ~subtractExact~,
      ~incrementExact~,
      ~decrementExact~,
      ~negateExact~,
      all with ~int~ and ~long~ parameters.

    - A few mathematical methods are in other classes.
      For example, there are methods
      ~compareUnsigned~,
      ~divideUnsigned~, and
      ~remainderUnsigned~ in the ~Integer~ and ~Long~ classes to
      _work with UNSIGNED values_.

    - As discussed in the preceding section, some users require strictly
      reproducible floating-point computations even if they are less efficient.
      The ~StrictMath~ class provides strict implementations of mathematical
      methods.

*** TODO 1.4.4 Number Type Conversions
    - important and details
      =TODO= =PAGE 37= 

    - ~Math.round~: If you want to round to the nearest integer instead.
      It returns a ~long~.

    - ~Math.toIntExact~: This alarms (throw an exception) you that a /cast/ can
      silently throw away important parts of a number if the number cannot
      convert a ~long~ to an ~int~.

*** 1.4.5 Relational and Logical Operators
    - _Caution_: =This help to avoid to shift to far away=
      The right-hand side argument of the shift operators is reduced
      + modulo 32 if the left hand side is an ~int~,
        or
      + modulo 64 if the left hand side is a ~long~.
      For example, the value of ~1 << 35~ is the same as ~1 << 3~ or ~8~.

    - _Tip_:
      The ~&~ (and) and ~|~ (or) operators, when applied to ~boolean~ values,
      _force evaluation of both operands before combining the results_.
      =NOT SHORT CIRCUIT ANY MORE=
      This usage is very uncommon:
      1. Provided that the right hand side doesn't have a side effect, they act
         just like ~&&~ and ~||~, except they are less efficient.

      2. If you really need to force evaluation of the second operand, assign it
         to a ~boolean~ variable so that the flow of execution is plainly visible.
         =avoid unwanted multiple side effects, if the rhs has side effect.=
         =this method will has one side effect=
         =if not this method, it might be multiple side effects. It depends on=
         =how many times the rhs is used.=

*** 1.4.6 Big Numbers
    - ~BigInteger~ and ~BigDecimal~ classes in the ~java.math~ package.
      _ARBITRARILY LONG SEQUENCE OF DIGITS_

    - Construct a ~BigInteger~ from a string of digits:
      1. Use the _static_ ~valueOf~ method turns a ~long~ into a ~BigInteger~:
         #+BEGIN_SRC java
         BigInteger n = BigInteger.valueOf(876543210123456789L);
         #+END_SRC

      2. from a string of digits:
         #+BEGIN_SRC java
         BigInteger k = new BigInteger("9876543210123456789"); 
         #+END_SRC

    - _Java does NOT permit the use of operators with objects_,
      so you must use method calls to work with big numbers.
      For example,
      #+BEGIN_SRC java
      BigInteger r = BigInteger.valueOf(5).multiply(n.add(k));
      #+END_SRC

    - ~BigDecimal.valueOf(n, e)~ returns a ~BigDecimal~ instance with value
      n\times10^-e
      For example,
      #+BEGIN_SRC java
      BigDecimal.valueOf(2, 0).substract(BigDecimal.valueOf(11, 1))
        // is exactly 0.9 in value.
      #+END_SRC

** 1.5 Strings 
   A string is a sequence of characters.
   In Java, a string can contain any Unicode characters (UTF-16).
*** DONE 1.5.1 Concatenation
    CLOSED: [2017-04-24 Mon 02:20]
    - When you concatenate a string with another value, that value is converted
      to a string. (=From Jian=: like scala implicit conversion?)

    - Don't mix concatenation and addition. At least, use parentheses properly
      group them.
      #+BEGIN_SRC java
      // expected result:
      // "Next year, you will be 43
      "Next year, you will be " + age + 1 // Error 
      "Next year, you will be " + (age + 1) // OK
      #+END_SRC

    - Combine several strings, separated with a delimiter, use the ~join~ method:
      #+BEGIN_SRC java
      String names = String.join(", ", "Peter", "Paul", "Mary");
        // Set names to "Peter, Paul, Mary"
      #+END_SRC
      1. The first argument is the separator string,
      2. followed by the strings you want to join.
         * There can be any number of them,
           or
         * you can supply an array of strings.

*** DONE 1.5.2 Substrings
    CLOSED: [2017-04-24 Mon 02:24]
    - ~substring~
      #+BEGIN_SRC java
      String greeting = "Hello, World!";
      String location = greeting.substring(7, 12); // Sets location to "World"
      #+END_SRC
    - ~split~
      #+BEGIN_SRC java
      // The separator is a literal
      String names = "Peter, Paul, Mary";
      String[] result = names.split(", ");
        // An array of three strings ["Peter", "Paul", "Mary"] 

      // The separator is a regular expression
      input.split("\\s+");
      #+END_SRC

*** DONE 1.5.3 String Comparison
    CLOSED: [2017-04-24 Mon 02:35]
    - ~equals~

    - ~==~:
      1. Don't use this in most of the time. This returns ~true~ only the lhs
         and rhs are the same object in memory.
      2. To test whether an object is ~null~, DO use ~==~.

    - When comparing a string _against a literal string_,
      it is a GOOD idea to _put the literal string first_:
      #+BEGIN_SRC java
      if (“World”.equals(location)) ///...
      #+END_SRC
      This test works correctly even when location is ~null~.

    - ~equalsIgnoreCase~

    - ~compareTo~ (use Unicode values)
      It returns the difference of Unicode values (can be negative).

    - The strings are compared _a character at a time_,
      until one of them _runs out of_ characters or a _mismatch_ is found.

    - _Tip_:
      When _sorting human-readable strings_,
      use a ~Collator~ object that knows about language-specific sorting rules.
      =TOD0= See Chapter 13 for more information.

*** DONE 1.5.4 Converting Between Numbers and Strings Variables
    CLOSED: [2017-04-24 Mon 14:42]
    - integer -> string. use static methods:
      + ~Integer.toString(n)~ (~\quot\quot + n~ can do the same thing, but it is ugly and
        slightly inefficient).
      + ~Integer.toString(n, radix)~, where the radix should be between 2 and 36.

    - string -> integer. use static methods:
      + ~Integer.parseInt(str);~
      + ~Integer.parseInt(str, radix);~

    - For floating-point numbers, use ~Double.toString~ and ~Double.parseDouble~

*** DONE 1.5.5 The String API
    CLOSED: [2017-04-24 Mon 14:51]
    - Table 1-4
      * group 1
        ~boolean startsWith(String str)~
        ~boolean endsWith(String str)~
        ~boolean contains(CharSequence str)~

      * group 2
        ~int indexOf(String str)~
        ~int lastIndexOf(String str)~
        ~int indexOf(String str, int fromIndex)~
        ~int lastIndexOf(String str, int fromIndex)~

      * group 3
        ~String toUpperCase()~
        ~String toLowerCase()~

      * group 4
        ~String trim()~

    - Java ~String~ class is /immutable/.

    - ~CharSequence~ is a common supertype of
      + ~String~
      + ~StringBuilder~

*** DONE 1.5.6 Code Points and Code Units
    CLOSED: [2017-04-24 Mon 15:20]
    - Nowadays, Unicode requires 21 bits.

    - Each valid Unicode value is called a /code point/.

    - Java suffers from having been born at the time between the transition from
      16 to 21 bits.
      One /code point/ contains one or two /code unit/.

    - Java strings are sequences of /code units/, the 16-bit quantities of the
      UTF-16 encoding.

    - If Chinese ideographs are not in your consideration, /code unit/ and
      /code point/ can be considered as the same thing.
      You can get
      + the ith character as ~char ch = str.charAt(i);~ and
      + the length of a string as ~int length = str.length();~

    - If you want to handle strings properly, you have to work harder.
      + The ith Unicode code point
        ~int codePoint = str.codePointAt(str.offsetByCodePoints(0, i));~
      + The total number of code point
        ~int length = str.codePointCount(0, str.length());~

    - Traverse a string (visit each code point in turn):
      + ~codePoints~ method yields a stream of ~int~ values. =TODO= =cHAPTER 8=

      + _FOR NOW_, just convert it to an array
        ~int[] codePoints = str.codePoints().toArray();~

      
** 1.6 Input and Output
*** 1.6.1 Reading Input
    - ~System.in~ object only has methods to read individual bytes.

    - To read strings and numbers, construct a ~Scanner~ that is attached to
      ~System.in~:
      =LOCATION= ~Scanner~ calss is located in the ~java.util~ package, which
                 ISN'T imported by default.
      #+BEGIN_SRC java
      Scanner in = new Scanner(System.in);

      // read a line of input.
      String name = in.nextLine();

      // read a word (delimited by whitespace)
      String firstName = in.next();

      // read an integer
      int age = in.nextInt();

      // read an floating-point number
      double height = in.nextDouble();
      #+END_SRC

    - Predicate methods used to check if there is another line, word, integer, or
      floating-point number available.
      + ~hasNextLine~
      + ~hasNext~
      + ~hasNextInt~
      + ~hasNextDouble~

    - _Tip_:
      The input through an ~Scanner~ object is visible. Use ~Console~ object to
      get things like password:
      #+BEGIN_SRC java
      Console terminal = System.console();
      String username = terminal.readLine("User name: ");
      char[] passwd = terminal.readPassword("Password: ");
      #+END_SRC
      The result passwd has a good feature due to its data type:
      ~char[]~ can be overwrite when you are done, while ~String~ (immutable) can
      be.

*** 1.6.2 Formatted Output
    - ~System.out.print(oneArg)~;

    - ~System.out.printf(formatString, ...);~

    - Table 1–5 Conversion Characters for Formatted Output

    - Table 1–6 Flags for Formatted Output

    - static method ~String.format(formatString, ...)~

** 1.7 Control Flow
*** 1.7.1 Branches
    - _Caution_:
      + -Xlint:fallthrough
        With the option ~-Xlint:fallthrough~, the compiler will issue a warning
        message whenever an alternative does not end with a ~break~ or ~return~
        statement.

      + If you acutally want to use the fallthrough behavior, tag the
        surrounding method with the annotation
        ~@SuppressWarnings("fallthrough")~.

    - The values of any of the following types can be used in Java ~switch~:
      + A constant expression of type ~char~, ~byte~, ~short~, or ~int~ (or their
        corresponding wrapper classes ~Character~, ~Byte~, ~Short~, and
        ~Integer~).

      + A string literal.

      + A value of an enumeration.

*** 1.7.2 Loops
*** 1.7.3 Breaking and Continuing
    - If you want to ~break~ to jump to the end of another enclosing statement
      (not the immediate one), use a _labeled_ ~break~ statement.
      Label the statement that should be exited, and provide the label with the
      ~break~ like this:
      #+BEGIN_SRC java
      outer:
      while (...) {
          ...
          while (...) {
            ...
            if (...) break outer;
            ...
          }
          ...
      }
      // Labeled break jumps here
      #+END_SRC
      The label can be any name.

    - _CAUTION_:
      You label the top of the statement, but the break statement jumps to the
      end.

    - A _regular_ ~break~ can only be used to exit a _loop_ or ~switch~
      A _labeled_ ~break~ can transfer control to the end of _any statement_,
      even _a block statement_:
      #+BEGIN_SRC java
      exit: {
          ...
          if (...) break exit;
          ...
      }
      // Labeled break jumps here
      #+END_SRC

    - There is also a _labeled_ ~continue~ statement that jumps to the next
      iteration of a labeled loop.

    - _Tip_
      ~break~ and ~continue~ statems are confusing in some cases.
      _We won't use them in this book._

*** 1.7.4 Local Variable Scope
    - In Java, you cannot have local variables with the same name in overlapping
      scopes.
** 1.8 Arrays and Array Lists
   - Built-in type: ~int[]~, ~String[]~, ...
   - ~ArrayList~ class for arrays that grow and shrink on demand.
   - =TODO=
*** 1.8.1 Working with Arrays
    - Declaration and initialization:
      #+BEGIN_SRC java
      String[] names1 = new String[100];
      
      // OR
      String[] names2;
      names2 = new String[100];
      #+END_SRC

    - Exception ~ArrayIndexOutOfBoundsException~

    - C style syntax is available, but FEW Java programmers use it.
      ~int numbers[];~
*** 1.8.2 Array Construction
    - When you construct an array with the ~new~ operator, it is
      _filled with a default value_.
      + Arrays of _numeric_ type
        (including ~char~, and _NOT_ including ~BigInteger~ whose instance is an
        object) are filled with _zeroes_.

      + Arrays of _boolean_ are filled with ~false~.

      + Arrays of _objects_ are filled with ~null~ references.

    - Another way to declare and initialize an array simutaneously:
      ~int[] primes = { 2, 3, 5, 7, 11, 13 };~

    - Assignment:
      ~primes = new int[] { 17 ,19, 23, 29, 31 };~

    - _Note_:
      0 length array: ~int[0]~ or ~new int[] {}~

*** 1.8.3 Array Lists
    - ~ArrayList~ class is in the ~java.util~ package.

    - An ~ArrayList~ object manages an array internally:
        When that array becomes too small or is insufficiently utilized, another
      internal array is automatically created, and the elements are moved into
      it.
        This process is invisible to the programmer using the array list.

    - Array lists are classes, and you use the normal syntax for constructing
      instances and invoking methods.

    - ~ArrayList~ class is a /generic class/.

    - Declaration:
      ~ArrayList<String> friends;~

      Initialization or assignment:
      ~friends = new ArrayList<>();~
      ~friends = new ArrayList<String>();~

    - empty ~<>~ is called /diamond syntax/.

    - Add elements to the end:
      ~friends.add("Peter");~

    - Add elements _before_ the given index:
      ~friends.add(0, "Peter");~

    - Unfortunately, there is _NO_ initializer syntax for array lists.

    - Remove elements:
      ~friends.remove(1);~

    - Use method calls to access elements, _NOT_ the ~[]~ syntax.
      #+BEGIN_SRC java
      String first = friends.get(0);
      friends.set(1, "Mary");
      #+END_SRC

    - ~size~ method of the array lists.
      =COMMENT= ~length~ is a property/field, _NOT_ a method.

*** 1.8.4 Wrapper Classes for Primitive Types
    - Java generic classes can't use /primitive types/ as type parameters.
      The remedy is to use /wrapper class/:
      + ~Integer~
      + ~Byte~
      + ~Short~
      + ~Long~
      + ~Character~
      + ~Float~
      + ~Double~
      + ~Boolean~

    - xxx

    - Conversion between primitive types and their corresponding wrapper types is
      _automatic_.

    - /autoboxing/, /unbox/
      #+BEGIN_SRC java
      ArrayList<Integer> numbers = new ArrayList<>();

      // autoboxing
      numbers.add(42);

      // (auto) unbox
      int first = numbers.get(0);
      #+END_SRC

    - ~==~ and ~!=~ compare object references, _NOT_ the contents of objects.
      Thus, remember to use ~equals~ method.
      For example,
      ~numbers.get(i) == numbers.get(j)~ doesn't NOT test whether the numbers at
      index =i= and =j= are the same. Should use ~equals~.

*** 1.8.5 The Enhanced for Loop
    - C style ~for~ loop

    - /enhanced/ ~for~ loop:
      #+BEGIN_SRC java
      int sum = 0;

      // Here `numbers` can be array or array list
      for (int n: numbers) {
          sum += n;
      }
      #+END_SRC

*** 1.8.6 Copying Arrays and Array Lists
    - For an /array/, use static method of copy ~Arrays.copyOf~:
      ~int[] copiedPrimes = Arrays.copyOf(primes, primes.length);~
 
    - For an /array list/:
      #+BEGIN_SRC java
      // Here `friends` is an array list
      ArrayList<String> copiedFriends = new ArrayList<>(friends);

      // Here `names` is an array
      String[] names = ...;
      ArrayList<String> friends = new ArrayList<>(Arrays.asList(names));
      ArrayList<String> friends = new ArrayList<>(Arrays.asList("Peter", "Paul",
                                                                "Mary"));
      #+END_SRC

    - Copy an array list into an array:
      ~String[] names = friends.toArray(new String[0]);~
      You _MUST_ supply an array of the correct type.

    - _NOTE_:
      There is _NO easy way_ to convert between
      primitive type arrays and the corresponding array lists of wrapper classes.
        For example, to convert between an ~int[]~ and an ~ArrayList<Integer>~,
      you need an _explicit loop_ or an ~IntStream~ (see Chapter 8). =TODO=

*** 1.8.7 Array Algorithms
    - /array/ realted:
      ~Arrays.fill(numbers, 0); // int[] array~
      ~Array.sort(names);~
      ~Array.toString(primes);~

    - (for array) ~parallelSort~ method that distributes the work over multiple
      processors if the array is large.

    - Fill an array list:
      ~Collections.fill(friends, ""); // ArrayList<String>~
      ~Collections.sort(friends);~
      ~friends.toString();~

      _NO_ counterpart for arrays.
      ~Collections.reverse(friends);~
      ~Collections.shuffle(friends);~

    - 
*** 1.8.8 Command-Line Arguments
    - Example: ~java Greeting -g cruel world~
      Here,
      + ~args[0]~ is "-g"
      + ~args[1]~ is "cruel"
      + ~args[2]~ is "world"

*** 1.8.9 Multidimensional Arrays
    - No true multidimensional arrays in Java, only arrays of arrays.
      #+BEGIN_SRC java
      int[][] square = {
          { 16, 3, 2, 13 },
          { 5, 10, 11, 8 },
          { 9, 6, 7, 12 },
          { 4, 15, 14, 1 }
      };
      #+END_SRC

    - There is _no requirement_ that the row arrays have equal length.
      ~int[][] triangleOfPascal = new int[n][];~

    - _Tip_:
      To print out a list of the elements of a two-dimensional array for
      debugging, call
      ~System.out.println(Arrays.deepToString(triangle));~

    - _Note_:
      _NO_ 2D array list,
      _BUT_
      1. you can delcare a variable of type ~ArrayList<ArrayList<Integer>>~
      2. build up the rows youself. ==

** 1.9 Functional Decomposition
*** 1.9.1 Declaring and Calling Static Methods
    #+BEGIN_SRC java
    class AverageOfTwoNumbers {
        public static double average(double x, double y) {
            double sum = x + y;
            return sum / 2;
        }

        public static void main(String[] args) {
            double a = 3.0;
            double b = 5.0;
            double result = average(a, b);
            // ...
        }
    }
    #+END_SRC

*** 1.9.2 Array Parameters and Return Values
    #+BEGIN_SRC java
    class XXX {
        // in place change
        public static void swap(int[] values, int i, int j) {
            int temp = values[i];
            values[i] = values[j]
            values[j] = temp;
        }

        // return an array (This is different from C, who can only use indirect
        // way (a pointer to an array) to return an array.)
        public static void swap(int[] values, int i, int j) {
            int temp = values[i];
            values[i] = values[j]
            values[j] = temp;
        }
    }
    #+END_SRC

*** 1.9.3 Variable Arguments
    - Declare a "varargs" parameter with ~...~ after the type:
      ~public static double average(double... values)~

        When the method is called, an array is created and filled with the argu-
      ments.
      _In the method body, you use it as you would any other array._

    - You can also pass an array directly as the "varargs" parameter, and this
      array is the "varargs" parameter it self, not the first element.

    - The variable parameter must be the last parameter of the method.
      =From Jian= This implies that only one variable parameter cant exist.

*** Exercises
    
* 2 OBJECT-ORIENTED PROGRAMMING
  The key points of this chapter are:
  1. _Mutator_ methods change the state of an object;
     _accessor_ methods don't.

  2. In Java, variables don't hold objects; they hold _references_ to objects.

  3. Instance variables and method implementations are declared inside the class
     declaration.

  4. An instance method is invoked on an object, which is accessible through the
     this reference.

  5. A constructor has the _SAME name as the class_. A class can have multiple
     (overloaded) constructors.

  6. Static variables DON'T belong to any objects.
     Static methods are NOT invoked on objects.

  7. Classes are organized into /packages/.
     Use ~import~ declarations so that you don't have to use the package name in
     your programs.

  8. Classes can be _nested_ in other classes.

  9. An /inner class/ is a _nonstatic_ nested class.
       Its instances have a reference to the object of the enclosing class that
     constructed it.

  10. The ~javadoc~ utility processes source files, producing HTML files with de-
      clarations and programmer-supplied comments.
      
** DONE 2.1 Working with Objects
   CLOSED: [2017-05-05 Fri 23:38]
   - ~LocalDate date = LocalDate.of(year, month, 1);~

   - ~date.plusDays(1);~ returns a newly constructed ~LocalDate~ object.

   - ~data.getMonthValue();~, ~data.getDayOfMonth();~

   - ~DayOfWeek weekday = date.getDayOfWeek();~

   - ~weekday.getValue();  // it returns an integer~
     1 for Monday, ..., and 7 for Sunday.

*** 2.1.1 Accessor and Mutator Methods
    - /mutator/ and /accessor/

    - all methods of the ~LocalDate~ class are /accessors/.

*** 2.1.2 Object References
    - In Java, a variable can ONLY hold a _reference_ to an object.

    - _Note_: =TODO= =???=

    - Be aware that it is possible to mutate a shared object through any of its
      references.
        However, if a class has no mutator methods (such as ~String~ or
      ~LocalDate~), you don't have to worry.

    - It is possible for an object variable to _refer to NO object_ at all, by
      setting it to the special value ~null~.

    - _Caution_
      Invoke a method on ~null~ causes a ~NullPointerException~ (which should
      really have been called a ~NullReferenceException~).

      For optional values, use ~Optional~ type.

** DONE 2.2 Implementing Classes
   CLOSED: [2017-05-06 Sat 10:01]
*** 2.2.1 Instance Variables
    - ~private~ variables: only methods of the same class can access them.
*** 2.2.2 Method Headers
    - ~private~ methods: only the other methods of the same class can access them
*** 2.2.3 Method Bodies
*** 2.2.4 Instance Method Invocations
*** 2.2.5 The ~this~ Reference
    - _Note_: =TODO=
      In some programming languages, instance variables are decorated in some
      way, for example ~\under{}name~ and ~\under{}salary~. This is legal in Java but is not
      commonly done.

    - _Note_:
      You CAN even declare ~this~ as a parameter of a method (but
      NOT a /constructor/)
      #+BEGIN_SRC java
      public void setSalary(Employee this, double salary) {
          this.salary = salary;
      }
      #+END_SRC
      =TODO= However, this syntax is very rarely used. It exists so that you can
      annotate the receiver of the method -- _See Chapter 11_. =TODO=

*** 2.2.6 Call by Value
** DONE 2.3 Object Construction
   CLOSED: [2017-05-07 Sun 00:39]
*** 2.3.1 Implementing Constructors
    - Declaring a constructor is similar to declaring a method.
      Same name as the class name.
      No return type.

    - ~public~ constructor
      #+BEGIN_SRC java
      public class Empoyee {
          public Employee(String name, double salary) {
              this.name = name;
              this.salary = salary;
          }

          // ...
      }
      #+END_SRC

    - ~private~ constructor: some methods call a private constructor.

    - If you accidentally specify a return type, then you declare a method.

    - The ~new~ operator returns a reference to the constructed object.
      You will normally
      + save that reference in a variable.
      + pass it to a method.

*** 2.3.2 Overloading
    There can be more than one version of a constructor.
*** 2.3.3 Calling One Constructor from Another
    #+BEGIN_SRC java
    public class Empoyee {
        public Employee(String name, double salary) {
            this.name = name;
            this.salary = salary;
        }

        public Employee(double salary) {
            this("", salary);
            // Other statements
        }
    }
    #+END_SRC
    Here, ~this~ is _NOT a reference to the object_ that is being constructed.
    Instead, it is a _special syntax_ that is only used for invoking another
    constructor of the same class.

*** 2.3.4 Default Initialization
    - If you don't set an instance variable explicitly in a constructor, it is
      automatically set to a _default value_:
      + numbers to ~0~
      + boolean values to ~false~ 
      + object references to ~null~

      For example,
      #+BEGIN_SRC java
      public class Employee {
          public Employee(String name) {
              // salary automatically set to zero
              this.name = name;
          }

          // ...
      }
      #+END_SRC

    - _Note_:
      In this regards,
      /instance variables/ are very different from /local variables/
      /local variables/ _MUST_ always be explicitly initialized.

    - This is not a good feature for object. It is the source of null pointer
      exception.

      For example, you have a constructor:
      #+BEGIN_SRC java
      public Employee(double salary) {
          // name automatically set to null
          this.salary = salary;
      }
      #+END_SRC
      When you call ~e.getName()~ (here ~e~ is an instance of ~Employee~), a null
      pointer exception will be raised.
      _SOLUTION_: The example of section 2.3.3

*** 2.3.5 Instance Variable Initialization
    - This initialization occurs
      + _AFTER_ the object has been allocated
      + _BEFORE_ a constructor runs.
      #+BEGIN_SRC java
      public class Employee {
          private String name = "";
          // ...
      }
      #+END_SRC

    - /initialization blocks/
      #+BEGIN_SRC java
      public class Employee() {
          private String name = "";
          private int id;
          private double salary;

          { // An initialization block
              Random generator = new Random();
              id = 1 + generator.nextInt(1_000_000);
          }

          public Employee(String name, double salary) {
              // ...
          }
      }
      #+END_SRC
      This is _NOT_ a commonly used feature. Most programmers place lengthy
      initialization code into a helper method and invoke that method from the
      constructors.

    - /Instance variable initializations/ and /initialization blocks/ are execut-
      ed
      + _in the order in which they appear_ in the class declaration
      + _BEFORE_ the body of the constructor.

*** 2.3.6 Final Instance Variables
    A ~final~ can't change the object it reference, though it can change the
    content of the object it points to.
*** 2.3.7 The Constructor with No Arguments
    - _Note_:
      If a class already has a constructor,
      it does NOT automatically get another constructor with no arguments.

      If you supply a constructor and also want a no-argument constructor,
      you have to write it yourself.

    - Due to the existence of garbage collector,
      Java has NO mechanism for "finalizing" an object when you don't need it
      (C++ has NO GC, and it requires this mechanism).

** DONE 2.4 Static Variables and Methods
   CLOSED: [2017-05-07 Sun 02:10]
*** DONE 2.4.1 Static Variables
    CLOSED: [2017-05-07 Sun 01:24]
    - A ~static~ variable means there is only one such variable per class.

    - A better name for the ~static~ variables should be /class variables/,
      though this is rarely used.

      Use ~static~ is a historical issue:
      + ~static~ of Java comes from C++
      + ~static~ of C++ comes from _an UNRELATED use_ in C

    - For example:
      #+BEGIN_SRC java
      public class Employee {
          private static int lastId = 0;
          private int id;

          public Employee() {
              lastId++;
              id = lastId;
          }
      }
      #+END_SRC

      =CAUTION= The class above doesn't work is its objects are constructed
      concurrently in multiple threads.
      _remedy this_: Chapter 10 =TODO=

*** DONE 2.4.2 Static Constants
    CLOSED: [2017-05-07 Sun 01:41]
    - _Mutable_ static variables are rare (but we have an example in the last
      section).
      statc constants (~static final~ variables) are quite common.

    - For example:
      #+BEGIN_SRC java
      public class Math {
          // ...
          public static final double PI = 3.14159265358979323846;
          // ...
      }
      #+END_SRC
      With this ~static~ keyword, you use ~Math~ class rather than its instance
      to access ~PI~.

    - Another thing you may want to share and can be ~final~ is a random number
      generator:
      + You don't want to waste resource to create one generator for each
        instance.
      + For the same reason, ~final~ is used to prevent the reference changing.

    - _Caution_ =TODO=
      Even though ~out~ is declared as ~final~ in the ~System~ class,
      there is a method ~setOut~ that sets ~System.out~ to a different stream.
      This method is a "native" method, _not implemented in Java_, which can
      bypass the access control mechanisms of the Java language.

      This is a very unusual situation from the early days of Java, and not
      something you are likely to encounter elsewhere.

*** DONE 2.4.3 Static Initialization Blocks
    CLOSED: [2017-05-07 Sun 01:24]
    #+BEGIN_SRC java
    public class CreditCardForm {
        private static final ArrayList<Integer> expirationYear = new ArrayList<>();
        static {
            // Add the next twenty years to the array list
            int year = LocalDate.now().getYear();
            for (int i = year; i <= year + 20; i++) {
                expirationYear.add(i);
            }
        }
        // ...
    }
    #+END_SRC

    - Static initialization occurs when the class is first loaded.

    - Like instance variables, static variables are ~0~, ~false~, or ~null~
      unless you explicitly set them to another value.

    - All /static variable initializations/ and /static initialization blocks/
      are executed _in the order in which they occur_ in the class declaration.

*** DONE 2.4.4 Static Methods
    CLOSED: [2017-05-07 Sun 02:01]
    - It is legal to invoke a static method on an object,
      but most java programmers would consider this poor style.

    - Since static methods DON'T operate on objects,
      + you _CANNOT_ access instance variables from a /static method/.

      However, /static methods/ can access the /static variables/ in their class.

*** DONE 2.4.5 Factory Methods
    CLOSED: [2017-05-07 Sun 02:10]
    - A common use for static methods is a factory method.

    - /factory method/: a static method that returns new instances of the class.

    - For example,
      #+BEGIN_SRC java
      NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
      NumberFormat percentFormatter = NumberFormat.getPercentInstance();
      double x = 0.1;
      System.out.println(currencyFormatter.format(x)); // Prints $0.10
      System.out.println(percentFormatter.format(x)); // Prints 10% 
      #+END_SRC

    - Q: Why not use a constructor instead?
      A: The ONLY way to distinguish two constructors is by their parameter
         types. You cannot have two constructors with no arguments.

    - _Moreover_
      + A /constructor/ ~new NumberFormat(...)~ yields a ~NumberFormat~.
      + A /factory method/ can return an object of a _subclass_.
        In fact, these /factory methods/ return _instances of_ the
        ~DecimalFormat~ class.

    - A factory method can also return a /shared object/, instead of
      unnecessarily constructing new ones.
        For example, the call ~Collections.emptyList()~ returns a shared
      immutable empty list.

** DONE 2.5 Packages
   CLOSED: [2017-05-08 Mon 15:09]
*** 2.5.1 Package Declarations
    - A package name: a dot-separated list of identifiers (e.g.
      ~java.util.regex~).

    - To guarantee unique package names, it is a good idea to use an Internet
      domain name (which is known to be unique) written in reverse.
        A major exception to this rule is the standard Java library whose package
      names start with ~java~ or ~javax~.

    - _Note_:
      _In Java, packages do not nest._
      For example, ~java.util~ and ~java.util.regex~ have nothing to do with each
      other.

    - Put a class into a package:
      #+BEGIN_SRC java
      package com.horstmann.corejava;

      public class Employee {
          // ...
      } 
      #+END_SRC
      Then, ~Empolyee~ can be use with /fully qualified name/
      ~com.horstmann.corejava.Employee~

    - /default package/: if no package is specified, your program is put into the
      /default package/. This use is not recommended.

    - When class files are read from a file system, the path name needs to match
      the package name.

      For example, if the right /fully qualified name/ is
      ~com.horstmann.corejava.Employee~, the file ~Employee.class~ must be in a
      subdirectory ~com/horstmann/corejava~.

    - If
      + you arrange the source files in the same way as their package structure
        and
      + compile from the directory that contains the initial package names, then
        the class files are automatically put in the correct place.

      For example,
      Suppose the ~EmployeeDemo~ class makes use of ~Employee~ objects, and you
      compile it as
      #+BEGIN_SRC bash
      javac com/horstmann/corejava/EmployeeDemo.java
      #+END_SRC
      The compiler generates class files
      + ~com/horstmann/corejava/EmployeeDemo.class~
      + ~com/horstmann/corejava/Employee.class~.

      You run the program by specifying the fully qualified class name:
      #+BEGIN_SRC bash
      java com.horstmann.corejava.EmployeeDemo
      #+END_SRC

    - _Caution_:
      If a source file is not in a subdirectory that matches its package name,
      the ~javac~ compiler will _NOT_ complain and generate a class file,
      BUT you will need to put it in the right place.
      =TODO= This can be quite confusing -- see Exercise 12.

    - _Tip_: =TODO= =Try=
      It is a good idea to run ~javac~ with the ~-d~ option.
      Then the class files are generated in a separate directory, without
      cluttering up the source tree, and they have the correct subdirectory
      structure.

*** 2.5.2 The Class Path
    - Place class files into a JAR files, rather than scattering and storing them
      in the file system.

    - ~jar~ utility is a part of the JDK.
      It command-line options are similar to those of the Unix ~tar~ program.
      For example, ~jar cvf library.jar com/mycompany/*.class~

    - _Note_:
      JAR files can actually be in two formats:
      + ZIP format (default)
      + "pack200", which is designed to compress class files more efficient.

    - ~jar~ is commonly used with package libraries, but
      it can also package a program. For example,
      #+BEGIN_SRC bash
      jar cvfe program.jar com.mycompany.MainClass com/mycompany/*.class

      # run it
      java -jar program.jar
      #+END_SRC

    - /class path/: A class path can contain
      + Directories containing class files (in subdirectories that match their
        package names)
      + JAR files
      + Directories containing JAR files

    - When you use library JAR files in a project, you need to tell the compiler
      and the virtual machine where these files are by specifying the
      /class path/.

    - The ~javac~ and ~java~ programs have an option ~-classpath~, which you can
      abbreviate to ~-cp~. For example
      #+BEGIN_SRC bash
      java -classpath .:../libs/lib1.jar:../libs/lib2.jar com.mycompany.MainClass
      #+END_SRC

    - Use wildcard to specify many JAR files in a directory:
      #+BEGIN_SRC bash
      java -cp .:../libs/\* com.mycompany.MainClass
      # Here * is escaped.
      # If no backslash here, Unix shell will intercept it, use it, and no
      # wildcard will be passed to `java` command.
      #+END_SRC

    - ~javac~ always looks for files in the current directory.

      ~java~ ONLY looks into the current directory when ~.~ is explicitly given
      through /class path/.

    - ~CLASSPATH~ enviroment variable.
      The details depend on your shell.
      #+BEGIN_SRC bash
      export CLASSPATH=.:/home/username/project/libs/\*
      #+END_SRC

      #+BEGIN_SRC powershell
      SET CLASSPATH=.;C:\Users\/username\project\libs\*
      #+END_SRC

    - _Caution_: This is truly bad advice!!!
      Some people suggests put all JAR files into the ~jre/lib/ext~ directory.

      + Code that manually loads classes does not work correctly when placed in
        the extension directory.

      + Foroget there are libraries in the ~jre/lib/ext~ directory.

*** 2.5.3 Package Scope
    - If you don't specify either ~public~ or ~private~, the feature (that is,
      the /class/, /method/, or /variable/)
      _can be accessed by all methods in the SAME package._

    - _Note_: One package can contain multiple classes.
      1. At most one can be a ~public~ class.
      2. If this /public class/ does exist, the name of the source file must
         match the /public class/ name.

    - ~ClassLoader~ =TODO= =???=

    - The Java implementors protect themselves from such an attack by rigging the
      ~ClassLoader~ class so it will NOT load any class whose fully qualified name
      starts with ~java~. =TODO= =???=

    - /manifest/: a plain text file containing entries
      #+BEGIN_SRC txt
      Name: com/mycompany/util/
      Sealed: true
      Name: com/mycompany/misc/
      Sealed: true
      #+END_SRC

    - /sealed JAR/: provide a /manifest/ and run the ~jar~ command like this:
      ~jar cvfm library.jar manifest.txt com/mycompany/*/*.class~

*** 2.5.4 Importing Classes
    - Import all classes from a package with a wildcard:
      ~import java.util.*;~

    - Wildcard can only import classes, not packages.
      You can't do ~import java.*;~

    - Compiler will complains when there are name conflictions when use ~import~.
      For example,
      #+BEGIN_SRC java
      import java.util.*;
      import java.sql.*;
      // They both have `Date` class
      #+END_SRC

      You can import the specific class that you want to solve this:
      #+BEGIN_SRC java
      import java.util.*;
      import java.sql.*;
      import java.sql.Date;
      #+END_SRC

    - Inside .class files, all class names are fully qualified.
      This means the quanlifiers are added when compile.

    - ~import~ is like the ~using~ in C++ (imports do NOT cause files to be
      recompiled).

      It doesn't like the ~#include~ in C,

*** 2.5.5 Static Imports
    - Only _import_ /static methods and variables/:
      + All: ~import static java.lang.Math.*;~
      + A specific: ~import static java.lang.Math.PI;~

    - _Note_: ~java.util.Comparator~ and ~java.util.strea.Collections~ have
      a lot of static things.

    - _Caution_:
      You CANNOT import static methods of fields from a class in the default
      package.
** 2.6 Nested Classes
   - /nested class/: a class inside another class.

   - WHY Useful:
     + restrict visibility

     + avoid cluttering up a package with generic names such as =Element=,
       =Node=, or =Item=.

   - Java has _TWO_ kinds of nested classes, with somewhat different behavior.
     =TODO= =???= 

*** 2.6.1 Static Nested Classes
    - CASE 1 ::
                #+BEGIN_SRC java
                  public class Invoice {
                      // See next section for the reason of `static` here
                      private static class Item { // `Item` is nested inside `Invoice`
                          String description;
                          int quantity;
                          double unitPrice;
                          double price() { return quantity * unitPrice; }
                      }
                      private ArrayList<Item> items = new ArrayList<>();
                      // ...
                  }
                #+END_SRC

      + Here ~Item~ is private for ~Invoice~, so only ~Invoice~ methods can
        access it. For that reason, I did not bother making the instance
        variables of the inner class private. =IMPORTANT=

      + An example of a method that constructs an object of the inner class:
        #+BEGIN_SRC java
          public class Invoice {
              // ...
              public void addItem(String description, int quantity,
                                  double unitPrice) {
                  Item newItem = new Item();
                  newItem.description = description;
                  newItem.quantity = quantity;
                  newItem.unitPrice = unitPrice;
                  items.add(newItem);
              }
          }
        #+END_SRC

    - CASE 2 ::
                A class can make a nested class public. In that case, one would
                want to use the usual encapsulation mechanism.
                #+BEGIN_SRC java
                  public class Invoice {
                      public static class Item { // A public nested class
                          private String description;
                          private int quantity;
                          private double unitPrice;
                          public Item(String description, int quantity, double unitPrice) {
                              this.description = description;
                              this.quantity = quantity;
                              this.unitPrice = unitPrice;
                          }
                          public double price() { return quantity * unitPrice; }
                          // ...
                      }

                      private ArrayList<Item> items = new ArrayList<>();

                      public void add(Item item) { items.add(item); }
                      // ...
                  }
                #+END_SRC
      + In this case, anyone can construct ~Item~ objects by using the
        qualified name ~Invoice.Item~. For example,
        #+BEGIN_SRC java
        Invoice.Item newItem = new Invoice.Item("Blackwell Toaster", 2, 19.95);
        myInvoice.add(newItem);
        #+END_SRC

      + There is essentially _NO DIFFERENCE_ between this ~Invoice.Item~ class
        and a class ~InvoiceItem~ declared outside any other class.
          Nesting the class just makes it obvious that the ~Item~ class
        represents items in an invoice.

*** 2.6.2 Inner Classes
    - /inner classes/: non-static nested classes.

    - Example:
      A social network in which each member has friends that are also members.
      #+BEGIN_SRC java
        public class Network {
            public class Member { // Member is an inner class of Network
                private String name;
                private ArrayList<Member> friends;
                public Member(String name) {
                    this.name = name;
                    friends = new ArrayList<>();
                }

                // ...
            }
            private ArrayList<Member> members;
            // ...
        }
      #+END_SRC

      + With the ~static~ modifier dropped, a ~Member~ object knows to which
        network it blongs

      + Define a method to add a member
        #+BEGIN_SRC java
          public class Network {
              // ...
              public Member enroll(String name) {
                  Member newMember = new Member(name);
                  members.add(newMember);
                  return newMember;
              }
          }
        #+END_SRC

      + When add a member, you can get a reference to it.
        #+BEGIN_SRC java
        Network myFace = new Network();
        Network.Member fred = myFace.enroll("Fred");
        #+END_SRC

      + Define a method to leave a network.
        #+BEGIN_SRC java
          public class Network {
              public class Member {
                  // ...
                      public void leave() {
                      members.remove(this);
                      // The inner class is accessing the instance variables of
                      // the outer class object that created it.
                  }
              }
              private ArrayList<Member> members;
              // ...
          }

          fred.leave();
        #+END_SRC

        The inner class is accessing the instance variables of the outer class
        object that created it.

      + The inner class can also invoke methods of the outer class through its
        outer class instance.

        Define a method to unenroll a member.
        #+BEGIN_SRC java
          public class Network {
              public class Member {
                  // ...
                  public void leave() {
                      unenroll(this);
                  }
              }

              private ArrayList<Member> members;

              public Member enroll(String name) { // ... }
              public void unenroll(Member m) { // ... }
              // ...
          }
        #+END_SRC
        ~unenroll(this);~ in this case is actually means
        ~outer.unenroll(this);~ (not a legal syntax, just illustration).

*** 2.6.3 Special Syntax Rules for Inner Classes
    - ~OuterClass.this~ denotes the outer class reference.

    - For example,
      #+BEGIN_SRC java
      public void leave() {
          Network.this.members.remove(this);
      }
      #+END_SRC
      Here, the ~Network.this~ is redundant.

    - Sometimes you may need the outer class reference explicitly:
      #+BEGIN_SRC java
      public class Network {
          public class Member {
              // ...
              public boolean belongsTo(Network n) {
                  return Network.this == n;
              }
          }
      }
      #+END_SRC

    - When you construct an inner class object, it remembers the enclosing class
      object that constructed it. In the preceding section, a new member was
      created by this method:
      #+BEGIN_SRC java
      public class Network {
          // ...
          Member enroll(String name) {
              Member newMember = new Member(name);
              // That is a shortcut for
              // Member newMember = this.new Member(name);

              // ...
          }
      }
      #+END_SRC

    - You can invoke an inner class constructor on any instance of an outer class:
      ~Network.Member wilma = myFace.new Member("Wilma");~

    - _NOTE_: =TODO=
      _Inner classes CANNOT declare static members other than compile-time constants._

      An ambiguity about the meaning of _static_.
      1. Does it mean there is only one instance in the virtual machine?
         Or
      2. only one instance per outer object?

      _The language designers decided not to tackle this issue._

    - _NOTE_: =TODO=
      By historical accident, inner classes were added to the Java language at a
      time when the virtual machine specification was considered complete, so
      they are translated into regular classes with a hidden instance variable
      referring to the enclosing instance.
      =TODO=
      _Exercise 14 invites you to explore this translation_

    - _NOTE_: =TODO=
      /Local classes/ are another variant of inner classes that we will discuss
      in Chapter 3.

** DONE 2.7 Documentation Comments
   CLOSED: [2017-05-12 Fri 15:55]
   - ~javadoc~: a tool from JDK used to generates HTML documentation from your
     source files.

   - The online AP documentation is simply the result of running ~javadoc~ on
     the source code of the standard Java library.

   - ~javadoc~ realted comments start with the special delimiter ~/**~.

*** 2.7.1 Comment Insertion
    - The ~javadoc~ utility extracts information for the following items:
      + Packages
      + Public classes and interfaces
      + Public and protected variables
      + Public and protected constructors and methods
      =TODO= See Chapter 4 for /protected features/

    - Comment starts with ~/**~ and ends with ~*/~.
      This kind of comment contains free-form text followed by /tags/.

    - /tag/: text starts with an =@=, such as =@author= or =@param=

    - _The first sentence of the free-form text should be a summary statement._

      The ~javadoc~ utility automatically generates summary pages that extract
      these sentences.

    - Use the HTML tag in the free form text is OK.

      Stay away from heading ~<h1>~, ~<h2>~, ..., ~<hn>~ or rules ~<hr>~, which
      can interfere with the formatting of the documentation.

    - _NOTE_:
      If your comments contain links to other files such as images (for example,
      diagrams or images of user interface components), place those files into a
      subdirectory of the directory containing the source file, named =doc-files=.
      The ~javadoc~ utility will copy the =doc-files= directories and their contents
      from the source directory to the documentation directory. You need to
      specify the =doc-files= directory in your link, for example
      ~<img src="doc-files/uml.png" alt="UML diagram"/>~.

*** 2.7.2 Class Comments
    - The class comment _MUST_ be placed directly _before_ the class declaration.

    - Exmaple:
      #+BEGIN_SRC java
      /**
       * An <code>Invoice</code> object represents an invoice with
       * line items for each part of the order.
       * @author Fred Flintstone
       * @author Barney Rubble
       * @version 1.1
       */
      public class Invoice {
          // ...
      }
      #+END_SRC

    - _NOTE_:
      There is NO need to put a * in front of every line. However, most IDEs
      supply the asterisks automatically, and some even rearrange them when the
      line breaks change.

*** 2.7.3 Method Comments
    - Place each method comment immediately before its method.
      Document the following features:
      + Each parameter, with a comment =@param= /variable description/.

      + The return value, if not ~void~: =@return= /description/.

      + Any thrown exceptions (See Chapter 5): =@throws=
        /exceptionClass description/.

    - Example:
      #+BEGIN_SRC java
      /** Raises the salary of an employee.
       * @param byPercent the percentage by which to raise the salary (e.g., 10 means 10%)
       * @return the amount of the raise
       */
      public double raiseSalary(double byPercent) {
          double raise = salary * byPercent / 100;
          salary += raise;
          return raise;
      }
      #+END_SRC

*** 2.7.4 Variable Comments
    - You only need to document public variables -- generally that means
      /static constants/. For example,
      #+BEGIN_SRC java
      /**
       * The number of days per year on Earth (excepting leap years)
       */
      public static final int DAYS_PER_YEAR = 365;
      #+END_SRC
*** 2.7.5 General Comments
    - =@since=: describe the version in which this feature became available.
      ~@since version 1.7.1~

    - =@deprecated=: describe deprecated features, and suggest a replacement.
      For example,
      ~@deprecated Use <code>setVisible(true)</code> instead~

    - _NOTE_:
      There is also a ~@Deprecated~ annotation that compilers use to issue
      warnings when deprecated itmes are used. =TODO= See Chapter 11.

      The annotation does not have a mechanism for suggesting a replacement,
      so you _should supply both the annotation and the Javadoc comment for
      deprecated items_.

*** 2.7.6 Links
    - Add hyperlinks or external documents with =@see= and =@link= tags.

    - =@see=:
      + package.class#feature label
        For example:
        ~@see com.horstmann.corejava.Employee#raiseSalary(double)~

        If omit the the package name, or both the package and class name, the
        feature will be located in the current package or class.

      + <a href="...">label</a>
        If =@see= is followed by a =<= character, you're specifying a hyperlink.
        For example，
        ~@see <a href="http://en.wikipedia.org/wiki/Leap_year">Leap years</a>~

      + "text"
        If the =@see= tag is followed by a ~"~ character, the text in quotes is
        displayed _in the "see also" section_. For example:
        ~@see "Core Java for the Impatient"~

        =comment= Multiple =@see= tags can be added for one feature, but they
                  must be put together.

    - =@link=:
      hyperlinks to other classes or methods anywhere in any of your
      documentation comments. Insert a tag of the form
      ~{@link package.class#feature label}~ anywhere in a comment.
      The feature description follows the same rules as for the =@see= tag.

*** 2.7.7 Package and Overview Comments
    - To generate package comments, a separate file in each package directory
      should be added.

      Supply a Java file named =package-info.java=. The file must contain:
      + an initial javadoc comment, delimited with ~/**~ and ~*/~
      + followed by a package statement.

      _REQUIREMENT:_ NO further code or comments.

    - An /overview comment/ for all source files:
      + requirement:
        * name: =overview.html=
        * location: the parent directory that contains all the source files.

      + All text between the tags =<body>= and =</body>= is extracted.
        This comment is displayed when the user select "Overview" from the
        navigation bar.

*** 2.7.8 Comment Extraction
    - Suppose =docDirectory= is where you want the HTML files to go.
      For these steps:
      1. go to the directory the same as that of =overview.html=, if you supplied
         one.
      2. ~javadoc -d docDirectory package1 package2 ...~
         If without ~-d docDirectory~ the HTML files are extracted to the current
         directory. That can get messy, not recommended.

    - Use ~-author~ and ~-version~ options to include the =@author= and
      =@version= tagsin the documentation (they are by default omitted).

    - Use ~-link~  option to include hyperlinks to standard classes. For example,
      run ~javadoc -link http://docs.oracle.com/javase/8/docs/api *.java~, and
      all standard library classes are automatically linked ot the documentation
      on the Oracle web site.

    - Use ~-linksource~ option, each source file is converted to HTML, and each
      class and method name turns into a hyperlink to the source.

** TODO Exercises
* TODO 3 INTERFACES AND LAMBDA EXPRESSIONS - PAGE 107 ~ 138
  The key points of this chapter are:
  - An interface specifies a set of methods that an implementing class must
    provide.

  - An interface is a supertype of any class that implements it. Therefore, one
    can assign instances of the class to variables of the interface type.

  - An interface can contain static methods. All variables of an interface are
    automatically static and final.

  - An interface can contain default methods that an implementing class can
    inherit or override.
 
  - The ~Comparable~ and ~Comparator~ interfaces are used for comparing objects.

  - A lambda expression denotes a block of code that can be executed at a later
    point in time.

  - Lambda expressions are converted to functional interfaces.

  - Method and constructor references refer to methods or constructors without
    invoking them.

  - Lambda expressions and local inner classes can access effectively final
    variables from the enclosing scope

** DONE 3.1 Interfaces
   CLOSED: [2017-05-11 Thu 15:07]
*** 3.1.1 Declaring an Interface
    - Consider a service that works on sequences of integers, reporting the
      _average_ of the first ~n~ values:
      ~public static double average(IntSequence seq, int n)~
      The sequence here can take many forms. Here are some examples:
      + A sequence of integers supplied by a user
      + A sequence of random integers
      + The sequence of prime numbers
      + The sequence of elements in an integer array
      + The sequence of code points in a string
      + The sequence of digits in a number

    - We want to implement a single mechanism for dealing with all these kinds of
      sequences.
      Find out what is common between integer sequences. At a minimum:
      + Test whether there is a next element
      + Get the next element

      #+BEGIN_SRC java
      public interface Instance {
          boolean hasNext();
          int next();
      }
      #+END_SRC
      You need not implement these methods,
      but you can provide default implementations if you like -- see Section
      3.2.2, “Default Methods,” on p. 100. =TODO=

      If NO implementation is provided, we say that the method is /abstract/.

    - _Note_: =IMPORTANT=
      All methods of an interface are automatically ~public~.

      Some programmers do it anyway (explicitly provide ~public~) for greater
      clarity.

    - The methods in the interface sufficie to implement the ~average~ method:
      #+BEGIN_SRC java
      public static double average(IntSequence seq, int n) {
          int count = 0;
          double sum = 0;
          while (seq.hasNext() && count < n) {
              count++;
              sum += seq.next();
          }
          return count == 0 ? 0 : sum / count;
      }
      #+END_SRC

*** 3.1.2 Implementing an Interface
    - The classes want to be usable with the ~average~ method need to implement
      the ~IntSequence~ interface. Here is a example of a infinitely many
      squares:
      #+BEGIN_SRC java
      public class SequareSequence implements IntSequence {
          private int i;

          public boolean hasNext() {
              return true;
          }

          public int next() {
              i++;
              return i * i;
          }
      }
      #+END_SRC

    - _Caution_:
      The implementing class _MUST_ declare the methods of the interface as
      ~public~.

      Otherwise, they would default to package access. Since the interface
      requires public access, the compiler would report an error.

    - Another example:
      #+BEGIN_SRC java
      public class DigitSequence implements IntSequence {
          private int number;

          public DigitSequence(int n) {
              number = n;
          }

          public boolean hasNext() {
              return number != 0;
          }

          public int next() {
              int result = number % 10;
              number /= 10;
              return result;
          }

          public int rest() {
              return number;
          }
      } 
      #+END_SRC

    - _Note_:
      /abstract class/: If a class only implements some of the methods, then
      it must be declared with the /abstract/ modifier.
      See Chapter 4. =TODO=

*** 3.1.3 Converting to an Interface Type
    - /subtype/ and /supertype/

    - _Note_:
      + It is possible to declare variables of an interface type
      + you can never have an object whose type is an interface.
        All objects are instances of classes.

*** 3.1.4 Casts and the instanceof Operator
    - /cast/

    - Example of cast:
      #+BEGIN_SRC java
      IntSequence sequence = ...;
      DigitSequence digits = (DigitSequence) sequence;
      System.out.println(digits.rest());
      #+END_SRC
      This is necessary because ~rest~ is a method of ~DigitSequence~ but not
      ~IntSequence~.

    - ~isinstanceof~ operator

    - 

*** 3.1.5 Extending Interfaces
    - An instance can /extend/ another.
*** 3.1.6 Implementing Multiple Interfaces
    - A class can implement any number of interfaces.
*** 3.1.7 Constants
    - Any variable defined in an interface is automatically
      ~public static final~.

    - _Note_: =IMPORTANT=
      You cannot have instance variables in an interface.
      _An interface specifies behavior, not object state._

** DONE 3.2 Static and Default Methods
   CLOSED: [2017-05-11 Thu 15:07]
   In earlier versions of Java, _ALL methods of an interface_ had to be
   /abstract/

   Nowadays you can add two kinds of methods with a concrete implementation:
   + static methods
   + default methods
*** 3.2.1 Static Methods
    - (In earlier version of Java)
      There was never a technical reason why an interface could not have static
      methods,
      but they did not fit into the view of interfaces as abstract specifications.
      =From Jian= I think this is why scala use /trait/ rather than /interface/.

    - Factory methods make a lot of sense in interfaces.

    - Example:
      #+BEGIN_SRC java
      public interface IntSequence {
          // ...
          public static IntSequence digitsOf(int n) {
              return new DigitSequence(n);
          }
      }
      #+END_SRC

    - _Note\under{}(history):
      In the past, it had been common to place static methods in a companion
      class, and you can find pairs of interfaces and utility classes, such as
      ~Collection/Collections~ or ~Path/Paths~, in the standard library.

      _This split is no longer necessary._

*** 3.2.2 Default Methods
    - Example:
      #+BEGIN_SRC java
      public interface IntSequence {
          default boolean hasNext() { return true; }

          int next();
      }
      #+END_SRC
      Here the ~default~ is required.

    - _Note (history)_:
      Again, an interface and a companion class that implements most or all of
      its methods, such as ~Collection/AbstractCollection~ or
      ~WindowListener/WindowAdapter~ in the Java API.

      _Nowadays just implement the methods in the interface_

    - Default method is important for /interface evolution/.
      For example,
      Suppose we provided a class ~public class Bag implements Collectoin~
      In Java 8, a ~stream~ method was added to the interface.
      + Case 1 :: a non-default method to an interface is not
                  /source-compatible/, _we must add a default method ~stream~ to
                  the interface_

      + Case 2 :: use the old JAR (include ~Bag~ class), an ~AbstractMethodError~
                  will triggered when a ~Bag~ instance use the ~stream~ method.
                    However, _add a default method ~stream~ to the interface_
                  (which is /binary-compatible/) can solve this:
                    Since the old JAR includes ~Bag~ is reused without change, no
                  ~Bag.stream~ method can be found, but ~Collection.stream~ now
                  can be used. 

*** 3.2.3 Resolving Default Method Conflicts
    - Example:
      #+BEGIN_SRC java
      public interface Person {
          String getName();
          default int getId() { return 0; }
      }
      

      public interface Identified {
          default int getId() { return Math.abs(hashCode()); }
      }
      

      public class Employee implements Person, Identified {
          public int getId() { return Identified.super.getId(); }
          // TODO: Why DO NOT use Identified.getId();

          // ...
      }
      #+END_SRC

    - Q: If one interface only has /abstract/ ~getId~, should the compiler pick
         the other (/default/) ~getId~?
      A: This might seem reasonable, but it's actually not:
           The class may expect some logic from the interface ~Identified~,
         rather than from ~Person~ (for instance, suppose identified id's are
         always real ), though this time something unexpected happens
         and no /default/ ~getId~ are created insdie ~Identified~.

    - If a class extends a superclass and implements an interface inheriting the
      same method for both, the rules are easier:
      + only use the superclass method, and
      + any default method from the interface is simply ignored.

** DONE 3.3 Examples of Interfaces
   CLOSED: [2017-05-12 Fri 00:41]
*** 3.3.1 The ~Comparable~ Interface
    - If a class wants to enable sorting for its objects, it should implement the
      ~Comparable~ interface.
      #+BEGIN_SRC java
      public interface Comparable<T> {
          int compareTo(T other);
      }
      #+END_SRC

    - /generic type/: A type with a type parameter such as ~Comparable~ or
      ~ArrayList~.

    - For objects that implement ~Comparable~, ~x.compareTo(y)~ returns
      + a positive value
      + 0
      + a negative value

    - For example:
      #+BEGIN_SRC java
      public class Employee implements Comparable<Employee> {
          // ...
          public int compareTo(Employee other) {
              return getId() - other.getId();
              // Ok if IDs always ≥ 0
          }
      }
      #+END_SRC

    - _Caution_: =TODO= =PAGE-117=
      Returning a difference of integers _does not work_ if the integers can be
      negative. Then the difference can overflow for large operands of opposite
      sign.
        In that case, use the ~Integer.compare~ method that works correctly for
      all integers. =???=

    - Compare floating-point values, you cannot just return the difference.
      Use static ~Double.compare~ method. It does right thing, even for +-\infty and
      NaN.
      #+BEGIN_SRC java
      public class Employee implements Comparable<Employee> {
          // ...
          public int compareTo(Employee other) {
              return Double.compare(salary, other.salary);
          }
      } 
      #+END_SRC

    - _Note_:
      In Java, a method can access private features of any object of its class.

    - Use ~Array.sort~ method to sort an array of ~Comparable~ objects:
      #+BEGIN_SRC java
      String[] friends = { "Peter", "Paul", "Mary" };
      Arrays.sort(friends);  // friends is now ["Mary", "Paul", "Peter"] 
      #+END_SRC

    - _Note_:
      Strangely, the ~Arrays.sort~ method does NOT check _at compile time_
      whether the argument is an array of ~Comparable~ objects.

      Instead, it throws an exception if it encounters an element of a class
      that doesn't implement the ~Comparable~ interface.

*** 3.3.2 The ~Comparator~ Interface
    - A second version of the ~Arrays.sort~ method whose parameters are an array
      and a /comparator/.

    - /comparator/: an instance of a class that implements the ~Comparator~
      interface.
      #+BEGIN_SRC java
      public interface Comparator<T> {
          int compare(T first, T second);
      }
      #+END_SRC

    - To compare strings by length, define a class that implements
      ~Comparator<String>~:
      #+BEGIN_SRC java
      class LengthComparator implements Comparator<String> {
          public int compare(String first, String second) {
              return first.length() - second.length();
          }
      }

      Comparator<String> comp = new LengthComparator();

      if (comp.compare(words[i], words[j]) > 0) ...
      #+END_SRC
      It's clear that here the ~compare~ method is called on the comparator
      object, _NOT_ the string itself.
      (This is different from the ~compareTo~ method from a comparable instance:
       If applicable it should be in the form of ~word[i].compareTo(words[j])~).

    - _Note_:
      Even though the ~LengthComparator~ object has no state, you still need to
      make an instance of it. ~compare~ is NOT a static method.

    - Application:
      #+BEGIN_SRC java
      String[] friends = { "Peter", "Paul", "Mary" };
      Arrays.sort(friends, new LengthComparator());
      #+END_SRC

    - =TODO= See Section 3.4.2 "Functional Interfaces".

*** 3.3.3 The ~Runnable~ Interface
    - You may want to run certain tasks in a separate thread, or give them to a
      thread pool for execution.
        To define the task, you implement the ~Runnable~ interface. It has just
      ONE method. For example,
      #+BEGIN_SRC java
      class HelloTask implements Runnable {
          public void run() {
              for (int i = 0; i < 1000; ++i) {
                  System.out.println("Hello, World!");
              }
          }
      }

      Runnable task = new HelloTask();
      Thread thread = new Thread(task);
      thread.start();
     #+END_SRC
     Now the ~run~ (typo??? ~start~ ???) method executes in a separate thread,
     and the current thread can proceed with other work.

    - _Note_: =TODO=
      See Chapter 10, other ways of executing a ~Runnable~.

    - There is also a ~Callable<T>~ interface for tasks that return a result of
      type ~T~.

*** 3.3.4 User Interface Callbacks
    - /call back/

    - In Java-based GUI libraries, interfaces are used for callbacks.

    - Example:
      #+BEGIN_SRC java
      public interface EventHandler<T> {
          void handle(T event);
      }

      class CancelAction implements EventHandler<ActionEvent> {
          public void handle(ActionEvent event) {
              System.out.println("Oh noes!");
          }
      }

      Button cancelButton = new Button("Cancel");
      cancelButton.setOnAction(new CancelAction());
      #+END_SRC

    - This is tedious. In other language, you just provide a function to the
      ~secOnAction~ method, without going through the detour of making a class
      and instantiating it. =TODO= The next section shows how you can do the same
      in Java.

** DONE 3.4 Lambda Expressions
   CLOSED: [2017-05-11 Thu 15:50]
   - /lambda expression/: a block of code that you can pass around so it can be
     executed later.

   - Java is a language of (almost) pure object-oriented, and there is no
     function types in Java (/function types/: for example, the arrow types in
     Scala).

     _ESSENSE_: Instead, functions are expressed as objects, instances of classes
                that implement a particular interface.
                  Lambda expressions give you a convenient syntax for creating
                such instances. =TODO=

*** DONE 3.4.1 The Syntax of Lambda Expressions
    CLOSED: [2017-05-11 Thu 15:35]
    - Lambda expressions:
      #+BEGIN_SRC java
      // Single expression body
      (String first, String second) -> first.length() - second.length()

      // Non-single expression body
      (String first, String second) -> {
          int difference = first.length() < second.length();

          if (difference < 0) return -1;
          else if (difference > 0) return 1;
          else return 0;
      } 
      
      // No parameter
      () -> { for (int i = 0; i < 1000; i++) doWork(); };
      
      // parameter types can be inferred
      Comparator<String> comp
          = (first, second) -> first.length() - second.length();
       
      // If single parameter lambda expression with its type can be inferred, the
      // parentheses can be omitted.
      EventHandler<ActionEvent> listener = event ->
          System.out.println("Oh noes!")
      #+END_SRC

    - You NEVER specify the _result type_ of a lambda expression.
      =From Jian= but if a chance can be given to specify it is not a bad idea!

      However, the compiler infers it from the body and checks that it matches
      the expected type.

*** DONE 3.4.2 Functional Interfaces
    CLOSED: [2017-05-11 Thu 15:50]
    - As you already saw, there are many interfaces in Java that express actions,
      such as ~Runnable~ or ~Comparator~.
      Lambda expressions are compatible with these interfaces.

    - /functional interface/: You can supply a lambda expression whenever an
      object of an interface with a _single_ /abstract method/ is expected.
      For example,
      #+BEGIN_SRC java
      Arrays.sort(words,
          (first, second) -> first.length() - second.length());
      #+END_SRC

    - In _most programming languages_ that support function literals, you can
      + declare function types such as ~(String, String) -> int~
      + declare variables of those types, put functions into those variables, and
        invoke them.

    - In /Java/ you can _ONLY_ do _ONE_ thing:
      put the lambda expression in a variable whose type is a
      /functional interface/ (can't be class), so that it is converted to an
      instance of that interface.

    - Note: =IMPORTANT=
      You _CANNOT_ assign a lambda expression to a variable of type ~Object~,
      REASON: ~Object~ is the common supertype of all classes.
              It is a class, NOT a /functional interface/.

    - The standard library provides a large number of /functional interfaces/
      (see Section 3.6.2, “Choosing a Functional Interface,” on p. 113).
      For example:
      #+BEGIN_SRC java
      public interface Predicate<T> {
          boolean test(T t);
      }
      #+END_SRC
      =TODO=
      The ~ArrayList~ class has a ~removeIf~ method whose parameter is a
      ~Predicate~. For example, the folloing statement removes all ~null~ values
      from an array list:
      #+BEGIN_SRC java
      list.removeIf(e -> e == null);
      #+END_SRC

** DONE 3.5 Method and Constructor References
   CLOSED: [2017-05-12 Fri 12:29]
*** 3.5.1 Method References
    - Introduce /method reference/ by examples:
      #+BEGIN_SRC java
      // #1
      Arrays.sort(strings, (x, y) -> x.compareToIgnoreCase(y));
                           // lambda expression

      Arrays.sort(strings, String::compareToIgnoreCase);
                           // method reference


      // #2 removes all null values from a list.
      list.removeIf(Objects::isNull);
      #+END_SRC

    - Another example:
      #+BEGIN_SRC java
      list.forEach(x -> System.out.println(x));

      list.forEach(System.out::println);
      #+END_SRC

    - Three variations of /method reference/:
      1. _Class::instanceMethod_:
         The first parameter becomes the receiver of the method, and any other
         parameters are passed to the method.

         ~String::compareToIgnoreCase~ is the same as
         ~(x, y) -> x.compareToIgnoreCase(y)~

      2. _Class::staticMethod_:
         all parameters are passed to the static method.

         ~Objects::isNull~ is equivalent to ~x -> Objects.isNull(x)~

      3. _object::instanceMethod_:
         the method is invoked on the given object, and the parameters are passed
         to the instance method.
         ~System.out::println~ is equivalent to ~x -> System.out.println(x)~

    - _NOTE_:
      Compiler will try to find from the context which overloaded method is
      required.

    - You can capture the ~this~ parameter in a method reference. For example,
      ~this::equals~ is the same as ~x -> this.equals(x)~.

    - _NOTE_:
      In an inner class, you can capture the ~this~ reference of an enclosing
      class as ~EnclosingClass.this::method~.

      You can also capture super - See Chapter 4   =TODO=
      
*** 3.5.2 Constructor References
    - ~ClassName::new~
      If the class has more than one constructor, then it depends on the context.

    - Examples,
      + ~Stream<Employee> stream = names.stream().map(Employee::new);~
      + ~int[]::new~ is equivalent to ~n -> new int[n]~

    - One of Java limitation (_NO possible_ to construct an array of generic
      type)
      =TODO= See Chapter 6
      can be overcome through using /constructor reference/:
      =IMPORTANT=
      #+BEGIN_SRC java
      // Usual `toArray` method return an `Object`, not an array of the element
      // type
      Object[] employees = stream.toArray();
      
      // With constructor reference
      Employee[] buttons = stream.toArray(Employee[]::new);
      #+END_SRC

** DONE 3.6 Processing Lambda Expressions
   CLOSED: [2017-05-14 Sun 20:02]
   This section show you how to write your own methods that can consume lambda
   expressions.

*** 3.6.1 Implementing Deferred Execution
    - The point of using lambdas is /deferred execution/.
      Reasons, such as:
      + Running the code in a separate thread

      + Running the code multiple times

      + Running the code at the right point in an algorithm (for example, the
        comparison operation in sorting)
 
      + Running the code when something happens (a button was clicked, data has
        arrived, and so on)
        
      + Running the code only when necessary

    - Example:
      #+BEGIN_SRC java
      // #1
        // pass
      repeat(10, () -> System.out.println("Hello, World!"));
        // as the parameter `action` to the method
      public static void repeat(int n, Runnable action) {
          for (int i = 0; i < n; ++i) action.run();
      }


      // #2
      public interface IntConsumer {
          void accept(int value);
      }
      
      public static void repeat(int n, IntConsumer action) {
          for (int i = 0; i < n; ++ i) action.accept(i);
      }
      #+END_SRC
*** 3.6.2 Choosing a Functional Interface
    - In most functional programming languages, function types are /structural/.
      They are in the form of (input: two strings input; output: int)
      + ~Function2<String, String, Integer>~
        OR
      + ~(String, String) -> int~

    - In Java, use functional interface such as ~Comparator<String>~. In the
      theory this is called /nominal typing/. =TODO= =???=

    - Provided: Table 3-1 =IMPORTANT=

    - _NOTE_:
      Most of the standard functional interfaces have nonabstract methods for
      producing or combining functions.
      For example,
      ~Predicate.isEqual(a).or(Predicate.isEqual(b))~, which is the same as
      ~x -> a.equals(x) || b.equals(x)~.

    - Table 3-2 =IMPORTANT=
      34 available specializations for primitive types ~int~, ~long~, and
      ~double~. Use them can reduce autoboxing. This is why the author use
      ~IntConsumer~ instead of a ~Consumer<Integer>~

*** 3.6.3 Implementing Your Own Functional Interfaces
    _Explain through Example_:

    There is no standard type for a mapping ~(int, int) -> Color~.
    You could use ~BiFunction<Integer, Integer, Color>~, BUT that involves
    /autoboxing/.

    + In this case, it makes sense to define a new interface
      #+BEGIN_SRC java
        @FunctionalInterface
        public interface PixelFunction {
            Color apply(int x, int y);
        }
      #+END_SRC

    + Advantages of using ~@FunctionalInterface~ annotation:
      1. The compiler checks that the annotated entity is an interface with a
         single abstract method.

      2. The _javadoc_ page includes a statement that your interface is a func-
         tional interface.

    + Implement a method can take a lambda expression parameter, and use it:
      #+BEGIN_SRC java
        BufferedImage createImage(int width, int height, PixelFunction f) {
            BufferedImage image = new BufferedImage(width, height,
                                                    BufferedImage.TYPE_INT_RGB);
            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    Color color = f.apply(x, y); // IMPORTANT
                    image.setRGB(x, y, color.getRGB());
                }
            }

            return image;
        }

        BufferedImage frenchFlag = createImage(150, 100,
            (x, y) -> x < 50 ? Color.BLUE : x < 100 ? Color.WHITE : Color.RED);
      #+END_SRC

** DONE 3.7 Lambda Expressions and Variable Scope
   CLOSED: [2017-05-14 Sun 21:05]
*** 3.7.1 Scope of a Lambda Expression
    - It is _illegal_ to
      + declare a parameter or a local variable in the lambda that has the same
        name as a local variable.
        For example,
        #+BEGIN_SRC java
          int first = 0;
          Comparator<String> comp = (first, second) -> first.length() -
              second.length();
          // Error: Variable `first` already defined
        #+END_SRC

      + introduce same name variables in a lambda expression

    - ~this~ in a lambda expression denotes the ~this~ parameter of the method
      that creates the lambda.

      For example,
      #+BEGIN_SRC java
        public class Application {
            public void doWork() {
                Runnable runner = () -> { // ...
                                          System.out.println(this.toString());
                                          // ...
                };

                // ...
            }
        }
      #+END_SRC
      The expression ~this.toString()~ calls the ~toString~ method of the
      ~Application~ object, _NOT_ the ~Runnable~ instance.
      There is nothing special about the use of this in a lambda expression.
      The scope of the lambda expression is nested inside the ~doWork~ method,
      and ~this~ has the same meaning anywhere in that method.

*** 3.7.2 Accessing Variables from the Enclosing Scope
    - /closure/: a block of code together with the values of free variables.
      In Java, lambda expressions are closures.

    - To ensure that the captured value is well defined,

      there is an important -RESTRICTION-:
      _In a lambda expression, you can only reference variables whose value
      doesn't change._

      For example, (here is a compile-time error):
      #+BEGIN_SRC java
        for (int i = 0; i < n; ++i) {
            new Thread(() -> System.out.println(i)).start();
            // Error -- cannot capture `i`
        }
      #+END_SRC

    - The rule is that a lambda expression can _ONLY_ access local variables
      from an enclosing scope that are /effectively final/.

    - /effectively final/: a variable is never modified -- it either IS or COULD
      BE declared as ~final~.

    - _NOTE_:
      The same rule applies to variables captured by local inner classes (see
      Section 3.9, “Local Inner Classes,” on p. 122).  =TODO=

      _In the past_, the rule was more draconian and required captured variables
      to actually be declared ~final~. _This is no longer the case_.

    - _NOTE_:
      The variable of an enhanced ~for~ loop is /effectively final/ since its
      scope is a single iteration. =TODO= =???=
      A legal example:
      #+BEGIN_SRC java
        for (String arg : args) {
            new Thread(() -> System.out.println(arg)).start();
            // OK to capture `arg`
        }
      #+END_SRC
      In contrast, the scope of ~i~ in traditional ~for~ is the entire loop.

    - As a consequence of the /effectively final/ rule,
      a lambda expression _CANNOT mutate any captured variables_.
      For example,
      #+BEGIN_SRC java
        public static void repeatMessage(String text, int count, int threads) {
            Runnable r = () -> {
                while (count > 0) {
                    count—; // Error: Can't mutate captured variable
                    System.out.println(text);
                }
            };
            for (int i = 0; i < threads; i++) new Thread(r).start();
        }
      #+END_SRC

      =TODO= This is actually a good thing. As you will see in Chapter 10, if
      two threads update count at the same time, its value is undefined.

    - _NOTE_: =IMPORTANT=
      _Don't count on the compiler to catch all concurrent access errors._

      The prohibition against mutation _ONLY_ holds for _local variables_.

      If ~count~ is an _instance variable_ or _static variable_ of an enclosing
      class, then NO ERROR is reported even though the result is just as
      undefined.

    - _CAUTION_: =IMPORTANT=
      One can circumvent the check for inappropriate mutations by using an array
      of length 1:
      #+BEGIN_SRC java
      int[] counter = new int[1];
      button.setOnAction(event -> counter[0]++);
      #+END_SRC

      The counter variable is /effectively final/ -- it is never changed since it
      always refers to the same array, so you can access it in the lambda
      expression.

      Of course, code like this is _NOT threadsafe_. Except possibly for a
      callback in a single-threaded UI, this is a terrible idea.

      =TODO= You will see how to implement a threadsafe shared counter in
      Chapter 10.

** DONE 3.8 Higher-Order Functions
   CLOSED: [2017-05-14 Sun 22:09]
*** 3.8.1 Methods that Return Functions
    Example
    - Q: Create a method that produces the correct comparator:
         Sometimes sort an array of strings in ascending order
         Other times in descending order.

    - A:
      + Code
        #+BEGIN_SRC java
          public static Comparator<String> compareInDirection(int direction) {
              return (x, y) -> direction * x.compareTo(y);
          }
        #+END_SRC
        * call ~compareInDirection(1)~ yields an ascending comparator
        * call ~compareInDirection(-1)~ yields a descending comparator

      + Application
        ~Arrays.sort(friends, compareInDirection(-1));~
         
*** 3.8.2 Methods That Modify Functions
    Generalize the idea from the last section: Reverse any comparator.
    #+BEGIN_SRC java
      public static Comparator<String> reverse(Comparator<String> comp) {
          return (x, y) -> comp.compare(y, x);
      }

      reverse(String::compareToIgnoreCase);
    #+END_SRC

    _NOTE_:
    The ~Comparator~ interface has default method ~reversed~ that produces the
    reverse of a given comparator in just this way.

*** 3.8.3 Comparator Methods
    - The ~Comparator~ interface has a number of useful static methods that are
      higher-order functions generating comparators.

    - The comparing method takes a /"key extractor" function/ that maps a type
      ~T~ to a comparable type (such as ~String~), and then compare them.

    - For example,
      + ~Arrays.sort(people, Comparator.comparing(Person::getName));~

      + Chain comparators
        #+BEGIN_SRC java
          Arrays.sort(people, Comparator
                      .comparing(Person::getLastName)
                      .thenComparing(Person::getFirstName));
        #+END_SRC

      + Some wariations of these methods.
        #+BEGIN_SRC java
          Arrays.sort(people, Comparator.comparing(Person::getName,
              (s, t) -> s.length() - t.length()));
        #+END_SRC

    - =IMPORTANT= Both the ~comparing~ and ~thenComparing~ methods have variants
      that avoid boxing of ~int~, ~long~, or ~double~ values.
        An easier way of sorting by name length would be
      ~Arrays.sort(people, Comparator.comparingInt(p -> p.getName().length()));~

    - If a key function can return ~null~, use static methods ~nullsFirst~ and
      ~nullsLast~.

      They take an existing comparator modify it so that no ~null~ realted exception
      but ranks them as smaller or larger than regular values.

      For example,
      #+BEGIN_SRC java
        import java.util.Comparator.*;

        Arrays.sort(people, comparing(Person::getMiddleName,
                                      nullsFirst(naturalOrder())));
      #+END_SRC
      + ~naturalOrder~: make a comparator for any class implementing ~Comparable~
      + ~reverseOrder~: give the reverse of the natural order.

** DONE 3.9 Local Inner Classes
   CLOSED: [2017-05-14 Sun 22:41]
   _Long before there were lambda expressions_
   Java had a mechanism for concisely defining classes that implement a interface
   (functional or not).
   _For Now_
   + For functional interfaces, use lambda expressions.
   + For non-functional, use /local inner classes/.

*** 3.9.1 Local Classes
   - /local class/: a class inside a method.

   - /local class/ occurs often when a class implements a interface and the
     caller of the method only cares about the interface, not the class.
     =FROM JIAN= user doesn't need to know the exact formation of this class, and
                 only use it in the way the interface specified.
                 The only way to get this class is through the return value of
                 this method, or used inside this method.

   - TODO
     #+BEGIN_SRC java
       private static Random generator = new Random();

       public static IntSequence randomInts(int low, int high) {
           class RandomSequence implements IntSequence {
               public int next() { return low + generator.nextInt(high - low + 1); }
               public boolean hasNext() { return true; }
           }

           return new RandomSequence();
       }
     #+END_SRC

*** 3.9.2 Anonymous Classes
    #+BEGIN_SRC java
      public static IntSequence randomInts(int low, int high) {
          return new IntSequence() {
              public int next() { return low + generator.nextInt(high - low + 1); }
              public boolean hasNext() { return true; }
          }
      }
    #+END_SRC
    + The expression ~new interface() { methods }~ means:
      Define a class implementing the interface that has the given methods, and
      construct one object of that class.

    + _NOTE_:
      As always, the ~()~ in the ~new~ expression indicate the construction
      arguments. A default constructor of the anonymous class is invoked.

    + _Before_ Java had /lambda expressions/,
      /anonymous inner classes/ were _the most concise_ syntax available for
      providing runnables, comparators, and other functional objects.
      _They show up frequently in legacy code._

    + Nowadays, they are only necessary when you need to provide two or more
      methods, as in the preceding example.
      If the ~IntSequence~ interface has a default ~hasNext~ method, as in
      Exercise 15, you can simply use a lambda expression: =IMPORTANT=
      #+BEGIN_SRC java
        public static IntSequence randomInts(int low, int high) {
            // This lambda expression is considered as a anonymous class that
            // implements `IntSequence` with default method `hasNext`.
            return () -> low + generator.nextInt(high - low + 1);
        }
      #+END_SRC

** TODO Exercises

* TODO 4 INHERITANCE AND REFLECTION - PAGE 139 ~ 179
  - /inheritance/

  - /fields/: instance variables and static variables.

  - /members/: /fields/, /methods/, and /nested classes\slash{}interfaces/.

  - /reflection/: the ability to find out more about classes and their members
    in running program.
    + _Reflection is a powerful feature, but it is undeniably COMPLEX._
    + _Tool builders oriented_

  - Key points:
    1. Use the ~super~ keyword to invoke a superclass method or constructor.

    2. A ~protected~ member of a subclass is accessible in a subclass method, but
       only when applied to objects of the same subclass.

    3. Every class is a subclass of ~Object~ which provides methods ~toString~,
       ~equals~, ~hashCode~, and ~clone~.

    4. Each enumerated type is a subclass of ~Enum~ which provides methods
       ~toString~, ~valueOf~, and ~compareTo~.

    5. The ~Class~ class provides information about a Java type, which can be a
       class, array, interface, primitive type, or ~void~.

    6. You can use a ~Class~ object to load resources that are placed alongside
       class files. TODO =???=

    7. You can load classes from locations other than the class path by using a
       class loader. TODO =???=

    8. The reflection library enables programs to discover members of arbitrary
       objects, access variables, and invoke methods. TODO =???=

    9. Proxy objects dynamically implement arbitrary interfaces, routing all
       method invocations to a handler. TODO =???=

** DONE 4.1 Extending a Class
   CLOSED: [2017-05-15 Mon 20:53]
*** 4.1.1 Super- and Subclasses
    #+BEGIN_SRC java
      public class Manager extends Employee {
          // added fields
          // added or overriding methods
      }
    #+END_SRC

*** 4.1.2 Defining and Inheriting Subclass Methods
    /inherited/
*** 4.1.3 Method Overriding
    - Example:
      #+BEGIN_SRC java
        public class Manager extends Employee {
            // ...
            public double getSalary() {  // Overrides superclass method
                return super.getSalary() + bonus;
            }
        }
      #+END_SRC

    - _Note_: TODO =???=
      _Unlike_ ~this~, ~super~ is NOT a reference to an object,
      but a directive to bypass dynamic method lookup
      (see Section 4.1.5, “Superclass Assignments,” on p. 131) and invoke a
      specific method instead. TODO =???=

    - ~@Override~ annotation

    - You can change the return type to a subtype when overriding a method.
      (/convariant return types/ are permitted)

    - _Caution_: =IMPORTANT=
      When override a method,
      the subclass method must be _at least as visible_ as the superclass method.

*** 4.1.4 Subclass Construction
    - Subclass cannot access the private instance variables of the superclass,
      it must initialize them through a super class constructor. For example,
      #+BEGIN_SRC java
        public Manager(String name, double salary) {
            super(name, salary);
            bonus = 0;
        }
      #+END_SRC

    - The superclass constructor call must be the _FIRST_ statement in the
      constructor for the subclass.

    - If omit the superclass constructor call, the superclass must have a
      no-argument constructor which is implicitly called.

*** 4.1.5 Superclass Assignments
    - /covariant/

    - /dynamic method lookup/
      For example,
      #+BEGIN_SRC java
        Manager boss = new Manager(/* ... */);
        Employee empl = boss;  // OK to assign to superclass variable
      #+END_SRC
      Though the type of ~empl~ is ~Employee~, when it calls ~getSalary~ method
      it calls the right one -- the method of ~Manager~, rather than ~Employee~.

    - _CAUTION_:
      In Java, assign a ~Manager[]~ array to an ~Employee[]~ variable is OK,
      BUT it is also _unsound_.
      #+BEGIN_SRC java
        Manager[] bosses = new Manager[10];
        Employee[] empls = bosses; // Legal in Java
        empls[0] = new Employee(/* ... */); // Runtime error
      #+END_SRC
      + ~empls~ and ~bosses~ reference the same ~Manager[]~ array, which cannot
        hold a lowly ~Employee~
      + runtime exception ~ArrayStoreException~.

*** 4.1.6 Casts
    One drawback from the preceding section:
    You can only invoke methods that belong to the superclass.

    For example,
    #+BEGIN_SRC java
      Employee empl = new Manager(/* ... */);
      empl.setBonus(10000); // Compile-time error
    #+END_SRC
    The second line is a compile-time error, though if it can pass compilation,
    the runtime should be OK due to /dynamic method lookup/.

    Solution:
    #+BEGIN_SRC java
      if (empl instanceof Manager) {
          Manager mgr = (Manager) empl;
          mgr.setBonus(10000);
      }
    #+END_SRC

*** 4.1.7 Final Methods and Classes
    - A good example: the ~getClass~ method of the ~Object~ class.
      It does not allow objects to lie about the class to which they belong.

    - ~final~ is good for efficiency only in the early days of Java.

      Modern VM will speculatively "inline" simple methods, even if they are not
      declared ~final~.

      When overriding happens, such inlining is undone.

*** 4.1.8 Abstract Methods and Classes
    - It is not possible to construct an instance of an abstract class.

    - There can be a variable whose type is an abstract class,
      provided it contains a reference to an object of a concrete subclass.
      #+BEGIN_SRC java
        public abstract class Person {
            private String name;
            public Person(String name) { this.name = name; }
            public final String getName() { return name; }
            public abstract int getId();
        }

        public class Student extends Person {
            private int id;
            public Student(String name, int id) { super(name); this.id = id; }
            public int getId() { return id; }
        }

        Person p = new Student(“Fred”, 1729);
      #+END_SRC
*** TODO 4.1.9 Protected Access
    - ~protected~: Restrict a method to
      1. subclasses ONLY,
      2. less commonly, to allow subclass methods to access an instance variable
         of a superclass.

    - _Caution_:
      In Java,
      ~protected~ grants package-level access, and it only protects access from
      other packages.

    - TODO =???= page 147

*** TODO 4.1.10 Anonymous Subclasses
    - 
*** 4.1.11 Inheritance and Default Methods
    - In this situation, _class wins_
      #+BEGIN_SRC java
        public interface Named {
            default String getName() { return ""; }
        }

        public class Person {
            // ...
            public String getName() { return name; }
        }

        public class Student extends Person implements Named {
            // ...
        }
      #+END_SRC

    - You must resolve a conflict when the same default method is inherited from
      two interfaces.

    - The "classes win" rule ensures compatibility with Java 7.
      If you add default methods to an interface, it has no effect on code that
      worked before there were default methods.

*** 4.1.12 Method Expressions with ~super~
    - ~super::instanceMethod~
      Exmaple:
      #+BEGIN_SRC java
        public class Worker {
            public void work() {
                for (int i = 0; i < 100; ++i) System.out.println("Working");
            }
        }

        public class ConcurrentWorker extends Worker {
            public void work() {
                Thread t = new Thread(super::work);
                t.start();
            }
        }
      #+END_SRC

** TODO 4.2 ~Object~: The Cosmic Superclass
   - When a class has no explicit superclass, it implicitly extends ~Object~.
     ~public class Employee { /* ... */ }~
     is equivalent to
     ~public class Employee extends Object { /* ... */ }~

   - =IMPORTANT=
     _Table 4-1 The Methods of the ~java.lang.Object~ Class_
     Page 149

   - _NOTE_: TODO =EXAMPLE= =???=
     Arrays are classes.
     Therefore, it is legal to convert an array, even a primitive type array, to
     a reference of type ~Object~

*** DONE 4.2.1 The ~toString~ Method
    CLOSED: [2017-05-16 Tue 16:00]
    - Many ~toString~ methods follow a format:
      the name of the class,
      followed by the instance variables enclosed in square brackets
      For example,
      1. The ~toString~ method of a ~Point~ object returns a string like this:
         ~java.awt.Point[x=10,y=20]~

      2. Implement the ~toString~ method of the ~Employee~ class:
         #+BEGIN_SRC java
           public String toString() {
               return getClass().getName() + "[name=" + name
                   + ",salary=" + salary + "]";
           }
         #+END_SRC
         Use ~getClass().getName()~ rather than the "Employee" literal guarantees
         this method does the right thing for subclasses as well. 
         #+BEGIN_SRC java
           public class Manager extends Employee {
               // ...
               public String toString() {
                   return super.toString() + "[bonus=" + bonus + "]";
               }
           }
         #+END_SRC

    - _TIP_:
      ~"" + x~ is more general than ~toString~ method -- it even works for ~null~
      and primitive type values.

    - _CAUTION_:
      #+BEGIN_SRC java
        int[] primes = { 2, 3, 5, 7, 11, 13 };

        // yield a string such as "[I@1a46e30". The prefix `[I` denotes an array of
        // integers
        primes.toString();

        // yield the string [2, 3, 5, 7, 11, 13]
        Arrays.toString(primes);
      #+END_SRC

*** TODO 4.2.2 The ~equals~ Method
    - _CAUTION_:
    - _TIP_:
    - _NOTE_:
*** TODO 4.2.3 The ~hashCode~ Method
    - _CAUTION_:
*** TODO 4.2.4 Cloning Objects
    - _NOTE_:
** DONE 4.3 Enumerations
   CLOSED: [2017-05-16 Tue 17:43]
   - Example:
     #+BEGIN_SRC java
       public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE };
     #+END_SRC

*** DONE 4.3.1 Methods of Enumerations
    CLOSED: [2017-05-16 Tue 17:10]
    - SINCE each enumerated type has a fixed set of instances,
      ~equals~ is not necessary, use ~==~ is OK.

    - No need to create the ~toString~ method for your enumeration, and it
      automatically provided to yield the name of the enumerated object.

    - A String to a value of a enumeration:
      ~Size notMySize = Size.valueOf("SMALL");~
      This set ~notMySize~ to ~Size.SMALL~

    - ~Size[] allValues = Size.values();~

    - _TIP_:
      Traverse all instances of an enumerated type:
      ~for (Size s : Size.values()) { System.out.println(s); }~

    - The ~ordinal~ method yields the position of an instance in the ~enum~
      declaration, counting from _zero_.

    - Every enumerated type automatically implements ~Comparable<E>~, allowing
      comparisons only against its own objects. The comparison is by oridinal values.

    - _NOTE_:
      Table 4-2 Methods of the ~java.lang.Enum<E>~ Class

*** DONE 4.3.2 Constructors, Methods, and Fields
    CLOSED: [2017-05-16 Tue 17:10]
    - Add constructors, methods, and fields to an enumerated type, if you want.
      For example,
      #+BEGIN_SRC java
        public enum Size {
            SMALL("S"), MEDIUM("M"), LARGE("L"), EXTRA_LARGE("XL");

            private String abbreviation;

            Size(String abbreviation) {
                this.abbreivation = abbreviation;
            }

            public String getAbbreviation() { return abbreviation; }
        }
      #+END_SRC
      Each instance of the enumeration is guaranteed to be constructed exactly
      once.

    - _NOTE_:
      _The constructor of an enumeration is always private_.
      You can omit the ~private~ modifier, as in the preceding example.

      It is a _syntax error_ to declare an enum constructor as ~public~ or
      ~protected~.

*** DONE 4.3.3 Bodies of Instances
    CLOSED: [2017-05-16 Tue 17:19]
    - You can add methods to each individual ~enum~ instance, but they have to
      override methods defined in the enumeration.
      For example, to implement a calculator:
      #+BEGIN_SRC java
        public enum Operation {
            ADD {
                public int eval(int arg1, int arg2) { return arg1 + arg2; }
            },
            SUBTRACT {
                public int eval(int arg1, int arg2) { return arg1 - arg2; }
            },
            MULTIPLY {
                public int eval(int arg1, int arg2) { return arg1 * arg2; }
            },
            DIVIDE {
                public int eval(int arg1, int arg2) { return arg1 / arg2; }
            };

            public abstract int eval(int arg1, int arg2);
        }

        Operation op = /* ... */;
        int result = op.eval(first, second);
      #+END_SRC

    - _NOTE_:
      Technically,
      _each of these constants belongs to an anonymous subclass of ~Operation~._

      Anything that you could place into an anonymous subclass body you can also
      add into the body of a member.

*** DONE 4.3.4 Static Members
    CLOSED: [2017-05-16 Tue 17:35]
    - It is _LEGAL_ for an enumeration to have /static members/.

      HOWEVER, you have to BE CAREFUL WITH _construction order_.
        The enumerated constants are constructed _BEFORE_ the static members,
      so you cannot refer to any static members in an enumeration constructor.

    - An ILLEGAL example: 
      #+BEGIN_SRC java
        public enum Modifier {
            PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, ABSTRACT;
            private static int maskBit = 1;
            private int mask;
            public Modifier() {
                mask = maskBit; // Error -- cannot access static variable in constructor
                maskbit *= 2; // Error
            }

            // ...
        }
      #+END_SRC

      REMEDY
      #+BEGIN_SRC java
        public enum Modifier {
            PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, ABSTRACT;
            private int mask;

            static {
                int maskBit = 1;
                for (Modifier m : Modifier.values()) {
                    m.mask = maskBit;
                    maskBit *= 2;
                }
            }
        }
      #+END_SRC

    - NOTE
      Enumerated types can be nested inside classes.
      Such nested enumerations are implicitly static nested classes -- that is,
      their methods cannot reference instance variables of the enclosing class.

*** DONE 4.3.5 Switching on an Enumeration
    CLOSED: [2017-05-16 Tue 17:43]
    - Enumeration constants can be used in a ~switch~ statement.
      For example,
      #+BEGIN_SRC java
        enum Operation { ADD, SUBTRACT, MULTIPLY, DIVIDE };

        public static int eval(Operation op, int arg1, int arg2) {
            int result = 0;

            switch (op) {
            case ADD: result = arg1 + arg2; break;
            case SUBTRACT: result = arg1 - arg2; break;
            case MULTIPLY: result = arg1 * arg2; break;
            case DIVIDE: result = arg1 / arg2; break;
            }

            return result;
        }
      #+END_SRC
      You use ~ADD~, NOT ~Operation.ADD~, inside the ~switch~ statement -- the
      type is _inferred_ from the type of the expression on which the ~switch~ is
      computed.

    - NOTE
      The language specification encourages the compilers to give a WARNING if
      a switch on an enumeration is _not exhaustive_.

      _Oracle compiler does NOT produce such a warning_

    - _TIP_
      Refer to the instances of an enumeration by their simple name (rather than
      their qualified name) outside a ~switch~, use a
      _static import declaration_. For example,
      ~import static com.horstmann.corejava.Size.*;~

** TODO 4.4 Runtime Type Information and Resources
*** 4.4.1 The Class Class
*** 4.4.2 Loading Resources
*** 4.4.3 Class Loaders
*** 4.4.4 The Context Class Loader
*** 4.4.5 Service Loaders
** TODO 4.5 Reflection
*** 4.5.1 Enumerating Class Members
*** 4.5.2 Inspecting Objects
*** 4.5.3 Invoking Methods
*** 4.5.4 Constructing Objects
*** 4.5.5 JavaBeans
*** 4.5.6 Working with Arrays
*** 4.5.7 Proxies
** TODO Exercises

* TODO 5 EXCEPTIONS, ASSERTIONS, AND LOGGING - PAGE 180 ~ 202
  - Exception-handling

  - ~assert~ statement: provides a structured and efficient way of expressing
    internal assumptions.

  - logging API: use it to keep a record of the various events, be they routine
    or suspicious, in the execution of your programs.

  - The key points of this chapter are: =TODO=
    1. In Java, /checked exceptions/ are tracked by the compiler.

    2. The try-with-resources statement automatically closes resources after
       normal execution or when an exception occurred.

    3. A stack trace describes all method calls that are pending at a point of
       execution.

    4. Loggers are arranged in a hierarchy, and they can receive logging messages
       with levels ranging from ~SEVERE~ to ~FINEST~.

    5. Log handlers can send logging messages to alternate destinations, and
       formatters control the message format.

    6. You can control logging properties with a log configuration file.

** TODO 5.1 Exception Handling
*** DONE 5.1.1 Throwing Exceptions
    CLOSED: [2017-05-15 Mon 21:55]
    Example:
    #+BEGIN_SRC java
      if (low > high) {
          throw new IllegalArgumentException(
              String.format("low should be <= high but low is %d and high is %d",
                  low, high));
      }
    #+END_SRC

*** DONE 5.1.2 The Exception Hierarchy
    CLOSED: [2017-05-15 Mon 21:55]
    - Figure 5-1 The exception hierarchy

      Throwable
       /       \
      Error    Exception
       |            \ 
       |             Runtime Exception
       |               /   \
      Subclasses      /     \
      are unchecked -/       Subclasses
      exceptions             are checked
                             exceptions

    - ~Error~: exceptions that program cannot be expected to handle, such as
      memory exhaustion.

      For ~Error~, usually the only thing you can do is to give a message to the
      user.

    - ~Exception~: This is usually (or should be) Programmer-reported. Two
      categories:
      + /Unchecked exceptions/ are subclasses of ~RuntimeException~.
      + All other exceptions are /checked exceptions/.

    - See in the next section TODO
      programmers MUST
      + either _catch_ /checked exceptions/
        or
      + declare them in the method header.

      The compiler checks that these exceptions are handled properly.

    - _Note_:
      The exceptions that are subclasses of ~RuntimeException~ are not checked
      during compilation.

    - /Checked exceptions/ are used in situations where failure
      _should be anticipated_.

    - /Unchecked exceptions/ indicate logic errors caused by programmers, _NOT_
      by unavoidable external risks.

      For example, ~NullPointerException~
      Just about any method might throw one, and programmers shouldn't spend
      time on catching them. Instead, they should make sure that no ~null~'s are
      dereferenced in the first place.

    - Sometimes, Implementors need to use their judgment:
      + ~Integer.parseInt(str)~ can throw _unchecked_ ~NumberFormatException~
      + ~Class.forName(str)~ can throw _checked_ ~ClassNotFoundException~

      Rationale:
      It's possible to check whether a string is a valid integer before calling
      ~Integer.parseInt~.

      It's NOT possible to know whether a class can be loaded until you actually
      try to load it.

    - When create your own exception classes,
      it is a good idea to supply both
      + a no-argument constructor
        and
      + a constructor with a message string.

      For example,
      #+BEGIN_SRC java
        public class FileFormatException extends IOException {
            public FileFormatException() {}
            public FileFormatException(String message) {
                super(message);
            }
            // TODO: Also add constructors for chained exceptions—see Section 5.1.7
        }
      #+END_SRC

*** TODO 5.1.3 Declaring Checked Exceptions
*** TODO 5.1.4 Catching Exceptions
*** TODO 5.1.5 The Try-with-Resources Statement
*** TODO 5.1.6 The finally Clause
*** TODO 5.1.7 Rethrowing and Chaining Exceptions
*** TODO 5.1.8 The Stack Trace
*** TODO 5.1.9 The ~Objects.requireNonNull~ Method
** DONE 5.2 Assertions
   CLOSED: [2017-05-16 Tue 14:25]
   - The assertion mechanism allows you
     + to put in checks during testing
       and
     + to have them automatically removed in the production code.

   - In Java, assertions are intended
     + as a debugging aid for validating internal assumptions,

     + NOT as a mechanism for enforcing contracts.
       (Throw an exception when you need enforce contracts)

*** 5.2.1 Using Assertions
    - Syntax:
      1. ~assert condition;~: evaluate the given condition, and throw an
         ~AssertionError~ if it is false.
         For example, ~assert x >= 0;~

      2. ~assert condition : expression;~: do the things above, and if the value
         of condition is false the expression here is turned into a string that
         becomes the message of the error object.
         For example, ~assert x >= 0 : x;~

*** 5.2.2 Enabling and Disabling Assertions
    - By default, assertions are disabled.

    - Enable them with the option ~-enableassertions~ or ~-ea~.
      For example, ~java -ea MainClass~.

      + No re-compilation is required because enabling or disabling assertions is
        handled by the class loader. =IMPORTANT=

      + You can even enable assertions in specific classes or in entire packages,
        for example:
        ~java -ea:MyClass -ea:com.mycompany.mylib... MainClass~

    - Disable assertions in certain classes and packages with the
      ~-disableassertions~ or ~-da~ option:
      ~java -ea:... -da:MyClass MainClass~

    - ~-ea~ and ~-da~ do NOT apply to the "system classes" that loaded without
      class loaders.

        Use ~enablesystemassertions~ or ~-esa~.

    - It is also possible to programmatically control the assertion status of
      /class loaders/ with the following methods:
      #+BEGIN_SRC java
        void ClassLoader.setDefaultAssertionStatus(boolean enabled);
        void ClassLoader.setClassAssertionStatus(String className, boolean enabled);
        void ClassLoader.setPackageAssertionStatus(String packageName,
                                                   boolean enabled);
      #+END_SRC
      As with the ~-enableassertions~ command-line option, the
      ~setPackageAssertionStatus~ method sets the assertion status for the given
      package and its subpackages.

** TODO 5.3 Logging
*** 5.3.1 Using Loggers
*** 5.3.2 Loggers
*** 5.3.3 Logging Levels
*** 5.3.4 Other Logging Methods
*** 5.3.5 Logging Configuration
*** 5.3.6 Log Handlers
*** 5.3.7 Filters and Formatters
** TODO Exercises
   
* TODO 6 GENERIC PROGRAMMING - PAGE 203 ~ 227
** 6.1 Generic Classes
** 6.2 Generic Methods
** 6.3 Type Bounds
** 6.4 Type Variance and Wildcards
*** 6.4.1 Subtype Wildcards
*** 6.4.2 Supertype Wildcards
*** 6.4.3 Wildcards with Type Variables
*** 6.4.4 Unbounded Wildcards
*** 6.4.5 Wildcard Capture
** 6.5 Generics in the Java Virtual Machine
*** 6.5.1 Type Erasure
*** 6.5.2 Cast Insertion
*** 6.5.3 Bridge Methods
** 6.6 Restrictions on Generics
*** 6.6.1 No Primitive Type Arguments
*** 6.6.2 At Runtime, All Types Are Raw
*** 6.6.3 You Cannot Instantiate Type Variables
*** 6.6.4 You Cannot Construct Arrays of Parameterized Types
*** 6.6.5 Class Type Variables Are Not Valid in Static Contexts
*** 6.6.6 Methods May Not Clash after Erasure
*** 6.6.7 Exceptions and Generics
** 6.7 Reflection and Generics
*** 6.7.1 The Class<T> Class
*** 6.7.2 Generic Type Information in the Virtual Machine
** Exercises

* TODO 7 COLLECTIONS - PAGE 228 ~ 246
** 7.1 An Overview of the Collections Framework
** 7.2 Iterators
** 7.3 Sets
** 7.4 Maps
** 7.5 Other Collections
*** 7.5.1 Properties
*** 7.5.2 Bit Sets
*** 7.5.3 Enumeration Sets and Maps
*** 7.5.4 Stacks, Queues, Deques, and Priority Queues
*** 7.5.5 Weak Hash Maps
** 7.6 Views
*** 7.6.1 Ranges
*** 7.6.2 Empty and Singleton Views
*** 7.6.3 Unmodifiable Views
** Exercises

* TODO 8 STREAMS - PAGE 247 ~ 260
** 8.1 From Iterating to Stream Operations
** 8.2 Stream Creation
** 8.3 The filter, map, and flatMap Methods
** 8.4 Extracting Substreams and Combining Streams
** 8.5 Other Stream Transformations
** 8.6 Simple Reductions
** 8.7 The Optional Type
*** 8.7.1 How to Work with Optional Values
*** 8.7.2 How Not to Work with Optional Values
*** 8.7.3 Creating Optional Values
*** 8.7.4 Composing Optional Value Functions with flatMap
** 8.8 Collecting Results
** 8.9 Collecting into Maps
** 8.10 Grouping and Partitioning
** 8.11 Downstream Collectors
** 8.12 Reduction Operations
** 8.13 Primitive Type Streams
** 8.14 Parallel Streams
** Exercises

* TODO 9 PROCESSING INPUT AND OUTPUT - PAGE 270 ~ 303
  The key points of this chapter are:
  1. Input streams are a source of bytes, and output streams are a destination
     for bytes.

  2. Use readers and writers for processing characters. Be sure to specify a
     character encoding.

  3. The ~Files~ class has convenience methods for reading all bytes or lines of
     a file.

  4. The ~DataInput~ and ~DataOutput~ interfaces have methods for writing numbers
     in binary format.

  5. Use a ~RandomAccessFile~ or a memory-mapped file for random access.

  6. A ~Path~ is an absolute or relative sequence of path components in a file
     system. Paths can be combined (or "resolved").

  7. Use the methods of the ~Files~ class to copy, move, or delete files and to
     recursively walk through a directory tree.

  8. To read or update a ZIP file, use a ZIP file system.

  9. You can read the contents of a web page with the ~URL~ class. To read
     metadata or write data, use the ~URLConnection~ class.

  10. With the ~Pattern~ and ~Matcher~ classes, you can find all matches of a
      regular expression in a string, as well as the captured groups for each match.

  11. The serialization mechanism can save and restore any object implementing
      the ~Serializable~ interface, provided its instance variables are also
      serializable.

** TODO 9.1 Input/Output Streams, Readers, and Writers
   - /input stream/ :: (In the Java API) a source from which one can read bytes.

   - =COMMENT= The /stream/ here are unrealted to the class ~Stream~ (see Ch8).

   - The bytes can _come from_
     + a file
     + a network connection
     + an array in memory

   - /output stream/ :: a destination for bytes.

   - /readers/ :: object that _consume_ sequences of characters.

   - /writers/ :: object that _produce_ sequences of characters.

*** DONE 9.1.1 Obtaining Streams
    CLOSED: [2017-05-16 Tue 22:17]
    - Obtain a stream from a _file_:
      #+BEGIN_SRC java
        InputStream in = Files.newInputStream(path);
        OutputStream out = Files.newOutputStream(path);
      #+END_SRC
      Here ~path~ is an instance of the ~Path~ class (TODO See Sec9.2.1).

    - Obtain a stream from a _URL_:
      #+BEGIN_SRC java
        URL url = new URL("http://horstmann.com/index.html");
        InputStream in = url.openStream();
      #+END_SRC
      TODO See Sec9.3 for the ~URL~ class.

    - Obtain a stream from an array of bytes.
      The ~ByteArrayInputStream~ class.
      #+BEGIN_SRC java
      byte[] bytes = /* ... */;
      InputStream in = new ByteArrayInputStream(bytes);
      #+END_SRC

    - Send output to a byte array, use ~ByteArrayOutputStream~:
      #+BEGIN_SRC java
      ByteArrayOutputStream out = new ByteArrayOutputStream();
      // TODO: Write to `out`, and then
      byte[] bytes = out.toByteArray();
      #+END_SRC
      TODO


*** DONE 9.1.2 Reading Bytes
    CLOSED: [2017-05-16 Tue 22:25]
    - The ~InputStream~ class has a method to read a single byte:
      #+BEGIN_SRC java
        InputStream in = /* ... */;
        int b = in.read();
      #+END_SRC
      Return values:
      + an integer 0 and 255.
      + -1 if the end of input has been reached.

    - _CAUTION_:
      + They Java ~byte~ type has values between -128 and 127.
      + You can cast the returned value into a ~byte~
        (=From Jian= I think first translate 0 ~ 255 to -128 to 127)
        after you have checked that the return value of the method ~read~ is not
        -1.

    - TWO methods to read bytes from an input stream into an array.
      Both methods read until
      + either the array or the specified range is filled
      + or no further input is available.

      Return values:
      + acutal number of bytes (TODO type??? int, long, ...)
      + -1 if no input was available at all

      #+BEGIN_SRC java
      byte[] bytes = /* ... */;
      actualBytesRead = in.read(bytes);
      actualBytesRead = in.read(bytes, start, length);
      #+END_SRC

    - Read all bytes from an input stream (NO method in the Java library):
      #+BEGIN_SRC java
        public static byte[] readAllBytes(InputStream in) throws IOException {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            copy(in, out);
            out.close();
            return out.toByteArray();
        }
      #+END_SRC
      TODO See ~copy~ in the next section.

    - _TIP_:
      Read all bytes from a file
      ~byte[] bytes = Files.readAllBytes(path);~

*** DONE 9.1.3 Writing Bytes
    CLOSED: [2017-05-16 Tue 23:16]
    - Write individual bytes and byte arrays through the ~write~ methods of an
      ~OutputStream~
      #+BEGIN_SRC java
        OutputStream out = /* ... */;
        int b = /* ... */;
        out.write(b);
        byte[] bytes = /* ... */;
        out.write(bytes);
        out.write(bytes, start, length);
      #+END_SRC
      Close the stream when you are done in order to commit any buffered output.

    - Try-with-resources statement (like the ~with~ in Python):
      #+BEGIN_SRC java
        try (OutputStream out = /* ... */) {
            out.write(bytes);
        }
      #+END_SRC

    - Copy an input stream to an output stream, use this helper method:
      TODO
      #+BEGIN_SRC java
        public static void copy(InputStream in, OutputStream out) throws IOException
        {
            final int BLOCKSIZE = 1024;
            byte[] bytes = new byte[BLOCKSIZE];
            int len;
            while ((len = in.read(bytes)) != -1) out.write(bytes, 0, len);
        }
      #+END_SRC

    - To save an ~InputStream~ to a file, call
      ~Files.copy(in, path, StandardCopyOption.REPLACE_EXISTING);~

*** TODO 9.1.4 Character Encodings
    -
*** TODO 9.1.5 Text Input
    -
*** TODO 9.1.6 Text Output
    -
*** TODO 9.1.7 Reading and Writing Binary Data
    -
*** TODO 9.1.8 Random-Access Files
    -
*** TODO 9.1.9 Memory-Mapped Files
    -
*** DONE 9.1.10 File Locking
    CLOSED: [2017-05-16 Tue 23:23]
    - To lock a file, call either the ~lock~ or ~tryLock~ methods of the
      ~FileChannel~ class.
      #+BEGIN_SRC java
        FileChannel = FileChannel.open(path);
        FileLock lock = channel.lock();

        // OR
        // FileLock lock = channel.tryLock();
      #+END_SRC

    - The first call (~lock~) blocks until the lock becomes available.

      The second call (~tryLock~) returns immediately, either with the lock or
      with ~null~ if the lock is not available.

      The file remains locked until the lock or the channel is closed.

    - It is best to use try-with-resources statement:
      #+BEGIN_SRC java
        try (FileLock lock = channel.lock()) {
            // ...
        }
      #+END_SRC
** TODO 9.2 Paths, Files, and Directories
*** 9.2.1 Paths
*** 9.2.2 Creating Files and Directories
*** 9.2.3 Copying, Moving, and Deleting Files
*** 9.2.4 Visiting Directory Entries
*** 9.2.5 ZIP File Systems
** TODO 9.3 URL Connections
** TODO 9.4 Regular Expressions
*** 9.4.1 The Regular Expression Syntax
*** 9.4.2 Finding One or All Matches
*** 9.4.3 Groups
*** 9.4.4 Removing or Replacing Matches
*** 9.4.5 Flags
** TODO 9.5 Serialization
*** 9.5.1 The Serializable Interface
*** 9.5.2 Transient Instance Variables
*** 9.5.3 The readObject and writeObject Methods
*** 9.5.4 The readResolve and writeReplace Methods
*** 9.5.5 Versioning
** TODO Exercises

* TODO 10 CONCURRENT PROGRAMMING - PAGE 304 ~ 343
** 10.1 Concurrent Tasks
*** 10.1.1 Running Tasks
*** 10.1.2 Futures and Executor Services
** 10.2 Thread Safety
*** 10.2.1 Visibility
*** 10.2.2 Race Conditions
*** 10.2.3 Strategies for Safe Concurrency
*** 10.2.4 Immutable Classes
** 10.3 Parallel Algorithms
*** 10.3.1 Parallel Streams
*** 10.3.2 Parallel Array Operations
** 10.4 Threadsafe Data Structures
*** 10.4.1 Concurrent Hash Maps
*** 10.4.2 Blocking Queues
*** 10.4.3 Other Threadsafe Data Structures
** 10.5 Atomic Values
** 10.6 Locks
*** 10.6.1 Reentrant Locks
*** 10.6.2 The synchronized Keyword
*** 10.6.3 Waiting on Conditions
** 10.7 Threads
*** 10.7.1 Starting a Thread
*** 10.7.2 Thread Interruption
*** 10.7.3 Thread-Local Variables
*** 10.7.4 Miscellaneous Thread Properties
** 10.8 Asynchronous Computations
*** 10.8.1 Long-Running Tasks in User Interface Callbacks
*** 10.8.2 Completable Futures
** 10.9 Processes
*** 10.9.1 Building a Process
*** 10.9.2 Running a Process
** Exercises

* TODO 11 ANNOTATIONS - PAGE 344 ~ 364
** 11.1 Using Annotations
*** 11.1.1 Annotation Elements
*** 11.1.2 Multiple and Repeated Annotations
*** 11.1.3 Annotating Declarations
*** 11.1.4 Annotating Type Uses
*** 11.1.5 Making Receivers Explicit
** 11.2 Defining Annotations
** 11.3 Standard Annotations
*** 11.3.1 Annotations for Compilation
*** 11.3.2 Annotations for Managing Resources
*** 11.3.3 Meta-Annotations
** 11.4 Processing Annotations at Runtime
** 11.5 Source-Level Annotation Processing
*** 11.5.1 Annotation Processors
*** 11.5.2 The Language Model API
*** 11.5.3 Using Annotations to Generate Source Code
** Exercises

* TODO 12 THE DATE AND TIME API - PAGE 365 ~ 380
** 12.1 The Time Line
** 12.2 Local Dates
** 12.3 Date Adjusters
** 12.4 Local Time
** 12.5 Zoned Time
** 12.6 Formatting and Parsing
** 12.7 Interoperating with Legacy Code
** Exercises

* TODO 13 INTERNATIONALIZATION - PAGE 381 ~ 399
** 13.1 Locales
*** 13.1.1 Specifying a Locale
*** 13.1.2 The Default Locale
*** 13.1.3 Display Names
** 13.2 Number Formats
** 13.3 Currencies
** 13.4 Date and Time Formatting
** 13.5 Collation and Normalization
** 13.6 Message Formatting
** 13.7 Resource Bundles
*** 13.7.1 Organizing Resource Bundles
*** 13.7.2 Bundle Classes
** 13.8 Character Encodings
** 13.9 Preferences
** Exercises

* TODO 14 COMPILING AND SCRIPTING - PAGE 400 ~ 422
** 14.1 The Compiler API
*** 14.1.1 Invoking the Compiler
*** 14.1.2 Launching a Compilation Task
*** 14.1.3 Reading Source Files from Memory
*** 14.1.4 Writing Byte Codes to Memory
*** 14.1.5 Capturing Diagnostics
** 14.2 The Scripting API
*** 14.2.1 Getting a Scripting Engine
*** 14.2.2 Bindings
*** 14.2.3 Redirecting Input and Output
*** 14.2.4 Calling Scripting Functions and Methods
*** 14.2.5 Compiling a Script
** 14.3 The Nashorn Scripting Engine
*** 14.3.1 Running Nashorn from the Command Line
*** 14.3.2 Invoking Getters, Setters, and Overloaded Methods
*** 14.3.3 Constructing Java Objects
*** 14.3.4 Strings in JavaScript and Java
*** 14.3.5 Numbers
*** 14.3.6 Working with Arrays
*** 14.3.7 Lists and Maps
*** 14.3.8 Lambdas
*** 14.3.9 Extending Java Classes and Implementing Java Interfaces
*** 14.3.10 Exceptions
** 14.4 Shell Scripting with Nashorn
*** 14.4.1 Executing Shell Commands
*** 14.4.2 String Interpolation
*** 14.4.3 Script Inputs
** Exercises

* Tips
  - Static initialization occurs when the class is first loaded.

  - _The constructor of an enumeration is always private_.

  - _NOTE_:
    _Integer types in Java are signed_ (In CLR, integer can be unsigned).

      However, if you work with values that can never be negative and you
    really need _an additional bit_, you can use methods that interpret
    values as unsigned.

    For example,
    + Reuirement: a byte value ~b~ represent the range from -128 to 127, you
      may want a range from 0 to 255.

    + Solution: Store it in a ~byte~ type value, and
      =???= due to the nature of binary arithmetic, certain operations such as
      addition and subtraction will work.
      For other operations, call ~Byte.toUnsignedInt(b)~, and get an ~int~
      value between 0 and 255.

  - _Even in hex form, the exponent is written in decimal_

  - _Tip_:
    The ~&~ (and) and ~|~ (or) operators, when applied to ~boolean~ values,
    _force evaluation of both operands before combining the results_.
    =NOT SHORT CIRCUIT ANY MORE=
    This usage is very uncommon:
    1. Provided that the right hand side doesn't have a side effect, they act
       just like ~&&~ and ~||~, except they are less efficient.

    2. If you really need to force evaluation of the second operand, assign it
       to a ~boolean~ variable so that the flow of execution is plainly visible.
       =avoid unwanted multiple side effects, if the rhs has side effect.=
       =this method will has one side effect=
       =if not this method, it might be multiple side effects. It depends on=
       =how many times the rhs is used.=

  - _Java does NOT permit the use of operators with objects_,
    so you must use method calls to work with big numbers.

  - When comparing a string _against a literal string_,
    it is a GOOD idea to _put the literal string first_:
    #+BEGIN_SRC java
    if (“World”.equals(location)) ///...
    #+END_SRC
    This test works correctly even when location is ~null~.
