#+TITLE: Java I/O, NIO and NIO.2
#+VERSION: 1st
#+YEAR: 2015
#+AUTHOR: Jeff Friesen
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[About the Author - xv][About the Author - xv]]
- [[About the Technical Reviewers - xvii][About the Technical Reviewers - xvii]]
- [[Acknowledgments - xix][Acknowledgments - xix]]
- [[Introduction - xxi][Introduction - xxi]]
- [[Part I: Getting Started with I/O - 1][Part I: Getting Started with I/O - 1]]
- [[Chapter 1: I/O Basics and APIs - 3][Chapter 1: I/O Basics and APIs - 3]]
  - [[Classic I/O - 3][Classic I/O - 3]]
    - [[File System Access and the ~File~ Class - 3][File System Access and the ~File~ Class - 3]]
    - [[Accessing File Content via ~RandomAccessFile~ - 5][Accessing File Content via ~RandomAccessFile~ - 5]]
    - [[Streaming Data via Stream Classes - 5][Streaming Data via Stream Classes - 5]]
      - [[Stream Classes and Standard I/O - 5][Stream Classes and Standard I/O - 5]]
    - [[JDK 1.1 and the Writer/Reader Classes - 8][JDK 1.1 and the Writer/Reader Classes - 8]]
  - [[NIO - 8][NIO - 8]]
    - [[Buffers - 9][Buffers - 9]]
    - [[Channels - 10][Channels - 10]]
    - [[Selectors - 11][Selectors - 11]]
    - [[Regular Expressions - 12][Regular Expressions - 12]]
    - [[Charsets - 13][Charsets - 13]]
    - [[Formatter - 13][Formatter - 13]]
  - [[NIO.2 - 13][NIO.2 - 13]]
    - [[Improved File System Interface - 14][Improved File System Interface - 14]]
    - [[Asynchronous I/O - 14][Asynchronous I/O - 14]]
    - [[Completion of Socket Channel Functionality - 14][Completion of Socket Channel Functionality - 14]]
  - [[Summary - 15][Summary - 15]]
- [[Part II: Classic I/O APIs - 17][Part II: Classic I/O APIs - 17]]
- [[Chapter 2: ~File~ - 19][Chapter 2: ~File~ - 19]]
  - [[Constructing ~File~ Instances - 19][Constructing ~File~ Instances - 19]]
  - [[Learning About Stored Abstract Paths - 22][Learning About Stored Abstract Paths - 22]]
  - [[Learning About a Path's File or Directory - 25][Learning About a Path's File or Directory - 25]]
  - [[Listing File System Root Directories - 27][Listing File System Root Directories - 27]]
  - [[Obtaining Disk Space Information - 28][Obtaining Disk Space Information - 28]]
  - [[Listing Directories - 30][Listing Directories - 30]]
  - [[Creating/Modifying Files and Directories - 33][Creating/Modifying Files and Directories - 33]]
  - [[Setting and Getting Permissions - 37][Setting and Getting Permissions - 37]]
  - [[Exploring Miscellaneous Capabilities - 39][Exploring Miscellaneous Capabilities - 39]]
  - [[Exercise - 41][Exercise - 41]]
  - [[Summary - 42][Summary - 42]]
- [[Chapter 3: ~RandomAccessFile~ - 43][Chapter 3: ~RandomAccessFile~ - 43]]
  - [[Exploring ~RandomAccessFile~ - 43][Exploring ~RandomAccessFile~ - 43]]
  - [[Using ~RandomAccessFile~ - 49][Using ~RandomAccessFile~ - 49]]
  - [[Summary - 57][Summary - 57]]
- [[Chapter 4: Streams - 59][Chapter 4: Streams - 59]]
  - [[Stream Classes Overview - 59][Stream Classes Overview - 59]]
  - [[Touring the Stream Classes - 61][Touring the Stream Classes - 61]]
    - [[~OutputStream~ and ~InputStream~ - 61][~OutputStream~ and ~InputStream~ - 61]]
    - [[~ByteArrayOutputStream~ and ~ByteArrayInputStream~ - 64][~ByteArrayOutputStream~ and ~ByteArrayInputStream~ - 64]]
    - [[~FileOutputStream~ and ~FileInputStream~ - 67][~FileOutputStream~ and ~FileInputStream~ - 67]]
    - [[~PipedOutputStream~ and ~PipedInputStream~ - 71][~PipedOutputStream~ and ~PipedInputStream~ - 71]]
    - [[~FilterOutputStream~ and ~FilterInputStream~ - 75][~FilterOutputStream~ and ~FilterInputStream~ - 75]]
    - [[~BufferedOutputStream~ and ~BufferedInputStream~ - 84][~BufferedOutputStream~ and ~BufferedInputStream~ - 84]]
    - [[~DataOutputStream~ and ~DataInputStream~ - 86][~DataOutputStream~ and ~DataInputStream~ - 86]]
    - [[Object Serialization and Deserialization - 88][Object Serialization and Deserialization - 88]]
      - [[Default Serialization and Deserialization - 89][Default Serialization and Deserialization - 89]]
      - [[Custom Serialization and Deserialization - 95][Custom Serialization and Deserialization - 95]]
      - [[Externalization - 101][Externalization - 101]]
    - [[~PrintStream~ - 104][~PrintStream~ - 104]]
  - [[Revisiting Standard I/O - 107][Revisiting Standard I/O - 107]]
  - [[Summary - 111][Summary - 111]]
- [[Chapter 5: Writers and Readers - 113][Chapter 5: Writers and Readers - 113]]
  - [[~Writer~ and ~Reader~ Classes Overview - 114][~Writer~ and ~Reader~ Classes Overview - 114]]
  - [[~Writer~ and ~Reader~ - 116][~Writer~ and ~Reader~ - 116]]
  - [[~OutputStreamWriter~ and ~InputStreamReader~ - 117][~OutputStreamWriter~ and ~InputStreamReader~ - 117]]
  - [[~FileWriter~ and ~FileReader~ - 119][~FileWriter~ and ~FileReader~ - 119]]
  - [[~BufferedWriter~ and ~BufferedReader~ - 121][~BufferedWriter~ and ~BufferedReader~ - 121]]
  - [[Summary - 124][Summary - 124]]
- [[Part III: New I/O APIs - 125][Part III: New I/O APIs - 125]]
- [[Chapter 6: Buffers - 127][Chapter 6: Buffers - 127]]
  - [[Introducing Buffers - 127][Introducing Buffers - 127]]
  - [[~Buffer~ and its Children - 128][~Buffer~ and its Children - 128]]
  - [[Buffers in Depth - 133][Buffers in Depth - 133]]
    - [[Buffer Creation - 133][Buffer Creation - 133]]
    - [[Buffer Writing and Reading - 136][Buffer Writing and Reading - 136]]
    - [[Flipping Buffers - 139][Flipping Buffers - 139]]
    - [[Marking Buffers - 141][Marking Buffers - 141]]
    - [[Buffer Subclass Operations - 142][Buffer Subclass Operations - 142]]
    - [[Byte Ordering - 143][Byte Ordering - 143]]
    - [[Direct Byte Buffers - 145][Direct Byte Buffers - 145]]
  - [[Summary - 147][Summary - 147]]
- [[Chapter 7: Channels - 149][Chapter 7: Channels - 149]]
  - [[Introducing Channels - 149][Introducing Channels - 149]]
  - [[Channel and Its Children - 149][Channel and Its Children - 149]]
  - [[Channels in Depth - 155][Channels in Depth - 155]]
    - [[Scatter/Gather I/O - 155][Scatter/Gather I/O - 155]]
    - [[File Channels - 158][File Channels - 158]]
    - [[Socket Channels - 179][Socket Channels - 179]]
    - [[Pipes - 195][Pipes - 195]]
  - [[Summary - 201][Summary - 201]]
- [[Chapter 8: Selectors - 203][Chapter 8: Selectors - 203]]
  - [[Selector Fundamentals - 204][Selector Fundamentals - 204]]
  - [[Selector Demonstration - 209][Selector Demonstration - 209]]
  - [[Summary - 214][Summary - 214]]
- [[Chapter 9: Regular Expressions - 215][Chapter 9: Regular Expressions - 215]]
  - [[Pattern, PatternSyntaxException, and Matcher - 215][Pattern, PatternSyntaxException, and Matcher - 215]]
  - [[Character Classes - 221][Character Classes - 221]]
  - [[Capturing Groups - 223][Capturing Groups - 223]]
  - [[Boundary Matchers and Zero-Length Matches - 224][Boundary Matchers and Zero-Length Matches - 224]]
  - [[Quantifiers - 225][Quantifiers - 225]]
  - [[Practical Regular Expressions - 228][Practical Regular Expressions - 228]]
  - [[Summary - 230][Summary - 230]]
- [[Chapter 10: Charsets - 231][Chapter 10: Charsets - 231]]
  - [[A Brief Review of the Fundamentals - 231][A Brief Review of the Fundamentals - 231]]
  - [[Working with Charsets - 232][Working with Charsets - 232]]
  - [[Charsets and the String Class - 239][Charsets and the String Class - 239]]
  - [[Summary - 241][Summary - 241]]
- [[Chapter 11: Formatter - 243][Chapter 11: Formatter - 243]]
  - [[Exploring ~Formatter~ - 243][Exploring ~Formatter~ - 243]]
  - [[Exploring ~Formattable~ and ~FormattableFlags~ - 249][Exploring ~Formattable~ and ~FormattableFlags~ - 249]]
  - [[Summary - 255][Summary - 255]]
- [[Part IV: More New I/O APIs - 257][Part IV: More New I/O APIs - 257]]
- [[Chapter 12: Improved File System Interface - 259][Chapter 12: Improved File System Interface - 259]]
  - [[Architecting a Better File Class - 259][Architecting a Better File Class - 259]]
    - [[File Systems and File System Providers - 261][File Systems and File System Providers - 261]]
  - [[Locating Files with Paths - 263][Locating Files with Paths - 263]]
    - [[Getting a Path and Accessing Its Name Elements - 264][Getting a Path and Accessing Its Name Elements - 264]]
    - [[Relative and Absolute Paths - 267][Relative and Absolute Paths - 267]]
    - [[Normalization, Relativization, and Resolution - 269][Normalization, Relativization, and Resolution - 269]]
    - [[Additional Capabilities - 271][Additional Capabilities - 271]]
  - [[Performing File System Tasks with Files - 273][Performing File System Tasks with Files - 273]]
    - [[Accessing File Stores - 273][Accessing File Stores - 273]]
    - [[Managing Attributes - 276][Managing Attributes - 276]]
    - [[Managing Files and Directories - 305][Managing Files and Directories - 305]]
    - [[Managing Symbolic and Hard Links - 343][Managing Symbolic and Hard Links - 343]]
    - [[Walking the File Tree - 351][Walking the File Tree - 351]]
    - [[Working with Additional Capabilities - 370][Working with Additional Capabilities - 370]]
  - [[Using Path Matchers and Watch Services - 373][Using Path Matchers and Watch Services - 373]]
    - [[Matching Paths - 374][Matching Paths - 374]]
    - [[Watching Directories - 377][Watching Directories - 377]]
  - [[Summary - 386][Summary - 386]]
- [[Chapter 13: Asynchronous I/O - 387][Chapter 13: Asynchronous I/O - 387]]
  - [[Asynchronous I/O Overview - 388][Asynchronous I/O Overview - 388]]
  - [[Asynchronous File Channels - 390][Asynchronous File Channels - 390]]
  - [[Asynchronous Socket Channels - 395][Asynchronous Socket Channels - 395]]
    - [[AsynchronousServerSocketChannel - 396][AsynchronousServerSocketChannel - 396]]
    - [[AsynchronousSocketChannel - 403][AsynchronousSocketChannel - 403]]
  - [[Asynchronous Channel Groups - 410][Asynchronous Channel Groups - 410]]
    - [[What About AsynchronousFileChannel? - 413][What About AsynchronousFileChannel? - 413]]
  - [[Summary - 415][Summary - 415]]
- [[Chapter 14: Completion of Socket Channel Functionality - 417][Chapter 14: Completion of Socket Channel Functionality - 417]]
  - [[Binding and Option Configuration - 417][Binding and Option Configuration - 417]]
  - [[Channel-Based Multicasting - 422][Channel-Based Multicasting - 422]]
  - [[Summary - 428][Summary - 428]]
- [[Part V: Appendices - 429][Part V: Appendices - 429]]
- [[Appendix A: Answers to Exercises - 431][Appendix A: Answers to Exercises - 431]]
  - [[Chapter 1: I/O Basics and APIs - 431][Chapter 1: I/O Basics and APIs - 431]]
  - [[Chapter 2: File - 432][Chapter 2: File - 432]]
  - [[Chapter 3: RandomAccessFile - 435][Chapter 3: RandomAccessFile - 435]]
  - [[Chapter 4: Streams - 436][Chapter 4: Streams - 436]]
  - [[Chapter 5: Writers and Readers - 444][Chapter 5: Writers and Readers - 444]]
  - [[Chapter 6: Buffers - 446][Chapter 6: Buffers - 446]]
  - [[Chapter 7: Channels - 449][Chapter 7: Channels - 449]]
  - [[Chapter 8: Selectors - 453][Chapter 8: Selectors - 453]]
  - [[Chapter 9: Regular Expressions - 453][Chapter 9: Regular Expressions - 453]]
  - [[Chapter 10: Charsets - 455][Chapter 10: Charsets - 455]]
  - [[Chapter 11: Formatter - 457][Chapter 11: Formatter - 457]]
  - [[Chapter 12: Improved File System Interface - 458][Chapter 12: Improved File System Interface - 458]]
  - [[Chapter 13: Asynchronous I/O - 471][Chapter 13: Asynchronous I/O - 471]]
  - [[Chapter 14: Completion of Socket Channel Functionality - 475][Chapter 14: Completion of Socket Channel Functionality - 475]]
- [[Appendix B: Sockets and Network Interfaces - 481][Appendix B: Sockets and Network Interfaces - 481]]
  - [[Sockets - 482][Sockets - 482]]
    - [[Socket Addresses - 484][Socket Addresses - 484]]
    - [[Socket Options - 486][Socket Options - 486]]
    - [[Socket and ServerSocket - 488][Socket and ServerSocket - 488]]
    - [[DatagramSocket and MulticastSocket - 495][DatagramSocket and MulticastSocket - 495]]
  - [[Network Interfaces - 503][Network Interfaces - 503]]
  - [[Using Network Interfaces with Sockets - 511][Using Network Interfaces with Sockets - 511]]
- [[Index - 513][Index - 513]]

* About the Author - xv
* About the Technical Reviewers - xvii
* Acknowledgments - xix
* Introduction - xxi
  This book introduces Java's I/O capabilities as of Java 8 update 51.

  - Chapter 1
    A broad overview of Java's classic I/O, NIO, and NIO.2.

    You learn what each category offers in terms of its capabilities, and you
    also learn about concepts such as /paths/ and /Direct Memory Access/.

  - Chapter 2 ~ 5
    Cover *classic I/O* APIs.
    + ~File~

    + ~RandomAccessFile~ 

    along with /streams/ (including object *serialization* and *externalization*)
    and *writers/readers*.

  - Chapter 6 ~ 11
    *NIO*
    + /buffers/

    + /channels/

    + /selectors/

    + /regular expressions/

    + /charsets/

    + /formatters/, which were not introduced with the other NIO types in Java 1.4
      because they depend on the variable arguments capability that was
      introduced in Java 5.

  - Chapter 12 ~ 14
    *NIO.2*, which improves (add some features that NIO doesn't have but is
    really useful):
    + file system interface
    + asynchronous I/O
    + the completion of socket channel functionality

  - Appendix A
    The _answers and solutions_ to the exercises after every chapter.

  - Appendix B
    A tutorial on /sockets and network interfaces/.

    =TODO=
    =Read= =!!!=
    Although not directly related to I/O, they leverage I/O capabilities and are
    mentioned elsewhere in this book.

* Part I: Getting Started with I/O - 1
* DONE Chapter 1: I/O Basics and APIs - 3
  CLOSED: [2018-07-26 Thu 19:42]
   - *History*
     1. Java initial suite of I/O APIs and related architecture are known as
        classic I/O.

     2. Because modern operating systems feature newer I/O paradigms, which
        classic I/O doesn't support, new I/O (NIO) was introduced as part of JDK
        1.4 to support them.

     3. Lack of time prevented some planned NIO features from being included in
        this release, which led to these other NIO features being deferred to
        JDK 5 and JDK 7

** DONE Classic I/O - 3
   CLOSED: [2018-07-23 Mon 02:42]
   - JDK 1.0 introduced rudimentary I/O facilities for
     + *accessing* the /file system/, to
       * create a directory
       * remove a file
       * perform another task

     + *accessing* file content randomly (as _opposed to sequentially_);

     + *streaming* /byte-oriented data/ _between sources and destinations_ in a
       /sequential manner/.

*** DONE File System Access and the ~File~ Class - 3
    CLOSED: [2018-07-23 Mon 01:39]
    Chapter 2 explores the File class.
    =TODO=

*** DONE Accessing File Content via ~RandomAccessFile~ - 5
    CLOSED: [2018-07-23 Mon 01:51]
    - ~java.io.RandomAccessFile~ provides /random access/ to a /file/.
      #+BEGIN_SRC java
        val raf = new RandomAccessFile("employees.dat", "r");
        int empIndex = 10;
        raf.seek(empIndex * EMP_REC_LEN);
        // Read contents of employee record.
      #+END_SRC

    - Chapter 3 explores the ~RandomAccessFile~ /class/.
      =TODO=

*** DONE Streaming Data via Stream Classes - 5
    CLOSED: [2018-07-23 Mon 02:39]
    - stream :: an ordered sequence of bytes of arbitrary length.

    - Example:
      #+BEGIN_SRC java
        try (val fis = new FileInputStream("image.jpg"))
        {
            // Read bytes from file.
            int _byte;
            while ((_byte = fis.read()) != -1) // -1 signifies EOF
            {
                // Process _byte in some way.
            }
        }
        catch (IOException ioe)
        {
            // Handle exception.
        }
      #+END_SRC

    - Example (with /buffer/ for improving performance):
      #+BEGIN_SRC java
        try (val fis = new FileInputStream("image.jpg");
             val bis = new BufferedInputStream(fis))
        {
            // Read bytes from file.
            int _byte;
            while ((_byte = bis.read()) != -1) // -1 signifies EOF
            {
                // Process _byte in some way.
            }
        }
        catch (IOException ioe)
        {
            // Handle exception.
        }
      #+END_SRC

    - Chapter 4 expores the /stream classes/.
      =TODO=

**** DONE Stream Classes and Standard I/O - 5
     CLOSED: [2018-07-23 Mon 02:39]
     - Many operating systems support /standard I/O/, which is _preconnected_ /input
       and output data streams/ BETWEEN a _computer program_ AND _its environment_
       WHEN it begins execution.

       The /preconnected streams/ are known as /standard input/, /standard output/,
       and /standard error/.

     - /Standard input/ *defaults to reading* its input from the keyboard.

       /standard output/ and /standard error/ *default to writing* their output
       to the screen.

       However, these /streams/ can be *redirected* to read input from a
       different source and write output to a different destination (such as a
       file).

     - _JDK 1.0_ introduced support for /standard I\slash{}O/ by adding the ~in~, ~out~,
       and ~err~ objects of type ~InputStream~ and ~PrintStream~ to the ~java.lang.System~
       /class/. You specify /method/ calls on these objects to access /standard input/,
       /standard output/, and /standard error/, as follows:
       #+BEGIN_SRC java
         int ch = System.in.read(); // Read single character from standard input.
         System.out.println("Hello"); // Write string to standard output.
         System.err.println("I/O error: " +
                            ioe.getMessage()); // Write string to standard error.
       #+END_SRC

     - As well as exploring ~InputStream~ and ~PrintStream~,
       Chapter 4 also _revisits_ /standard I/O/ to show you how to
       _programmatically_ *redirect* these /streams/.

*** DONE JDK 1.1 and the Writer/Reader Classes - 8
    CLOSED: [2018-07-23 Mon 02:41]
    - JDK 1.0's I/O capabilities are suitable for _streaming bytes_,
      BUT _CANNOT_ properly _stream characters_ because they don't account for
      character encodings.

      JDK 1.1 overcame this problem by introducing /writer\slash{}reader classes/ that
      take /character encodings/ into account.
        For example, the ~java.io~ /package/ includes ~FileWriter~ and ~FileReader~
      /classes/ for writing and reading /character streams/.

    - Chapter 5 explores various /writer and reader classes/.
      =TODO=

** DONE NIO - 8
   CLOSED: [2018-07-26 Thu 19:01]
   - /Modern operating systems/ offer sophisticated I/O services (such as
     _readiness selection_ =???=) for *improving I/O performance and simplifying
     I/O*.

       /Java Specification Request (JSR) 51/ (www.jcp.org/en/jsr/detail?id=51) was
     created to address these capabilities.

   - JSR 51's description indicates that it provides APIs for
     + /scalable I\slash{}O/
     + /fast buffered binary and character I\slash{}O/
     + /regular expressions/
     + /charset conversion/.

     Collectively, these APIs are known as /NIO/.

   - _JDK 1.4_ *implemented* /NIO/ in terms of the following APIs:
     + Buffers
     + Channels
     + Selectors
     + Regular expressions
     + Charsets
     The /regular expression and charset APIs/ were provided to *simplify* _common
     I/O-related tasks_.

*** DONE Buffers - 9
    CLOSED: [2018-07-24 Tue 22:11]
    - /Buffers/ are the *foundation* for NIO operations.
      Essentially, NIO is _ALL about moving data INTO and OUT of buffers_.
      =IMPORTANT=
      + A process such as the JVM performs I/O by asking the OS to _drain_ a
        /buffer/'s contents to storage via a *write* operation.

      + Ask the OS to _fill_ a /buffer/ with data *read* from a storage device.

    - =TODO= NOTE =TODO=

    - Consider a read operation involving a disk drive.
      =TODO=

      1. The OS issues a command to the /disk controller/ to *read* a block of
         bytes _FROM_ a disk _INTO_ an /OS buffer/.

         Once this operation completes,
         the OS copies the /buffer/ contents to the /process buffer/ specified
         by the process when it issued a read() operation.

      2. In turn, the OS has requested to the /disk controller/ to *read* a block
         of bytes from the disk. The disk controller (also known as a DMA
         controller) reads these bytes directly into an operating system buffer
         via Direct Memory Access (DMA), a feature of computer systems that
         allows certain hardware subsystems to access main system (RAM) memory
         independently of the central processing unit (CPU). The operating
         system then copies these bytes to the process’s buffer.

    - Copying bytes _FROM_ the /OS buffer/ _TO_ the /process buffer/ is *NOT very
      efficient*.

        It would be _MORE performant_ to have the /DMA controller/ copy _directly_
      to the /process buffer/,

      _BUT there are *TWO problems* with this approach_:

      + The /DMA controller/ typically *CANNOT communicate directly* with the /user
        space/ in which the JVM process runs.
          Instead, it communicates with the OS's /kernel space/.

      + Block-oriented devices such as a /DMA controller/ work with _fixed-size data
        blocks_.
          IN CONTRAST,
        the /JVM process/ might request a size of data that is
        * *NOT a multiple* of the block size
          OR
        * that is /misaligned/.

      Because of these problems, the OS acts as an intermediary, _tearing apart_
      and _recombining_ data as it SWITCHES BETWEEN the /JVM process/ and the
      /DMA controller/.

    - =TODO= NOTE =TODO=

    - The data assembly/disassembly tasks can be made *more efficient* _BY_ letting
      the /JVM process/ *pass* _a list of buffer addresses_ *to* the OS in a SINGLE
      /system call/. The OS then *fills* or *drains* these /buffers/ in sequence,
      + *scattering* data *to* _MULTIPLE_ /buffers/ DURING a _read_ operation;
        OR
      + *gathering* data *from* SEVERAL /buffers/ DURING a _write_ operation.

      This scatter/gather activity
      *reduces* the number of (potentially expensive) /system calls/ that the JVM
      process must make
      _AND_
      lets the OS _optimize data handling_ because it knows the total amount of
      /buffer/ space.

      Furthermore, when _multiple processors or cores_ are available, the OS may
      allow /buffers/ to be _filled_ or _drained_ *SIMULTANEOUSLY*.

    - JDK 1.4's ~java.nio.Buffer~ /class/ abstracts the concept of a /JVM process
      buffer/. It serves as the /superclass/ for ~java.nio.ByteBuffer~ and /OTHER buffer
      classes/.

      Because I/O is fundamentally byte-oriented, *only* ~ByteBuffer~ instances can
      be used with /channels/ (which are discussed shortly).
        Most of the other ~Buffer~ /subclasses/ are *conveniences* for working with
      /multibyte data/ (such as /characters/ or /integers/).

    - =TODO=
      Chapter 6 explores the ~Buffer~ class and its children.

*** DONE Channels - 10
    CLOSED: [2018-07-25 Wed 11:36]
    - Forcing a CPU to perform I/O tasks and wait for I/O completions (such a
      CPU is said to be I/O bound) is *wasteful of this resource*.

      _Performance can be improved by offloading these tasks to DMA controllers
      so that the processor can get on with other work._

    - A /channel/ serves as a conduit for communicating (via the OS) with a /DMA
      controller/ to *efficiently* _drain byte_ buffers to or _fill byte_
      buffers from a disk.

    - JDK 1.4's ~java.nio.channels.Channel~ /interface/, its /subinterfaces/, and
      various /classes/ implement the /channel/ architecture.

    - One of these /classes/ is called ~java.nio.channels.FileChannel~, and it
      abstracts a /channel/ for _READING, WRITING, MAPPING, and MANIPULATING a
      file_.

      + One interesting feature of ~FileChannel~ is its support for /file locking/,
        upon which sophisticated applications such as database management systems
        rely.

        * /File locking/ lets a process *prevent* or *limit* access to a file while
          the process is accessing the file.

        * /File locking/ is often used to lock a region of a file, although it can
          be applied to an entire file.

        *A lock ranges from a starting byte offset in the file and continues for
        a specific number of bytes.*

      + Another interesting ~FileChannel~ feature is *memory-mapped file I/O via the
        ~map()~ method.* ~map()~ returns a ~java.nio.MappedByteBuffer~ whose content is
        a memory-mapped region of a file.
          File content is accessed via memory accesses; *buffer copies and read-write
        system calls are eliminated.*

    - You can obtain a /channel/ by calling the ~java.nio.channels.Channels~ /class/'s
      /methods/ or the methods in classic I/O classes such as ~RandomAccessFile~.

    - =TODO= Chapter 7 explores Channel, Channels, and more.

*** DONE Selectors - 11
    CLOSED: [2018-07-26 Thu 19:01]
    - I/O is classified as
      + /block-oriented/
        Example: Reading from or writing to a file.
        or
      + /stream-oriented/.
        Example: Reading from the keyboard or writing to a network connection.

    - /Stream I/O/ is *often slower* than /block I/O/.
      Further more, input tends to be _intermittent_.

      For example, the user might _pause_ while entering a /stream/ of characters
      or _momentary slowness_ in a network connection causes a playing video to
      proceed in a jerky fashion.

    - Many OS's allow /streams/ to be configured to operate in /nonblocking mode/
      in which a /thread/ continually checks for available input *WITHOUT blocking*
      when no input is available.
        The /thread/ can handle incoming data or perform other tasks until data
      arrives.

    - This "polling for available input" activity _can be *WASTEFUL*,_ especially
      when the /thread/ needs to monitor many input streams (such as in a web
      server context).

      Modern OS's can perform this checking _EFFICIENTLY_, which is known as
      /readiness selection/, and which is often built on top of /nonblocking mode/.
        The OS monitors a collection of /streams/ and returns an indication to the
      /thread/ of which /streams/ are ready to perform I/O.
        As a result, a single /thread/ can multiplex many active /streams/ via
      common code and makes it possible, in a web server context, to manage a
      huge number of network connections.

    - JDK 1.4 supports /readiness selection/ by providing /selectors/, which are
      instances of the ~java.nio.channels.Selector~ /class/ that can examine one
      or more /channels/ and determine which /channels/ are ready for reading or
      writing.
        This way a SINGLE /thread/ can manage MULTIPLE /channels/ (and, therefore,
      MULTIPLE network connections) *efficiently*. Being able to use *fewer* /threads/
      is advantageous where /thread/ creation and /thread/ context switching is
      expensive in terms of performance and/or memory use. See Figure 1-3.

      Figure 1-3. A thread manages three channels via a selector

    - =TODO= Chapter 8 explores Selector and its related types.

*** DONE Regular Expressions - 12
    CLOSED: [2018-07-23 Mon 03:07]
    - /Regular expressions/ were introduced as part of /NIO/.

    - =From Jian= This looks not that reasonable!
      Although you might wonder about the _rationale_ for doing this (what have
      /regular expressions/ got to do with I/O?), /regular expressions/ are commonly
      used to scan textual data that is read from a file or other source.

      The need to perform these scans as quickly as possible mandated their
      inclusion.

    - JDK 1.4 supports /regular expressions/ via the ~java.util.regex~ /package/
      and its ~Pattern~ and ~Matcher~ /classes/.

    - =TODO=
      Chapter 9 explores the ~Pattern~ and ~Matcher~ /classes/.

*** DONE Charsets - 13
    CLOSED: [2018-07-23 Mon 03:10]
    - I previously mentioned that JDK 1.1 introduced /writer/reader classes/ that
      take /character encodings/ into account.

    - Originally, /classes/ such as ~java.io.InputStreamReader~ worked with the
      ~java.io.ByteToCharConverter~ /class/ to perform *conversions based on
      encodings*.
        ~ByteToCharConverter~ was eventually *deprecated and removed from _JDK
      6_ and successors.*

    - In its place, the more capable ~java.nio.charset~ package along with its
      ~Charset~, ~CharsetEncoder~, ~CharsetDecoder~, and _related types_ was
      introduced.

    - =TODO=
      Chapter 10 explores the ~Charset~ /class/.

*** DONE Formatter - 13
    CLOSED: [2018-07-23 Mon 03:13]
    - /JSR 51/ mentions a simple printf-style formatting facility.

      Such a facility offers significant value in preparing data for
      presentation, to which many C programmers can attest.
        However, JDK 1.4 did *NOT* include this capability because it relies on
      /variable argument lists/, a language feature that did *NOT debut until
      JDK 5.*

      Fortunately, JDK 5 also included a ~java.util.Formatter~ /class/ with a
      wealth of formatting capabilities along with related types that support
      custom formatting, and added ~printf()~ (and related ~format()~) methods
      to the ~PrintStream~ /class/.

    - Chapter 11 explores ~Formatter~ and demonstrates ~printf()~.

** DONE NIO.2 - 13
   CLOSED: [2018-07-26 Thu 19:37]
   - /JSR 51/ specifies that NIO would *introduce an improved* /file system
     interface/ that *overcomes* various problems with the legacy ~File~
     /class/. *HOWEVER*,

     + lack of time prevented this feature from being included.

     + Also, it wasn't possible to support /asynchronous I\slash{}O/ and complete /socket
       channel/ functionality.

     /JSR 203/ (www.jcp.org/en/jsr/detail?id=203) was subsequently created to
     address these omissions, which debuted in *JDK 7*.

   - *NOTE* =TODO= =DETAILS=
     /big buffers (buffers with 64-bit addressability)/.

*** DONE Improved File System Interface - 14
    CLOSED: [2018-07-26 Thu 19:29]
    - The legacy ~File~ /class/ *suffers from various problems*.
      For example,
      + the ~renameTo()~ /method/ does *NOT* work *consistently* across OS's.
  
      + many of ~File~'s /methods/ do *NOT scale*;
        requesting a large directory listing from a server could result in a
        hang.

    - The _NEW_ /file system interface/ mentioned in /JSR 203/ fixes these and
      other problems.
      For example,
      + it
        * supports /bulk access/ to file attributes,
        * provides a change notification facility,
        * offers the ability to escape to file system-specific APIs, and
        * has a service provider interface for pluggable file system implementations.

       =TODO= Chapter 12 explores the improved file system interface.

*** DONE Asynchronous I/O - 14
    CLOSED: [2018-07-26 Thu 19:31]
    - =TODO= More notes

    - =TODO= Chapter 13 explores asynchronous I/O.

*** DONE Completion of Socket Channel Functionality - 14
    CLOSED: [2018-07-26 Thu 19:37]
    - /JDK 1.4/ added the ~DatagramChannel~, ~ServerSocketChannel~, and
      ~SocketChannel~ /classes/ to the ~java.nio.channels~ /package/.

      *HOWEVER*,
      + lack of time prevented these classes from supporting /binding/ and /option
        configuration/.

      + Also, /channel-based multicast/ datagrams were *not* supported.

    - /JDK 7/ added /binding/ support and /option configuration/ to the aforemen-
      tioned /classes/.

      Also, it introduced a new ~java.nio.channels.MulticastChannel~ interface.

    - =TODO= Chapter 14 explores the completion of socket channel functionality.

    - Exercises =???= =TODO=

** TODO Summary - 15

* Part II: Classic I/O APIs - 17
* TODO Chapter 2: ~File~ - 19
  - Applications often _interact_ with a /file system/, which is usually implemented
    as a hierarchy of files and directories starting from a root directory.

    OS's on which a JVM runs typically support *at least ONE* /file system/.
    For example,
    + _Unix/Linux_ combines all _mounted (attached and prepared) disks_ into one 
      /virtual file system/.

    + In contrast,
      _Windows_ associates a separate file system with each active disk drive.

  - Java offers access to the underlying OS's available file system(s) via its
    concrete ~java.io.File~ /class/, which this chapter explores.
    =TODO=

** DONE Constructing ~File~ Instances - 19
   CLOSED: [2018-07-26 Thu 20:19]
   - *NOTE*
     ~java.io~ use the property ~user.dir~ to identify the current working directory,
     which is usually the location where JVM launches.

     + You can obtain the /system property/ value by calling the ~java.lang.System~'s
       ~getProperty()~ /method/.

   - “\\” for a /Windows Universal Naming Convention (UNC)/ path,

   - *NOTE*
     The /default name-separator character/ is defined by the /system property/
     ~file.separator~ and is made available in ~File~'s ~public static separator~
     (of type ~String~) and ~separatorChar~ fields.

   - *TIP*
     Because ~File(String path)~, ~File(String parent, String child)~, and
     ~File(File parent, String child)~ _do *NOT* detect invalid path arguments_
     (apart from throwing a ~java.lang.NullPointerException~ when /path/ or /child/
     is ~null~), you must be careful when specifying paths.

** DONE Learning About Stored Abstract Paths - 22
   CLOSED: [2018-07-26 Thu 20:43]
   Methods
   - ~File getAbsoluteFile()~ is equivalent to ~new File(this.getAbsolutePath())~.

   - ~String getAbsolutePath()~

   - About "Canonical"
     Doing so typically involves
     + removing redundant names such as “.” and “..” from the path,

     + resolving symbolic links (on Unix/Linux operating systems),

     + converting drive letters to a standard case (on Windows operating systems).

     + This method throws ~IOException~ when an I/O error occurs (creating the
       /canonical path/ may require _file system queries_).

   - ~File getCanonicalFile()~

   - ~String getCanonicalPath()~

   - ~String getName()~
     The last part of the path saved in a ~File~ object.

   - ~String getParent()~
     Return ~null~ when this path doesn't name a /parent directory/.

   - ~File getParentFile()~

   - ~String getPath()~

   - ~boolean isAbsolute()~
     The definition of /absolute path/ is _system dependent_.
     + For Unix/Linux operating systems,
       a path is absolute when its prefix is ~"/"~.

     + For Windows operating systems,
       a path is absolute when its prefix is a drive
       specifier followed by ~"\"~ or when its prefix is ~"\\"~

   - ~String toString()~ is the synonym for ~getPath()~.

** DONE Learning About a Path's File or Directory - 25
   CLOSED: [2018-07-26 Thu 21:03]
   Methods
   - ~boolean exists()~

   - ~boolean isDirectory()~

   - ~boolean isFile()~

   - ~boolean isHidden()~

   - ~boolean lastModified()~
     Return the time that the file denoted by this File object's abstract path was
     last modified, or _0 when the file doesn't exist_ or an _I/O error occurred
     during this method call_.

     The returned value is measured in *milliseconds* since the /Unix epoch/
     (00:00:00 GMT, January 1, 1970)

   - ~boolean length()~

** DONE Listing File System Root Directories - 27
   CLOSED: [2018-07-26 Thu 20:50]
   The /static method/ ~listRoots()~ of ~File~ returns ~File[]~, which is OS
   dependent:

   - For Linux/Unix, the result only contains one element.

   - For Windows, the result contains all the dirves.

** TODO Obtaining Disk Space Information - 28
** TODO Listing Directories - 30
   - Methods
     + ~String[] list()~

     + ~String[] list(FilenameFilter filter)~

     + ~File[] listFiles()~

     + ~File[] listFiles(FileFilter filter)~

     + ~File[] listFiles(FilenameFilter filter)~

   - =TODO=

** TODO Creating/Modifying Files and Directories - 33
** TODO Setting and Getting Permissions - 37
** DONE Exploring Miscellaneous Capabilities - 39
   CLOSED: [2018-07-26 Thu 21:01]
   - Methods -- ~File~ implements ~java.lang.Comparable~ /interface/'s ~compareTo()~
     /method/ and overrides ~equals()~ and ~hashCode()~. 

     + ~int compareTo(File path)~
       Compare two paths lexicographically.
       The ordering defined by this /method/ depends on the underlying OS.
       + For Windows, alphabetic case is INSIGNIFICANT.

     + ~boolean equals(Object obj)~
       OS dependent.

     + ~int hashCode()~
       OS dependent.
       * On Unix/Linux operating systems, a path’s hash code equals the XOR
         of its path string’s hash code and decimal value 1234321.

       * On Windows operating systems, the hash code is the XOR of the lowercased
         path string's hash code and decimal value 1234321.


       The current locale (geographical, political, or cultural region) is *not
       taken into account when lowercasing the path string.*
       =From Jian= How can this happen?????? =???= =TODO=

** TODO Exercise - 41
** TODO Summary - 42

* TODO Chapter 3: ~RandomAccessFile~ - 43
** TODO Exploring ~RandomAccessFile~ - 43
   - /Constructors/:
     + They
       * *Create* and open a *new* ~file~ when it doesn't exist
         OR
       * *Open* an *existing* file.

     + ~RandomAccessFile(File file, String mode)~

     + ~RandomAccessFile(String path, String mode)~

   - The /mode/ can be ~"r"~, ~"rw"~, ~"rws"~, or ~"rwd"~.
     Otherwise an ~IllegalArgumentException~ is thrown.
     + ~"r"~
       Open a existing file for reading ONLY.

       Any attempt to write to the file results in a thrown instance of the
       ~java.io.IOException~.

     + ~"rw"~

     + ~"rws"~
       Each update to the file's *content must be written _synchronously_ to the
       underlying storage device*.
       =TODO= =???=

     + ~"rwd"~.
       Each update to the file's *content or /metadata/ must be written
       _synchronously_ to the underlying storage device*.
       =TODO= =???=

       * *Note*
         A file's /metadata/ is data about the file and _NOT_ the actual file
         contents. Examples of /metadata/ include
         + the file's _length_
           and
         + the _time_ the file was last modified.

   - The ~"rwd"~ and ~"rws"~ have guarantees when a file reside in the local
     storage device.

     *NO guarantee* is made when the file does NOT reside on a local device.

   - *Note*
     A file's /metadata/ is data about the file and _NOT_ the actual file
     contents. Examples of /metadata/ include
     + the file's _length_
       and
     + the _time_ the file was last modified.

   - =From Jian=
     It is obvious the guarantee from the ~"rwd"~ and ~"rws"~ have a cost.

   - *CAUTION*
     + Use ~"r"~ mode, you cannot create a file -- this is write, not read only.
       If you do this, you will get a ~FileNotFoundException~.

     + 

** TODO Using ~RandomAccessFile~ - 49
** TODO Summary - 57

* TODO Chapter 4: Streams - 59
  - Along with ~java.io.File~ and ~java.io.RandomAccessFile~, Java's classic I/O
    infrastructure provides /streams/ for performing I/O operations.

    + stream :: an ordered sequence of bytes of an ARBITRARY length.

    + Bytes flow over an output stream from an application to a destination and
      flow over an input stream from a source to an application.

  - Java provides /classes/ in the ~java.io~ /package/ that identify various /stream/
    destinations for _writing_ and _reading_; for example,
    + /byte arrays/
    + /files/
    + /thread pipes/.

  - =TODO= This chapter explores many of these /classes/.

** TODO Stream Classes Overview - 59
** TODO Touring the Stream Classes - 61
*** ~OutputStream~ and ~InputStream~ - 61
*** ~ByteArrayOutputStream~ and ~ByteArrayInputStream~ - 64
*** ~FileOutputStream~ and ~FileInputStream~ - 67
*** ~PipedOutputStream~ and ~PipedInputStream~ - 71
*** ~FilterOutputStream~ and ~FilterInputStream~ - 75
*** ~BufferedOutputStream~ and ~BufferedInputStream~ - 84
*** ~DataOutputStream~ and ~DataInputStream~ - 86
*** Object Serialization and Deserialization - 88
**** Default Serialization and Deserialization - 89
**** Custom Serialization and Deserialization - 95
**** Externalization - 101
*** ~PrintStream~ - 104

** TODO Revisiting Standard I/O - 107
** TODO Summary - 111

* TODO Chapter 5: Writers and Readers - 113
** ~Writer~ and ~Reader~ Classes Overview - 114
** ~Writer~ and ~Reader~ - 116
** ~OutputStreamWriter~ and ~InputStreamReader~ - 117
** ~FileWriter~ and ~FileReader~ - 119
** ~BufferedWriter~ and ~BufferedReader~ - 121
** Summary - 124

* Part III: New I/O APIs - 125
* TODO Chapter 6: Buffers - 127
** Introducing Buffers - 127
** ~Buffer~ and its Children - 128
** Buffers in Depth - 133
*** Buffer Creation - 133
*** Buffer Writing and Reading - 136
*** Flipping Buffers - 139
*** Marking Buffers - 141
*** Buffer Subclass Operations - 142
*** Byte Ordering - 143
*** Direct Byte Buffers - 145

** Summary - 147

* TODO Chapter 7: Channels - 149
** Introducing Channels - 149
** Channel and Its Children - 149
** Channels in Depth - 155
*** Scatter/Gather I/O - 155
*** File Channels - 158
*** Socket Channels - 179
*** Pipes - 195

** Summary - 201

* TODO Chapter 8: Selectors - 203
** Selector Fundamentals - 204
** Selector Demonstration - 209
** Summary - 214

* TODO Chapter 9: Regular Expressions - 215
** Pattern, PatternSyntaxException, and Matcher - 215
** Character Classes - 221
** Capturing Groups - 223
** Boundary Matchers and Zero-Length Matches - 224
** Quantifiers - 225
** Practical Regular Expressions - 228
** Summary - 230

* TODO Chapter 10: Charsets - 231
** A Brief Review of the Fundamentals - 231
** Working with Charsets - 232
** Charsets and the String Class - 239
** Summary - 241

* TODO Chapter 11: Formatter - 243
** Exploring ~Formatter~ - 243
** Exploring ~Formattable~ and ~FormattableFlags~ - 249
** Summary - 255

* Part IV: More New I/O APIs - 257
* TODO Chapter 12: Improved File System Interface - 259
** Architecting a Better File Class - 259
*** File Systems and File System Providers - 261

** Locating Files with Paths - 263
*** Getting a Path and Accessing Its Name Elements - 264
*** Relative and Absolute Paths - 267
*** Normalization, Relativization, and Resolution - 269
*** Additional Capabilities - 271

** Performing File System Tasks with Files - 273
*** Accessing File Stores - 273
*** Managing Attributes - 276
*** Managing Files and Directories - 305
*** Managing Symbolic and Hard Links - 343
*** Walking the File Tree - 351
*** Working with Additional Capabilities - 370

** Using Path Matchers and Watch Services - 373
*** Matching Paths - 374
*** Watching Directories - 377

** Summary - 386

* TODO Chapter 13: Asynchronous I/O - 387
** Asynchronous I/O Overview - 388
** Asynchronous File Channels - 390
** Asynchronous Socket Channels - 395
*** AsynchronousServerSocketChannel - 396
*** AsynchronousSocketChannel - 403

** Asynchronous Channel Groups - 410
*** What About AsynchronousFileChannel? - 413

** Summary - 415

* TODO Chapter 14: Completion of Socket Channel Functionality - 417
** Binding and Option Configuration - 417
** Channel-Based Multicasting - 422
** Summary - 428

* TODO Part V: Appendices - 429
* TODO Appendix A: Answers to Exercises - 431
** Chapter 1: I/O Basics and APIs - 431
** Chapter 2: File - 432
** Chapter 3: RandomAccessFile - 435
** Chapter 4: Streams - 436
** Chapter 5: Writers and Readers - 444
** Chapter 6: Buffers - 446
** Chapter 7: Channels - 449
** Chapter 8: Selectors - 453
** Chapter 9: Regular Expressions - 453
** Chapter 10: Charsets - 455
** Chapter 11: Formatter - 457
** Chapter 12: Improved File System Interface - 458
** Chapter 13: Asynchronous I/O - 471
** Chapter 14: Completion of Socket Channel Functionality - 475

* TODO Appendix B: Sockets and Network Interfaces - 481
** Sockets - 482
*** Socket Addresses - 484
*** Socket Options - 486
*** Socket and ServerSocket - 488
*** DatagramSocket and MulticastSocket - 495

** Network Interfaces - 503
** Using Network Interfaces with Sockets - 511

* TODO Index - 513
