#+TITLE: Java 8 Lambdas
#+SUBTITLE: Functional Programming for The Masses
#+VERSION: 2014
#+AUTHOR: Richard Warburton
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Preface - vii][Preface - vii]]
  - [[Why Should I Read This Book?][Why Should I Read This Book?]]
  - [[Who Should Read This Book?][Who Should Read This Book?]]
  - [[How to Read This Book][How to Read This Book]]
  - [[Conventions Used in This Book][Conventions Used in This Book]]
  - [[Using Code Examples][Using Code Examples]]
  - [[How to Contact Us][How to Contact Us]]
  - [[Achknowledgments][Achknowledgments]]
- [[1. Introduction - 1][1. Introduction - 1]]
  - [[Why Did They Need to Change Java Again? - 1][Why Did They Need to Change Java Again? - 1]]
  - [[What Is Functional Programming? - 2][What Is Functional Programming? - 2]]
  - [[Example Domain - 3][Example Domain - 3]]
- [[2. Lambda Expressions - 5][2. Lambda Expressions - 5]]
  - [[Your First Lambda Expression - 5][Your First Lambda Expression - 5]]
  - [[How to Spot a Lambda in a Haystack - 6][How to Spot a Lambda in a Haystack - 6]]
  - [[Using Values - 8][Using Values - 8]]
  - [[Functional Interfaces - 9][Functional Interfaces - 9]]
  - [[Type Inference - 11][Type Inference - 11]]
  - [[Key Points - 13][Key Points - 13]]
  - [[=Re-Do= Exercises - 14][=Re-Do= Exercises - 14]]
- [[3. Streams - 17][3. Streams - 17]]
  - [[From External Iteration to Internal Iteration - 17][From External Iteration to Internal Iteration - 17]]
  - [[What's Actually Going On - 20][What's Actually Going On - 20]]
  - [[Common Stream Operations - 21][Common Stream Operations - 21]]
    - [[~collect(toList())~ - 22][~collect(toList())~ - 22]]
    - [[~map~ - 22][~map~ - 22]]
    - [[~filter~ - 24][~filter~ - 24]]
    - [[~flatMap~ - 25][~flatMap~ - 25]]
    - [[~max~ and ~min~ - 26][~max~ and ~min~ - 26]]
    - [[A Common Pattern Appears - 27][A Common Pattern Appears - 27]]
    - [[~reduce~ - 28][~reduce~ - 28]]
    - [[Putting Operations Together - 30][Putting Operations Together - 30]]
  - [[Refactoring Legacy Code][Refactoring Legacy Code]]
  - [[Multiple Stream Calls][Multiple Stream Calls]]
  - [[Higher-Order Functions][Higher-Order Functions]]
  - [[Good Use of Lambda Expressions][Good Use of Lambda Expressions]]
  - [[Key Points][Key Points]]
  - [[Exercises][Exercises]]
  - [[Advanced Exercises][Advanced Exercises]]
- [[4. Libraries - 41][4. Libraries - 41]]
  - [[Using Lambda Expressions in Code - 41][Using Lambda Expressions in Code - 41]]
  - [[Primitives - 42][Primitives - 42]]
  - [[Overload Resolution - 45][Overload Resolution - 45]]
  - [[~@FunctionalInterface~ - 47][~@FunctionalInterface~ - 47]]
  - [[Binary Interface Compatibility - 47][Binary Interface Compatibility - 47]]
  - [[Default Methods - 48][Default Methods - 48]]
    - [[Default Methods and Subclassing - 49][Default Methods and Subclassing - 49]]
  - [[Multiple Inheritance - 52][Multiple Inheritance - 52]]
    - [[The Three Rules - 53][The Three Rules - 53]]
  - [[Tradeoffs - 54][Tradeoffs - 54]]
  - [[Static Methods on Interfaces - 54][Static Methods on Interfaces - 54]]
  - [[Optional - 55][Optional - 55]]
  - [[Key Points - 56][Key Points - 56]]
  - [[Exercises - 57][Exercises - 57]]
  - [[Open Exercises - 58][Open Exercises - 58]]
- [[5. Advanced Collections and Collectors - 59][5. Advanced Collections and Collectors - 59]]
  - [[Method References - 59][Method References - 59]]
  - [[Element Ordering - 60][Element Ordering - 60]]
  - [[Enter the Collector - 62][Enter the Collector - 62]]
    - [[Into Other Collections - 62][Into Other Collections - 62]]
    - [[To Values - 63][To Values - 63]]
    - [[Partitioning the Data - 64][Partitioning the Data - 64]]
    - [[Grouping the Data - 65][Grouping the Data - 65]]
    - [[Strings - 66][Strings - 66]]
    - [[Composing Collectors - 67][Composing Collectors - 67]]
    - [[Refactoring and Custom Collectors - 69][Refactoring and Custom Collectors - 69]]
    - [[Reduction as a Collector - 76][Reduction as a Collector - 76]]
  - [[Collection Niceties - 77][Collection Niceties - 77]]
  - [[Key Points - 78][Key Points - 78]]
  - [[Exercises - 78][Exercises - 78]]
- [[6. Data Parallelism - 81][6. Data Parallelism - 81]]
  - [[Parallelism Versus Concurrency - 81][Parallelism Versus Concurrency - 81]]
  - [[Why Is Parallelism Important? - 83][Why Is Parallelism Important? - 83]]
  - [[Parallel Stream Operations - 83][Parallel Stream Operations - 83]]
  - [[Simulations - 85][Simulations - 85]]
  - [[Caveats - 88][Caveats - 88]]
  - [[Performance - 89][Performance - 89]]
  - [[Parallel Array Operations - 92][Parallel Array Operations - 92]]
  - [[Key Points - 94][Key Points - 94]]
  - [[Exercises - 94][Exercises - 94]]
- [[7. Testing, Debugging, and Refactoring - 97][7. Testing, Debugging, and Refactoring - 97]]
  - [[Lambda Refactoring Candidates - 97][Lambda Refactoring Candidates - 97]]
    - [[In, Out, In, Out, Shake It All About - 98][In, Out, In, Out, Shake It All About - 98]]
    - [[The Lonely Override - 98][The Lonely Override - 98]]
    - [[Behavioral Write Everything Twice - 99][Behavioral Write Everything Twice - 99]]
  - [[Unit Testing Lambda Expressions - 102][Unit Testing Lambda Expressions - 102]]
  - [[Using Lambda Expressions in Test Doubles - 105][Using Lambda Expressions in Test Doubles - 105]]
  - [[Lazy Evaluation Versus Debugging - 106][Lazy Evaluation Versus Debugging - 106]]
  - [[Logging and Printing - 106][Logging and Printing - 106]]
  - [[The Solution: peek - 107][The Solution: peek - 107]]
  - [[Midstream Breakpoints - 107][Midstream Breakpoints - 107]]
  - [[Key Points - 108][Key Points - 108]]
- [[8. Design and Architectural Principles -109][8. Design and Architectural Principles -109]]
  - [[Lambda-Enabled Design Patterns - 110][Lambda-Enabled Design Patterns - 110]]
    - [[Command Pattern - 110][Command Pattern - 110]]
    - [[Strategy Pattern - 114][Strategy Pattern - 114]]
    - [[Observer Pattern - 117][Observer Pattern - 117]]
    - [[Template Method Pattern - 119][Template Method Pattern - 119]]
  - [[Lambda-Enabled Domain-Specific Languages - 123][Lambda-Enabled Domain-Specific Languages - 123]]
    - [[A DSL in Java - 124][A DSL in Java - 124]]
    - [[How We Got There - 125][How We Got There - 125]]
    - [[Evaluation - 127][Evaluation - 127]]
  - [[Lambda-Enabled SOLID Principles - 127][Lambda-Enabled SOLID Principles - 127]]
    - [[The Single Responsibility Principle - 128][The Single Responsibility Principle - 128]]
    - [[The Open/Closed Principle - 130][The Open/Closed Principle - 130]]
    - [[The Dependency Inversion Principle - 134][The Dependency Inversion Principle - 134]]
  - [[Further Reading - 137][Further Reading - 137]]
  - [[Key Points - 137][Key Points - 137]]
- [[9. Lambda-Enabled Concurrency - 139][9. Lambda-Enabled Concurrency - 139]]
  - [[Why Use Nonblocking I/O? - 139][Why Use Nonblocking I/O? - 139]]
  - [[Callbacks - 140][Callbacks - 140]]
  - [[Message Passing Architectures - 144][Message Passing Architectures - 144]]
  - [[The Pyramid of Doom - 145][The Pyramid of Doom - 145]]
  - [[Futures - 147][Futures - 147]]
  - [[Completable Futures - 149][Completable Futures - 149]]
  - [[Reactive Programming - 152][Reactive Programming - 152]]
  - [[When and Where - 155][When and Where - 155]]
  - [[Key Points - 155][Key Points - 155]]
  - [[Exercises - 156][Exercises - 156]]
- [[10. Moving Forward - 159][10. Moving Forward - 159]]
- [[Index - 161][Index - 161]]

* DONE Preface - vii
  CLOSED: [2017-09-20 Wed 20:09]
  =Useless words=
** DONE Why Should I Read This Book?
   CLOSED: [2017-09-20 Wed 19:15]
   In this book we'll explore:
   - How to write simpler, cleaner, and easier-to-read code—especially around
     collections

   - How to easily use parallelism to improve performance

   - How to model your domain more accurately and build better DSLs

   - How to write less error-prone and simpler concurrent code

   - How to test and debug your lambda expressions

** DONE Who Should Read This Book?
   CLOSED: [2017-09-20 Wed 19:28]
   =NOTHING=

** DONE How to Read This Book
   CLOSED: [2017-09-20 Wed 19:28]
   - Chapters 2 through 6 cover the core language changes and also the improved
     libraries that JDK 8 brings.

   - The final three chapters are about applying functional programming in the wild.
     + Chapter 7:
       talk about a few tricks that make testing and debugging code a bit easier.

     + Chapter 8:
       explains how existing principles of good software design also apply to
       lambda expressions.

     + Chapter 9:
       Then I talk about concurrency and how to use lambda expressions to write
       concurrent code that's easy to understand and maintain.

     These chapters also introduce _third-party libraries_, where relevant.

** DONE Conventions Used in This Book
   CLOSED: [2017-09-20 Wed 19:29]

** DONE Using Code Examples
   CLOSED: [2017-09-20 Wed 20:00]

** DONE How to Contact Us
   CLOSED: [2017-09-20 Wed 19:14]

** DONE Achknowledgments
   CLOSED: [2017-09-20 Wed 19:14]

* DONE 1. Introduction - 1
  CLOSED: [2017-09-20 Wed 20:09]
** DONE Why Did They Need to Change Java Again? - 1
   CLOSED: [2017-09-20 Wed 20:07]
   =TODO=
   Java 8 allows you to write complex collection-processing algorithms, and
   simply by changing a single method call you can efficiently execute this code
   on multicore CPUs.

** DONE What Is Functional Programming? - 2
   CLOSED: [2017-09-20 Wed 20:07]
   =USELESS WORDS=

** DONE Example Domain - 3
   CLOSED: [2017-09-20 Wed 20:09]
   Throughout the book, examples are structured around a common problem domain:
   music. Specifically, the examples represent the kind of information you might
   see on albums. Here’s a brief summary of the terms:

   - Artist :: An individual or group who creates music
     + name :: The name of the artist (e.g., “The Beatles”)
     + members :: A set of other artists who comprise this group (e.g.,
                  “John Lennon”); this field might be empty
     + origin :: The primary location of origin of the group (e.g., “Liverpool”)

   - Track :: A single piece of music
     + name :: The name of the track (e.g., “Yellow Submarine”)

   - Album :: A single release of music, comprising several tracks
     + name :: The name of the album (e.g., “Revolver”)
     + tracks :: A list of tracks
     + musicians :: A list of artists who helped create the music on this album

* DONE 2. Lambda Expressions - 5
  CLOSED: [2017-09-20 Wed 22:26]
** DONE Your First Lambda Expression - 5
   CLOSED: [2017-09-20 Wed 20:24]
   - The First Example:
     + Old and redundant
       #+BEGIN_SRC java
         button.addActionLis(new ActionListener() {
                 public void actionPerformed(ActionEvent event) {
                     System.out.println("button clicked");
                 }
             });
       #+END_SRC

     + New and concise
       #+BEGIN_SRC java
         button.addActionLis(event -> System.out.println("button clicked"));
       #+END_SRC
       * Here ~javac~ can infer the type of ~event~.
       * However, ~javac~ can't always figure the type(s) out, and sometime you
         need to provide the type info.

** DONE How to Spot a Lambda in a Haystack - 6
   CLOSED: [2017-09-20 Wed 20:44]
   - Example 2-3. Some different ways of writting (not in-place) lambda
     expressions
     #+BEGIN_SRC java
       Runnable noArguments = () -> System.out.println("Hello World");

       ActionListener oneArgument = event ->  System.out.println("button clicked");

       Runnable multiStatement = () -> {
           System.out.print("Hello");
           System.out.println(" World");
       };

       BinaryOperator<Long> add = (x, y) -> x + y;

       BinaryOperator<Long> addExplicity = (long x, long y) -> x + y;
     #+END_SRC

     + One thing should be noticed:
       When assign a lambda expression to a variable, we annotate this varable
       * with certain interface, which has an abstact method that can be repre-
         sented by this lambda expression.

       * _Rather than_ the return type of the body of this lambda expression.

     + If you want to explicitly write the type of a parameter of a lambda
       expression, you need parentheses -- even if you only have one parameter.

   - What is implicit in all these examples is that a lambda expression's type is
     _context dependent_.
     =IMPORTANT=

   - This /target typing/ is NOT entirely new, either. For example,
     + Example 2-4, the types of /array initializers/ in Java have always been
       inferred from their contexts.
       ~String[] array = {"hello", "world"};~

     + ~null~
       You can know what the type of ~null~ is only once you actually assign it
       to something.

** DONE Using Values - 8
   CLOSED: [2017-09-20 Wed 21:02]
   - When you've used /anonymous inner classes/ in the past, you've probably
     encountered a situation in which you wanted to use a variable from the
     surrounding method. In order to do so, you had to make the variable
     ~final~.
     #+BEGIN_SRC java
       // Example 2-5. A final local variable being captured by an anonymous inner class

       final String name = getUserName();

       button.addActionListener(new ActionListener() {
               public void actionPerformed(ActionEvent event) {
                   System.out.println("hi " + name);
               }
           });
     #+END_SRC

   - This restriction is relaxed a bit in Java 8:
     It's possible to refer to variables that aren't ~final~;
     however, they still have to be /effectively final/.

     Although you haven't declared the variable(s) as ~final~, you still _CANNOT_
     use them as nonfinal variable(s) if they are to be used in lambda
     expressions, or else the compiler will show an error.

     An example with compling error.
     #+BEGIN_SRC java
       // Example 2-7. Fails to compile due to the use of a not effectively final variable

       String name = getUserName();

       name = formatUserName(name);

       button.addActionListener(event -> System.out.println("hi " + name));
     #+END_SRC

   - Consider this /effectively final/ restriction this way:
     the lambda capture /values/, not /variables/.

   - There has been much _DEBATE_ over whether Java really has closures,
     because you can refer to _ONLY_ /effectively final/ variables.

   - /functional interfaces/

** DONE Functional Interfaces - 9
   CLOSED: [2017-09-20 Wed 21:45]
   - functional interface :: an interface with a SINGLE /abstract method/ that is
        used as the type of a lambda expression.

   - Before Java 8, people use one method anonymous class instance, whose class
     implements the required (now called /functional interface/) interface. This
     instance is used to represent an operation that can be reused in the caller.

     Now we use lambda expression which implements the only method of certain
     /functional interfaces/.

   - Table 2-1. Important functional interfaces in Java
     | Interface name      | Arguments | Returns |
     |---------------------+-----------+---------|
     | ~Predicate<T>~      | T         | boolean |
     | ~Consumer<T>~       | T         | void    |
     | ~Function<T,R>~     | T         | R       |
     | ~Supplier<T>~       | None      | T       |
     | ~UnaryOperator<T>~  | T         | T       |
     | ~BinaryOperator<T>~ | (T, T)    | T       |

** DONE Type Inference - 11
   CLOSED: [2017-09-20 Wed 22:01]
   - The /type inference/ used in lambdas is actually an EXTENSION of the
     /target type inference/ introduced in Java 7.

     Java 7 allows you to use a /diamond operator/ that asks ~javac~ to infer the
     generic arguments for you.

     #+BEGIN_SRC java
       // Example 2-9. Diamond inference for variables

       Map<String, Integer> oldWordCounts = new HashMap<String, Integer>();

       Map<String, Integer> diamondWordCounts = new HashMap<>();
     #+END_SRC

   - The ~Predicate<T>~ /functional interface/:
     #+BEGIN_SRC java
       public interface Predicate<T> {
           boolean test(T t);
       }
     #+END_SRC

   - The inference is smart, but if it doesn't have enough information, it won't
     be able to make the right decision.
     #+BEGIN_SRC java
       // Right
       BinaryOperator<Long> addLongs = (x, y) -> x + y;

       // Wrong
       BinaryOperator addLongs = (x, y) -> x + y;
     #+END_SRC

     The 2nd version has missing generics, and ~javac~ will take the ~Object~ as
     default, and ~Object~ has NO ~+~ operation. The error message will be:
     =Operator '&#x002B;' cannot be applied to java.lang.Object, java.lang.Object.=

   - =TODO=
     We will return to the topic of type inference and its interaction with
     method overloading in “Overload Resolution” on page 45, but there’s no need
     to understand more detail until then.

** DONE Key Points - 13
   CLOSED: [2017-09-20 Wed 22:02]
   - x
** DONE =Re-Do= Exercises - 14
   CLOSED: [2017-09-20 Wed 22:26]
   - x

* DONE 3. Streams - 17
  CLOSED: [2017-09-21 Thu 21:42]
  The most important core library changes are focused around the Collections API
  and its new addition: /streams/.
    /Streams/ allow us to write collections-processing code at a higher level of
  abstraction.

** DONE From External Iteration to Internal Iteration - 17
   CLOSED: [2017-09-21 Thu 01:40]
   #+BEGIN_SRC java
     int count = 0;

     for (Artist artist : allArtists) {
         if (artist.isForm("London")) {
             count++;
         }
     }
   #+END_SRC

   - Traditional iterations -- use ~for~ or /foreach/ -- has a lot of problems:
     + A lot of boilerplate code that need to be written every time you want to
       iterate over the collections.

     + It's hard to write a parallel version -- you need to rewrite every ~for~ (
       /foreach/) iteration individually in order to make them operate in
       parallel -- NO universal pattern.

     + The code here doesn't fluently convey the intent of the programmer.

   - With /stream/:
     #+BEGIN_SRC java
       long count = allArtists.stream()
           .filter(artist -> artist.isFrom("London"))
           .count();
     #+END_SRC

   - /external iteration/ and /internal iteration/ ??? =TODO=

** DONE What's Actually Going On - 20
   CLOSED: [2017-09-21 Thu 01:56]
   - In the code mentioned in the last section
     #+BEGIN_SRC java
       long count = allArtists.stream()
           .filter(artist -> artist.isFrom("London"))
           .count();
     #+END_SRC
     + methods like ~filter~ in the middle is /lazy/

     + methods like ~count~ that generate a final value out of the ~Stream~ se-
       quence are called /eager/.

   - It's very easy to figure out whether an operation is /eager/ or /lazy/:
     look at what it returns.

     + If it gives you back a ~Stream~, it's /lazy/;
     + if it gives you back another value or ~void~, then it's /eager/.

   - If these code terminate in the step of ~filter~, since it returns a
     ~Stream~, nothing will be printed out.
     #+BEGIN_SRC java
       // Without being printed out strings
       long count = allArtists.stream()
           .filter(artist -> {
                   system.out.println(artist.getName());
                   return artistt.isFrom("London");
               });


       // With being printed out strings
       long count = allArtists.stream()
           .filter(artist -> {
                   system.out.println(artist.getName());
                   return artistt.isFrom("London");
               })
           .count();
     #+END_SRC

** DONE Common Stream Operations - 21
   CLOSED: [2017-09-21 Thu 18:32]
   =IMPORTANT= =TODO= Read the javadoc API of the ~Stream~.
*** DONE ~collect(toList())~ - 22
    CLOSED: [2017-09-21 Thu 02:04]
    - /eager/

    - Example:
      #+BEGIN_SRC java
        List<String> collected = Stream.of("a", "b", "c")
            .collect(Collectors.toList());

        assertEquals(Arrays.asList("a", "b", "c"), collected);
      #+END_SRC

*** DONE ~map~ - 22
    CLOSED: [2017-09-21 Thu 02:09]
    #+BEGIN_SRC java
      List<String> collected = new ArrayList<>();

      for (String string : artist("a", "b", "hello")) {
          String uppercaseString = string, toUpperCase();
          collected.add(uppercaseString);
      }

      assertEquals(asList("A", "B", "HELLO"), collected).
    #+END_SRC

    #+BEGIN_SRC java
      // Example 3-9. Converting strings to uppercase equivalents using map
      List<String> collected = Stream.of("a", "b", "hello")
          .map(string -> string.toUpperCase())
          .collect(toList());

      assertEquals(asList("A", "B", "HELLO"), collected);
    #+END_SRC
*** DONE ~filter~ - 24
    CLOSED: [2017-09-21 Thu 17:51]
    #+BEGIN_SRC java
      // Example 3-11. Functional style

      List<String> beginningWithNumbers
          = Stream.of("a", "1abc", "abc1")
          .filter(value -> isDigit(value.charAt(0)))
          .collect(toList());

      assertEquals(asList("1abc"), beginningWithNumbers);
    #+END_SRC

*** DONE ~flatMap~ - 25
    CLOSED: [2017-09-21 Thu 17:54]
    #+BEGIN_SRC java
      // Example 3-12. Stream list

      List<Integer> together = Stream.of(asList(1, 2), asList(3, 4))
          .flatMap(numbers -> numbers.stream())
          .collect(toList());

      assertEquals(asList(1, 2, 3, 4), together);
    #+END_SRC

*** DONE ~max~ and ~min~ - 26
    CLOSED: [2017-09-21 Thu 17:59]
    #+BEGIN_SRC java
      // Example 3-13. Finding the shortest track with streams

      List<Track> tracks = asList(new Track("Bakai", 524),
                                  new Track("Violets for Your Furs", 378),
                                  new Track("Time Was", 451));

      Track shortestTrack = tracks.stream()
          .min(Comparator.comparing(track -> track.getLength()))
          .get();

      assertEquals(tracks.get(1), shortestTrack);
    #+END_SRC

    - ~get()~ is a method of ~Optional<T>~

*** DONE A Common Pattern Appears - 27
    CLOSED: [2017-09-21 Thu 18:01]
    Use loops to represent some stream operations above.
    
*** DONE ~reduce~ - 28
    CLOSED: [2017-09-21 Thu 18:16]
    #+BEGIN_SRC java
      // Example 3-16. Implementing sum using reduce
      int count = Stream.of(1, 2, 3)
          .reduce(0, (acc, element) -> acc + element);

      assertEquals(6, count);


      // Example 3-17. Expanding the application of reduce
      BinaryOperator<Integer> accumulator = (acc, element) -> acc + element;
      int count = accumulator.apply(
                      accumulator.apply(
                          accumulator.apply(0, 1),
                          2),
                      3);
    #+END_SRC

*** DONE Putting Operations Together - 30
    CLOSED: [2017-09-21 Thu 18:32]
    Now is probably a good time to think about whether you really want to expose
    ~List~ and ~Set~ objects in your domain model, though.
      Perhaps a ~Stream~ factory would be a better choice.

    The big win of only exposing collections via ~Stream~ is that it _better
    encapsulates_ your domain model's data structure. It's IMPOSSIBLE for any use
    of your domain classes to affect the inner workings of your ~List~ or ~Set~
    simply by exposing a ~Stream~.

    =TODO= the last paragraph
    It also encourages users of your domain class to write code in a more modern
    Java 8 style. It’s possible to incrementally

** DONE Refactoring Legacy Code
   CLOSED: [2017-09-21 Thu 18:34]
   #+BEGIN_SRC java
     public Set<String> findLongTracks(List<Album> albums) {
         Set<String> trackNames = new HashSet<>();
         for(Album album : albums) {
             for (Track track : album.getTrackList()) {
                 if (track.getLength() > 60) {
                     String name = track.getName();
                     trackNames.add(name);
                 }
             }
         }
         return trackNames;
     }


     public Set<String> findLongTracks(List<Album> albums) {
         return albums.stream()
             .flatMap(album -> album.getTracks())
             .filter(track -> track.getLength() > 60)
             .map(track -> track.getName())
             .collect(toSet());
     }
   #+END_SRC

** DONE Multiple Stream Calls
   CLOSED: [2017-09-21 Thu 18:55]
   Why a chainning stream call is usually much better than multiple stream calls
   (with intermediate variables):
   - It's harder to read what's going on because the ratio of boilerplate code to
     actual business logic is worse (=From Jian= NOT always).

   - It's less efficient because it requires eagerly creating new collection
     objects at each intermediate step.

   - It clutters your method with meaningless garbage variables that are needed
     only as intermediate results (=From Jian= if not "ONLY", it's OK).

   - It makes operations harder to automatically parallelize.
     =TODO=

** DONE Higher-Order Functions
   CLOSED: [2017-09-21 Thu 18:57]
** DONE Good Use of Lambda Expressions
   CLOSED: [2017-09-21 Thu 19:01]
** TODO Key Points
** TODO Exercises
   1. 
   2. 
   3. 
   4. 
   5. 
   6. 
   7. 

** TODO Advanced Exercises
   1. 
   2. 

* DONE 4. Libraries - 41
  CLOSED: [2017-10-03 Tue 01:22]
  - We've talked about how to WRITE lambda expressions.
    We'll talk about how to USE lambda expressions.

  - Another Java 8 change:
    /interfaces/ now can have /default methods/ and /static methods/.

** TODO Using Lambda Expressions in Code - 41
** TODO Primitives - 42
   - =RE-Read=

   - /boxed type/

   - /boxing/

   - /unboxing/

   - Only the ~int~, ~long~, and ~double~ types have been chosen as the focus of
     the primitive specialization implementation in Java 8 because the impact is
     most noticeable in numerical algorithms.

   - The primitive specializations have a very clear-cut _naming convention_:
     + If the _return type_ is a primitive, the interface is prefixed with =To= and
       the primitive type, as in ~ToLongFunction~ (shown in Figure 4-1).

     + If the _argument type_ is a primitive type, the name PREFIX is just the
       type name, as in ~LongFunction~ (Figure 4-2). If the higher-order function
       uses a primitive type, it is suffixed with =To= and the primitive type, as
       in ~mapToLong~.

   - =TODO=

** DONE Overload Resolution - 45
   CLOSED: [2017-10-03 Tue 01:22]
   Before the introduction of /lambda expressions/, for overloadings like the
   code below, we choose the most specific one.
   #+BEGIN_SRC java
     // overloadedMethod("abc")

     private void overloadedMethod(Object o) {
         System.out.print("Object");
     }
     private void overloadedMethod(String s) {
         System.out.print("String");
     }
   #+END_SRC

   For /lambda expressions/ we follow similar rules. 
   In summary, the parameter types of a lambda are inferred from the target type,
   and the inference follows these rules:

   - If there is a single possible target type, the lambda expression infers the
     type from the corresponding argument on the functional interface.

   - If there are several possible target types, the most specific type is
     inferred.
     #+BEGIN_SRC java
       private interface IntegerBiFunction extends BinaryOperator<Integer> {
       }

       private void overloadedMethod(BinaryOperator<Integer> lambda) {
           System.out.print("BinaryOperator");
       }

       private void overloadedMethod(IntegerBiFunction lambda) {
           System.out.print("IntegerBinaryOperator");
       }

       // overloadedMethod((x, y) -> x + y);
       // // The second one, which has the parameter type `IntegerBiFunction`, will be
       // // picked.

     #+END_SRC

   - If there are several possible target types and there is no most specific
     type, you must manually provide a type.
     #+BEGIN_SRC java
       private interface IntPredicate {
           public boolean test(int value);
       }

       private void overloadedMethod(Predicate<Integer> predicate) {
           System.out.print("Predicate");
       }

       private void overloadedMethod(IntPredicate predicate) {
           System.out.print("IntPredicate");
       }


       // overloadedMethod((x) -> true);
       // // `javac` cannot make a choice. There is no `extends` relation between
       // // `Predicate<Integer>` and `IntPredicate`, and we can NOT say which one is
       // // more specific.
     #+END_SRC

** DONE ~@FunctionalInterface~ - 47
   CLOSED: [2017-10-03 Tue 01:03]
   - Some single method interfaces are NOT designed as /functional interfaces/.

   - Non-functional interface examples:
     Some interfaces that might assume the object has internal state and be
     interfaces with a single method only coincidentally (~java.lang.Comparable~
     and ~java.io.Closeable~).

   - Functional interface examples:
     In contrast to ~Closeable~ and ~Comparable~,
     all the new interfaces introduced in order to provide ~Stream~ interoperabi-
     -lity are expected to be implemented by lambda expressions -- they are
     really there to bundle up blocks of code as data. Consequently, they have
     the ~@FunctionalInterface~ annotation applied.

   - With the ~@FunctionalInterface~ annotation, ~javac~ will help you to check
     if the annotated interface satisfy the criteria.

** DONE Binary Interface Compatibility - 47
   CLOSED: [2017-10-03 Tue 00:53]
** DONE Default Methods - 48
   CLOSED: [2017-10-03 Tue 00:01]
   - ~Collection~ has a new ~stream~ /default method/.

   - ~Iterable~ has a new ~forEach~ /default method/:
     #+BEGIN_SRC java
       default void forEach(Consumer<? super T> action) {
           for (T t: this) {
               action.accept(t);
           }
       }
     #+END_SRC

   - Other than the addition of a new keyword, ~default~ methods also have
     slightly different inheritance rules to regular methods.
     (=From Jian= Next section)

   - The other big difference is that, UNLIKE classes, /interfaces/ do NOT have
     instance fields, so /default methods/ can modify their child classes
     _only by calling methods on them_.
       This helps you avoid making assumptions about the implementation of their
     children.

*** DONE Default Methods and Subclassing - 49
    CLOSED: [2017-10-03 Tue 00:02]
    There are some subtleties about the way that ~default~ methods override and
    can be overridden by other methods.

    Put simply: class wins.
    =IMPORTANT= See the example.

    The motivation for this decision is that ~default~ methods are designed
    primarily to allow binary compatible API evolution.

    =From Jian=
    =Quote from the section "Binary Interface Compatibility"=
    In a new version of Java, we add a new method ~m~ to an existing interface
    ~I~. For some code written in OLD Java, there are some class ~OC~ that
    implements OLD ~I~, and not implements method ~m~. If we don't provide
    /default method/, the binary interface compatibility will be broken.

    Allowing classes to win over ANY /default methods/ simplifies a lot of
    inheritance scenarios.

** DONE Multiple Inheritance - 52
   CLOSED: [2017-10-03 Tue 00:53]
   Example
   #+BEGIN_SRC java
     public interface Jukebox {
         public default String rock() {
             return "... all over the world!";
         }
     }

     public interface Carriage {
         public default String rock() {
             return "... from side to side";
         }
     }

     public class MusicalCarriage implements Carriage, Jukebox {
         @Override
         public String rock() {
             return Carriage.super.rock();
         }
     }
   #+END_SRC
   - If there is no implementation for ~rock~, we'll see an compile error:
     =class MusicalCarriage inherits unrelated defaults for rock() from types
      Carriage and Jukebox.=

   - The usage of the ~super~ method.

*** The Three Rules - 53
    1. Any class wins over any interface.

    2. Subtype wins over supertype.

    3. No rule 3.
       If the previous two rules don’t give us the answer, the subclass must
       either implement the method or declare it abstract.

    _Rule 1 is what brings us compatibility with old code._

** DONE Tradeoffs - 54
   CLOSED: [2017-10-02 Mon 16:53]
   - =From Jian=
     What is the difference between:
     + /interface/
     + /trait/ (in other languages)
     + /abstract class/

   - Distinction between /interfaces/ and /abstract classes/:
     + interfaces:
       * multiple implementation
       * can inherit /default methods/ from MULTIPLE interfaces.
       * cannot inherit fields

     + abstract classes:
       * single inherit
       * can inherit fields

** DONE Static Methods on Interfaces - 54
   CLOSED: [2017-10-02 Mon 15:36]
   - Start from Java 8, you can put non-abstract static methods inside interfaces.

   - Sometimes a class can be an appropriate location for utility code, such as
     the ~Objects~ class introduced in Java 7 that contained functionality that was
     _NOT specific_ to any particular class.

   - There are often good semantic reasons for a method to relate to a concept,
     then it should always be put in the same class or interface rather than
     hidden in a utility class to the side (Before Java 8, people have to do
     make utility classes due to the syntax requirement that interfaces CANNOT
     contain concrete code.

** DONE Optional - 55
   CLOSED: [2017-10-02 Mon 15:35]
   #+BEGIN_SRC java
     Optional<String> a = Optional.of("a");
     assertEquals("a", a.get());

     Optional emptyOptional = Optional.empty();
     Optional alsoEmpty = Optional.ofNullable(null);
     assertFalse(emptyOptional.isPresent());
     assertTrue(a.isPresent());

     assertEquals("b", emptyOptional.orElse("b"));
     assertEquals("c", emptyOptional.orElseGet(() -> "c"));
   #+END_SRC
   
** DONE Key Points - 56
   CLOSED: [2017-10-03 Tue 01:06]
   - A significant _performance advantage_ can be had by using primitive
     _SPECIALIZED_ lambda expressions and /streams/ such as ~IntStream~.

   - /Default methods/ are methods with bodies on interfaces prefixed with the
     keyword ~default~.

   - The ~Optional~ class lets you avoid using ~null~ by modeling situations
     where a value may not be present.

** TODO Exercises - 57
** TODO Open Exercises - 58

* TODO 5. Advanced Collections and Collectors - 59
  - New ~Collector~ abstraction.

  - /method references/

  - More advanced topics within the collections library
    + element ordering within streams
    + other useful API changes

** DONE Method References - 59
   CLOSED: [2017-10-03 Tue 21:58]
   - ~artist -> artist.getName()~
     can be abbreviated as
     ~Artist::getName~

   - The standard form is ~Classname::methodName~

   - Call constructors
     ~(name, nationality) -> new Artist(name, nationality)~
     can be abbreviated as
     ~Artist::new~

   - Use /method references/ to create arrays:
     ~Srring[]::new~

   - 

** TODO Element Ordering - 60
** TODO Enter the Collector - 62
*** Into Other Collections - 62
*** To Values - 63
*** Partitioning the Data - 64
*** Grouping the Data - 65
*** Strings - 66
*** Composing Collectors - 67
*** Refactoring and Custom Collectors - 69
*** Reduction as a Collector - 76

** TODO Collection Niceties - 77
** TODO Key Points - 78
** TODO Exercises - 78

* TODO 6. Data Parallelism - 81
** Parallelism Versus Concurrency - 81
** Why Is Parallelism Important? - 83
** Parallel Stream Operations - 83
** Simulations - 85
** Caveats - 88
** Performance - 89
** Parallel Array Operations - 92
** Key Points - 94
** Exercises - 94

* TODO 7. Testing, Debugging, and Refactoring - 97
** Lambda Refactoring Candidates - 97
*** In, Out, In, Out, Shake It All About - 98
*** The Lonely Override - 98
*** Behavioral Write Everything Twice - 99

** Unit Testing Lambda Expressions - 102
** Using Lambda Expressions in Test Doubles - 105
** Lazy Evaluation Versus Debugging - 106
** Logging and Printing - 106
** The Solution: peek - 107
** Midstream Breakpoints - 107
** Key Points - 108

* TODO 8. Design and Architectural Principles -109
** Lambda-Enabled Design Patterns - 110
*** Command Pattern - 110
*** Strategy Pattern - 114
*** Observer Pattern - 117
*** Template Method Pattern - 119

** Lambda-Enabled Domain-Specific Languages - 123
*** A DSL in Java - 124
*** How We Got There - 125
*** Evaluation - 127

** Lambda-Enabled SOLID Principles - 127
*** The Single Responsibility Principle - 128
*** The Open/Closed Principle - 130
*** The Dependency Inversion Principle - 134

** Further Reading - 137
** Key Points - 137

* TODO 9. Lambda-Enabled Concurrency - 139
** Why Use Nonblocking I/O? - 139
** Callbacks - 140
** Message Passing Architectures - 144
** The Pyramid of Doom - 145
** Futures - 147
** Completable Futures - 149
** Reactive Programming - 152
** When and Where - 155
** Key Points - 155
** Exercises - 156

* DONE 10. Moving Forward - 159
  CLOSED: [2017-10-03 Tue 02:20]
  - =From Jian= The author mentioned the ~Jodatime~ library.
    However, browse the ~Jodatime~ official website, I see
    #+BEGIN_QUOTE
     Joda-Time is the de facto standard date and time library for Java PRIOR TO
     Java SE 8. Users are now _asked to migrate_ to ~java.time~ (JSR-310).
    #+END_QUOTE

  - Open exercises =TODO=
    + =TODO= =???= Jenkins CI system
    + =TODO= =???= /collector/
    + =TODO= =???= RxJava or ~CompletableFuture~

* TODO Index - 161
