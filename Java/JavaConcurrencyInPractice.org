#+TITLE: Java Concurrency in Practice
#+VERSION: 2006
#+AUTHOR: Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Listings - xii][Listings - xii]]
- [[Preface - xvii][Preface - xvii]]
- [[1 Introduction - 1][1 Introduction - 1]]
  - [[1.1 A (very) brief history of concurrency - 1][1.1 A (very) brief history of concurrency - 1]]
  - [[1.2 Benefits of threads - 3][1.2 Benefits of threads - 3]]
    - [[1.2.1 Exploiting multiple processors - 3][1.2.1 Exploiting multiple processors - 3]]
    - [[1.2.2 Simplicity of modeling - 3][1.2.2 Simplicity of modeling - 3]]
    - [[1.2.3 Simplified handling of asynchronous events - 4][1.2.3 Simplified handling of asynchronous events - 4]]
    - [[1.2.4 More responsive user interfaces - 5][1.2.4 More responsive user interfaces - 5]]
  - [[1.3 Risks of threads - 5][1.3 Risks of threads - 5]]
    - [[1.3.1 Safety hazards - 5][1.3.1 Safety hazards - 5]]
    - [[1.3.2 Liveness hazards - 8][1.3.2 Liveness hazards - 8]]
    - [[1.3.3 Performance hazards - 8][1.3.3 Performance hazards - 8]]
  - [[1.4 Threads are everywhere - 9][1.4 Threads are everywhere - 9]]
- [[I Fundamentals - 13][I Fundamentals - 13]]
- [[2 Thread Safety - 15][2 Thread Safety - 15]]
  - [[2.1 What is thread safety? - 17][2.1 What is thread safety? - 17]]
    - [[2.1.1 Example: a stateless servlet - 18][2.1.1 Example: a stateless servlet - 18]]
  - [[2.2 Atomicity - 19][2.2 Atomicity - 19]]
    - [[2.2.1 Race conditions - 20][2.2.1 Race conditions - 20]]
    - [[2.2.2 Example: race conditions in lazy initialization - 21][2.2.2 Example: race conditions in lazy initialization - 21]]
    - [[2.2.3 Compound actions - 22][2.2.3 Compound actions - 22]]
  - [[2.3 Locking - 23][2.3 Locking - 23]]
    - [[2.3.1 Intrinsic locks - 25][2.3.1 Intrinsic locks - 25]]
    - [[2.3.2 Reentrancy - 26][2.3.2 Reentrancy - 26]]
  - [[2.4 Guarding state with locks - 27][2.4 Guarding state with locks - 27]]
  - [[2.5 Liveness and performance - 29][2.5 Liveness and performance - 29]]
- [[3 Sharing Objects - 33][3 Sharing Objects - 33]]
  - [[3.1 Visibility - 33][3.1 Visibility - 33]]
    - [[3.1.1 Stale data - 35][3.1.1 Stale data - 35]]
    - [[3.1.2 Nonatomic 64-bit operations - 36][3.1.2 Nonatomic 64-bit operations - 36]]
    - [[3.1.3 Locking and visibility - 36][3.1.3 Locking and visibility - 36]]
    - [[3.1.4 Volatile variables - 37][3.1.4 Volatile variables - 37]]
  - [[3.2 Publication and escape - 39][3.2 Publication and escape - 39]]
    - [[3.2.1 Safe construction practices - 41][3.2.1 Safe construction practices - 41]]
  - [[3.3 Thread confinement - 42][3.3 Thread confinement - 42]]
    - [[3.3.1 Ad-hoc thread confinement - 43][3.3.1 Ad-hoc thread confinement - 43]]
    - [[3.3.2 Stack confinement - 44][3.3.2 Stack confinement - 44]]
    - [[3.3.3 ThreadLocal - 45][3.3.3 ThreadLocal - 45]]
  - [[3.4 Immutability - 46][3.4 Immutability - 46]]
    - [[3.4.1 Final fields - 48][3.4.1 Final fields - 48]]
    - [[3.4.2 Example: Using volatile to publish immutable objects - 48][3.4.2 Example: Using volatile to publish immutable objects - 48]]
  - [[3.5 Safe publication - 49][3.5 Safe publication - 49]]
    - [[3.5.1 Improper publication: when good objects go bad - 50][3.5.1 Improper publication: when good objects go bad - 50]]
    - [[3.5.2 Immutable objects and initialization safety - 51][3.5.2 Immutable objects and initialization safety - 51]]
    - [[3.5.3 Safe publication idioms - 52][3.5.3 Safe publication idioms - 52]]
    - [[3.5.4 Effectively immutable objects - 53][3.5.4 Effectively immutable objects - 53]]
    - [[3.5.5 Mutable objects - 54][3.5.5 Mutable objects - 54]]
    - [[3.5.6 Sharing objects safely - 54][3.5.6 Sharing objects safely - 54]]
- [[4 Composing Objects - 55][4 Composing Objects - 55]]
  - [[4.1 Designing a thread-safe class - 55][4.1 Designing a thread-safe class - 55]]
    - [[4.1.1 Gathering synchronization requirements - 56][4.1.1 Gathering synchronization requirements - 56]]
    - [[4.1.2 State-dependent operations - 57][4.1.2 State-dependent operations - 57]]
    - [[4.1.3 State ownership - 57][4.1.3 State ownership - 57]]
  - [[4.2 Instance confinement - 58][4.2 Instance confinement - 58]]
    - [[4.2.1 The Java monitor pattern - 60][4.2.1 The Java monitor pattern - 60]]
    - [[4.2.2 Example: tracking fleet vehicles - 61][4.2.2 Example: tracking fleet vehicles - 61]]
  - [[4.3 Delegating thread safety - 62][4.3 Delegating thread safety - 62]]
    - [[4.3.1 Example: vehicle tracker using delegation - 64][4.3.1 Example: vehicle tracker using delegation - 64]]
    - [[4.3.2 Independent state variables - 66][4.3.2 Independent state variables - 66]]
    - [[4.3.3 When delegation fails - 67][4.3.3 When delegation fails - 67]]
    - [[4.3.4 Publishing underlying state variables - 68][4.3.4 Publishing underlying state variables - 68]]
    - [[4.3.5 Example: vehicle tracker that publishes its state - 69][4.3.5 Example: vehicle tracker that publishes its state - 69]]
  - [[4.4 Adding functionality to existing thread-safe classes - 71][4.4 Adding functionality to existing thread-safe classes - 71]]
    - [[4.4.1 Client-side locking - 72][4.4.1 Client-side locking - 72]]
    - [[4.4.2 Composition - 73][4.4.2 Composition - 73]]
  - [[4.5 Documenting synchronization policies - 74][4.5 Documenting synchronization policies - 74]]
    - [[4.5.1 Interpreting vague documentation - 76][4.5.1 Interpreting vague documentation - 76]]
- [[5 Building Blocks - 79][5 Building Blocks - 79]]
  - [[5.1 Synchronized collections - 79][5.1 Synchronized collections - 79]]
    - [[5.1.1 Problems with synchronized collections - 79][5.1.1 Problems with synchronized collections - 79]]
    - [[5.1.2 Iterators and ~ConcurrentModificationException~ - 82][5.1.2 Iterators and ~ConcurrentModificationException~ - 82]]
    - [[5.1.3 Hidden iterators - 83][5.1.3 Hidden iterators - 83]]
  - [[5.2 Concurrent collections - 84][5.2 Concurrent collections - 84]]
    - [[5.2.1 ~ConcurrentHashMap~ - 85][5.2.1 ~ConcurrentHashMap~ - 85]]
    - [[5.2.2 Additional atomic ~Map~ operations - 86][5.2.2 Additional atomic ~Map~ operations - 86]]
    - [[5.2.3 ~CopyOnWriteArrayList~ - 86][5.2.3 ~CopyOnWriteArrayList~ - 86]]
  - [[5.3 Blocking queues and the producer-consumer pattern - 87][5.3 Blocking queues and the producer-consumer pattern - 87]]
    - [[5.3.1 Example: desktop search - 89][5.3.1 Example: desktop search - 89]]
    - [[5.3.2 Serial thread confinement - 90][5.3.2 Serial thread confinement - 90]]
    - [[5.3.3 Deques and work stealing - 92][5.3.3 Deques and work stealing - 92]]
  - [[5.4 Blocking and interruptible methods - 92][5.4 Blocking and interruptible methods - 92]]
  - [[5.5 Synchronizers - 94][5.5 Synchronizers - 94]]
    - [[5.5.1 Latches - 94][5.5.1 Latches - 94]]
    - [[5.5.2 ~FutureTask~ - 95][5.5.2 ~FutureTask~ - 95]]
    - [[5.5.3 Semaphores - 98][5.5.3 Semaphores - 98]]
    - [[5.5.4 Barriers - 99][5.5.4 Barriers - 99]]
  - [[5.6 Building an efficient, scalable result cache - 101][5.6 Building an efficient, scalable result cache - 101]]
- [[Summary of Part I][Summary of Part I]]
- [[II Structuring Concurrent Applications - 111][II Structuring Concurrent Applications - 111]]
- [[6 Task Execution - 113][6 Task Execution - 113]]
  - [[6.1 Executing tasks in threads - 113][6.1 Executing tasks in threads - 113]]
    - [[6.1.1 Executing tasks sequentially - 114][6.1.1 Executing tasks sequentially - 114]]
    - [[6.1.2 Explicitly creating threads for tasks - 115][6.1.2 Explicitly creating threads for tasks - 115]]
    - [[6.1.3 Disadvantages of unbounded thread creation - 116][6.1.3 Disadvantages of unbounded thread creation - 116]]
  - [[6.2 The Executor framework - 117][6.2 The Executor framework - 117]]
    - [[6.2.1 Example: web server using ~Executor~ - 117][6.2.1 Example: web server using ~Executor~ - 117]]
    - [[6.2.2 Execution policies - 118][6.2.2 Execution policies - 118]]
    - [[6.2.3 Thread pools - 119][6.2.3 Thread pools - 119]]
    - [[6.2.4 ~Executor~ lifecycle - 121][6.2.4 ~Executor~ lifecycle - 121]]
    - [[6.2.5 Delayed and periodic tasks - 123][6.2.5 Delayed and periodic tasks - 123]]
  - [[6.3 Finding exploitable parallelism - 123][6.3 Finding exploitable parallelism - 123]]
    - [[6.3.1 Example: sequential page renderer - 124][6.3.1 Example: sequential page renderer - 124]]
    - [[6.3.2 Result-bearing tasks: ~Callable~ and ~Future~ - 125][6.3.2 Result-bearing tasks: ~Callable~ and ~Future~ - 125]]
    - [[6.3.3 Example: page renderer with ~Future~ - 127][6.3.3 Example: page renderer with ~Future~ - 127]]
    - [[6.3.4 Limitations of parallelizing heterogeneous tasks - 127][6.3.4 Limitations of parallelizing heterogeneous tasks - 127]]
    - [[6.3.5 ~CompletionService~: ~Executor~ meets ~BlockingQueue~ - 129][6.3.5 ~CompletionService~: ~Executor~ meets ~BlockingQueue~ - 129]]
    - [[6.3.6 Example: page renderer with ~CompletionService~ - 130][6.3.6 Example: page renderer with ~CompletionService~ - 130]]
    - [[6.3.7 Placing time limits on tasks - 131][6.3.7 Placing time limits on tasks - 131]]
    - [[6.3.8 Example: a travel reservations portal - 131][6.3.8 Example: a travel reservations portal - 131]]
    - [[Summary - 133][Summary - 133]]
- [[7 Cancellation and Shutdown - 135][7 Cancellation and Shutdown - 135]]
  - [[7.1 Task cancellation - 135][7.1 Task cancellation - 135]]
  - [[7.2 Stopping a thread-based service - 150][7.2 Stopping a thread-based service - 150]]
  - [[7.3 Handling abnormal thread termination - 161][7.3 Handling abnormal thread termination - 161]]
  - [[7.4 JVM shutdown - 164][7.4 JVM shutdown - 164]]
- [[8 Applying Thread Pools - 167][8 Applying Thread Pools - 167]]
  - [[8.1 Implicit couplings between tasks and execution policies - 167][8.1 Implicit couplings between tasks and execution policies - 167]]
  - [[8.2 Sizing thread pools - 170][8.2 Sizing thread pools - 170]]
  - [[8.3 Configuring ThreadPoolExecutor - 171][8.3 Configuring ThreadPoolExecutor - 171]]
  - [[8.4 Extending ThreadPoolExecutor - 179][8.4 Extending ThreadPoolExecutor - 179]]
  - [[8.5 Parallelizing recursive algorithms - 181][8.5 Parallelizing recursive algorithms - 181]]
- [[9 GUI Applications - 189][9 GUI Applications - 189]]
  - [[9.1 Why are GUIs single-threaded? - 189][9.1 Why are GUIs single-threaded? - 189]]
  - [[9.2 Short-running GUI tasks - 192][9.2 Short-running GUI tasks - 192]]
  - [[9.3 Long-running GUI tasks - 195][9.3 Long-running GUI tasks - 195]]
  - [[9.4 Shared data models - 198][9.4 Shared data models - 198]]
  - [[9.5 Other forms of single-threaded subsystems - 202][9.5 Other forms of single-threaded subsystems - 202]]
- [[III Liveness, Performance, and Testing - 203][III Liveness, Performance, and Testing - 203]]
- [[10 Avoiding Liveness Hazards - 205][10 Avoiding Liveness Hazards - 205]]
  - [[10.1 Deadlock - 205][10.1 Deadlock - 205]]
    - [[10.1.1 Lock-ordering deadlocks - 206][10.1.1 Lock-ordering deadlocks - 206]]
    - [[10.1.2 Dynamic lock order deadlocks - 207][10.1.2 Dynamic lock order deadlocks - 207]]
    - [[10.1.3 Deadlocks between cooperating objects - 211][10.1.3 Deadlocks between cooperating objects - 211]]
    - [[10.1.4 Open calls - 211][10.1.4 Open calls - 211]]
    - [[10.1.5 Resource deadlocks - 213][10.1.5 Resource deadlocks - 213]]
  - [[10.2 Avoiding and diagnosing deadlocks - 215][10.2 Avoiding and diagnosing deadlocks - 215]]
    - [[10.2.1 Timed lock attempts - 215][10.2.1 Timed lock attempts - 215]]
    - [[10.2.2 Deadlock analysis with thread dumps - 216][10.2.2 Deadlock analysis with thread dumps - 216]]
  - [[10.3 Other liveness hazards - 218][10.3 Other liveness hazards - 218]]
    - [[10.3.1 Starvation - 218][10.3.1 Starvation - 218]]
    - [[10.3.2 Poor responsiveness - 219][10.3.2 Poor responsiveness - 219]]
    - [[10.3.3 Livelock - 219][10.3.3 Livelock - 219]]
  - [[Summary][Summary]]
- [[11 Performance and Scalability - 221][11 Performance and Scalability - 221]]
  - [[11.1 Thinking about performance - 221][11.1 Thinking about performance - 221]]
  - [[11.2 Amdahl’s law - 225][11.2 Amdahl’s law - 225]]
  - [[11.3 Costs introduced by threads - 229][11.3 Costs introduced by threads - 229]]
  - [[11.4 Reducing lock contention - 232][11.4 Reducing lock contention - 232]]
  - [[11.5 Example: Comparing Map performance - 242][11.5 Example: Comparing Map performance - 242]]
  - [[11.6 Reducing context switch overhead - 243][11.6 Reducing context switch overhead - 243]]
- [[12 Testing Concurrent Programs - 247][12 Testing Concurrent Programs - 247]]
  - [[12.1 Testing for correctness - 248][12.1 Testing for correctness - 248]]
  - [[12.2 Testing for performance - 260][12.2 Testing for performance - 260]]
  - [[12.3 Avoiding performance testing pitfalls - 266][12.3 Avoiding performance testing pitfalls - 266]]
  - [[12.4 Complementary testing approaches - 270][12.4 Complementary testing approaches - 270]]
- [[IV Advanced Topics - 275][IV Advanced Topics - 275]]
- [[13 Explicit Locks - 277][13 Explicit Locks - 277]]
  - [[13.1 ~Lock~ and ~ReentrantLock~ - 277][13.1 ~Lock~ and ~ReentrantLock~ - 277]]
    - [[13.1.1 Polled and timed lock acquisition - 279][13.1.1 Polled and timed lock acquisition - 279]]
    - [[13.1.2 Interruptible lock acquisition - 279][13.1.2 Interruptible lock acquisition - 279]]
    - [[13.1.3 Non-block-structured locking - 281][13.1.3 Non-block-structured locking - 281]]
  - [[13.2 Performance considerations - 282][13.2 Performance considerations - 282]]
  - [[13.3 Fairness - 283][13.3 Fairness - 283]]
  - [[13.4 Choosing between synchronized and ReentrantLock - 285][13.4 Choosing between synchronized and ReentrantLock - 285]]
  - [[13.5 Read-write locks - 286][13.5 Read-write locks - 286]]
  - [[Summary][Summary]]
- [[14 Building Custom Synchronizers - 291][14 Building Custom Synchronizers - 291]]
  - [[14.1 Managing state dependence - 291][14.1 Managing state dependence - 291]]
    - [[14.1.1 Example: propagating precondition failure to callers - 292][14.1.1 Example: propagating precondition failure to callers - 292]]
    - [[14.1.2 Example: crude blocking by polling and sleeping - 295][14.1.2 Example: crude blocking by polling and sleeping - 295]]
    - [[14.1.3 Condition queues to the rescue - 296][14.1.3 Condition queues to the rescue - 296]]
  - [[14.2 Using condition queues - 298][14.2 Using condition queues - 298]]
    - [[14.2.1 The condition predicate - 299][14.2.1 The condition predicate - 299]]
    - [[14.2.2 Waking up too soon - 300][14.2.2 Waking up too soon - 300]]
    - [[14.2.3 Missed signals - 301][14.2.3 Missed signals - 301]]
    - [[14.2.4 Notification - 302][14.2.4 Notification - 302]]
    - [[14.2.5 Example: a gate class - 304][14.2.5 Example: a gate class - 304]]
    - [[14.2.6 Subclass safety issues - 304][14.2.6 Subclass safety issues - 304]]
    - [[14.2.7 Encapsulating condition queues - 306][14.2.7 Encapsulating condition queues - 306]]
    - [[14.2.8 Entry and exit protocols - 306][14.2.8 Entry and exit protocols - 306]]
  - [[14.3 Explicit condition objects - 306][14.3 Explicit condition objects - 306]]
  - [[14.4 Anatomy of a synchronizer - 308][14.4 Anatomy of a synchronizer - 308]]
  - [[14.5 ~AbstractQueuedSynchronizer~ - 311][14.5 ~AbstractQueuedSynchronizer~ - 311]]
    - [[14.5.1 A simple latch - 313][14.5.1 A simple latch - 313]]
  - [[14.6 AQS in ~java.util.concurrent~ synchronizer classes - 314][14.6 AQS in ~java.util.concurrent~ synchronizer classes - 314]]
    - [[14.6.1 ~ReentrantLock~ - 314][14.6.1 ~ReentrantLock~ - 314]]
    - [[14.6.2 ~Semaphore~ and ~CountDownLatch~ - 315][14.6.2 ~Semaphore~ and ~CountDownLatch~ - 315]]
    - [[14.6.3 ~FutureTask~ - 316][14.6.3 ~FutureTask~ - 316]]
    - [[14.6.4 ~ReentrantReadWriteLock~ - 316][14.6.4 ~ReentrantReadWriteLock~ - 316]]
  - [[Summary - 317][Summary - 317]]
- [[15 Atomic Variables and Nonblocking Synchronization - 319][15 Atomic Variables and Nonblocking Synchronization - 319]]
  - [[15.1 Disadvantages of locking - 319][15.1 Disadvantages of locking - 319]]
  - [[15.2 Hardware support for concurrency - 321][15.2 Hardware support for concurrency - 321]]
    - [[15.2.1 Compare and swap - 321][15.2.1 Compare and swap - 321]]
    - [[15.2.2 A nonblocking counter - 322][15.2.2 A nonblocking counter - 322]]
    - [[15.2.3 CAS support in the JVM - 324][15.2.3 CAS support in the JVM - 324]]
  - [[15.3 Atomic variable classes - 324][15.3 Atomic variable classes - 324]]
    - [[15.3.1 Atomics as “better volatiles” - 325][15.3.1 Atomics as “better volatiles” - 325]]
    - [[15.3.2 Performance comparison: locks versus atomic variables - 326][15.3.2 Performance comparison: locks versus atomic variables - 326]]
  - [[15.4 Nonblocking algorithms - 329][15.4 Nonblocking algorithms - 329]]
    - [[15.4.1 A nonblocking stack - 330][15.4.1 A nonblocking stack - 330]]
    - [[15.4.2 A nonblocking linked list - 330][15.4.2 A nonblocking linked list - 330]]
    - [[15.4.3 Atomic field updaters - 335][15.4.3 Atomic field updaters - 335]]
    - [[15.4.4 The ABA problem - 336][15.4.4 The ABA problem - 336]]
  - [[Summary][Summary]]
- [[16 The Java Memory Model - 337][16 The Java Memory Model - 337]]
  - [[16.1 What is a memory model, and why would I want one? - 337][16.1 What is a memory model, and why would I want one? - 337]]
    - [[16.1.1 Platform memory models - 338][16.1.1 Platform memory models - 338]]
    - [[16.1.2 Reordering - 339][16.1.2 Reordering - 339]]
    - [[16.1.3 The Java Memory Model in 500 words or less - 339][16.1.3 The Java Memory Model in 500 words or less - 339]]
    - [[16.1.4 Piggybacking on synchronization - 342][16.1.4 Piggybacking on synchronization - 342]]
  - [[16.2 Publication - 344][16.2 Publication - 344]]
    - [[16.2.1 Unsafe publication - 344][16.2.1 Unsafe publication - 344]]
    - [[16.2.2 Safe publication - 346][16.2.2 Safe publication - 346]]
    - [[16.2.3 Safe initialization idioms - 346][16.2.3 Safe initialization idioms - 346]]
    - [[16.2.4 Double-checked locking - 348][16.2.4 Double-checked locking - 348]]
  - [[16.3 Initialization safety - 349][16.3 Initialization safety - 349]]
  - [[Summary][Summary]]
- [[A Annotations for Concurrency - 353][A Annotations for Concurrency - 353]]
  - [[A.1 Class annotations - 353][A.1 Class annotations - 353]]
  - [[A.2 Field and method annotations - 353][A.2 Field and method annotations - 353]]
- [[Bibliography - 355][Bibliography - 355]]
- [[Index - 359][Index - 359]]

* TODO Listings - xii
* TODO Preface - xvii
* TODO 1 Introduction - 1
  /Threads/ are an inescapable feature of the Java language, and they can
  simplify the development of complex systems by _turning complicated
  asynchronous code into simpler straight-line code_.
    In addition, /threads/ are the easiest way to tap the computing power of
  multiprocessor systems.

** DONE 1.1 A (very) brief history of concurrency - 1
   CLOSED: [2017-12-28 Thu 18:56]
   - processes :: isolated, independently executing programs to which the
                  operating system allocates resources such as memory, file
                  handles, and security credentials.

   - /processes/ could communicate with one another through a variety of
     _coarse-grained communication mechanisms_:
     + sockets
     + signal handlers
     + shared memory
     + semaphores
     + files

   - _Several motivating factors_ led to the development of operating systems
     that allowed multiple programs to execute simultaneously:
     + Resource utilization.
     + Fairness
     + Convenience

   - /Threads/ allow multiple streams of program control flow to _coexist whithin
     a process_. They share _process-wide_ resources.

   - /Threads/ also provide a natural decomposition for exploiting hardware
     parallelism on multiprocessor systems;
     =TODO=
     /multiple threads/ within the same program can be scheduled simultaneously
     on multiple CPUs.
     =TODO=

   - /Threads/ are sometimes called /lightweight process/.

   - Most modern OS's treat /threads/, _NOT_ /processes/, as the _basic units of
     scheduling_.

   - _ALL_ /threads/ within a process have access to the _SAME_ /variables/ and
     allocate objects from the SAME /heap/, which allows finer-grained data
     sharing than inter-process mechanisms.

     BUT WITHOUT explicit synchronization to coordinate access to shared data, a
     /thread/ may modify variables that another /thread/ is in the middle of
     using, with unpredictable results.

** TODO 1.2 Benefits of threads - 3
*** DONE 1.2.1 Exploiting multiple processors - 3
    CLOSED: [2017-12-28 Thu 19:53]
    - For multiprocessor systems: multithreads can utilize multicores.

    - For single processor systems: utilize the waiting time (i.e. IO) of one
      thread.

*** TODO 1.2.2 Simplicity of modeling - 3
*** DONE 1.2.3 Simplified handling of asynchronous events - 4
    CLOSED: [2017-12-28 Thu 20:16]
    - Historically, OS's placed relatively _LOW limits on the number_ of
      /threads/ that a /process/ could create, as few as _several hundred (or
      even less)_.

    - =TODO= 
      As a result,
      operating systems developed efficient facilities for
      multiplexed I/O, such as the Unix ~select~ and ~poll~ system calls,
      and
      to access these facilities, the Java class libraries acquired a set of
      packages (~java.nio~) for nonblocking I/O.

    - However,
      OS support for _LARGER numbers_ of /threads/ has _IMPROVED significantly_,
      making the thread-per-client model practical even for large numbers of
      clients on some platforms.

*** TODO 1.2.4 More responsive user interfaces - 5
    - /event dispatch thread (EDT)/

** TODO 1.3 Risks of threads - 5
   - Java's _built-in support_ for /threads/ is a double-edged sword:
     + *PROS*:
       while it simplifies the development of concurrent applications by
       providing language and library support and a formal _cross-platform
       memory model_

     + *CONS*: 
       it also raises the bar for developers because more programs will use
       /threads/.

*** DONE 1.3.1 Safety hazards - 5
    CLOSED: [2017-12-28 Thu 21:11]
    - Listing 1.1. Non-thread-safe sequence generator
      #+BEGIN_SRC java
        @NotThreadSafe
        public class UnsafeSequence {
            private int value;

            // Returns a unique value.
            public int getNext() {
                return value++;
            }
        }
      #+END_SRC

    - In this book we will use some /nonstandard annotation/:
      + ~@NotThreadSafe~
      + ~@ThreadSafe~
      + ~@Immutable~

      If a class is annotated with ~@ThreadSafe~, users can use it with
      confidence in a multithreaded environment, maintainers are put on notice
      that it makes thread safety guarantees that _must be preserved_, and
      software analysis tools can identify possible coding errors.

    - The ~UnsafeSequence~ illustrates a common /concurrency hazard/ called a
      /race condition/.

    - Fix it:
      #+BEGIN_SRC java
        @ThreadSafe
        public class Sequence {
            @GuardedBy("this") private int value;

            public synchronized int getNext() {
                return value++;
            }
        }
      #+END_SRC

      Exactly why this works is the subject of Chapter 2 and 3.

*** DONE 1.3.2 Liveness hazards - 8
    CLOSED: [2017-12-28 Thu 21:20]
    - While /safety/ means “nothing bad ever happens”,

      /liveness/ concerns the complementary goal that “something good eventually
      happens”.

    - liveness failure :: it occurs when an activity gets into a state such that
         it is permanently unable to make forward progress.

    - Concurrency programming does NOT introduce /liveness failure/. It just
      introduces additional forms of /liveness failure/ that do NOT occur in
      single-threaded programs.

    - An inadvertent infinite loop is a kind of /liveness failure/ in single
      thread situation.

    - For concurrency, for example, a /liveness failure/ can be
      if thread A is waiting for a resource that thread B holds exclusively, and
      B never releases it, A will wait forever.

*** TODO 1.3.3 Performance hazards - 8

** TODO 1.4 Threads are everywhere - 9
   - *Timer* - 9
   - *Servlets and JavaServer Pages (JSPs)* - 10
   - *Remote Method Invocation* - 10
   - *Swing and AWT* - 10

* TODO I Fundamentals - 13
* TODO 2 Thread Safety - 15
** 2.1 What is thread safety? - 17
*** 2.1.1 Example: a stateless servlet - 18

** 2.2 Atomicity - 19
*** 2.2.1 Race conditions - 20
*** 2.2.2 Example: race conditions in lazy initialization - 21
*** 2.2.3 Compound actions - 22

** 2.3 Locking - 23
*** 2.3.1 Intrinsic locks - 25
*** 2.3.2 Reentrancy - 26

** 2.4 Guarding state with locks - 27
** 2.5 Liveness and performance - 29

* TODO 3 Sharing Objects - 33
** 3.1 Visibility - 33
*** 3.1.1 Stale data - 35
*** 3.1.2 Nonatomic 64-bit operations - 36
*** 3.1.3 Locking and visibility - 36
*** 3.1.4 Volatile variables - 37

** 3.2 Publication and escape - 39
*** 3.2.1 Safe construction practices - 41

** 3.3 Thread confinement - 42
*** 3.3.1 Ad-hoc thread confinement - 43
*** 3.3.2 Stack confinement - 44
*** 3.3.3 ThreadLocal - 45

** 3.4 Immutability - 46
*** 3.4.1 Final fields - 48
*** 3.4.2 Example: Using volatile to publish immutable objects - 48

** 3.5 Safe publication - 49
*** 3.5.1 Improper publication: when good objects go bad - 50
*** 3.5.2 Immutable objects and initialization safety - 51
*** 3.5.3 Safe publication idioms - 52
*** 3.5.4 Effectively immutable objects - 53
*** 3.5.5 Mutable objects - 54
*** 3.5.6 Sharing objects safely - 54
    - *Thread-confined*
    - *Shared read-only*
    - *Shared thread-safe*
    - *Guarded*

* TODO 4 Composing Objects - 55
** 4.1 Designing a thread-safe class - 55
*** 4.1.1 Gathering synchronization requirements - 56
*** 4.1.2 State-dependent operations - 57
*** 4.1.3 State ownership - 57

** 4.2 Instance confinement - 58
*** 4.2.1 The Java monitor pattern - 60
*** 4.2.2 Example: tracking fleet vehicles - 61

** 4.3 Delegating thread safety - 62
*** 4.3.1 Example: vehicle tracker using delegation - 64
*** 4.3.2 Independent state variables - 66
*** 4.3.3 When delegation fails - 67
*** 4.3.4 Publishing underlying state variables - 68
*** 4.3.5 Example: vehicle tracker that publishes its state - 69

** 4.4 Adding functionality to existing thread-safe classes - 71
*** 4.4.1 Client-side locking - 72
*** 4.4.2 Composition - 73

** 4.5 Documenting synchronization policies - 74
*** 4.5.1 Interpreting vague documentation - 76

* TODO 5 Building Blocks - 79
** 5.1 Synchronized collections - 79
*** 5.1.1 Problems with synchronized collections - 79
*** 5.1.2 Iterators and ~ConcurrentModificationException~ - 82
*** 5.1.3 Hidden iterators - 83

** 5.2 Concurrent collections - 84
*** 5.2.1 ~ConcurrentHashMap~ - 85
*** 5.2.2 Additional atomic ~Map~ operations - 86
*** 5.2.3 ~CopyOnWriteArrayList~ - 86

** 5.3 Blocking queues and the producer-consumer pattern - 87
*** 5.3.1 Example: desktop search - 89
*** 5.3.2 Serial thread confinement - 90
*** 5.3.3 Deques and work stealing - 92

** 5.4 Blocking and interruptible methods - 92
** 5.5 Synchronizers - 94
*** 5.5.1 Latches - 94
*** 5.5.2 ~FutureTask~ - 95
*** 5.5.3 Semaphores - 98
*** 5.5.4 Barriers - 99

** 5.6 Building an efficient, scalable result cache - 101
* TODO Summary of Part I
* II Structuring Concurrent Applications - 111
* TODO 6 Task Execution - 113
** 6.1 Executing tasks in threads - 113
*** 6.1.1 Executing tasks sequentially - 114
*** 6.1.2 Explicitly creating threads for tasks - 115
*** 6.1.3 Disadvantages of unbounded thread creation - 116

** 6.2 The Executor framework - 117
*** 6.2.1 Example: web server using ~Executor~ - 117
*** 6.2.2 Execution policies - 118
*** 6.2.3 Thread pools - 119
*** 6.2.4 ~Executor~ lifecycle - 121
*** 6.2.5 Delayed and periodic tasks - 123

** 6.3 Finding exploitable parallelism - 123
*** 6.3.1 Example: sequential page renderer - 124
*** 6.3.2 Result-bearing tasks: ~Callable~ and ~Future~ - 125
*** 6.3.3 Example: page renderer with ~Future~ - 127
*** 6.3.4 Limitations of parallelizing heterogeneous tasks - 127
*** 6.3.5 ~CompletionService~: ~Executor~ meets ~BlockingQueue~ - 129
*** 6.3.6 Example: page renderer with ~CompletionService~ - 130
*** 6.3.7 Placing time limits on tasks - 131
*** 6.3.8 Example: a travel reservations portal - 131
*** Summary - 133

* 7 Cancellation and Shutdown - 135
** 7.1 Task cancellation - 135
** 7.2 Stopping a thread-based service - 150
** 7.3 Handling abnormal thread termination - 161
** 7.4 JVM shutdown - 164

* 8 Applying Thread Pools - 167
** 8.1 Implicit couplings between tasks and execution policies - 167
** 8.2 Sizing thread pools - 170
** 8.3 Configuring ThreadPoolExecutor - 171
** 8.4 Extending ThreadPoolExecutor - 179
** 8.5 Parallelizing recursive algorithms - 181

* 9 GUI Applications - 189
** 9.1 Why are GUIs single-threaded? - 189
** 9.2 Short-running GUI tasks - 192
** 9.3 Long-running GUI tasks - 195
** 9.4 Shared data models - 198
** 9.5 Other forms of single-threaded subsystems - 202

* III Liveness, Performance, and Testing - 203
* TODO 10 Avoiding Liveness Hazards - 205
** 10.1 Deadlock - 205
*** 10.1.1 Lock-ordering deadlocks - 206
*** 10.1.2 Dynamic lock order deadlocks - 207
*** 10.1.3 Deadlocks between cooperating objects - 211
*** 10.1.4 Open calls - 211
*** 10.1.5 Resource deadlocks - 213

** 10.2 Avoiding and diagnosing deadlocks - 215
*** 10.2.1 Timed lock attempts - 215
*** 10.2.2 Deadlock analysis with thread dumps - 216

** 10.3 Other liveness hazards - 218
*** 10.3.1 Starvation - 218
*** 10.3.2 Poor responsiveness - 219
*** 10.3.3 Livelock - 219

** Summary

* 11 Performance and Scalability - 221
** 11.1 Thinking about performance - 221
** 11.2 Amdahl’s law - 225
** 11.3 Costs introduced by threads - 229
** 11.4 Reducing lock contention - 232
** 11.5 Example: Comparing Map performance - 242
** 11.6 Reducing context switch overhead - 243

* 12 Testing Concurrent Programs - 247
** 12.1 Testing for correctness - 248
** 12.2 Testing for performance - 260
** 12.3 Avoiding performance testing pitfalls - 266
** 12.4 Complementary testing approaches - 270

* IV Advanced Topics - 275
* TODO 13 Explicit Locks - 277
** 13.1 ~Lock~ and ~ReentrantLock~ - 277
*** 13.1.1 Polled and timed lock acquisition - 279
*** 13.1.2 Interruptible lock acquisition - 279
*** 13.1.3 Non-block-structured locking - 281

** 13.2 Performance considerations - 282
** 13.3 Fairness - 283
** 13.4 Choosing between synchronized and ReentrantLock - 285
** 13.5 Read-write locks - 286
** Summary

* TODO 14 Building Custom Synchronizers - 291
** 14.1 Managing state dependence - 291
*** 14.1.1 Example: propagating precondition failure to callers - 292
*** 14.1.2 Example: crude blocking by polling and sleeping - 295
*** 14.1.3 Condition queues to the rescue - 296

** 14.2 Using condition queues - 298
*** 14.2.1 The condition predicate - 299
*** 14.2.2 Waking up too soon - 300
*** 14.2.3 Missed signals - 301
*** 14.2.4 Notification - 302
*** 14.2.5 Example: a gate class - 304
*** 14.2.6 Subclass safety issues - 304
*** 14.2.7 Encapsulating condition queues - 306
*** 14.2.8 Entry and exit protocols - 306

** 14.3 Explicit condition objects - 306
** 14.4 Anatomy of a synchronizer - 308
** 14.5 ~AbstractQueuedSynchronizer~ - 311
*** 14.5.1 A simple latch - 313

** 14.6 AQS in ~java.util.concurrent~ synchronizer classes - 314
*** 14.6.1 ~ReentrantLock~ - 314
*** 14.6.2 ~Semaphore~ and ~CountDownLatch~ - 315
*** 14.6.3 ~FutureTask~ - 316
*** 14.6.4 ~ReentrantReadWriteLock~ - 316

** Summary - 317

* TODO 15 Atomic Variables and Nonblocking Synchronization - 319
** 15.1 Disadvantages of locking - 319
** 15.2 Hardware support for concurrency - 321
*** 15.2.1 Compare and swap - 321
*** 15.2.2 A nonblocking counter - 322
*** 15.2.3 CAS support in the JVM - 324

** 15.3 Atomic variable classes - 324
*** 15.3.1 Atomics as “better volatiles” - 325
*** 15.3.2 Performance comparison: locks versus atomic variables - 326

** 15.4 Nonblocking algorithms - 329
*** 15.4.1 A nonblocking stack - 330
*** 15.4.2 A nonblocking linked list - 330
*** 15.4.3 Atomic field updaters - 335
*** 15.4.4 The ABA problem - 336

** Summary

* TODO 16 The Java Memory Model - 337
** 16.1 What is a memory model, and why would I want one? - 337
*** 16.1.1 Platform memory models - 338
*** 16.1.2 Reordering - 339
*** 16.1.3 The Java Memory Model in 500 words or less - 339
*** 16.1.4 Piggybacking on synchronization - 342

** 16.2 Publication - 344
*** 16.2.1 Unsafe publication - 344
*** 16.2.2 Safe publication - 346
*** 16.2.3 Safe initialization idioms - 346
*** 16.2.4 Double-checked locking - 348

** 16.3 Initialization safety - 349
** Summary

* TODO A Annotations for Concurrency - 353
** A.1 Class annotations - 353
** A.2 Field and method annotations - 353

* Bibliography - 355
* Index - 359
