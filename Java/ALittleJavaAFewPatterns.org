#+TITLE: A Little Java, A Few Patterns
#+VERSION: 1997
#+AUTHOR: Matthias Felleisen, Daniel P. Friedman, Drawings by Duane Bibby, Foreword by Ralph E. Johnson
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Foreword - ix][Foreword - ix]]
- [[Preface - xi                  =RE-READ=][Preface - xi                  =RE-READ=]]
  - [[THE INTENDED AUDIENCE][THE INTENDED AUDIENCE]]
  - [[WHAT THIS BOOK IS NOT ABOUT][WHAT THIS BOOK IS NOT ABOUT]]
  - [[ACKNOWLEDGEMENTS][ACKNOWLEDGEMENTS]]
  - [[READING GUIDELINES][READING GUIDELINES]]
- [[Experimenting with Java - xiii][Experimenting with Java - xiii]]
- [[1. Modern Toys - 3][1. Modern Toys - 3]]
- [[2. Methods to Our Madness - 13][2. Methods to Our Madness - 13]]
- [[3. What's New? - 43][3. What's New? - 43]]
- [[4. Come to Our Carousel - 57][4. Come to Our Carousel - 57]]
- [[5. Objects Are People, Too - 69][5. Objects Are People, Too - 69]]
- [[6. Boring Protocols - 85][6. Boring Protocols - 85]]
- [[7. Oh My! - 99][7. Oh My! - 99]]
- [[8. Like Father, Like Son - 117][8. Like Father, Like Son - 117]]
- [[9. Be a Good Visitor - 139][9. Be a Good Visitor - 139]]
- [[10. The State of Things to Come - 161][10. The State of Things to Come - 161]]
- [[Commencement - 177][Commencement - 177]]
- [[Index - 178][Index - 178]]

* DONE Foreword - ix
  CLOSED: [2017-10-18 Wed 21:01]
  - Felleisen and Friedman show that the functional (input-output driven) method
    of program design naturally leads to the use of well-known object-oriented
    design patterns.

  - If you know functional design, the book will gently introduce you to
    /pattern-based programming/ in Java.

* DONE Preface - xi                  =RE-READ=
  CLOSED: [2017-10-19 Thu 08:03]
  - This book introduces Java's OO elements:
    + /(abstract) class/
    + /fields/
    + /methods/
    + /inheritance/
    + /interfaces/

    This small core language has a simple semantics model, which greatly helps
    programmers to express themselves.

    GC helps managing the memory.

  - /design patterns/  =TODO=

** DONE THE INTENDED AUDIENCE
   CLOSED: [2017-10-19 Thu 07:58]
   - The book is primarily intended for people -- practicing programmers,
     instructors and students alike -- who wish to study the _essential elements
     of object-oriented programming_ and the idea of _design patterns_.

   - Readers must have some basic programming experience.

   - They will benefit most from the book if they understand _the principles of
     functional design_.

   - the principles of functional design :: the design of program fragments based
        on their input-output behavior.

** DONE WHAT THIS BOOK IS NOT ABOUT
   CLOSED: [2017-10-19 Thu 07:58]
   - NOT a comprehensive introduction to Java.

   - NOT a comprehensive design patterns book.
     You need to learn more by youself, and you can use the additional references
     about patterns mentioned at the end of the book.

** DONE ACKNOWLEDGEMENTS
   CLOSED: [2017-10-19 Thu 07:58]
** DONE READING GUIDELINES
   CLOSED: [2017-10-19 Thu 08:03]
   - Do NOT rush through this book.
     Allow seven sittings, at least.

   - Typeface conventions:
     + /italic/ for field and method names.
     + /sans serif/ for basic data.
     + /boldface/ for keywords.
     + /typewriter face (mono)/ for code.

* DONE Experimenting with Java - xiii
  CLOSED: [2017-10-19 Thu 10:48]
  Here are some hints on how to experiment with Java:
  1. Create a file that contains a complete hierarchy of classes.
     =TODO= Try JShell when use Java 9

  2. To each class whose name does NOT end with a superscript D, V, I, or M, add
     a ~toString~ method accroding to these rules:
     + no field class
       ~return "new " + getClass().getName() + "()";~

     + one field, say ~x~, class
       ~return "new " + getClass().getName() + "(" + x + ")";~

     + two fields, say ~x~ and ~y~, class
       ~return "new " + getClass().getName() + "(" + x + ", " + y + ")";~

  3. Add a ~Main~ class with ~main~ method to the bottom of the file:
     #+BEGIN_SRC java
       class Main {
           public static void main(String args[]) {
               DataType_or_Interface y = new ......;
               System.out.println(...);
           }
       }
     #+END_SRC

  4. Finally, compile the file and interpret the class ~Main~.

* DONE 1. Modern Toys - 3
  CLOSED: [2017-10-19 Thu 09:35]
  - [Page 4]
    + Q: What are ~abstract class~, ~class~, and ~extends~?

    + A: Easy:
      * ~abstract class~ introduces a datatype
      * ~class~ introduces a variant
      * ~extends~ connects a variant to a datatype

  - *The First Bit of Advice*
    When specifying a collection of data
    + use abstract classes for datatypes
    + extended classes for variants.

* DONE 2. Methods to Our Madness - 13
  CLOSED: [2017-10-19 Thu 10:40]
  - [Page 15] An /abstract method/ in an /abstract class/ introduces an
    _obligation_.

  - [Page 26] *The Second Bit of Advice*
    When writing a function over a data type, place a method in each of the
    variants that make up the datatype.

    If a field of a variant belongs to the same datatype, the method may call
    the corresponding method of the field in computing the function.

* DONE 3. What's New? - 43
  CLOSED: [2017-10-19 Thu 16:18]
  - EN:
    + Anchovy [page 43]

  - *The Third Bit of Advice*
    When writing a function that returns values of a datatype, use ~new~ to
    create these values.

  - Footnote 4 [page 53]

* DONE 4. Come to Our Carousel - 57
  CLOSED: [2017-10-19 Thu 16:51]
  - [Page 57] Vistor class:
    #+BEGIN_SRC java
      class OnlyOnionsV {
          boolean forSkewer() { return true; }
          boolean forOnion(ShishD s) { return s.onlyOnions(); }
          boolean forLamb(ShishD s) { return false; }
          boolean forTomato(ShishD s) { return false; }
      }
    #+END_SRC

  - [Page 59] How to use the /visitor class/:
    #+BEGIN_SRC java
      abstract class ShishD {
          OnlyOnionsV ooFn = new OnlyOnionsV();
          abstract boolean onlyOnions();
      }

      class Skewer extends ShishD {
          boolean onlyOnions() {
              return ooFn.forSkewer();
          }
      }

      class Onion extends ShishD {
          ShishD s;

          Onion(ShishD _s) { s = _s; }

          boolean onlyOnions() {
              return ooFn.forOnion(s);
          }
      }

      class Lamb extends ShishD {
          ShishD s;

          Lamb(ShishD _s) { s = _s; }

          boolean onlyLambs() {
              return ooFn.forLamb(s);
          }
      }

      class Tomato extends ShishD {
          ShishD s;

          Tomato(ShishD _s) { s = _s; }

          boolean onlyTomatos() {
              return ooFn.forTomato(s);
          }
      }
    #+END_SRC

  - *The Fourth Bit of Advice*
    When writing several functions for the same self-referential datatype,
    use /visitor protocols/ so that all methods for a function can be found in a
    single class.

    =TODO=
    =TODO= =???= /self-referential datatype/
    =TODO=

* TODO 5. Objects Are People, Too - 69
* TODO 6. Boring Protocols - 85
* TODO 7. Oh My! - 99

* TODO 8. Like Father, Like Son - 117
* TODO 9. Be a Good Visitor - 139

* TODO 10. The State of Things to Come - 161
* TODO Commencement - 177
* TODO Index - 178
