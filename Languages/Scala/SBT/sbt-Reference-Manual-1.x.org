#+TITLE: sbt Reference Manual
#+VERSION: 1.x
#+AUTHOR: Shiti Saxena
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[1. Getting Started with sbt][1. Getting Started with sbt]]
  - [[a. Installing sbt][a. Installing sbt]]
    - [[i. Installing sbt on Mac][i. Installing sbt on Mac]]
    - [[ii. Installing sbt on Windows][ii. Installing sbt on Windows]]
    - [[iii. Installing sbt on Linux][iii. Installing sbt on Linux]]
  - [[b. Hello, World =NOTE=][b. Hello, World =NOTE=]]
  - [[c. Directory structure][c. Directory structure]]
  - [[d. Running][d. Running]]
  - [[e. Build definition][e. Build definition]]
  - [[f. Task graph][f. Task graph]]
  - [[g. Scopes][g. Scopes]]
  - [[h. Appending values][h. Appending values]]
  - [[i. Scope delegation (~.value~ lookup)][i. Scope delegation (~.value~ lookup)]]
  - [[j. Library dependencies][j. Library dependencies]]
  - [[k. Multi-project builds][k. Multi-project builds]]
  - [[l. Using plugins =TODO= =A lot of questions=][l. Using plugins =TODO= =A lot of questions=]]
  - [[m. Custom settings and tasks][m. Custom settings and tasks]]
  - [[n. Organizing the build][n. Organizing the build]]
  - [[o. Getting Started summary =Important=][o. Getting Started summary =Important=]]
- [[2. General Information][2. General Information]]
  - [[a. Credits][a. Credits]]
  - [[b. Community Plugins][b. Community Plugins]]
  - [[c. Community Repository Policy][c. Community Repository Policy]]
  - [[d. Bintray For Plugins][d. Bintray For Plugins]]
  - [[e. Setup Notes][e. Setup Notes]]
  - [[f. Using Sonatype][f. Using Sonatype]]
  - [[g. Contributing to sbt][g. Contributing to sbt]]
  - [[h. Changes][h. Changes]]
    -   [[i. Migrating from sbt 0.13.x][i. Migrating from sbt 0.13.x]]
    -  [[ii. sbt 1.0.4][ii. sbt 1.0.4]]
    - [[iii. sbt 0.13.5+ Technology Previews][iii. sbt 0.13.5+ Technology Previews]]
    -  [[iv. sbt 0.13.0 - 0.13.2][iv. sbt 0.13.0 - 0.13.2]]
    -   [[v. sbt 0.12.4][v. sbt 0.12.4]]
    -  [[vi. Older Changes][vi. Older Changes]]
    - [[vii. Migrating from 0.7 to 0.10+][vii. Migrating from 0.7 to 0.10+]]
- [[3. Detailed Topics][3. Detailed Topics]]
  - [[a. Using sbt][a. Using sbt]]
    -   [[i. Command Line Reference][i. Command Line Reference]]
    -  [[ii. Console Project][ii. Console Project]]
    - [[iii. Cross-building][iii. Cross-building]]
    -  [[iv. Interacting with the Configuration System][iv. Interacting with the Configuration System]]
    -   [[v. Triggered Execution][v. Triggered Execution]]
    -  [[vi. Scripts, REPL, and Dependencies][vi. Scripts, REPL, and Dependencies]]
    - [[vii. Understanding Incremental Recompilation][vii. Understanding Incremental Recompilation]]
  - [[b. Configuration][b. Configuration]]
    -    [[i. Classpaths, sources, and resources][i. Classpaths, sources, and resources]]
    -   [[ii. Compiler Plugin Support][ii. Compiler Plugin Support]]
    -  [[iii. Configuring Scala][iii. Configuring Scala]]
    -   [[iv. Forking][iv. Forking]]
    -    [[v. Global Settings][v. Global Settings]]
    -   [[vi. Java Sources][vi. Java Sources]]
    -  [[vii. Mapping Files][vii. Mapping Files]]
    - [[viii. Local Scala][viii. Local Scala]]
    -   [[ix. Macro Projects][ix. Macro Projects]]
    -    [[x. Paths][x. Paths]]
    -   [[xi. Parallel Execution][xi. Parallel Execution]]
    -  [[xii. External Processes][xii. External Processes]]
    - [[xiii. Running Project Code][xiii. Running Project Code]]
    -  [[xiv. Testing][xiv. Testing]]
  - [[c. Dependency Management][c. Dependency Management]]
    -    [[i. Artifacts][i. Artifacts]]
    -   [[ii. Dependency Management Flow][ii. Dependency Management Flow]]
    -  [[iii. Library Management][iii. Library Management]]
    -   [[iv. Proxy Repositories][iv. Proxy Repositories]]
    -    [[v. Publishing][v. Publishing]]
    -   [[vi. Resolvers][vi. Resolvers]]
    -  [[vii. Update Report][vii. Update Report]]
    - [[viii. Cached resolution][viii. Cached resolution]]
  - [[d. Tasks and Commands][d. Tasks and Commands]]
    -   [[i. Tasks][i. Tasks]]
    -  [[ii. Input Tasks][ii. Input Tasks]]
    - [[iii. Commands][iii. Commands]]
    -  [[iv. Parsing and tab completion][iv. Parsing and tab completion]]
    -   [[v. State and actions][v. State and actions]]
    -  [[vi. Tasks/Settings: Motivation][vi. Tasks/Settings: Motivation]]
  - [[e. Plugins and Best Practices][e. Plugins and Best Practices]]
    -   [[i. General Best Practices][i. General Best Practices]]
    -  [[ii. Plugins][ii. Plugins]]
    - [[iii. Plugins Best Practices][iii. Plugins Best Practices]]
    -  [[iv. Setting up Travis CI with sbt][iv. Setting up Travis CI with sbt]]
    -   [[v. Testing sbt plugins][v. Testing sbt plugins]]
    -  [[vi. sbt new and Templates][vi. sbt new and Templates]]
    - [[vii. Cross building plugins][vii. Cross building plugins]]
- [[4. How to...][4. How to...]]
  - [[a. Classpaths][a. Classpaths]]
  - [[b. Customizing paths][b. Customizing paths]]
  - [[c. Generating files][c. Generating files]]
  - [[d. Inspect the build][d. Inspect the build]]
  - [[e. Interactive mode][e. Interactive mode]]
  - [[f. Configure and use logging][f. Configure and use logging]]
  - [[g. Project metadata][g. Project metadata]]
  - [[h. Configure packaging][h. Configure packaging]]
  - [[i. Running commands][i. Running commands]]
  - [[j. Configure and use Scala][j. Configure and use Scala]]
  - [[k. Generate API documentation][k. Generate API documentation]]
  - [[l. Triggered execution][l. Triggered execution]]
  - [[m .Define Custom Tasks][m .Define Custom Tasks]]
  - [[n. How to take an action on startup][n. How to take an action on startup]]
  - [[o. Sequencing][o. Sequencing]]
    -   [[i. Defining a sequential task with Def.sequential][i. Defining a sequential task with Def.sequential]]
    -  [[ii. Defining a dynamic task with Def.taskDyn][ii. Defining a dynamic task with Def.taskDyn]]
    - [[iii. Doing something after an input task][iii. Doing something after an input task]]
    -  [[iv. Defining a dynamic input task with Def.inputTaskDyn][iv. Defining a dynamic input task with Def.inputTaskDyn]]
    -   [[v. How to sequence using commands][v. How to sequence using commands]]
  - [[p. Examples][p. Examples]]
    -   [[i. ~.sbt~ build examples][i. ~.sbt~ build examples]]
    -  [[ii. ~.sbt~ build with ~.scala~ files example][ii. ~.sbt~ build with ~.scala~ files example]]
    - [[iii. Advanced configurations example][iii. Advanced configurations example]]
    -  [[iv. Advanced command example][iv. Advanced command example]]
- [[5. Frequently Asked Questions][5. Frequently Asked Questions]]
- [[6. Index][6. Index]]
- [[7. Developer’s Guide (Work in progress)][7. Developer’s Guide (Work in progress)]]
  - [[a. Modularization][a. Modularization]]
    - [[i. Module summary][i. Module summary]]
  - [[b. sbt Coding Guideline][b. sbt Coding Guideline]]
  - [[c. sbt-datatype][c. sbt-datatype]]
  - [[d. Compiler Interface][d. Compiler Interface]]
    - [[i. Fetching the most specific sources][i. Fetching the most specific sources]]
  - [[e. sbt Launcher][e. sbt Launcher]]
    -   [[i. Getting Started with the sbt launcher][i. Getting Started with the sbt launcher]]
    -  [[ii. Sbt Launcher Architecture][ii. Sbt Launcher Architecture]]
    - [[iii. sbt Launcher Configuration][iii. sbt Launcher Configuration]]
  - [[f. Notes][f. Notes]]
    -   [[i. Core Principles][i. Core Principles]]
    -  [[ii. Settings Core][ii. Settings Core]]
    - [[iii. Setting Initialization][iii. Setting Initialization]]
    -  [[iv. Build Loaders][iv. Build Loaders]]
    -   [[v. Creating Command Line Applications Using sbt][v. Creating Command Line Applications Using sbt]]
    -  [[vi. Nightly Builds][vi. Nightly Builds]]
- [[Contents in Depth][Contents in Depth]]
- [[Combined Pages][Combined Pages]]

* DONE 1. Getting Started with sbt
  CLOSED: [2017-12-21 Thu 05:26]
  - The most important conceptual background can be found in
    + /build definition/
    + /scopes/
    + /task graph/

** DONE a. Installing sbt
   CLOSED: [2017-12-21 Thu 17:50]
*** TODO i. Installing sbt on Mac
*** TODO ii. Installing sbt on Windows
*** iii. Installing sbt on Linux

** TODO b. Hello, World =NOTE=
** DONE c. Directory structure
   CLOSED: [2017-12-18 Mon 21:07]
   - Base directory :: the directory containing the project.

   - Source code :: /sbt/ uses the same directory structure as /Maven/ for source
                    files by default (all paths are relative to the base
                    directory). 

     + Source code directory structure
       #+BEGIN_SRC text
         src/
           main/
             resources/
                <files to include in main jar here>
             scala/
                <main Scala sources>
             java/
                <main Java sources>

           test/
             resources
                <files to include in test jar here>
             scala/
                <test Scala sources>
             java/
                <test Java sources>
       #+END_SRC

     + Other directories in ~src/~ will be ignored.
       Additionally, all hidden directories will be ignored.

     + You can also put =.scala= files in the base directory.
       This is usually for small projects.

       =From Jian= I will NEVER do this with project source file. However,
       see below!!!

     + Put =.scala= files in base directory is NOT ONLY an odd trick.
       It becomes relevant later. =TODO= =IMPORTANT=

   - *sbt build definition files*
     =build.sbt= (actually any files named with =.sbt= extension) in the
     project's base directory.

   - *Build support files*
     In addition to =build.sbt=, =project= directory can contain =.scala= files
     that defines helper objects and one-off plugins.

     =TODO= See /organizing the build/ for more.

   - *Build products*
     Generated files (compiled classes, packaged jars, managed files, caches, and
     documentation) will be written to the =target= directory by default.

   - *Configuring version control*
     Add ~target/~ to =.gitignore=

     Note:
     + this deliberately has _a trailing ~/~ (to match only directories)_
       and
     + it deliberately has _NO leading ~/~ (to match =project/target/= in
       addition to plain =target/=)_.

** DONE d. Running
   CLOSED: [2017-12-18 Mon 21:07]
   - *sbt shell*
     + Use ~sbt~ command to get into /sbt shell/.

       Inside /sbt shell/, you can type in sbt commands like ~compile~, ~run~,
       etc.

   - *Batch mode*
     In you system shell, type ~sbt~, and then specify a space-separated list of
     /sbt commands/ as arguments.
       If a /sbt command/ needs arguments, enclose this command and its argument
     in quotes as one string, and pass this string as one argument of the ~sbt~
     command. sbt by enclosing them in quotes.

     + For example, ~sbt clean compile "testOnly TestA testB"~. Here we have
       * _THREE commands_
       * the last command ~testOnly~ has _TWO arguments_.

     + =Note=:
       Running in batch mode requires JVM spinup and JIT each time, so your build
       will run _much slower_.

       For day-to-day coding, we recommend
       * using the /sbt shell/
         or
       * /Continuous build and test feature/ described below. =TODO=

   - *Continuous build and test*
     + Type in a =~= prefixed prefixed command, and press <Enter>. Then the
       command after =~= will run automatically when one or more source files
       change.

     + Press <Enter> again to stop watching for changes.

     + This feature can be used with either /sbt shell/ or /batch mode/.

     + =TODO= See /Triggered Execution/ for more details.

   - *Common commands*
     - =TODO= 
       For a more complete list, see /Command Line Reference/.

     - =TODO= This table
       | ~clean~	           | Deletes all generated files (in the target directory).   |
       |---------------------+----------------------------------------------------------|
       | ~compile~	         | Compiles the main sources                                |
       |                     | (in src/main/scala and src/main/java directories).       |
       |---------------------+----------------------------------------------------------|
       | ~test~	             | Compiles and runs all tests.                             |
       |---------------------+----------------------------------------------------------|
       | ~console~	         | Starts the Scala interpreter with a classpath            |
       |                     | including the compiled sources and all dependencies.     |
       |                     | To return to sbt, type :quit, Ctrl+D (Unix), or          |
       |                     | Ctrl+Z (Windows).                                        |
       |---------------------+----------------------------------------------------------|
       | ~run <argument>*~	 | Runs the main class for the project in the same          |
       |                     | virtual machine as sbt.                                  |
       |---------------------+----------------------------------------------------------|
       | ~package~	         | Creates a jar file containing the files in               |
       |                     | src/main/resources and the classes compiled from         |
       |                     | src/main/scala and src/main/java.                        |
       |---------------------+----------------------------------------------------------|
       | ~help <command>~	   | Displays detailed help for the specified command.        |
       |                     | If no command is provided, displays brief                |
       |                     | descriptions of all commands.                            |
       |---------------------+----------------------------------------------------------|
       | ~reload~	           | Reloads the build definition                             |
       |                     | (=build.sbt=, =project/*.scala=, =project/*.sbt= files). |
       |                     | Needed if you change the build definition.               |

   - *Tab completion*
     Press <Tab> once to show only a subset of most likely completions.
     Press <Tab> more times to show more verbose choices.

   - *History Commands* =TODO= 1. =RE-READ= 2. =Try them in practice=
     | ~!~	       | Show history command help.                                        |
     | ~!!~	       | Execute the previous command again.                               |
     | ~!:~	       | Show all previous commands.                                       |
     | ~!:n~	     | Show the last ~n~ commands.                                       |
     | ~!n~	       | Execute the command with index ~n~, as shown by the ~!:~ command. |
     | ~!-n~	     | Execute the _nth_ command before this one.                        |
     | ~!string~	 | Execute the most recent command starting with ~string~.           |
     | ~!?string~	 | Execute the most recent command containing ~string~.              |

** TODO e. Build definition
   - This page describes sbt build definitions, including
     + some “theory”
     + the syntax of =build.sbt=.

   - *Specifying the sbt version*
     If =project/build.sbt= is not present, the sbt launcher will choose an
     _ARBITRARY_ version. =IMPORTANT= _NO guarantee_ to get the newest version!!!

     _YOU SHOULD NEVER DO THIS!!!_

   - *What is a build definition?*
     + build definition :: A set of /projects/ (of type ~Project~).

     + The /build definition/ is defined in =build.sbt=.

     + Because the term /project/ can be ambiguous, we often call it /subproject/
       in this guide.

     + Example:
       #+BEGIN_SRC scala
         lazy val root = (project in file("."))
           .settings(
             name := "Hello",
             scalaVersion := "2.12.3"
           )
       #+END_SRC

     + Each subproject is configured by key-value pairs.
       =IMPORTANT=

   - *How build.sbt defines settings*
     =build.sbt= defines /subprojects/, which holds a sequence of key-value pairs
     called /setting expressions/ using =build.sbt= DSL.
     #+BEGIN_SRC scala
       lazy val root = (project in file("."))
         .settings(
           name         := "Hello",
           organization := "com.example",
           scalaVersion := "2.12.4",
           version      := "0.1.0-SNAPSHOT"
         )
     #+END_SRC

     + The =build.sbt= DSL: a setting/task expression

       organization     :=       { "com.example" }
       ------------  ---------   -----------------
            key      operator   (setting/task) body

     + The name /setting expression/ has wider meaning than /task expression/.
       =TODO= More details in this section.

     + A key is an instance of ~SettingKey[T]~, ~TaskKey[T]~, or ~InputKey[T]~,
       where ~T~ is the expected value type.

     + You can use ~val~'s, ~lazy val~'s, and ~def~'s in =build.sbt=.

     + _Top-level objects and classes_ are NOT allowed in =build.sbt=.
       Those should go in the =project/= directory as Scala source files.
       =TODO=

   - *Keys*
     + *Types*
       There are _THREE_ flavors of key:
       * ~SettingKey[T]~:
         a key for a value _computed once_ (the value is computed _when loading_
         the /subproject/, and kept around).

       * ~TaskKey[T]~:
         a key for a value, called a /task/, that has to be _recomputed EACH
         time_, potentially _with side effects_.

       * ~InputKey[T]~:
         a key for a /task/ that _has command line arguments_ as input.
         =TODO= Check out /Input Tasks/ for more details.

     + *Built-in Keys*
       The built-in keys are just fields in an object called /Keys/.
       A =build.sbt= implicitly has an import =sbt.Keys._=

     + *Custom Keys*
       * Custom keys may be defined with their respective _creation methods_:
         - ~settingKey~
         - ~taskKey~
         - ~inputKey~

       * Each method expects the type of the value associated with the key as
         well as a description.
         =TODO= =???=

       * The name of the key is taken from the ~val~ the key is assigned to.
         For example, to define a key for a new task called ~hello~,
         ~lazy val hello = taskKey[Unit]("An example task")~

       * There are ~val~'s and ~def~'s in addition to settings.
         1. Run ~val~'s and ~def~'s _BEFORE_ /settings/ regardless of where they
            are defined in the file.

         2. Typically, ~lazy val~'s are used instead of ~val~'s to avoid
            initialization order problems.

     + *Task vs Setting keys*
       * Define a task with ~TaskKey[T]~.

       * Tasks :: operations such as compile or package.

       * /Tasks/
         - may return ~Unit~, OR
         - may return a value related to the /task/.

         For example, ~package~ is a ~TaskKey[File]~ and its value is the jar
         file it creates.

       * Each time you /start a task execution/, for example by typing ~compile~
         at the /interactive sbt prompt/, sbt will re-run any tasks involved
         exactly _ONCE_.


   - *Defining tasks and settings*
     + *Types for tasks and settings*

   - *Keys in sbt shell*

   - *Imports in* =build.sbt=

   - *Bare =.sbt= build definition*

   - *Adding library dependencies*

** DONE f. Task graph
   CLOSED: [2017-12-19 Tue 20:27]
   Continuing from /build definition/, this page explains =build.sbt= definition
   in more detail.

   - RATHER THAN thinking of settings as _key-value pairs_,
     a better analogy would be to think of it as a /directed acyclic graph
     (DAG)/ of /tasks/ where the edges denote /happens-before/. Let's call this
     the /task graph/.

   - *Terminology*
     Review:
     + Setting/Task expression :: entry inside ~.settings(...)~.

     + Key :: Left hand side of a setting expression.
              It could be a ~SettingKey[A]~, a ~TaskKey[A]~, or an ~InputKey[A]~.

     + Setting :: Defined by a /setting expression/ with ~SettingKey[A]~.
                  The value is calculated _ONCE during load_.

     + Task :: Defined by a /task expression/ with ~TaskKey[A]~.
               The value is calculated _EACH TIME it is invoked_.

   - *Declaring dependency to other tasks*
     _In =build.sbt= DSL_, we use ~.value~ method to _express the dependency to
     another task or setting_. The ~value~ method is special (explained later)
     and _may ONLY_ be (=TODO= =From Jian= may???) called in the argument to ~:=~
     (or, ~+=~ or ~++=~, which we'll see later).

     + Example
       #+BEGIN_SRC scala
         // build.sbt
         val scalacOptions = taskKey[Seq[String]]("Options for the Scala compiler.")
         val update = taskKey[UpdateReport]("Resolves and optionally retrieves dependencies, producing a report.")
         val clean = taskKey[Unit]("Deletes files produced by the build, such as generated sources, compiled classes, and task caches.")

         scalacOptions := {
           val ur = update.value  // `update` task happens-before `scalacOptions`
           val x = clean.value    // `clean` task happens-before `scalacOptions`
           // ---- `scalacOptions` begins here ----
           ur.allConfigurations.take(3)
         }
       #+END_SRC

       + ~update.value~ and ~clean.value~ declare /task dependencies/, whereas
         ~ur.allConfigurations.take(3)~ is the body of the /task/.

       + ~.value~ is _NOT a normal Scala method call_.
         =build.sbt= DSL uses a _macro_ to _lift these outside of the task body_.
         Both ~update~ and ~clean~ /tasks/ are completed by the time task engine
         evaluates the opening ~{~ of ~scalacOptions~ _regardless of which line
         it appears in the body_.

         For example,
         * #1
           #+BEGIN_SRC scala
             lazy val root = (project in file("."))
               .settings(
                 name := "Hello",
                 organization := "com.example",
                 scalaVersion := "2.12.4",
                 version := "0.1.0-SNAPSHOT",
                 scalacOptions := {
                   val out = clean.value  // `clean` task happens-before `scalacOptions`
                   val log = out.log
                   log.info("123")
                   val ur = update.value  // `update` task happens-before `scalacOptions`
                   log.info("456")
                   ur.allConfigurations.take(3)
                 }
               )

             // > scalacOptions
             // [info] Updating {file:/xxx/}root...
             // [info] Resolving jline#jline;2.14.1 ...
             // [info] Done updating.
             // [info] 123
             // [info] 456
             // [success] Total time: 0 s, completed Jan 2, 2017 10:38:24 PM
           #+END_SRC
           From the out, it looks like run ~streams~ and ~update~ before the ~{~
           of ~scalacOptions~

         * #2
           #+BEGIN_SRC scala
             lazy val root = (project in file("."))
               .settings(
                 name := "Hello",
                 organization := "com.example",
                 scalaVersion := "2.12.4",
                 version := "0.1.0-SNAPSHOT",
                 scalacOptions := {
                   val ur = update.value  // update task happens-before scalacOptions
                   if (false) {
                     val x = clean.value  // clean task happens-before scalacOptions
                   }
                   ur.allConfigurations.take(3)
                 }
               )

             // > run
             // [info] Updating {file:/xxx/}root...
             // [info] Resolving jline#jline;2.14.1 ...
             // [info] Done updating.
             // [info] Compiling 1 Scala source to /Users/eugene/work/quick-test/task-graph/target/scala-2.12/classes...
             // [info] Running example.Hello
             // hello
             // [success] Total time: 0 s, completed Jan 2, 2017 10:45:19 PM

             // > scalacOptions
             // [info] Updating {file:/xxx/}root...
             // [info] Resolving jline#jline;2.14.1 ...
             // [info] Done updating.
             // [success] Total time: 0 s, completed Jan 2, 2017 10:45:23 PM
           #+END_SRC
           Now if you check for =target/scala-2.12/classes/=, it won't exist
           because ~clean~ task has run even though it is inside the
           ~if (false)~.

       + =IMPORTANT=
         NO guarantee about the ordering of ~update~ and ~clean~ /tasks/.
         Can be
         * ~update~ before ~clean~
         * ~clean~ before ~update~
         * in parallel

   - *Inlining ~.value~ calls*
     For example,
     #+BEGIN_SRC scala
       scalaOptions := {
         val x = clean.value
         update.value.allConfigurations.take(3)
       }
     #+END_SRC
     =From Jian= I don't think this is a good feature. I'll never use inlining in
     any formal projects.

     + *Inspecting the task*
       From the output of ~inspect <task name>~, you can find the dependencies
       information.

     + *Defining a task that depends on other settings*
       * Example,
         #+BEGIN_SRC scala
           lazy val root = (project in file("."))
             .settings(
               name := "Hello",
               organization := "com.example",
               scalaVersion := "2.12.4",
               version := "0.1.0-SNAPSHOT",
               scalacOptions := List("-encoding", "utf8", "-Xfatal-warnings", "-deprecation", "-unchecked"),
               scalacOptions := {
                 val old = scalacOptions.value
                 scalaBinaryVersion.value match {
                   case "2.12" => old
                   case _      => old filterNot (Set("-Xfatal-warnings", "-deprecation").apply)
                 }
               }
             )

           // > show scalacOptions
           // [info] * -encoding
           // [info] * utf8
           // [info] * -Xfatal-warnings
           // [info] * -deprecation
           // [info] * -unchecked
           // [success] Total time: 0 s, completed Jan 2, 2017 11:44:44 PM
           //
           // > ++2.11.8!
           // [info] Forcing Scala version to 2.11.8 on all projects.
           // [info] Reapplying settings...
           // [info] Set current project to Hello (in build file:/xxx/)
           //
           // > show scalacOptions
           // [info] * -encoding
           // [info] * utf8
           // [info] * -unchecked
           // [success] Total time: 0 s, completed Jan 2, 2017 11:44:51 PM
         #+END_SRC
         The ~++2.11.8!~ command can force the Scala version choice on all
         projects.

       * A /task key/ can depend on /a setting key/, if two keys have the same
         value type.
         #+BEGIN_SRC scala
           val scalacOptions = taskKey[Seq[String]]("Options for the Scala compiler.")
           val checksums = settingKey[Seq[String]]("The list of checksums to generate and to verify for dependencies.")

           scalacOptions := checksums.value

           // Illegal
           checksums := scalacOptions.value
         #+END_SRC

         There is _NO way to go the other direction_ -- a /task key/ cannot depend
         on a /setting key/.

     + *Defining a setting that depends on other settings*
       For example,
       #+BEGIN_SRC scala
         scalaSource in Compile := {
           val old = (scalaSource in Compile).value
           scalaBinaryVersion.value match {
             case "2.11" => baseDirectory.value / "src-2.11" / "main" / "scala"
             case _      => old
           }
         }
       #+END_SRC
       This rewires ~scalaSource~ in ~Compile~ key to a different directory only
       when ~scalaBinaryVersion~ is "2.11".

   - *What's the point of the =build.sbt= DSL?*
     + *Intro to Make*
     + *Rake*
     + *Benefits of hybrid flow-based programming*
       1. De-duplication
          =???=

       2. Parallel
          The task engine can schedule mutually non-dependent tasks in parallel.

       3. The separation of concern and the flexibility.
          * Use the task graph to wire the tasks together, while

          * /sbt/ and /plugins/ can provide various features such as
            _compilation_ and _library dependency management_ as functions that
            can be reused.

   - *Summary*

** TODO g. Scopes
   - *The whole story about keys*
   - *Scope axes*

   - 
     + *Scoping by the subproject axis*
     + *Scoping by the configuration axis*
     + *Scoping by Task axis*
     + *Global scope component*

   - *Referring to scopes in a build definition*

   - *Referring to scoped keys from the sbt shell*

   - *Examples of scoped key notation*

   - *Inspecting scopes*

   - *When to specify a scope*

   - *Build-level settings*

   - *Scope delegation*

** TODO h. Appending values
   - *Appending to previous values:* ~+=~ and ~++=~
     + When the value type, i.e. the ~T~ in ~SettingKey[T]~, is a sequence, we
       have _TWO_ more operations (besides ~:=~):
       * ~+=~ will append a single element to the sequence.

       * ~++=~ will concatenate another sequence.

     + For example,
       #+BEGIN_SRC scala
         // Use `+=`
         sourceDirectories in Compile += new File("source")
         // // Or
         sourceDirectories in Compile += file("source")


         // Use `++=`
         sourceDirectories in Compile ++= Seq(file("sources1"), file("sources2"))
       #+END_SRC

       
     + *When settings are undefined*
       * Whenever a setting uses ~:=~, ~+=~, or ~++=~ to create a dependency, the
         value it depends on must exist. Or else, sbt will complain
         "Reference to undefined setting". Pay attention to the /scope/.

     + *Tasks based on other keys' values* =TODO= =???= 
       ~Def.task~
       
   - *Appending with dependencies:* ~+=~ and ~++=~
     Example,
     ~cleanFiles += file("coverage-report-" + name.value + ".txt")~

** TODO i. Scope delegation (~.value~ lookup)
   - *Scope delegation rules*
   - *Rule 1: Scope axis precedence*
   - *Rule 2: The task axis delegation*
   - *Rule 3: The configuration axis search path*
   - *Rule 4: The subproject axis search path*
   - *Inspect command lists the delegates*
   - ~.value~ *lookup vs dynamic dispatch*

** DONE j. Library dependencies
   CLOSED: [2017-12-20 Wed 14:44]
   - Library dependencies can be added in _TWO_ ways:
     + unmanaged dependencies :: jars dropped into the =lib= directory.

     + managed dependencies :: packages configured in the build definition and
          downloaded automatically from repositories.

   - *Unmanaged dependencies*
     + If you want the simplest use of /unmanaged dependencies/, there's NOTHING
       to add to =build.sbt=, just put jar's in the =lib= directory in your
       project.

     + /Dependencies/ in =lib= go on all the /classpaths/ (for ~compile~, ~test~,
       ~run~, and ~console~).

       If you wanted to change the /classpath/ for just one of those, you would
       adjust ~dependencyClasspath in Compile~ or
       ~dependencyClasspath in Runtime~ for example.

     + If you want, you can change ~unmanagedBase~ key to use a different
       directory rather than =lib=. For example, use =custom_lib= instead:
       ~unmanagedBase := baseDirectory.value / "custom_lib"~
       Here ~baseDirectory~ is the project root directory.

     + ~unmanagedJars~ task: lists the jars from the ~unmanagedBase~ directory.

     + If you need to use multiple directories for /unmanaged packages/, you
       might need to replace the whole ~unmanagedJars~ task with the one that can
       do something to help you. e.g. empty the list for ~Compile~ configuration
       regardless of the files in =lib= directory:
       ~unmanagedJars in Compile := Seq.empty[sbt.Attributed[java.io.File]]~

   - *Managed Dependencies*
     + *The ~libraryDependencies~ key*
       * ~libraryDependencies~ is declared in ~sbt.Keys~ as
         ~val libraryDependencies = settingKey[Seq[ModuleID]]("Declares managed dependencies.")~

       * Add a dependency:
         - ~libraryDependencies += groupID % artifactID % revision~

         - ~libraryDependencies += groupID % artifactID % revision % configuration~
           The ~configuration~ above can be
           + a string
             OR
           + a ~Configuration~ val

       * ~%~ can help to convert a string to ~ModuleID~ to satisfy the
         declaration of ~libraryDependencies~

     + For example, type
       ~libraryDependencies += "org.apache.derby" % "derby" % "10.4.1.3"~ into
       =build.sbt= and then ~update~, sbt should download Debry to
       ~/.ivy2/cache/org.apache.derby/~

       Note: you actually rarely type ~update~ command for _TWO_ reasons
       - ~compile~ depends on ~update~, when you call ~compile~ related tasks,
         ~update~ will be run automatically.

       - IDEs like Intellij idea can be configured to run ~update~ when they
         detect the change of =build.sbt=

     + You can also use ~++=~, and you rarely use ~:=~

     + *Getting the right Scala version with* ~%%~
       ~%%~ is a shortcut. If ~scalaVersion~ for your build is set to 2.11.1, the
       two lines below are equivalent:
       * ~libraryDependencies += "org.scala-tools" % "scala-stm_2.11.1" % "0.3"~
       * ~libraryDependencies += "org.scala-tools" %% "scala-stm" % "0.3"~

       many dependencies are compiled for multiple Scala versions, and you’d like
       to get the one that matches your project to ensure binary compatibility.

       * =TODO= See /Cross Building/ for more details.

     + *Ivy revisions*
       =TODO= See the /Ivy revisions/ documentation for details. =TODO=

       The revision does NOT have to be a single fixed version.
       You can specify ~"latest.integration"~, ~"2.9.+"~, or ~"[1.0,)"~.

     + *Resolvers*
       * /sbt/ uses the standard Maven2 repository by default.

       * If this CANNOT cover all your cases, you'll have to add a /resolver/ to
         help Ivy find it. The pattern is ~resolvers += <name> at <location>~.
         For example,
         ~resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"~

       * This key is defined in ~sbt.Keys~:
         ~val resolvers = settingKey[Seq[Resolver]]("The user-defined additional resolvers for automatically managed dependencies.")~

       * If you want to search your local Maven repository
         ~resolvers += "Local Maven Repository" at "file://" + Path.userHome.absolutePath + "/.m2/repository"~
         or, for convenience:
         ~resolvers += Resolver.mavenLocal~

       * See /Resolvers/ for details on defining other types of repositories.

     + *Overriding default resolvers*
       * ~resolvers~ does NOT contain the /default resolvers/;
         only additional ones added by your build definition.

       * sbt combines ~resolvers~ with some /default repositories/ to form
         ~externalResolvers~.

       * To _change_ or _remove_ the /default resolvers/, you would need to
         _OVERRIDE_ ~externalResolvers~ instead of ~resolvervs~.

     + *Per-configuration dependencies*
       Often some dependencies (like ~ScalaCheck~, ~Specs2~, and ~ScalaTest~) are
       used by your test code (by default in =src/test/scala=, which is compiled
       by the ~Test~ configuration) but NOT your main code.

       * If you want a dependency to show up in the /classpath/ ONLY for the
         ~Test~ configuration and NOT the ~Compile~ configuration, add ~% "test"~
         like this:
         ~libraryDependencies += "org.apache.derby" % "derby" % "10.4.1.3" % "test"~

       * You may also use the _type-safe version_ of ~Test~ configuration as
         follows:
         ~libraryDependencies += "org.apache.derby" % "derby" % "10.4.1.3" % Test~

       * After doing this,
         this library is NOT listed in ~compile:dependencyClasspath~,
         but it is listed ~test:dependencyClasspath~

** DONE k. Multi-project builds
   CLOSED: [2017-12-21 Thu 01:12]
   This page introduces _multiple subprojects_ in a single build.

   - *Multiple subprojects*
     Sometimes users may want to keep multiple related /subprojects/ in a single
     build, especially if they depend on one another and you tend to modify them
     together.

     + Each /subproject/ in a build
       * has its own source directory.
       * generates its own jar file when run ~package~.

     + For example,
       #+BEGIN_SRC scala
         lazy val util = (project in file("util"))
         lazy val core = (project in file("core"))
       #+END_SRC

       If the name of a base directory is the same as the name of the ~val~, it
       can be omitted.
       #+BEGIN_SRC scala
         lazy val util = project
         lazy val core = project
       #+END_SRC

     + *Common settings*
       To factor out /common settings/ across multiple /subprojects/,
       + create a sequence named ~commonSettings~
       + call settings method on each project. 

       #+BEGIN_SRC scala
         lazy val commonSettings = Seq(
           organization := "com.example",
           version := "0.1.0-SNAPSHOT",
           scalaVersion := "2.12.4"
         )

         lazy val core = (project in file("core"))
           .settings(
             commonSettings,
             // other settings
             )

         lazy val util = (project in file("util"))
           .settings(
             commonSettings,
             // other settings
             )
       #+END_SRC

     + *Build-wide settings* =TODO= =RE-DO=
       Another a bit advanced technique for factoring out /common settings/
       across /subprojects/ is to define the settings scoped to ~ThisBuild~.

   - *Dependencies*
     * /Subprojects/ in one build can be completely independent of one another.
     * /Subprojects/ can be related to one another by some kind of dependency.
       _TWO_ types:
       - /aggregate/
       - /classpath/

     * *Aggregation*
       - For example,
         #+BEGIN_SRC scala
           lazy val root = (project in file("."))
             .aggregate(util, core)

           lazy val util = (project in file("util"))
           lazy val core = (project in file("core"))
         #+END_SRC
         When you run ~compile~ in the sbt shell (by default, you are in the
         ~root~ subproject), all three projects will be compiled.

         If you want to compile one /subproject/ that being aggregated, rather
         than the ~root~ , you need to use ~project <project name>~ to switch to
         that /subproject/.

       - /aggregation/ will run the aggregated tasks in parallel and with no
         defined ordering between them. 

       - Control aggregation per-task
         #+BEGIN_SRC scala
           lazy val root = (project in file("."))
             .aggregate(util, core)
             .settings(
               aggregate in update := false
             )

           lazy val util = (project in file("util"))
           lazy val core = (project in file("core"))
         #+END_SRC

     * *Classpath dependencies*
       ~lazy val core = project.dependsOn(util)~
       ~dependsOn~ can have multiple arguments.

     * *Per-configuration classpath dependencies*
       - ~foo.dependsOn(bar)~ means that _the compile configuration in ~foo~
         depends on the compile configuration in ~bar~._ 

         This can be written explicitly as:
         ~foo.dependsOn(bar % "compile -> compile")~, where the ~"-> compile"~
         part can be ignored, which is the default, no matter what before the
         ~->~.

       - A useful declaration is ~"test->test"~.
         This allows you to put utility code for testing in ~bar/src/test/scala~
         and then use that code in ~foo/src/test/scala~, for example.

       - There can be multiple configurations for a dependency. For example,
         ~dependsOn(bar % "test->test; compile->compile")~.

       - =TODO= =From Jian=
         Can I put spaces around ~->~???

   - *Default root project*
     If a project is NOT defined for the root directory in the build,
     sbt creates a default one that aggregates all other projects in the build.

   - *Navigating projects interactively*
     + Use ~projects~ to list all /subprojects/, including the /root project/.

       =From Jian= Remember? In this document, /project/ and /subproject/ are
       exchangeable.

     + Use ~project <projectName>~ to select a current project.

     + When you start a /sbt shell/, the /root project/ is selected by default.

     + When you are in /subproject/ A, you can run the command in another
       /subproject/ with the syntax ~subProjectID/command~

   - *Common code*
     The definitions in =.sbt= files are not visible in other =.sbt= files.
     In order to share code between =.sbt= files, define one or more
     _Scala files_ in the =project/= directory of the /build root/. 

** DONE l. Using plugins =TODO= =A lot of questions=
   CLOSED: [2017-12-21 Thu 03:44]
   - *What is a plugin?*
     A plugin extends the build definition, most commonly by adding _NEW_
     /settings/. The new settings could be _NEW_ /tasks/.

     For example, a plugin could add a ~codeCoverage~ task which would
     generate a test coverage report.

   - *Declaring a plugin*
     + If your project is in directory =hello=, and you’re adding /sbt-site
       plugin/ to the build definition, create =hello/project/site.sbt= and
       declare the plugin dependency by passing the plugin's /Ivy module ID/ to
       ~addSbtPlugin~: 
       ~addSbtPlugin("com.typesafe.sbt" % "sbt-site" % "0.7.0")~

     + If add /sbt-assembly/ (=TODO= ???), create =hello/project/assembly.sbt=
       with the following:
       ~addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "0.11.2")~

     + If not located on one of the default repositories =TODO= =???=
       ~resolvers += Resolver.sonatypeRepo("public")~

     + =TODO= See next section.

   - *Enabling and disabling auto plugins*
     + =TODO=
       As of _sbt 0.13.5_, there is a new /auto plugins/ feature that enables
       plugins to automatically, and safely, ensure their settings and
       dependencies are on a project.

       Many /auto plugins/ should have their default settings automatically,
       however _some may require explicit enablement_. For example,
       #+BEGIN_SRC scala
         lazy val util = (project in file("util"))
           .enablePlugins(FooPlugin, BarPlugin)
           .settings(
             name := "hello-util"
           )
       #+END_SRC

       * ~enablePlugins~ method :: it allows projects to explicitly define the
            /auto plugins/ they wish to consume. 
            =TODO= =???=

     + ~disablePlugins~ method :: exclude plugins in some project.
       * For example, remove ~IvyPlugin~ /settings/ from ~util~
         #+BEGIN_SRC scala
           lazy val util = (project in file("util"))
             .enablePlugins(FooPlugin, BarPlugin)
             .disablePlugins(plugins.IvyPlugin)
             .settings(
               name := "hello-util"
             )
         #+END_SRC

     + /Auto plugins/ _should document whether they need to be explicitly enabled_. 
       =TODO= =IMPORTANT=

     + Run the ~plugins~ command to list the enabled auto plugins.
       For example,
       #+BEGIN_SRC text
         > plugins
         In file:/home/jsuereth/projects/sbt/test-ivy-issues/
                 sbt.plugins.IvyPlugin: enabled in scala-sbt-org
                 sbt.plugins.JvmPlugin: enabled in scala-sbt-org
                 sbt.plugins.CorePlugin: enabled in scala-sbt-org
                 sbt.plugins.JUnitXmlReportPlugin: enabled in scala-sbt-org
       #+END_SRC

       This output is showing that the /sbt default plugins/ are all _enabled_.

       * sbt’s default settings are provided via three plugins: =TODO= =???=
         - ~CorePlugin~:
           Provides the core parallelism controls for tasks.

         - ~IvyPlugin~:
           Provides the mechanisms to publish/resolve modules.

         - ~JvmPlugin~:
           Provides the mechanisms to compile/test/run/package Java/Scala projects. 

       In addition, ~JUnitXmlReportPlugin~ provides an experimental support for
       generating /junit-xml/.

     + Older non-auto plugins often require settings to be added explicitly. The
       plugin documentation will indicate how to configure it, but typically for
       older plugins this involves adding the base settings for the plugin and
       customizing as necessary.

       For example, for the sbt-site plugin, create =site.sbt= with the following
       content ~site.settings~ to enable it for that project.

       If there is multiple projects, add it to a specific one:
       #+BEGIN_SRC scala
         // don't use the site plugin for the `util` project
         lazy val util = (project in file("util"))

         // enable the site plugin for the `core` project
         lazy val core = (project in file("core"))
           .settings(site.settings)
       #+END_SRC
       
   - *Global plugins*
     Plugins can be installed for _ALL_ your projects at once by declaring them
     in =~/.sbt/1.0/plugins/= (=From Jian= I think this =1.0= is the main
     version number of sbt. Am I right???).

     Roughly speaking, any =.sbt= or =.scala= in this directory behaves as if they
     were in the =project/= directory for _ALL_ projects.

     + One thing you can, but you should use sparingly: 
       create =build.sbt= in this global directory, and put ~addSbtPlugin~
       expressions in it to add plugins to all your projects at once.

       Use this feature you increase the dependency on the machine environment,
       which is _NOT good_.

   - *Available Plugins* =TODO= =Links=
     =TODO= A link in this document to a list of available plugins.

     + Some especially popular plugins are:
       * those for IDEs (to import an sbt project into your IDE)
       * those supporting web frameworks, such as /xsbt-web-plugin/. 

     + See the *Plugins* section for More details

     + See the *Plugins-Best-Practices* section for More details.

** DONE m. Custom settings and tasks
   CLOSED: [2017-12-21 Thu 17:50]
   This page gets you started _creating_ your own /settings/ and /tasks/.

   - *Defining a key*
     - /Keys/ have one of _THREE types_:
       + ~SettingKey~ (read /.sbt build definition/)
       + ~TaskKey~ (read /.sbt build definition/)
       + ~InputKey~ (read /Input Tasks/ page)

     - =TODO= =Something Wrong???=
       This document says
       #+BEGIN_QUOTE
       The key constructors have two string parameters:
       the name of the key (like "scalaVersion") and
       a documentation string (like "The version of scala used for building.").
       #+END_QUOTE

       However, the definition is in this form
       ~val scalaVersion = settingKey[String]("The version of scala used for building.")~

     - Keys may be defined in an =.sbt= file, a =.scala= file, or in an /auto
       plugin/. Any ~val~'s found under ~autoImport~ object of an enabled /auto
       plugin/ will be imported automatically into your =.sbt= files.

   - *Implementing a task*
     - Use ~:=~ to associate some code with the task key.
       For example,
       #+BEGIN_SRC scala
         val sampleStringTask = taskKey[String]("A sample string task.")
         val sampleIntTask = taskKey[Int]("A sample int task.")

         lazy val commonSettings = Seq(
           organization := "com.example",
           version := "0.1.0-SNAPSHOT"
         )

         lazy val library = (project in file("library"))
           .settings(
             commonSettings,
             sampleStringTask := System.getProperty("user.home"),
             sampleIntTask := {
               val sum = 1 + 2
               println("sum: " + sum)
               sum
             }
           )
       #+END_SRC

     - The hardest part about implementing /tasks/ is often NOT sbt-specific;
       /tasks/ are just Scala code.

   - *Execution semantics of tasks*
     By /execution semantics/, we mean exactly _WHEN_ these /tasks/ are evaluated

     Assume ~startServer~ and ~stopServer~ are two /tasks/, you
     Put the callings of their ~value~ methods in order WON'T make them run _in
     order_. This is the property of /tasks/.

     We can do this in two ways:

     + *Cleanup task*
       The last operation should become the task that depends on other
       intermediate tasks. For instance ~stopServer~ should depend on
       ~sampleStringTask~, _at which point ~stopServer~ should be the
       ~sampleStringTask~._

       =From Jian= WHY NOT name the last ~sampleStringTask~ as ~stopServer~, and
       set its dependencies as ~sampleStringTask~?

       #+BEGIN_SRC scala
         val startServer = taskKey[Unit]("start server")
         val stopServer = taskKey[Unit]("stop server")
         val sampleIntTask = taskKey[Int]("A sample int task.")
         val sampleStringTask = taskKey[String]("A sample string task.")

         lazy val commonSettings = Seq(
           organization := "com.example",
           version := "0.1.0-SNAPSHOT"
         )

         lazy val library = (project in file("library"))
           .settings(
             commonSettings,
             startServer := {
               println("starting...")
               Thread.sleep(500)
             },
             sampleIntTask := {
               startServer.value
               val sum = 1 + 2
               println("sum: " + sum)
               sum
             },
             sampleStringTask := {
               startServer.value
               val s = sampleIntTask.value.toString
               println("s: " + s)
               s
             },
             sampleStringTask := {
               val old = sampleStringTask.value
               println("stopping...")
               Thread.sleep(500)
               old
             }
           )
       #+END_SRC

     + *Use plain Scala*
       You can also use plain scala to force the order.
       Scala program plain method calls follow /sequential semantics/.

       However, plain scala code won't implement deduplication, so you have to be
       careful about that.

   - *Turn them into plugins*
     =TODO=
     It's very easy to create a plugin, as /teased earlier/ and /discussed at
     more length here/. 

** DONE n. Organizing the build
   CLOSED: [2017-12-21 Thu 05:20]
   - *sbt is recursive*
     + =TODO= =TODO= =TODO=

     + Any time files ending in =.scala= or =.sbt= are used, naming them
       =build.sbt= and =Dependencies.scala= are _conventions_ ONLY.
       This also means that multiple files are allowed. 

   - *Tracking dependencies in one place*
     + =project/Dependencies.scala=
       #+BEGIN_SRC scala
         import sbt._

         object Dependencies {
           // Versions
           lazy val akkaVersion = "2.3.8"

           // Libraries
           val akkaActor = "com.typesafe.akka" %% "akka-actor" % akkaVersion
           val akkaCluster = "com.typesafe.akka" %% "akka-cluster" % akkaVersion
           val specs2core = "org.specs2" %% "specs2-core" % "2.4.17"

           // Projects
           val backendDeps =
             Seq(akkaActor, specs2core % Test)
         }
       #+END_SRC

     + =build.sbt=
       #+BEGIN_SRC scala
         import Dependencies._

         lazy val commonSettings = Seq(
           version := "0.1.0",
           scalaVersion := "2.12.4"
         )

         lazy val backend = (project in file("backend"))
           .settings(
             commonSettings,
             libraryDependencies ++= backendDeps
           )
       #+END_SRC

   - *When to use =.scala= files*
     The recommended approach:
     + define _MOST settings_ in a multi-project =build.sbt= file

     + using =project/*.scala= files for
       * _task implementations_
       * share values, such as keys.

     + The use of =.scala= files also depends on how comfortable you or your team
       are with Scala. 

   - *Defining auto plugins* =TODO=
     For more advanced users,
     another way of organizing your build is to define one-off /auto plugins/ in
     =project/*.scala=. By defining /triggered plugins/ =TODO= =???=,
     /auto plugins/ can be used as a convenient way to inject custom tasks and
     commands across all /subprojects/.

** TODO o. Getting Started summary =Important=
   - *sbt: The Core Concepts*
     =RE-READ= this list

   - *Advanced Notes*

* TODO 2. General Information
** a. Credits
** b. Community Plugins
** c. Community Repository Policy
** d. Bintray For Plugins
** e. Setup Notes
** f. Using Sonatype
** g. Contributing to sbt
** h. Changes
***   i. Migrating from sbt 0.13.x
***  ii. sbt 1.0.4
*** iii. sbt 0.13.5+ Technology Previews
***  iv. sbt 0.13.0 - 0.13.2
***   v. sbt 0.12.4
***  vi. Older Changes
*** vii. Migrating from 0.7 to 0.10+

* TODO 3. Detailed Topics
** a. Using sbt
***   i. Command Line Reference
***  ii. Console Project
*** iii. Cross-building
***  iv. Interacting with the Configuration System
***   v. Triggered Execution
***  vi. Scripts, REPL, and Dependencies
*** vii. Understanding Incremental Recompilation

** b. Configuration
***    i. Classpaths, sources, and resources
***   ii. Compiler Plugin Support
***  iii. Configuring Scala
***   iv. Forking
***    v. Global Settings
***   vi. Java Sources
***  vii. Mapping Files
*** viii. Local Scala
***   ix. Macro Projects
***    x. Paths
***   xi. Parallel Execution
***  xii. External Processes
*** xiii. Running Project Code
***  xiv. Testing

** c. Dependency Management
***    i. Artifacts
***   ii. Dependency Management Flow
***  iii. Library Management
***   iv. Proxy Repositories
***    v. Publishing
***   vi. Resolvers
***  vii. Update Report
*** viii. Cached resolution

** d. Tasks and Commands
***   i. Tasks
***  ii. Input Tasks
*** iii. Commands
***  iv. Parsing and tab completion
***   v. State and actions
***  vi. Tasks/Settings: Motivation

** e. Plugins and Best Practices
***   i. General Best Practices
***  ii. Plugins
*** iii. Plugins Best Practices
***  iv. Setting up Travis CI with sbt
***   v. Testing sbt plugins
***  vi. sbt new and Templates
*** vii. Cross building plugins

* TODO 4. How to...
** a. Classpaths
** b. Customizing paths
** c. Generating files
** d. Inspect the build
** e. Interactive mode
** f. Configure and use logging
** g. Project metadata
** h. Configure packaging
** i. Running commands
** j. Configure and use Scala
** k. Generate API documentation
** l. Triggered execution
** m .Define Custom Tasks
** n. How to take an action on startup
** o. Sequencing
***   i. Defining a sequential task with Def.sequential
***  ii. Defining a dynamic task with Def.taskDyn
*** iii. Doing something after an input task
***  iv. Defining a dynamic input task with Def.inputTaskDyn
***   v. How to sequence using commands

** p. Examples
***   i. ~.sbt~ build examples
***  ii. ~.sbt~ build with ~.scala~ files example
*** iii. Advanced configurations example
***  iv. Advanced command example

* TODO 5. Frequently Asked Questions
* TODO 6. Index
* TODO 7. Developer’s Guide (Work in progress)
** a. Modularization
*** i. Module summary
** b. sbt Coding Guideline
** c. sbt-datatype
** d. Compiler Interface
*** i. Fetching the most specific sources
** e. sbt Launcher
***   i. Getting Started with the sbt launcher
***  ii. Sbt Launcher Architecture
*** iii. sbt Launcher Configuration
** f. Notes
***   i. Core Principles
***  ii. Settings Core
*** iii. Setting Initialization
***  iv. Build Loaders
***   v. Creating Command Line Applications Using sbt
***  vi. Nightly Builds
* TODO Contents in Depth
* TODO Combined Pages
