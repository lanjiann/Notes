#+TITLE: Haskell Programming from First Principles
#+VERSION: 0.12.0
#+AUTHO Christopher Allen, Julie Moronuki
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Contents][Contents]]
  - [[Authors' preface][Authors' preface]]
    - [[Chris's story][Chris's story]]
    - [[Julie's story][Julie's story]]
  - [[Acknowledgements][Acknowledgements]]
  - [[Introduction][Introduction]]
  - [[Why This Book][Why This Book]]
    - [[OK, but I was just looking for a monad tutorial...][OK, but I was just looking for a monad tutorial...]]
    - [[But I've heard Haskell is hard...][But I've heard Haskell is hard...]]
  - [[A few words to new programmers][A few words to new programmers]]
  - [[Haskevangelism][Haskevangelism]]
  - [[What's in this book?][What's in this book?]]
  - [[Best practices for examples and exercises][Best practices for examples and exercises]]
- [[1 All You Need is Lambda][1 All You Need is Lambda]]
  - [[1.1 All You Need is Lambda][1.1 All You Need is Lambda]]
  - [[1.2 What is functional programming?][1.2 What is functional programming?]]
  - [[1.3 What is a function?][1.3 What is a function?]]
  - [[1.4 The structure of lambda terms][1.4 The structure of lambda terms]]
    - [[Alpha equivalence][Alpha equivalence]]
  - [[1.5 Beta reduction][1.5 Beta reduction]]
    - [[Free varibales][Free varibales]]
  - [[1.6 Multiple arguments][1.6 Multiple arguments]]
    - [[Intermission: Equivalence Exercises][Intermission: Equivalence Exercises]]
  - [[1.7 Evaluation is simplification][1.7 Evaluation is simplification]]
  - [[1.8 Combinators][1.8 Combinators]]
  - [[1.9 Divergence][1.9 Divergence]]
  - [[1.10 Summary][1.10 Summary]]
  - [[1.11 Chapter Exercises][1.11 Chapter Exercises]]
  - [[1.12 Answers][1.12 Answers]]
  - [[1.13 Definitions][1.13 Definitions]]
  - [[1.14 Follow-up resources][1.14 Follow-up resources]]
- [[2 Hello, Haskell!][2 Hello, Haskell!]]
  - [[2.1 Hello, Haskell][2.1 Hello, Haskell]]
  - [[2.2 Interacting with Haskell code][2.2 Interacting with Haskell code]]
    - [[Using the REPL][Using the REPL]]
    - [[GHCi commands][GHCi commands]]
    - [[Working from source files][Working from source files]]
  - [[2.3 Understanding expressions][2.3 Understanding expressions]]
  - [[2.4 Functions][2.4 Functions]]
    - [[Defining functions][Defining functions]]
  - [[2.5 Evaluation][2.5 Evaluation]]
    - [[Exercises: Comprehension Check][Exercises: Comprehension Check]]
  - [[2.6 Infix operators][2.6 Infix operators]]
    - [[Associativity and precedence][Associativity and precedence]]
    - [[Exercises: Parentheses and Association][Exercises: Parentheses and Association]]
  - [[2.7 Declaring values][2.7 Declaring values]]
    - [[Troubleshooting][Troubleshooting]]
    - [[Exercises: Heal the Sick][Exercises: Heal the Sick]]
  - [[2.8 Arithmetic functions in Haskell][2.8 Arithmetic functions in Haskell]]
    - [[Laws for quotients and remainders][Laws for quotients and remainders]]
    - [[Using 'mod'][Using 'mod']]
    - [[Negative numbers][Negative numbers]]
  - [[2.9 Parenthesization][2.9 Parenthesization]]
    - [[Parenthesizing infix operators][Parenthesizing infix operators]]
  - [[2.10 ~let~ and ~where~][2.10 ~let~ and ~where~]]
    - [[Exercises: A Head Code][Exercises: A Head Code]]
  - [[2.11 Chapter Exercises][2.11 Chapter Exercises]]
    - [[Parenthesization][Parenthesization]]
    - [[Equivalent expressions][Equivalent expressions]]
    - [[More fun with functions][More fun with functions]]
  - [[2.12 Definitions][2.12 Definitions]]
  - [[2.13 Follow-up resources][2.13 Follow-up resources]]
- [[3 Strings][3 Strings]]
  - [[3.1 Strings][3.1 Strings]]
  - [[3.2 A first look at types][3.2 A first look at types]]
  - [[3.3 Printing simple strings][3.3 Printing simple strings]]
    - [[String concatenation][String concatenation]]
  - [[3.4 Top-level versus local definitions][3.4 Top-level versus local definitions]]
    - [[Exercises: Scope][Exercises: Scope]]
  - [[3.5 Types of concatenation functions][3.5 Types of concatenation functions]]
    - [[Exercises: Syntax Errors][Exercises: Syntax Errors]]
  - [[3.6 Concatenation and scoping][3.6 Concatenation and scoping]]
  - [[3.7 More list functions][3.7 More list functions]]
  - [[3.8 Chapter Exercises][3.8 Chapter Exercises]]
    - [[Reading syntax][Reading syntax]]
    - [[Building functions][Building functions]]
  - [[3.9 Definitions][3.9 Definitions]]
- [[4 Basic datatypes][4 Basic datatypes]]
  - [[4.1 Basic Datatypes][4.1 Basic Datatypes]]
  - [[4.2 What are types?][4.2 What are types?]]
  - [[4.3 Anatomy of a data declaration][4.3 Anatomy of a data declaration]]
    - [[Exercises: Mood Swing][Exercises: Mood Swing]]
  - [[4.4 Numeric types][4.4 Numeric types]]
    - [[Integral numbers][Integral numbers]]
    - [[Integer][Integer]]
    - [[Why do we have ~Int~][Why do we have ~Int~]]
    - [[Fractional numbers][Fractional numbers]]
  - [[4.5 Comparing values][4.5 Comparing values]]
  - [[4.6 Go on and Bool me][4.6 Go on and Bool me]]
    - [[Exercises: Find the Mistakes][Exercises: Find the Mistakes]]
    - [[Conditionals with if-then-else][Conditionals with if-then-else]]
  - [[4.7 Tuples  =RE-READ= CLOSED: [2017-05-21 Sun 03:11]][4.7 Tuples  =RE-READ= CLOSED: [2017-05-21 Sun 03:11]]]
  - [[4.8 Lists][4.8 Lists]]
  - [[4.9 Chapter Exercises][4.9 Chapter Exercises]]
    - [[Correcting syntax][Correcting syntax]]
    - [[Match the function names to their types][Match the function names to their types]]
  - [[4.10 Definitions][4.10 Definitions]]
  - [[4.11 Names and variables][4.11 Names and variables]]
    - [[Names][Names]]
    - [[Conventions for variables][Conventions for variables]]
- [[5 Types][5 Types]]
  - [[5.1 Types][5.1 Types]]
  - [[5.2 What are types for?][5.2 What are types for?]]
  - [[5.3 How to read type signatures][5.3 How to read type signatures]]
    - [[Understanding the function type][Understanding the function type]]
    - [[Typeclass-constrained type variables][Typeclass-constrained type variables]]
    - [[Exercises: Type Matching][Exercises: Type Matching]]
  - [[5.4 Currying][5.4 Currying]]
    - [[Partial application][Partial application]]
    - [[Manual currying and uncurrying][Manual currying and uncurrying]]
    - [[Currying and uncurrying existing functions][Currying and uncurrying existing functions]]
    - [[Sectioning][Sectioning]]
    - [[Exercises: Type Arguments][Exercises: Type Arguments]]
  - [[5.5 Polymorphism][5.5 Polymorphism]]
    - [[Exercises: Parametricity][Exercises: Parametricity]]
    - [[Polymorphic constants][Polymorphic constants]]
    - [[Working around constraints][Working around constraints]]
  - [[5.6 Type inference][5.6 Type inference]]
    - [[Exercises: Apply Yourself][Exercises: Apply Yourself]]
  - [[5.7 Asserting types for declarations][5.7 Asserting types for declarations]]
  - [[5.8 Chapter Exercises][5.8 Chapter Exercises]]
    - [[Multiple choice][Multiple choice]]
    - [[Determine the type][Determine the type]]
    - [[Does it compile?][Does it compile?]]
    - [[Type variable or specific type constructor?][Type variable or specific type constructor?]]
    - [[Write a type signature][Write a type signature]]
    - [[Given a type, write the function][Given a type, write the function]]
    - [[Fix it][Fix it]]
    - [[Type-Know-Do][Type-Know-Do]]
  - [[5.9 Definitions][5.9 Definitions]]
  - [[5.10 Follow-up resources][5.10 Follow-up resources]]
- [[6 Typeclasses][6 Typeclasses]]
  - [[6.1 Typeclasses][6.1 Typeclasses]]
  - [[6.2 What are typeclasses?][6.2 What are typeclasses?]]
  - [[6.3 Back to ~Bool~][6.3 Back to ~Bool~]]
  - [[6.4 ~Eq~][6.4 ~Eq~]]
  - [[6.5 Writing typeclass instances][6.5 Writing typeclass instances]]
    - [[~Eq~ instances][~Eq~ instances]]
    - [[Partial functions -- not so strange danger][Partial functions -- not so strange danger]]
    - [[Sometimes we need to ask for more][Sometimes we need to ask for more]]
    - [[Exercises: ~Eq~ Instances][Exercises: ~Eq~ Instances]]
  - [[6.6 ~Num~][6.6 ~Num~]]
    - [[~Integral~][~Integral~]]
    - [[~Fractional~][~Fractional~]]
  - [[6.7 Type-defaulting typeclasses][6.7 Type-defaulting typeclasses]]
  - [[6.8 ~Ord~][6.8 ~Ord~]]
    - [[~Ord~ instances][~Ord~ instances]]
    - [[~Ord~ implies ~Eq~][~Ord~ implies ~Eq~]]
    - [[Exercises: Will They Work?][Exercises: Will They Work?]]
  - [[6.9 ~Enum~][6.9 ~Enum~]]
  - [[6.10 ~Show~][6.10 ~Show~]]
    - [[Printing and side effects][Printing and side effects]]
    - [[Working with Show][Working with Show]]
  - [[6.11 ~Read~][6.11 ~Read~]]
  - [[6.12 Instances are dispatched by type][6.12 Instances are dispatched by type]]
  - [[6.13 Gimme more operations][6.13 Gimme more operations]]
    - [[Concrete types imply all the typeclasses they provide][Concrete types imply all the typeclasses they provide]]
  - [[6.14 Chapter Exercises][6.14 Chapter Exercises]]
    - [[Multiple choice][Multiple choice]]
    - [[Does it typecheck?][Does it typecheck?]]
    - [[Given a datatype declaration, what can we do?][Given a datatype declaration, what can we do?]]
    - [[Match the types][Match the types]]
    - [[Type-Kwon-Do Two: Electric Typealoo][Type-Kwon-Do Two: Electric Typealoo]]
  - [[6.15 Chapter Definitions][6.15 Chapter Definitions]]
  - [[6.16 Typeclass inheritance, partial][6.16 Typeclass inheritance, partial]]
  - [[6.17 Follow-up resources][6.17 Follow-up resources]]
- [[7 More functional patterns][7 More functional patterns]]
  - [[7.1 Make it func-y][7.1 Make it func-y]]
  - [[7.2 Arguments and parameters][7.2 Arguments and parameters]]
    - [[Declaring parameters][Declaring parameters]]
    - [[Binding variables to values][Binding variables to values]]
  - [[7.3 Anonymous functions][7.3 Anonymous functions]]
    - [[Exercises: Grab Bag][Exercises: Grab Bag]]
    - [[The utility of lambda syntax][The utility of lambda syntax]]
  - [[7.4 Pattern matching][7.4 Pattern matching]]
    - [[Handling all the cases][Handling all the cases]]
    - [[Pattern matching against data constructors][Pattern matching against data constructors]]
    - [[Pattern matching tuples][Pattern matching tuples]]
    - [[Exercises: Variety Pack][Exercises: Variety Pack]]
  - [[7.5 Case expressions][7.5 Case expressions]]
    - [[Exercises: Case Practice][Exercises: Case Practice]]
  - [[7.6 Higher-order functions][7.6 Higher-order functions]]
    - [[Exercises: Artful Dodgy][Exercises: Artful Dodgy]]
  - [[7.7 Guards][7.7 Guards]]
    - [[if-then-else][if-then-else]]
    - [[Writing guard blocks][Writing guard blocks]]
    - [[Exercises: Guard Duty][Exercises: Guard Duty]]
  - [[7.8 Function composition][7.8 Function composition]]
  - [[7.9 Pointfree style][7.9 Pointfree style]]
  - [[7.10 Demonstrating composition][7.10 Demonstrating composition]]
  - [[7.11 Chapter Exercises][7.11 Chapter Exercises]]
    - [[Multiple choice][Multiple choice]]
    - [[Let's write code][Let's write code]]
  - [[7.12 Chapter Definitions][7.12 Chapter Definitions]]
  - [[7.13 Follow-up resources][7.13 Follow-up resources]]
- [[8 Recursion][8 Recursion]]
  - [[8.1 Recursion][8.1 Recursion]]
  - [[8.2 Factorial][8.2 Factorial]]
    - [[Another way to look at recursion][Another way to look at recursion]]
    - [[Intermission: Exercise][Intermission: Exercise]]
  - [[8.3 Bottom][8.3 Bottom]]
  - [[8.4 Fibonacci numbers][8.4 Fibonacci numbers]]
  - [[8.5 Integral division from scratch][8.5 Integral division from scratch]]
  - [[8.6 Chapter Exercises][8.6 Chapter Exercises]]
    - [[Reviewing types][Reviewing types]]
    - [[Reviewing currying][Reviewing currying]]
    - [[Recursion][Recursion]]
    - [[Fixing dividedBy][Fixing dividedBy]]
    - [[McCarthy 91 function][McCarthy 91 function]]
    - [[Numbers into words][Numbers into words]]
  - [[8.7 Definitions][8.7 Definitions]]
- [[9 Lists][9 Lists]]
  - [[9.1 Lists][9.1 Lists]]
  - [[9.2 The list datatype][9.2 The list datatype]]
  - [[9.3 Pattern matching on lists][9.3 Pattern matching on lists]]
  - [[9.4 List's syntactic sugar][9.4 List's syntactic sugar]]
  - [[9.5 Using ranges to construct lists][9.5 Using ranges to construct lists]]
    - [[Exercise: EnumFromTo][Exercise: EnumFromTo]]
  - [[9.6 Extracting portions of lists][9.6 Extracting portions of lists]]
    - [[Exercises: Thy Fearful Symmetry][Exercises: Thy Fearful Symmetry]]
  - [[9.7 List comprehensions][9.7 List comprehensions]]
    - [[Adding predicates][Adding predicates]]
    - [[Exercises: Comprehend Thy Lists][Exercises: Comprehend Thy Lists]]
    - [[List comprehensions with Strings][List comprehensions with Strings]]
    - [[Exercises: Square Cube][Exercises: Square Cube]]
  - [[9.8 Spines and nonstrict evaluation][9.8 Spines and nonstrict evaluation]]
    - [[Using GHCi's ~:sprint~ command][Using GHCi's ~:sprint~ command]]
    - [[Spines are evaluated independently of values][Spines are evaluated independently of values]]
    - [[Exercises: Bottom Madness][Exercises: Bottom Madness]]
      - [[Will it blow up?][Will it blow up?]]
      - [[Intermission: Is it in normal form?][Intermission: Is it in normal form?]]
  - [[9.9 Transforming lists of values][9.9 Transforming lists of values]]
    - [[Exercises: More Bottoms][Exercises: More Bottoms]]
  - [[9.10 Filtering lists of values][9.10 Filtering lists of values]]
    - [[Exercises: Filtering][Exercises: Filtering]]
  - [[9.11 Zipping lists][9.11 Zipping lists]]
    - [[Zipping exercises][Zipping exercises]]
  - [[9.12 Chapter Exercises][9.12 Chapter Exercises]]
    - [[~Data.Char~][~Data.Char~]]
    - [[Ciphers][Ciphers]]
    - [[Writing your own standard functions][Writing your own standard functions]]
  - [[9.13 Definitions][9.13 Definitions]]
  - [[9.14 Follow-up resources][9.14 Follow-up resources]]
- [[10 Folding lists][10 Folding lists]]
  - [[10.1 Folds][10.1 Folds]]
  - [[10.2 Bringing you into the fold][10.2 Bringing you into the fold]]
  - [[10.3 Recursive patterns][10.3 Recursive patterns]]
  - [[10.4 Fold right =IMPORTANT= =RE-READ=][10.4 Fold right =IMPORTANT= =RE-READ=]]
    - [[How ~foldr~ evaluates][How ~foldr~ evaluates]]
  - [[10.5 Fold left][10.5 Fold left]]
    - [[Associativity and folding][Associativity and folding]]
    - [[Exercises: Understanding Folds][Exercises: Understanding Folds]]
    - [[Unconditional spine recursion][Unconditional spine recursion]]
  - [[10.6 How to write fold functions][10.6 How to write fold functions]]
    - [[Exercises: Database Processing][Exercises: Database Processing]]
  - [[10.7 Folding and evaluation][10.7 Folding and evaluation]]
  - [[10.8 Summary][10.8 Summary]]
    - [[~foldr~][~foldr~]]
    - [[~foldl~][~foldl~]]
  - [[10.9 Scans][10.9 Scans]]
    - [[Getting the fibonacci number we want][Getting the fibonacci number we want]]
    - [[Scans Exercises][Scans Exercises]]
  - [[10.10 Chapter Exercises][10.10 Chapter Exercises]]
    - [[Warm-up and review][Warm-up and review]]
    - [[Rewriting functions using folds][Rewriting functions using folds]]
  - [[10.11 Definitions][10.11 Definitions]]
  - [[10.12 Follow-up resources][10.12 Follow-up resources]]
- [[11 Algebraic datatypes  ------- Page 381-452][11 Algebraic datatypes  ------- Page 381-452]]
  - [[11.1 Algebraic datatypes][11.1 Algebraic datatypes]]
  - [[11.2 Data declarations review][11.2 Data declarations review]]
  - [[11.3 Data and type constructors][11.3 Data and type constructors]]
  - [[11.4 Type constructors and kinds][11.4 Type constructors and kinds]]
  - [[11.5 Data constructors and values][11.5 Data constructors and values]]
    - [[Exercises: Dog Types][Exercises: Dog Types]]
  - [[11.6 What's a type and what's data?][11.6 What's a type and what's data?]]
    - [[Exercises: Vehicles][Exercises: Vehicles]]
  - [[11.7 Data constructor arities][11.7 Data constructor arities]]
  - [[11.8 What makes these datatypes algebraic?][11.8 What makes these datatypes algebraic?]]
    - [[Exercises: Cardinality][Exercises: Cardinality]]
    - [[Simple datatypes with nullary data constructors][Simple datatypes with nullary data constructors]]
    - [[Exercises: For Example][Exercises: For Example]]
    - [[Unary constructors][Unary constructors]]
  - [[11.9 newtype][11.9 newtype]]
    - [[Exercises: Logic Goats][Exercises: Logic Goats]]
  - [[11.10 Sum types][11.10 Sum types]]
    - [[Exercises: Pity the Bool][Exercises: Pity the Bool]]
  - [[11.11 Product types][11.11 Product types]]
    - [[Record syntax][Record syntax]]
  - [[11.12 Normal form][11.12 Normal form]]
    - [[Exercises: How Does Your Garden Grow?][Exercises: How Does Your Garden Grow?]]
  - [[11.13 Constructing and deconstructing values][11.13 Constructing and deconstructing values]]
    - [[Sum and Product][Sum and Product]]
    - [[Constructing values][Constructing values]]
    - [[Exercise: Programmers][Exercise: Programmers]]
    - [[Accidental bottoms from records][Accidental bottoms from records]]
    - [[Deconstructing values][Deconstructing values]]
    - [[Accidental bottoms from records][Accidental bottoms from records]]
  - [[11.14 Function type is exponential][11.14 Function type is exponential]]
    - [[Exponentiation in what order?][Exponentiation in what order?]]
    - [[Exercises: The Quad][Exercises: The Quad]]
  - [[11.15 Higher-kinded datatypes][11.15 Higher-kinded datatypes]]
  - [[11.16 Lists are polymorphic][11.16 Lists are polymorphic]]
  - [[11.17 Binary Tree][11.17 Binary Tree]]
    - [[Inserting into trees][Inserting into trees]]
    - [[Write map for BinaryTree][Write map for BinaryTree]]
    - [[Convert binary trees to lists][Convert binary trees to lists]]
    - [[Write foldr for BinaryTree][Write foldr for BinaryTree]]
  - [[11.18 Chapter Exercises][11.18 Chapter Exercises]]
    - [[Multiple choice][Multiple choice]]
    - [[Ciphers][Ciphers]]
    - [[As-patterns][As-patterns]]
    - [[Language exercises][Language exercises]]
    - [[Phone exercise][Phone exercise]]
    - [[Hutton's Razor][Hutton's Razor]]
  - [[11.19 Definitions][11.19 Definitions]]
- [[12 Signaling adversity][12 Signaling adversity]]
  - [[12.1 Signaling adversity][12.1 Signaling adversity]]
  - [[12.2 How I learned to stop worrying and love Nothing][12.2 How I learned to stop worrying and love Nothing]]
    - [[Smart constructors for datatypes][Smart constructors for datatypes]]
  - [[12.3 Bleating either][12.3 Bleating either]]
  - [[12.4 Kinds, a thousand stars in your types][12.4 Kinds, a thousand stars in your types]]
    - [[Data constructors are functions][Data constructors are functions]]
  - [[12.5 Chapter Exercises][12.5 Chapter Exercises]]
    - [[Determine the kinds][Determine the kinds]]
    - [[String processing][String processing]]
    - [[Validate the word][Validate the word]]
    - [[It's only Natural][It's only Natural]]
    - [[Small library for ~Maybe~][Small library for ~Maybe~]]
    - [[Small library for ~Either~][Small library for ~Either~]]
    - [[Unfolds][Unfolds]]
    - [[Why bother?][Why bother?]]
    - [[Write your own iterate and unfoldr][Write your own iterate and unfoldr]]
    - [[Finally something other than a list!][Finally something other than a list!]]
  - [[12.6 Definitions][12.6 Definitions]]
- [[][]]
- [[][]]
- [[13 Building projects][13 Building projects]]
  - [[13.1 Modules][13.1 Modules]]
  - [[13.2 Making packages with Stack][13.2 Making packages with Stack]]
  - [[13.3 Working with a basic project][13.3 Working with a basic project]]
    - [[Building the project][Building the project]]
    - [[Loading and running code from the REPL][Loading and running code from the REPL]]
    - [[=stack exec=][=stack exec=]]
    - [[Executable stanzas in Cabal files][Executable stanzas in Cabal files]]
  - [[13.4 Making our project a library][13.4 Making our project a library]]
  - [[13.5 Module exports][13.5 Module exports]]
    - [[Exposing modules][Exposing modules]]
  - [[13.6 More on importing modules][13.6 More on importing modules]]
    - [[Qualified imports][Qualified imports]]
    - [[Intermission: Check your understanding][Intermission: Check your understanding]]
  - [[13.7 Making our program interactive][13.7 Making our program interactive]]
    - [[Adding a prompt][Adding a prompt]]
  - [[13.8 do syntax and IO][13.8 do syntax and IO]]
    - [[return][return]]
  - [[13.9 Hangman game][13.9 Hangman game]]
  - [[13.10 Step One: Importing modules][13.10 Step One: Importing modules]]
  - [[13.11 Step Two: Generating a word list][13.11 Step Two: Generating a word list]]
  - [[13.12 Step Three: Making a puzzle][13.12 Step Three: Making a puzzle]]
  - [[13.13 Adding a ~newtype~][13.13 Adding a ~newtype~]]
  - [[13.14 Chapter exercises][13.14 Chapter exercises]]
    - [[Hangman game logic][Hangman game logic]]
    - [[Modifying code][Modifying code]]
  - [[13.15 Follow-up resources][13.15 Follow-up resources]]
- [[14 Testing][14 Testing]]
  - [[14.1 Testing][14.1 Testing]]
  - [[14.2 A quick tour of testing for the uninitated][14.2 A quick tour of testing for the uninitated]]
  - [[14.3 Conventional testing][14.3 Conventional testing]]
    - [[Truth according to ~Hspec~][Truth according to ~Hspec~]]
    - [[Our first ~Hspec~ test][Our first ~Hspec~ test]]
    - [[Intermission: Short Exercise][Intermission: Short Exercise]]
  - [[14.4 Enter ~QuickCheck~][14.4 Enter ~QuickCheck~]]
    - [[Arbitrary instances][Arbitrary instances]]
    - [[Using ~QuickCheck~ without ~Hspec~][Using ~QuickCheck~ without ~Hspec~]]
  - [[14.5 Morse code][14.5 Morse code]]
    - [[Turning words into code][Turning words into code]]
    - [[The ~Main~ event][The ~Main~ event]]
    - [[Make sure it's all working][Make sure it's all working]]
    - [[Time to test!][Time to test!]]
    - [[Testing the Morse code][Testing the Morse code]]
  - [[14.6 Kicking around QuickCheck][14.6 Kicking around QuickCheck]]
    - [[Babby's First Arbitrary][Babby's First Arbitrary]]
    - [[Identity Crisis][Identity Crisis]]
    - [[Arbitrary Products][Arbitrary Products]]
    - [[Greater than the sum of its parts][Greater than the sum of its parts]]
    - [[CoArbitrary][CoArbitrary]]
  - [[14.7 Chapter Exercises][14.7 Chapter Exercises]]
    - [[Validating numbers into words][Validating numbers into words]]
    - [[Using QuickCheck][Using QuickCheck]]
    - [[Failure][Failure]]
    - [[Idempotence][Idempotence]]
    - [[Make a Gen random generator for the datatype][Make a Gen random generator for the datatype]]
    - [[Hangman testing][Hangman testing]]
    - [[Validating ciphers][Validating ciphers]]
  - [[14.8 Definitions][14.8 Definitions]]
  - [[14.9 Follow-up resources][14.9 Follow-up resources]]
- [[15 Monoid, Semigroup][15 Monoid, Semigroup]]
  - [[15.1 Monoids and semigroups][15.1 Monoids and semigroups]]
  - [[15.2 What we talk about when we talk about algebras][15.2 What we talk about when we talk about algebras]]
  - [[15.3 Monoid][15.3 Monoid]]
  - [[15.4 How Monoid is defined in Haskell][15.4 How Monoid is defined in Haskell]]
  - [[15.5 Examples of using Monoid][15.5 Examples of using Monoid]]
    - [[List][List]]
  - [[15.6 Why ~Integer~ doesn't have a Monoid][15.6 Why ~Integer~ doesn't have a Monoid]]
    - [[Why ~newtype~?][Why ~newtype~?]]
    - [[More on Sum and Product][More on Sum and Product]]
  - [[15.7 Why bother?][15.7 Why bother?]]
  - [[15.8 Laws][15.8 Laws]]
  - [[15.9 Different instance, same representation][15.9 Different instance, same representation]]
  - [[15.10 Reusing algebras by asking for algebras][15.10 Reusing algebras by asking for algebras]]
    - [[Exercise: Optional Monoid][Exercise: Optional Monoid]]
    - [[Associativity][Associativity]]
    - [[Identity][Identity]]
    - [[The problem of orphan instances][The problem of orphan instances]]
  - [[15.11 Madness][15.11 Madness]]
  - [[15.12 Better living through QuickCheck][15.12 Better living through QuickCheck]]
    - [[Validating associativity with QuickCheck][Validating associativity with QuickCheck]]
    - [[Quickchecking left and right identity][Quickchecking left and right identity]]
    - [[Testing QuickCheck's patience][Testing QuickCheck's patience]]
    - [[Exercise: Maybe Another Monoid][Exercise: Maybe Another Monoid]]
  - [[15.13 Semigroup][15.13 Semigroup]]
    - [[NonEmpty, a useful datatype][NonEmpty, a useful datatype]]
    - [[Strength can be weakness][Strength can be weakness]]
  - [[15.14 Chapter exercises][15.14 Chapter exercises]]
    - [[Semigroup exercises][Semigroup exercises]]
    - [[Monoid exercises][Monoid exercises]]
  - [[15.15 Definitions][15.15 Definitions]]
  - [[15.16 Follow-up resources][15.16 Follow-up resources]]
- [[16 Functor][16 Functor]]
  - [[16.1 Functor][16.1 Functor]]
  - [[16.2 What's a functor?][16.2 What's a functor?]]
  - [[16.3 There's a whole lot of fmap going round][16.3 There's a whole lot of fmap going round]]
  - [[16.4 Let's talk about f, baby][16.4 Let's talk about f, baby]]
    - [[Shining star come into view][Shining star come into view]]
    - [[Exercises: Be Kind][Exercises: Be Kind]]
    - [[A shining star for you to see][A shining star for you to see]]
    - [[Functor is function application][Functor is function application]]
    - [[A shining star for you to see what your f can truly be][A shining star for you to see what your f can truly be]]
    - [[Typeclasses and constructor classes][Typeclasses and constructor classes]]
  - [[16.5 Functor Laws][16.5 Functor Laws]]
    - [[Identity][Identity]]
    - [[Composition][Composition]]
    - [[Structure preservation][Structure preservation]]
  - [[16.6 The Good, the Bad, and the Ugly][16.6 The Good, the Bad, and the Ugly]]
    - [[Composition should just work][Composition should just work]]
  - [[16.7 Commonly used functors][16.7 Commonly used functors]]
    - [[The functors are stacked and that's a fact][The functors are stacked and that's a fact]]
    - [[What if we lift twice?][What if we lift twice?]]
    - [[Lift me baby one more time][Lift me baby one more time]]
    - [[The real type of thing going down][The real type of thing going down]]
    - [[Get on up and get down][Get on up and get down]]
    - [[One more round for the P-Funkshun][One more round for the P-Funkshun]]
    - [[Stay on the scene like an ~fmap~ machine][Stay on the scene like an ~fmap~ machine]]
    - [[Exercises: Heavy Lifting][Exercises: Heavy Lifting]]
  - [[16.8 Transforming the unapplied type argument][16.8 Transforming the unapplied type argument]]
  - [[16.9 QuickChecking Functor instances][16.9 QuickChecking Functor instances]]
    - [[Making QuickCheck generate functions too][Making QuickCheck generate functions too]]
  - [[16.10 Exercises: Instances of Func][16.10 Exercises: Instances of Func]]
  - [[16.11 Ignoring possibilities][16.11 Ignoring possibilities]]
    - [[~Maybe~][~Maybe~]]
    - [[Exercise: Possibly][Exercise: Possibly]]
    - [[~Either~][~Either~]]
    - [[Short Exercise][Short Exercise]]
  - [[16.12 A somewhat surprising functor][16.12 A somewhat surprising functor]]
  - [[16.13 More structure, more functors][16.13 More structure, more functors]]
  - [[16.14 IO Functor][16.14 IO Functor]]
  - [[16.15 What if we want to do something different?][16.15 What if we want to do something different?]]
  - [[16.16 Functors are unique to a datatype][16.16 Functors are unique to a datatype]]
  - [[16.17 Chapter exercises][16.17 Chapter exercises]]
  - [[16.18 Definitions][16.18 Definitions]]
  - [[16.19 Follow-up resources][16.19 Follow-up resources]]
- [[17 Applicative][17 Applicative]]
  - [[17.1 Applicative][17.1 Applicative]]
  - [[17.2 Defining Applicative][17.2 Defining Applicative]]
  - [[17.3 Functor vs. Applicative][17.3 Functor vs. Applicative]]
  - [[17.4 Applicative functors are monoidal functors][17.4 Applicative functors are monoidal functors]]
    - [[Show me the monoids][Show me the monoids]]
    - [[Tuple Monoid and Applicative side by side][Tuple Monoid and Applicative side by side]]
    - [[Maybe Monoid and Applicative][Maybe Monoid and Applicative]]
  - [[17.5 Applicative in use][17.5 Applicative in use]]
    - [[List Applicative][List Applicative]]
      - [[What's the List applicative do?][What's the List applicative do?]]
      - [[Exercises: Lookups][Exercises: Lookups]]
    - [[Identity][Identity]]
      - [[Specializing the types][Specializing the types]]
      - [[Exercise: Identity Instance][Exercise: Identity Instance]]
    - [[Constant][Constant]]
      - [[Specializing the types][Specializing the types]]
      - [[Exercise: Constant Instance][Exercise: Constant Instance]]
    - [[~Maybe~ Applicative][~Maybe~ Applicative]]
      - [[Specializing the types][Specializing the types]]
      - [[Using the ~Maybe~ Applicative][Using the ~Maybe~ Applicative]]
      - [[Breaking down the example we just saw][Breaking down the example we just saw]]
      - [[~Maybe~ Functor and the Name constructor][~Maybe~ Functor and the Name constructor]]
      - [[~Maybe~ Applicative and Person][~Maybe~ Applicative and Person]]
      - [[Before we moooove on][Before we moooove on]]
      - [[Exercise: Fixer Upper][Exercise: Fixer Upper]]
  - [[17.6 Applicative laws][17.6 Applicative laws]]
  - [[17.7 You knew this was coming][17.7 You knew this was coming]]
  - [[17.8 ZipList Monoid][17.8 ZipList Monoid]]
    - [[Zero vs. Identity][Zero vs. Identity]]
    - [[List Applicative Exercise][List Applicative Exercise]]
    - [[ZipList Applicative Exercise][ZipList Applicative Exercise]]
    - [[Either and Validation Applicative][Either and Validation Applicative]]
      - [[Specializing the types][Specializing the types]]
      - [[~Either~ versus Validation][~Either~ versus Validation]]
      - [[Exercise: Variations on ~Either~][Exercise: Variations on ~Either~]]
  - [[17.9 Chapter Exercises][17.9 Chapter Exercises]]
    - [[Combinations][Combinations]]
  - [[17.10 Definitions][17.10 Definitions]]
  - [[17.11 Follow-up resources][17.11 Follow-up resources]]
- [[18 Monad][18 Monad]]
  - [[18.1 Monad][18.1 Monad]]
  - [[18.2 Sorry -- Monad is not a burrito][18.2 Sorry -- Monad is not a burrito]]
    - [[Applicative m][Applicative m]]
    - [[Core operations][Core operations]]
    - [[The novel part of Monad][The novel part of Monad]]
    - [[What Monad is not][What Monad is not]]
    - [[Monad also lifts!][Monad also lifts!]]
  - [[18.3 Do syntax and monads][18.3 Do syntax and monads]]
    - [[When fmap alone isn't enough][When fmap alone isn't enough]]
  - [[18.4 Examples of Monad use][18.4 Examples of Monad use]]
    - [[List][List]]
      - [[Specializing the types][Specializing the types]]
      - [[Example of the List Monad in use][Example of the List Monad in use]]
    - [[~Maybe~][~Maybe~]]
      - [[Specializing the types][Specializing the types]]
      - [[Using the Maybe Monad][Using the Maybe Monad]]
      - [[Exploding a spherical cow][Exploding a spherical cow]]
      - [[Fail fast, like an overfunded startup][Fail fast, like an overfunded startup]]
    - [[~Either~][~Either~]]
      - [[Specializing the types][Specializing the types]]
      - [[Using the Either Monad][Using the Either Monad]]
      - [[Short Exercise: Either Monad][Short Exercise: Either Monad]]
  - [[18.5 Monad laws][18.5 Monad laws]]
    - [[Identity laws][Identity laws]]
    - [[Associativity][Associativity]]
    - [[We're doing that thing again][We're doing that thing again]]
    - [[Bad Monads and their denizens][Bad Monads and their denizens]]
  - [[18.6 Application and composition][18.6 Application and composition]]
  - [[18.7 Chapter Exercises][18.7 Chapter Exercises]]
  - [[18.8 Definition][18.8 Definition]]
  - [[18.9 Follow-up resources][18.9 Follow-up resources]]
- [[19 Applying structure][19 Applying structure]]
  - [[19.1 Applied structure][19.1 Applied structure]]
  - [[19.2 Monoid][19.2 Monoid]]
    - [[Templating content in Scotty][Templating content in Scotty]]
    - [[Concatenating connection parameters][Concatenating connection parameters]]
    - [[Concatenating key configurations][Concatenating key configurations]]
  - [[19.3 Functor][19.3 Functor]]
    - [[Lifting over ~IO~][Lifting over ~IO~]]
    - [[Lifting over web app monads][Lifting over web app monads]]
  - [[19.4 Applicative][19.4 Applicative]]
    - [[hgrev][hgrev]]
    - [[More parsing][More parsing]]
    - [[And now for something different][And now for something different]]
  - [[19.5 Monad][19.5 Monad]]
    - [[Opening a network socket][Opening a network socket]]
    - [[Binding over failure in initialization][Binding over failure in initialization]]
  - [[19.6 An end-to-end example: URL shortener][19.6 An end-to-end example: URL shortener]]
    - [[Brief aside about polymorphic literals][Brief aside about polymorphic literals]]
    - [[Back to the show][Back to the show]]
    - [[Exercise][Exercise]]
  - [[19.7 That's a wrap!][19.7 That's a wrap!]]
  - [[19.8 Follow-up resources][19.8 Follow-up resources]]
- [[20 Foldable][20 Foldable]]
  - [[20.1 Foldable][20.1 Foldable]]
  - [[20.2 The Foldable class][20.2 The Foldable class]]
  - [[20.3 Revenge of the monoids][20.3 Revenge of the monoids]]
    - [[And now for something different][And now for something different]]
  - [[20.4 Demonstrating Foldable instances][20.4 Demonstrating Foldable instances]]
    - [[~Identity~][~Identity~]]
    - [[~Maybe~][~Maybe~]]
  - [[20.5 Some basic derived operations][20.5 Some basic derived operations]]
    - [[Exercises: Library Functions][Exercises: Library Functions]]
  - [[20.6 Chapter Exercises][20.6 Chapter Exercises]]
  - [[20.7 Follow-up resources][20.7 Follow-up resources]]
- [[21 ~Traversable~][21 ~Traversable~]]
  - [[21.1 ~Traversable~][21.1 ~Traversable~]]
  - [[21.2 The ~Traversable~ typeclass definition][21.2 The ~Traversable~ typeclass definition]]
  - [[21.3 ~sequenceA~][21.3 ~sequenceA~]]
  - [[21.4 ~traverse~][21.4 ~traverse~]]
    - [[~mapM~ is just ~traverse~][~mapM~ is just ~traverse~]]
  - [[21.5 So, what's traversable for?][21.5 So, what's traversable for?]]
  - [[21.6 Morse code revisited][21.6 Morse code revisited]]
  - [[21.7 Axing tedious code][21.7 Axing tedious code]]
  - [[21.8 Do all the things][21.8 Do all the things]]
    - [[Strength for understanding][Strength for understanding]]
  - [[21.9 Traversable instances][21.9 Traversable instances]]
    - [[~Either~][~Either~]]
    - [[~Tuple~][~Tuple~]]
  - [[21.10 Traversable Laws][21.10 Traversable Laws]]
  - [[21.11 Quality Control][21.11 Quality Control]]
  - [[21.12 Chapter Exercises][21.12 Chapter Exercises]]
    - [[Traversable instances][Traversable instances]]
    - [[Identity][Identity]]
      - [[Constant][Constant]]
      - [[Maybe][Maybe]]
      - [[List][List]]
      - [[Three][Three]]
      - [[Three'][Three']]
      - [[S][S]]
    - [[Instances for Tree][Instances for Tree]]
  - [[21.13 Follow-up resources][21.13 Follow-up resources]]
- [[22 Reader][22 Reader]]
  - [[22.1 Reader][22.1 Reader]]
  - [[22.2 A new beginning][22.2 A new beginning]]
    - [[Short Exercise: Warming Up][Short Exercise: Warming Up]]
  - [[22.3 This is Reader][22.3 This is Reader]]
  - [[22.4 Breaking down the ~Functor~ of functions][22.4 Breaking down the ~Functor~ of functions]]
  - [[22.5 But uh, ~Reader~?][22.5 But uh, ~Reader~?]]
    - [[Exercise: Ask][Exercise: Ask]]
  - [[22.6 Functions have an ~Applicative~ too][22.6 Functions have an ~Applicative~ too]]
    - [[Demonstrating the function applicative][Demonstrating the function applicative]]
    - [[Exercise: Reading Comprehension][Exercise: Reading Comprehension]]
  - [[22.7 The Monad of functions][22.7 The Monad of functions]]
    - [[The ~Monad~ instance][The ~Monad~ instance]]
    - [[Example uses of the Reader type][Example uses of the Reader type]]
    - [[Exercise: ~Reader~ ~Monad~][Exercise: ~Reader~ ~Monad~]]
  - [[22.8 Reader ~Monad~ by itself is kinda boring][22.8 Reader ~Monad~ by itself is kinda boring]]
  - [[22.9 You can change what comes below, but not above][22.9 You can change what comes below, but not above]]
  - [[22.10 You tend to see ~ReaderT~, not Reader][22.10 You tend to see ~ReaderT~, not Reader]]
  - [[22.11 Chapter Exercises][22.11 Chapter Exercises]]
    - [[A warm-up stretch][A warm-up stretch]]
    - [[Rewriting Shawty][Rewriting Shawty]]
  - [[22.12 Follow-up resources][22.12 Follow-up resources]]
- [[23 State][23 State]]
  - [[23.1 State][23.1 State]]
  - [[23.2 What is state?][23.2 What is state?]]
  - [[23.3 Random numbers][23.3 Random numbers]]
  - [[23.4 The State newtype][23.4 The State newtype]]
  - [[23.5 Throw down][23.5 Throw down]]
    - [[Keep on rolling][Keep on rolling]]
    - [[Exercises: Roll Your Own][Exercises: Roll Your Own]]
  - [[23.6 Write State for yourself][23.6 Write State for yourself]]
    - [[State ~Functor~][State ~Functor~]]
    - [[State ~Applicative~][State ~Applicative~]]
    - [[State ~Monad~][State ~Monad~]]
  - [[23.7 Get a coding job with one weird trick][23.7 Get a coding job with one weird trick]]
    - [[Fizzbuzz Differently][Fizzbuzz Differently]]
  - [[23.8 Chapter exercises][23.8 Chapter exercises]]
  - [[23.9 Follow-up resources][23.9 Follow-up resources]]
- [[24 Parser combinators][24 Parser combinators]]
  - [[24.1 Parser combinators][24.1 Parser combinators]]
  - [[24.2 A few more words of introduction][24.2 A few more words of introduction]]
  - [[24.3 Understanding the parsing process][24.3 Understanding the parsing process]]
    - [[Since we didn't use an analogy for Monad][Since we didn't use an analogy for Monad]]
    - [[What demonstration purposes?][What demonstration purposes?]]
    - [[Back to the code][Back to the code]]
    - [[A bit like...][A bit like...]]
    - [[Back to our regularly scheduled coding][Back to our regularly scheduled coding]]
    - [[Exercises: Parsing Practice][Exercises: Parsing Practice]]
    - [[Intermission: parsing free jazz][Intermission: parsing free jazz]]
  - [[24.4 Parsing fractions][24.4 Parsing fractions]]
    - [[Exercise: Unit of Success][Exercise: Unit of Success]]
  - [[24.5 Haskell's parsing ecosystem][24.5 Haskell's parsing ecosystem]]
    - [[Typeclasses of Parsers][Typeclasses of Parsers]]
  - [[24.6 Alternative][24.6 Alternative]]
    - [[~QuasiQuotes~][~QuasiQuotes~]]
    - [[Return to Alternative][Return to Alternative]]
    - [[Exercise: Try Try][Exercise: Try Try]]
  - [[24.7 Parsing configuration files][24.7 Parsing configuration files]]
  - [[24.8 Character and token parsers][24.8 Character and token parsers]]
    - [[Insert tokens to play][Insert tokens to play]]
  - [[24.9 Polymorphic parsers][24.9 Polymorphic parsers]]
    - [[It's not perfect and could bite you][It's not perfect and could bite you]]
    - [[Failure and backtracking][Failure and backtracking]]
  - [[24.10 Marshalling from an AST to a datatype][24.10 Marshalling from an AST to a datatype]]
    - [[Marshalling and unmarshalling JSON data][Marshalling and unmarshalling JSON data]]
    - [[Provided a strict ByteString when a lazy one was expected][Provided a strict ByteString when a lazy one was expected]]
    - [[Provided a lazy ByteString when a strict one was expected][Provided a lazy ByteString when a strict one was expected]]
    - [[Back to the...JSON][Back to the...JSON]]
  - [[24.11 Chapter Exercises][24.11 Chapter Exercises]]
  - [[24.12 Definitions][24.12 Definitions]]
- [[25 Composing types][25 Composing types]]
  - [[25.1 Composing types][25.1 Composing types]]
  - [[25.2 Common functions as types][25.2 Common functions as types]]
    - [[~Identity~ is boring][~Identity~ is boring]]
    - [[~Compose~][~Compose~]]
  - [[25.3 Two little functors sittin' in a tree, L-I-F-T-I-N-G][25.3 Two little functors sittin' in a tree, L-I-F-T-I-N-G]]
  - [[25.4 Twinplicative][25.4 Twinplicative]]
    - [[GOTCHA! Exercise time][GOTCHA! Exercise time]]
  - [[25.5 Twonad?][25.5 Twonad?]]
    - [[No free burrito lunches][No free burrito lunches]]
  - [[25.6 Exercises: Compose Instances][25.6 Exercises: Compose Instances]]
    - [[~Compose~ ~Foldable~][~Compose~ ~Foldable~]]
    - [[~Compose~ ~Traversable~][~Compose~ ~Traversable~]]
    - [[And now for something completely different][And now for something completely different]]
  - [[25.7 Monad transformers][25.7 Monad transformers]]
    - [[Monadic stacking][Monadic stacking]]
    - [[Doing it badly][Doing it badly]]
  - [[25.8 ~IdentityT~][25.8 ~IdentityT~]]
    - [[The bind breakdown][The bind breakdown]]
    - [[Implementing the bind, step by step][Implementing the bind, step by step]]
    - [[The essential extra of Monad transformers][The essential extra of Monad transformers]]
  - [[25.9 Finding a pattern][25.9 Finding a pattern]]
- [[26 Monad transformers][26 Monad transformers]]
  - [[26.1 Monad transformers][26.1 Monad transformers]]
  - [[26.2 ~MaybeT~][26.2 ~MaybeT~]]
    - [[Spoiler alert!][Spoiler alert!]]
    - [[~MaybeT~ Monad instance][~MaybeT~ Monad instance]]
  - [[26.3 ~EitherT~][26.3 ~EitherT~]]
    - [[Exercises: ~EitherT~][Exercises: ~EitherT~]]
  - [[26.4 ~ReaderT~][26.4 ~ReaderT~]]
  - [[26.5 ~StateT~][26.5 ~StateT~]]
    - [[Exercises: ~StateT~][Exercises: ~StateT~]]
    - [[~ReaderT~, ~WriterT~, ~StateT~][~ReaderT~, ~WriterT~, ~StateT~]]
    - [[Correspondence between ~StateT~ and Parser][Correspondence between ~StateT~ and Parser]]
  - [[26.6 Types you probably don't want to use][26.6 Types you probably don't want to use]]
    - [[Why not use Writer or ~WriterT~?][Why not use Writer or ~WriterT~?]]
    - [[The ~ListT~ you want isn't made from the List type][The ~ListT~ you want isn't made from the List type]]
  - [[26.7 Recovering an ordinary type from a transformer][26.7 Recovering an ordinary type from a transformer]]
  - [[26.8 Lexically inner is structurally outer][26.8 Lexically inner is structurally outer]]
    - [[Exercise: Wrap It Up][Exercise: Wrap It Up]]
  - [[26.9 ~MonadTrans~][26.9 ~MonadTrans~]]
    - [[The typeclass that lifts][The typeclass that lifts]]
    - [[Motivating ~MonadTrans~][Motivating ~MonadTrans~]]
    - [[~MonadTrans~ instances][~MonadTrans~ instances]]
    - [[Exercises: Lift More][Exercises: Lift More]]
    - [[Prolific lifting is the failure mode][Prolific lifting is the failure mode]]
    - [[Wrap it, smack it, pre-lift it][Wrap it, smack it, pre-lift it]]
  - [[26.10 ~MonadIO~ aka zoom-zoom][26.10 ~MonadIO~ aka zoom-zoom]]
    - [[Example ~MonadIO~ instances][Example ~MonadIO~ instances]]
    - [[Exercises: Some Instances][Exercises: Some Instances]]
  - [[26.11 Monad transformers in use][26.11 Monad transformers in use]]
    - [[~MaybeT~ in use][~MaybeT~ in use]]
    - [[Temporary extension of structure][Temporary extension of structure]]
    - [[~ExceptT~ aka ~EitherT~ in use][~ExceptT~ aka ~EitherT~ in use]]
    - [[Scotty, again][Scotty, again]]
    - [[Slightly more advanced code][Slightly more advanced code]]
  - [[26.12 Monads do not commute][26.12 Monads do not commute]]
    - [[Hypothetical Exercise][Hypothetical Exercise]]
  - [[26.13 Transform if you want to][26.13 Transform if you want to]]
  - [[26.14 Chapter Exercises][26.14 Chapter Exercises]]
    - [[Write the code][Write the code]]
    - [[Fix the code][Fix the code]]
    - [[Hit counter][Hit counter]]
    - [[Morra][Morra]]
  - [[26.15 Follow-up resources][26.15 Follow-up resources]]
- [[27 Non-strictness][27 Non-strictness]]
  - [[27.1 Laziness][27.1 Laziness]]
  - [[27.2 Observational Bottom Theory][27.2 Observational Bottom Theory]]
    - [[Standards and obligations][Standards and obligations]]
  - [[27.3 Outside in, inside out][27.3 Outside in, inside out]]
  - [[27.4 What does the other way look like?][27.4 What does the other way look like?]]
    - [[Can we make Haskell strict?][Can we make Haskell strict?]]
    - [[~seq~ and ye shall find][~seq~ and ye shall find]]
    - [[~seq~ and weak head normal form][~seq~ and weak head normal form]]
    - [[Case matching also chains evaluation][Case matching also chains evaluation]]
    - [[Core Dump][Core Dump]]
    - [[A little bit stricter now][A little bit stricter now]]
    - [[Exercises: Evaluate][Exercises: Evaluate]]
  - [[27.5 Call by name, call by need][27.5 Call by name, call by need]]
  - [[27.6 Non-strict evaluation changes what we can do][27.6 Non-strict evaluation changes what we can do]]
  - [[27.7 Thunk Life][27.7 Thunk Life]]
    - [[Not all values get thunked][Not all values get thunked]]
  - [[27.8 Sharing is caring][27.8 Sharing is caring]]
    - [[Using trace to observe sharing][Using trace to observe sharing]]
    - [[What promotes sharing][What promotes sharing]]
    - [[What subverts or prevents sharing][What subverts or prevents sharing]]
    - [[Why polymorphic values never seem to get forced][Why polymorphic values never seem to get forced]]
    - [[Preventing sharing on purpose][Preventing sharing on purpose]]
    - [[Forcing sharing][Forcing sharing]]
  - [[27.9 Refutable and irrefutable patterns][27.9 Refutable and irrefutable patterns]]
    - [[Lazy patterns][Lazy patterns]]
  - [[27.10 Bang-patterns][27.10 Bang-patterns]]
    - [[Bang patterns in data][Bang patterns in data]]
  - [[27.11 Strict and StrictData][27.11 Strict and StrictData]]
  - [[27.12 Adding strictness][27.12 Adding strictness]]
  - [[27.13 Chapter Exercises][27.13 Chapter Exercises]]
    - [[Strict List][Strict List]]
    - [[What will ~:sprint~ output?][What will ~:sprint~ output?]]
    - [[Will printing this expression result in bottom?][Will printing this expression result in bottom?]]
    - [[Make the expression bottom][Make the expression bottom]]
  - [[27.14 Follow-up resources][27.14 Follow-up resources]]
- [[28 Basic libraries][28 Basic libraries]]
  - [[28.1 Basic libraries and data structures][28.1 Basic libraries and data structures]]
  - [[28.2 Benchmarking with Criterion][28.2 Benchmarking with Criterion]]
    - [[More on ~whnf~ and ~nf~][More on ~whnf~ and ~nf~]]
    - [[Making the case for ~nf~][Making the case for ~nf~]]
  - [[28.3 Profiling your programs][28.3 Profiling your programs]]
    - [[Profiling time usage][Profiling time usage]]
    - [[Profiling heap usage][Profiling heap usage]]
  - [[28.4 Constant applicative forms][28.4 Constant applicative forms]]
  - [[28.5 ~Map~][28.5 ~Map~]]
    - [[What's something that's faster with ~Map~?][What's something that's faster with ~Map~?]]
    - [[What's slower with ~Map~?][What's slower with ~Map~?]]
  - [[28.6 ~Set~][28.6 ~Set~]]
    - [[Exercise: Benchmark Practice][Exercise: Benchmark Practice]]
  - [[28.7 Sequence][28.7 Sequence]]
    - [[What's faster with Sequence?][What's faster with Sequence?]]
    - [[What's slower with Sequence?][What's slower with Sequence?]]
  - [[28.8 Vector][28.8 Vector]]
    - [[When does one want a ~Vector~ in Haskell?][When does one want a ~Vector~ in Haskell?]]
    - [[What's this about slicing?][What's this about slicing?]]
    - [[Updating vectors][Updating vectors]]
    - [[Mutable Vectors][Mutable Vectors]]
    - [[A sidebar on the ST Monad][A sidebar on the ST Monad]]
    - [[Exercises: ~Vector~][Exercises: ~Vector~]]
  - [[28.9 String types][28.9 String types]]
    - [[String][String]]
    - [[Text][Text]]
    - [[Don't trust your gut, measure][Don't trust your gut, measure]]
    - [[ByteString][ByteString]]
    - [[ByteString examples][ByteString examples]]
    - [[ByteString traps][ByteString traps]]
    - [[When would I use ByteString instead of Text for textual data?][When would I use ByteString instead of Text for textual data?]]
  - [[28.10 Chapter Exercises][28.10 Chapter Exercises]]
    - [[Difference List][Difference List]]
    - [[A simple queue][A simple queue]]
  - [[28.11 Follow-up resources][28.11 Follow-up resources]]
- [[29 ~IO~][29 ~IO~]]
  - [[29.1 ~IO~][29.1 ~IO~]]
  - [[29.2 Where ~IO~ explanations go astray][29.2 Where ~IO~ explanations go astray]]
    - [[Burn the State to the ground!][Burn the State to the ground!]]
  - [[29.3 The reason we need this type][29.3 The reason we need this type]]
    - [[What?][What?]]
    - [[Order and chaos][Order and chaos]]
  - [[29.4 Sharing][29.4 Sharing]]
    - [[The time has come][The time has come]]
    - [[Another example][Another example]]
    - [[The code! It doesn't work!][The code! It doesn't work!]]
  - [[29.5 ~IO~ doesn't disable sharing for everything][29.5 ~IO~ doesn't disable sharing for everything]]
  - [[29.6 Purity is losing meaning][29.6 Purity is losing meaning]]
    - [[Semantically, pedantically accurate][Semantically, pedantically accurate]]
    - [[Referential transparency][Referential transparency]]
  - [[29.7 IO's Functor, Applicative, and Monad][29.7 IO's Functor, Applicative, and Monad]]
    - [[The ~IO~ Functor][The ~IO~ Functor]]
    - [[Applicative and ~IO~][Applicative and ~IO~]]
    - [[Monad and ~IO~][Monad and ~IO~]]
    - [[Monadic associativity][Monadic associativity]]
  - [[29.8 Well, then, how do we ~MVar~?][29.8 Well, then, how do we ~MVar~?]]
  - [[29.9 Chapter Exercises][29.9 Chapter Exercises]]
    - [[File I/O with Vigenère][File I/O with Vigenère]]
    - [[Add timeouts to your utility][Add timeouts to your utility]]
    - [[Config directories][Config directories]]
  - [[29.10 Follow-up resources][29.10 Follow-up resources]]
- [[30 When things go wrong][30 When things go wrong]]
  - [[30.1 Exceptions][30.1 Exceptions]]
  - [[30.2 The Exception class and methods][30.2 The Exception class and methods]]
    - [[But there is something different going on here][But there is something different going on here]]
    - [[A brief introduction to existential quantification][A brief introduction to existential quantification]]
    - [[So, wait, what?][So, wait, what?]]
    - [[Typeable][Typeable]]
  - [[30.3 This machine kills programs][30.3 This machine kills programs]]
    - [[Catch me if you can][Catch me if you can]]
  - [[30.4 Want either? Try!][30.4 Want either? Try!]]
  - [[30.5 The unbearable imprecision of trying][30.5 The unbearable imprecision of trying]]
  - [[30.6 Why ~throwIO~?][30.6 Why ~throwIO~?]]
  - [[30.7 Making our own exception types][30.7 Making our own exception types]]
    - [[Adding context][Adding context]]
    - [[Catch one, catch all][Catch one, catch all]]
  - [[30.8 Surprising interaction with bottom][30.8 Surprising interaction with bottom]]
  - [[30.9 Asynchronous Exceptions][30.9 Asynchronous Exceptions]]
    - [[Don't panic!][Don't panic!]]
  - [[30.10 Follow-up Reading][30.10 Follow-up Reading]]
- [[31 Final project][31 Final project]]
  - [[31.1 Final project][31.1 Final project]]
  - [[31.2 fingerd][31.2 fingerd]]
    - [[Caveat for the Windows users][Caveat for the Windows users]]
  - [[31.3 Exploring finger][31.3 Exploring finger]]
    - [[Project overview][Project overview]]
    - [[=fingerd.cabal=][=fingerd.cabal=]]
    - [[=src/Debug.hs=][=src/Debug.hs=]]
  - [[31.4 Slightly modernized fingerd][31.4 Slightly modernized fingerd]]
    - [[Let your fingers do the walking][Let your fingers do the walking]]
  - [[31.5 Chapter Exercises][31.5 Chapter Exercises]]
- [[Tips][Tips]]

* TODO Contents
** Authors' preface
*** Chris's story
*** Julie's story
** Acknowledgements
** Introduction
** Why This Book
*** OK, but I was just looking for a monad tutorial...
*** But I've heard Haskell is hard...
** A few words to new programmers
** Haskevangelism
** What's in this book?
** Best practices for examples and exercises
* DONE 1 All You Need is Lambda
  CLOSED: [2017-05-19 Fri 00:01]
** DONE 1.1 All You Need is Lambda
   CLOSED: [2017-05-17 Wed 22:42]
   - /calculus/: a method of calculation or reasoning;

   - /lambda calculus/: one process for formalizing a method.

** DONE 1.2 What is functional programming?
   CLOSED: [2017-05-17 Wed 22:51]
   - When we say the /purity/ of a functional programming language, we acutally
     say in which level its /referential transparency/ is.
       If we say a language is pure, we mean it has PERFECT
     /referential transparency/.

** DONE 1.3 What is a function?
   CLOSED: [2017-05-18 Thu 14:50]
   - /domain/
   - /codomain/
   - /range/
** DONE 1.4 The structure of lambda terms
   CLOSED: [2017-05-18 Thu 15:17]
   - /lambda calculus/ has three basic components (/lambda terms/):
     + expressions :: refer to a superset of all those things:
       * a variable name
       * an abstraction
       * a combination of those things

     + variables :: here variables means those have no meaning or value;
                  they are just names for potential inputs to functions

     + abstractions :: functions
       * /head/
       * /body/

   - The variable named in the head is the /parameter/ and /binds/ all instances
     of that same variable in the body of the function.

*** Alpha equivalence
    - /alpha equivalence/: a form of equivalence between lambda terms

** DONE 1.5 Beta reduction
   CLOSED: [2017-05-17 Wed 22:36]
   - /beta reduction/: apply a function to an argument.
     =COMMENT= This reduction eliminates the head of the abstraction, since its
               only purpose was to bind a variable.

   - The process of /beta reduction/ _stops when_ there are either no more heads,
     or lambdas, left to apply or no more arguments to apply functions to.

*** Free varibales 
    - /free variables/: variables that are not named in the head.

    - /alpha equivalence/ does not apply to /free variables/.
      For example, ~\lambda{}x.xy~ and ~\lambda{}x.xz~ are not equivalent because ~z~ and ~y~
      might be different.

** DONE 1.6 Multiple arguments
   CLOSED: [2017-05-18 Thu 16:04]
   - Each lambda can only bind one parameter and can only accept one argument.

   - Functions that require multiple arguments have multiple, nested heads.

   - /Curry/: discovered by Moses Schönfinkel in the 1920s. Re-discovered by
     Haskell Curry.

*** Intermission: Equivalence Exercises
** DONE 1.7 Evaluation is simplification
   CLOSED: [2017-05-18 Thu 16:25]
   - There are multiple normal forms in lambda calculus.

   - We will concentrate /beta normal form/ here.

   - /beta reduction/: apply lambdas to arguments.

   - /beta normal form/: a form when you cannot /beta reduce/ (apply lambdas to
     arguments) the terms any further.

** DONE 1.8 Combinators
   CLOSED: [2017-05-17 Wed 22:22]
   - /combinator/: a lambda term with no free variables.
     =comment= As the name suggests, serve only to combine the arguments they are given.
** DONE 1.9 Divergence
   CLOSED: [2017-05-17 Wed 22:22]
   - NOT ALL reducible lambda terms reduce neatly to a /beta normal form/.

   - /divergence/: in this context it means that the reduction process never terminates or ends.

   - /omega divergence/: after some reduction steps, go back to the initial form.
** DONE 1.10 Summary
   CLOSED: [2017-06-06 Tue 20:14]
** DONE 1.11 Chapter Exercises
   CLOSED: [2017-06-06 Tue 20:14]
** DONE 1.12 Answers
   CLOSED: [2017-06-06 Tue 20:14]
** DONE 1.13 Definitions
   CLOSED: [2017-06-06 Tue 20:15]
** TODO 1.14 Follow-up resources
   1. 
   2. 
   3. 
* DONE 2 Hello, Haskell!
  CLOSED: [2017-06-06 Tue 20:14]
** DONE 2.1 Hello, Haskell
   CLOSED: [2017-05-19 Fri 20:46]
   INSTALLATION

   GHC version is between 7.8 and 8.0 is compatible with everything in this book
   (ver 0.12.0).
** DONE 2.2 Interacting with Haskell code
   CLOSED: [2017-05-19 Fri 21:00]
*** Using the REPL
    - ~:quit~ or ~:q~

    - ~Prelude~ is a library of standard functions.
      + It is loaded automatically by GHCi or Stack GHCi.

      + It can be turned off (=TODO= talk about this later).

      + There are alternative Preludes, which we won't use in this book. =TODO=

      + It is contained in Haskell's ~base~ package, which can be found
        https://www.stackage.org/package/base. When we mention "in base", we
        means in this ~base~ package.

*** GHCi commands
    - ~:~ prefixed commands are GHCi features, and they are not Haskell code.
*** Working from source files
    - Source files of Haskell use =.hs= as their file names extension.

    - ~::~ is a way to write down a /type signature/.

    - ~:load~

    - ~:module~ or ~:m~ can unload the file from GHCi, and help you go back to
      (switch to the ~Prelude~ scope) the ~Prelude>~ prompt.

** DONE 2.3 Understanding expressions
   CLOSED: [2017-05-19 Fri 21:15]
   - Everything in Haskell is
     + an /expression/
       OR
     + a /declaration/

   - Expressions may be
     + values
     + combinations of values
     + functions applied to values

   - Expressions evaluate to a result (can be itself if a expression is a literal
     value).

   - We'll cover /declarations/ more later, =TODO=
     but it suffices to say for now that they are top-level bindings which
     allows us to name expressions.
     We can then use those names to refer to them multiple times without copying
     and pasting the expressions.

   - /Normal form/: the irreducible form (of a expression).

   - /redexes/: Reducible expressions =IMPORTANT=

   - Generally refer to the process of _FROM the initial form of a expression TO
     a /normal form/_ as /evaluation/ or /reduction/.

     People also often use some _IMPRECISE_ words like:
     "normalizing" or "executing" an expression.

** DONE 2.4 Functions
   CLOSED: [2017-05-19 Fri 22:01]
   Haskell function is always /currying/.

*** Defining functions
    - _Capitalization matters!_
      Variables must also begin with lowercase letters.

** DONE 2.5 Evaluation
   CLOSED: [2017-05-19 Fri 22:31]
   - nonstrict evaluation or say "lazy evaluation".

   - /canonical form / normal form/

   - Haskell doesn't evaluate everything to /canonical or normal form/ by
     default.

     Instead, it only evaluates to /weak head normal form (WHNF)/ by default.

   - /weak head normal form (WHNF)/
     For example,
     ~(\f -> (1, 2 + f)) 2~ reduces to the following in /WHNF/ ~(1, 2 + 2)~.

*** Exercises: Comprehension Check
    1. Use ~let~

    2. Write a function:
       #+BEGIN_SRC haskell
         areaCircle :: Fractional a => a -> a
         areaCircle r = 3.14 * (r * r)
       #+END_SRC

    3. Use ~pi~ in ~Prelude~:
       #+BEGIN_SRC haskell
         areaCircle :: Floating a => a -> a
         areaCircle r = pi * (r * r)
       #+END_SRC

** DONE 2.6 Infix operators
   CLOSED: [2017-05-19 Fri 23:30]
   - ~id~

   - Operators are functions which can be used in infix style.
     _All_ operators are functions; _NOT all_ functions are operators.

   - Use functions in infix fashions:
     ~10 `div` 4~

   - Use infix operators in prefix fashions:
     ~(+) 100 100~

   - If the function name is alphanumeric, it is a prefix function by
     default, and not all prefix functions can be made infix.
     =TODO= =Which can which cannot???=

     _If the name is a symbol, it is infix by default_
     but can be made prefix by wrapping it in parentheses.

   - You cannot make a prefix function into an infix function using backticks,
     then wrap that in parentheses and make it into a prefix function.
     =WHY???=

*** Associativity and precedence
    - ~:info~ or ~:i~ (this command can take more than one arguments):
      This command can tell you
      if what you test is 
      1. an infix operator
         OR
      2. a function that can be a infix operator when it is wrapped by backticks

      If it is, tell you its type info, associativity, precedence level (0 ~ 9).
      If it is not, tell you the type info only.

    - 
*** Exercises: Parentheses and Association
    _EASY_
** DONE 2.7 Declaring values
   CLOSED: [2017-06-06 Tue 20:14]
   - The order of declarations
     + In a source code file it doesn't matter
       because GHCi loads the entire file at once, so it knows all the values
       that have been defined.

     + When you enter them one by one into the REPL, the order does matter.

   - For example,
     #+BEGIN_SRC haskell
       -- This is legal
       x = 1
       y = 2
       k = x + y + z
       z = 3
     #+END_SRC
     In source file, binding order is not important.

     However, due to the property of closure, variables must be defined _before_
     the declaration of the closures include them.

   - _Module names are capitalized_,
     UNLIKE variable names, which mustn't be.

*** DONE Troubleshooting
    CLOSED: [2017-05-20 Sat 17:10]
    - Indentation of Haskell code is significant.

    - _Reminder_: Use spaces, NOT tabs.

    - In source code files, indentation often replaces syntactic markers like
      curly brackets, semicolons, and parentheses.

      =FROM JIAN=: I'm curious how to do in the opposite way ,if it exists -- I
      don't think use the layout code as a part of syntax is good.

    - _Indentation can easily go wrong in a copy-and-paste job as well._

    - The basic rule of using indentation:
      + code that is part of an expression should be indented under the beginning
        of that expression, even when the beginning of the expression is not at
        the leftmost margin.

      + Furthermore, parts of the expression that are grouped should be indented
        to the same level.

    - Exapmles:
      + Example-1
        #+BEGIN_SRC haskell
          -- RIGHT
          let
            x = 3
            y = 4

          -- or

          let x = 3
              y = 4


          -- Wrong
          let x = 3
           y = 4

          -- or

          let
           x = 3
            y = 4
        #+END_SRC

      + Example-2
        #+BEGIN_SRC haskell
          -- RIGHT
          x = 10 * 5 + y

          x = 10
            * 5 + y

          x = 10
               * 5 + y

          -- WRONG
          x = 10
           * 5 + y

           x = 10 * 5 + y  -- NOT at the beginning column of the line
        #+END_SRC

      + Example-3
        + _WRONG_
          not starting a declaration at the beginning (left) column of the line.
          #+BEGIN_SRC haskell
            -- learn.hs
            module Learn where

             x = 10 * 5 + y
            myResult = x * 5
            y = 10
          #+END_SRC

        + _RIGHT_
          #+BEGIN_SRC haskell
            -- learn.hs
            module Learn where

            -- All indent in the same way
             x = 10 * 5 + y
             myResult = x * 5
             y = 10
          #+END_SRC

        + _BETTER_
          #+BEGIN_SRC haskell
             -- learn.hs
             module Learn where

             -- No indentation
             x = 10 * 5 + y
             myResult = x * 5
             y = 10
          
          #+END_SRC

*** DONE Exercises: Heal the Sick
    CLOSED: [2017-05-20 Sat 17:15]
    1. ~3 .14~ -> ~3.14~
    2. ~b~ -> ~x~
    3. Correct indentation
** DONE 2.8 Arithmetic functions in Haskell
   CLOSED: [2017-05-20 Sat 20:36]
   - =TODO= ~div~, ~mod~, ~quot~, and ~rem~
     =TODO= =TODO=

   - Compare ~div~ and ~quot~
     #+BEGIN_SRC haskell
       -- -- rounds down
       -- Prelude> div 20 (-6)
       -- -4
       -- -- rounds toward zero
       -- Prelude> quot 20 (-6)
       -- -3
     #+END_SRC

   - =TODO=
     Also, rem and mod have slightly different use cases; we'll look at mod in a
     little more detail down below. We will cover (~/~) in more detail in a later
     chapter, as that will require some explanation of types and typeclasses.

*** TODO Laws for quotients and remainders
    - footnote: =???=
*** TODO Using 'mod'
    - x
*** DONE Negative numbers
    CLOSED: [2017-05-20 Sat 20:37]
    Due to the interaction of parentheses, currying, and infix syntax,
    _negative numbers get SPECIAL TREATMENT in Haskell_.
    + Evaluate an isolated negative number in GHCi is simple:
      #+BEGIN_SRC haskell
        -- Prelude> -1000
        -- -1000
      #+END_SRC

    + Since ~+~ and ~-~ has the same precedence, ~1000 + -9~ can't work.
      Write it as ~1000 + (-9)~.

    + The negation of numbers in Haskell by the use of a _unary_ ~-~ is a form of
      /syntactic sugar/.
      ~-9~ is translated inside to ~negate 9~.

      _Fortunately, syntactic overloading like this isn't common in Haskell._

** DONE 2.9 Parenthesization
   CLOSED: [2017-05-20 Sat 21:40]
   - ~(^) \colon{}\colon] (Num a, Integral b) => a -> b -> a~
     ~infixr 8 ^~

   - ~(*) \colon{}\colon{} Num a => a -> a -> a~
     ~infixl 7 *~

   - ~(+) \colon{}\colon{} Num a => a -> a -> a~
     ~infixl 6 +~

   - ~(-) \colon{}\colon{} Num a => a -> a -> a~
     ~infixl 6 -~

   - ~($) \colon\colon{} (a -> b) -> a -> b~
     ~infixr 0 $~

   - Since ~(*30) \colon\colon{} Num a => a -> a~,
     ~3 (*30)~ doesn't work and ~(*30) 3)~ works.

     You can't the pass the prefixed ~3~ in pattern 1 pass to the ~(*30)~
     operator after it.

*** Parenthesizing infix operators
    - /sectioning/ allows you to pass around partially applied functions.
      For example, ~(+1)~

    - /sectioning/ generate a function after partially applied a function,
      which is always prefix _NEVER_ suffix.

    - If you use /sectioning/ with a function that is not commutative, the order
      matters.
      #+BEGIN_SRC haskell
        (1/) 2  -- 0.5
        (/1) 2  -- 2.0
      #+END_SRC

    - ~(-2) 1~ doesn't work, _which is different from the other operators_.
      This is because the ~-~ here function represents _negation_, not
      subtraction,
      when it's applied to a single argument, _GHCi does not know what to do_
      with that, and so it returns an error message.
      =TODO=
      #+BEGIN_SRC haskell
        (-2) 1
        -- <interactive>:26:1: error:
        --     • Non type-variable argument in the constraint: Num ((a -> a) -> t)
        --       (Use FlexibleContexts to permit this)
        --     • When checking the inferred type
        --         it :: forall t a. (Num ((a -> a) -> t), Num a) => t
      #+END_SRC

    - Use sectioning for subtraction, ~-~ must be the first argument (or use
      ~substract~):
      #+BEGIN_SRC haskell
        (1 -) 3  -- it works
        (- 1) 3  -- ERROR

        -- USE
        (substract 2) 3
      #+END_SRC

** DONE 2.10 ~let~ and ~where~
   CLOSED: [2017-05-20 Sat 22:21]
   - It takes some practice to get used to the appropriate times to use each
     (~let~ and ~where~),
     BUT _they are fundamentally different_:
     + ~let~ introduces an expression,
       so it can be used wherever you can have an expression,

     + BUT ~where~ is a declaration and is bound to a surrounding syntactic
       construct.
       =TODO=: What does "surrounding syntactic construct" mean???

   - When you use ~:load~ in GHCi, it will unload the previous loaded module
     (except ~Prelude~), and then load the new one that you want.

     This is a limitation from ~GHCi~.

*** Exercises: A Head Code
    ~where~ is a declaration and is bound to a surrounding syntactic construct.

    =TODO=: it seems you can't put a declaration in the wrong example below,
            _BUT WHY???_

    - Worable Example
      #+BEGIN_SRC haskell
        -- This works in source file
        mult1 = x * y
          where x = 5
                y = 6
      #+END_SRC

    - Wrong Example
      #+BEGIN_SRC haskell
        -- This CANNOT work in source file
        x * y
          where x = 5
                y = 6
      #+END_SRC

** DONE 2.11 Chapter Exercises
   CLOSED: [2017-05-18 Thu 17:23]
*** DONE Parenthesization
    CLOSED: [2017-05-18 Thu 17:23]
    1. ~2 + (2 * 3) - 1~
    2. ~(^) 10 $ (1 + 1)~ OR ~10 ^ (1 + 1)~
    3. ~(2 ^ 2) * (4 ^ 5) + 1~

*** DONE Equivalent expressions
    CLOSED: [2017-05-18 Thu 17:23]
    1. \check
    2. \check
    3. ~363~ AND ~-363~
    4. Int AND Float
    5. ~28~ AND ~46~

*** DONE More fun with functions
    CLOSED: [2017-05-18 Thu 17:23]

** DONE 2.12 Definitions
   CLOSED: [2017-05-18 Thu 18:07]
   1. Terminology: /argument/ and /parameter/
      - They are often used interchangably, but they have distinction.

      - /parameter/ (or /formal parameter/): a value that will be passed to the
        function when the function is called.

        Thus, parameters are usually variables.

      - /argument/: an input value the function is applied to.
      =IMPORTANT= =TODO= =???=

   2. /expression/: a combination of symbols that conforms to syntactic rules and
      can be evaluated to some result.
      _In Haskell_, an expression is a _well-structured combination of_:
      - constants
      - variables
      - functions
      =IMPORTANT=

      We usually mean "reducible expression" when we use the term /expression/,
      though irreducible constants are technically expressions (we usually refer
      to those as /values/).

   3. /redex/: reducible expression

   4. /value/: an expression that cannot be reduced or evaluated any further.

   5. /function/:
      Functions can be DESCRIBED AS _a list of ordered pairs of their inputs and
      the resulting outputs_, like a mapping.

   6. /infix notation/

   7. /operators/: functions that are /infix/ _by default_.
      _In Haskell_, operators must use symbols and not alphanumeric characters.
      =IMPORTANT= =TODO= =???=

   8. /syntactic sugar/: a syntax that is not intrinsically necessary, but it
      often makes for more readable code than the alternatives.

** TODO 2.13 Follow-up resources
* DONE 3 Strings
  CLOSED: [2017-05-19 Fri 20:12]
** DONE 3.1 Strings
   CLOSED: [2017-05-18 Thu 20:43]
   =TODO= Wierd section name???
** DONE 3.2 A first look at types
   CLOSED: [2017-05-18 Thu 20:43]
   - ~:type~: A GHCi command used to check the type of a value, expression, or
     function.

   - The ~::~ symbol is read as "has the type".

   - /type signature/: a line of code that defines the types for a value,
     expression, or function.

   - ~String~ is a /type alias (type synonym)/ for _a list of_ ~Char~ (~[Char]~).

   - When we talk about lists in more detail later, we'll see why the square
     brackets are considered syntactic sugar; =TODO=

** DONE 3.3 Printing simple strings
   CLOSED: [2017-05-19 Fri 00:52]
   - ~print~
     TYPE: ~print :: Show a => a -> IO ()~
     #+BEGIN_SRC haskell
       -- Prelude>
       print "hello world!"

       -- "hello world!"
       -- Prelude>
     #+END_SRC
     The qutation marks still around it.

   - ~putstrLn~ and ~putStr~
     TYPE: ~putStrLn :: String -> IO ()~
     TYPE: ~putStr :: String -> IO ()~
     #+BEGIN_SRC haskell
       -- Prelude>
       putStrLn "hello world!"

       -- hello world!
       -- Prelude>

       -- Prelude>
       putStr "hello world!"

       -- hello world!Prelude>
     #+END_SRC

   - In source file
     #+BEGIN_SRC haskell
       -- print1.hs
       module Print1 where

       main :: IO ()
       main = putStrLn "hello world!"
     #+END_SRC

     Run it:
     #+BEGIN_SRC haskell
       -- Prelude> :l print1.hs
       -- [1 of 1] Compiling Print1
       -- Ok, modules loaded: Print1.

       -- *Print1> main
       -- hello world!
       -- *Print1>
     #+END_SRC

   - GHCi prompt may have changed to reflect the name of the module loaded.
     Use ~:module~ or ~:m~ to _unload_ the module and return to ~Prelude~.

   - You can also set your prompt to something specific (fixed).
     #+BEGIN_SRC haskell
       -- Prelude> :set prompt "λ> "
       -- λ> :r
       -- O,, modules loaded: Print1.
       -- λ> main
       -- hello world!
       -- λ>
     #+END_SRC
     Set it permanently: change =/.ghci= file

   - ~main~ is the default action when you build an executable or run it in a REPL.

     It is _NOT_ a function but is often a series of instructions to execute,
     which can include applying functions and producing side-effects.

   - When building a project with /Stack/:
     + having a ~main~ executable in a ~Main.hs~ file is obligatory,

     + but you can have source files and load them in GHCi without necessarily
       having ~main~ block.

   - ~do~ notation: a special syntax that allows for sequencing actions.
     #+BEGIN_SRC haskell
       -- print2.hs
       module Print2 where

       main :: IO ()
       main = do
         putStrLn "Count to four for me:"
         putStr "one, two"
         putStr ", three, and"
         putStrLn " four!"
     #+END_SRC

     #+BEGIN_SRC haskell
       -- Prelude> :l print2.hs
       -- [1 of 1] Compiling Print2
       -- Ok, modules loaded: Print2.
       -- Prelude> main
       -- Count to four for me:
       -- one, two, three, and four!
       -- Prelude>
     #+END_SRC
     The ~do~ is actually a syntactic sugar. It often makes for more readable
     code than the de-sugared version.
     =TODO= Say more in Chapter 13 (Monad)

*** String concatenation
    - ~++~:
      + Example: ~"hello" ++ " world!"~

    - ~concat~:
      + Example: ~concat [hello, " ", world]~

** DONE 3.4 Top-level versus local definitions
   CLOSED: [2017-05-19 Fri 02:54]
   - Top-level declarations are
     _NOT nested_ within anything else (OUTERMOST), which means they are in scope
     throughout the whole module.

     It doesn't necessarily mean they are defined at the top of the file.

     When the compiler reads the file,
     it will see all the top-level declarations, no matter what order they
     come in the file
     (=TODO= _with some limitations_ which we'll see later).

   - Example:
     #+BEGIN_SRC haskell
       module TopOrLocal where

       topLevelFunction :: Integer -> Integer
       topLevelFunction x = x + woot + topLevelValue
         where woot :: Integer
               woot = 10

       topLevelValue :: Integer
       topLevelValue = 5
     #+END_SRC

     + The ~where~ and ~let~ clauses in Haskell _introduce_ /local bindings/ or
       declarations. The are definitely not visible outside.

   - /bind (or declare)/: give an expression a name.

     _This is not usually necessary for one-time use._

*** DONE Exercises: Scope
    CLOSED: [2017-05-19 Fri 00:56]
    1. \check
    2. ~h~ is not in scope for function ~g~.
    3. ~r~ is not in scope for function ~area~.
    4. \check
** DONE 3.5 Types of concatenation functions
   CLOSED: [2017-05-19 Fri 19:56]
   - When refer to an infix operator in a position that is not infix,
     _put parentheses around it_.

   - ~(++) :: [a] -> [a] -> [a]~

   - ~concat :: Foldable t => t [a] -> [a]~  
     + please understand ~Foldable t => t [a]~ as being ~[ [a] ]~.
       =TODO=: Explain later

*** DONE Exercises: Syntax Errors
    CLOSED: [2017-05-19 Fri 00:59]
    1. Error message: =<interactive>:1:1: error: parse error on input ‘++’=
    2. Error message: =<interactive>:2:2: error: parse error on input ‘<’=
    3. \check
** DONE 3.6 Concatenation and scoping
   CLOSED: [2017-05-19 Fri 20:04]
   - ~:info~ or ~:i~
     #+BEGIN_SRC haskell
     -- Prelude> :i (++)
     -- (++) :: [a] -> [a] -> [a]  -- Defined in ‘GHC.Base’
     -- infixr 5 ++
     #+END_SRC

** DONE 3.7 More list functions
   CLOSED: [2017-05-19 Fri 20:12]
   - ~:~ operator: called "cons," which is used to build a list.

   - ~head~, ~tail~, ~take~, ~drop~, and ~!!~

   - About these functions:
     + All these functions are standard ~Prelude~ functions

     + many of them are considered /unsafe/ -- they do not cover the case of an
       empty list as input.

       They just throw out an error message, or exception. This isn't ideal
       behavior, so the use of these functions is considered unwise for programs
       of any real size or complexity,
       =TODO= _talk out some better ways later_.

** DONE 3.8 Chapter Exercises
   CLOSED: [2017-05-19 Fri 18:42]
*** DONE Reading syntax
    CLOSED: [2017-05-19 Fri 01:20]
    1. Decide if they are written correctly, and correct the wrong ones (easy).
       a) x
       b) x
       c) \check
       d) \check
       e) x
       f) \check
       g) x
       h) \check

    2. Pair the lines of code and their results
       a) -> d)
       b) -> c)
       c) -> e)
       d) -> a)
       e) -> b)

*** DONE Building functions
    CLOSED: [2017-05-19 Fri 18:42]
    1. Write short codes to generate expected outputs from given inputs
       First, ~import Data.List.Split~
       a) ~"Curry is awesome" ++ "!"~
       b) ~drop 4 $ (head . splitOn " ") "Curry is awesome!"~
       c) ~last $ splitOn " " "Curry is awesome!"~

    2. Write 1 into a source file
       #+BEGIN_SRC haskell
         module OperateStrings where

         import Data.List.Split

         addSuffix :: String -> String -> String
         addSuffix str suffix = str ++ suffix

         firstWordLastCharString :: String -> String
         firstWordLastCharString str = drop lenForDrop firstWord
           where
             firstWord = head $ splitOn " " str
             lenForDrop = length firstWord - 1

         lastWord :: String -> String
         lastWord str = last $ splitOn " " str
       #+END_SRC

    3. Write a function to return the 
       #+BEGIN_SRC haskell
         thirdLetter :: String -> Char
         thirdLetter x = head $ drop 2 x
         -- Use `head :: [a] -> a` rather than `(take 1) :: [a] -> [a]`
       #+END_SRC

    4. Write a function to return the 
       #+BEGIN_SRC haskell
         letterIndex :: Int -> Char
         letterIndex x = "Curry is awesome!" !! x
       #+END_SRC

    5. Write a function to reverse ="Curry is awesome"=
       #+BEGIN_SRC haskell
         rvrs :: String -> String
         rvrs = (drop 9 str) ++ (take 4 $ drop 5 str) ++ (take 5 str)
           where str = "Curry is awesome"
       #+END_SRC

    6. Write 5 into a module
       #+BEGIN_SRC haskell
         module Reverse where

         rvrs :: String -> String
         rvrs x = thirdWd ++ middle ++ firstWd
           where
             firstWd = take 5 x
             middle = take 4 $ drop 5 x
             thirdWd = drop 9 x
       #+END_SRC

** DONE 3.9 Definitions
   CLOSED: [2017-05-19 Fri 01:50]
   1. ~String~: a sequence of characters.
      In Haskell, a linked-list of ~Char~ values, aka ~[Char]~. 

   2. /type (datatype)/: a classification of values or data.

      _UNLIKE in other languages_,
      datatypes in Haskell _by default_ do NOT delimit the operations that can be
      performed on that data.
      =TODO= =???=

   3. /concatenation/: In Haskell,
      ~(++) :: [a] -> [a] -> [a]~.

   4. /scope/: _WHERE_ a variable referred to by name is _valid_.
      /visibility/: If a variable _isn't visible_ is _not in scope_.

   5. /local bindings/: bindings local to particular expressions.

      _The primary delineation_ here from /top level bindings/ is:
      that /local bindings/ _CANNOT be imported_ by other programs or modules.

   6. /top level bindings/: In Haskell, this means bindings that stand outside of
      any other declaration (outermost declarations).

      They can be made available to other modules
      + within this programms
      + to other programms

   7. /data structures/: a way of organizing data so that the data can be
      accessed
      + _conveniently_
      + _efficiently_
* TODO 4 Basic datatypes
** DONE 4.1 Basic Datatypes
   CLOSED: [2017-05-20 Sat 22:26]
   - Types play an important role in the _readability_, _safety_, and
     _maintainability_ of Haskell code.

   - In this chapter, we will
     + review types we have seen in previous chapters;

     + learn about datatypes, /type constructors/, and /data constructors/;

     + work with predefined datatypes;

     + learn more about /type signatures/ and a bit about /typeclasses/.

** DONE 4.2 What are types?
   CLOSED: [2017-05-21 Sun 01:32]
** DONE 4.3 Anatomy of a data declaration
   CLOSED: [2017-05-21 Sun 01:41]
   - /data declarations/: How datatypes are defined.

   - /type constructor/: The name of the type and is capitalized.

   - /data constructor/: the values that inhabit the type they are defined in.

   - Example of /data declaration/ to ~Bool~
     ~data Bool = False | True~
     1. Here /type constructor/ is ~Bool~

     2. Here /data constructors/ are ~False~ and ~True~

     3. Here ~|~ indicates a /sum type/ or /logical disjunction: "or"/.
        _Read_: ~Bool~ value is ~True~ or ~False~.

   - Try
     #+BEGIN_SRC haskell
       -- Prelude> :info Bool
       -- data Bool = False | True
     #+END_SRC

*** DONE Exercises: Mood Swing
    CLOSED: [2017-05-21 Sun 01:41]
    - /pattern matching/

    - Given:
      #+BEGIN_SRC haskell
        data Mood = Blah | Woot deriving Show
      #+END_SRC

    - A: type constructors: ~Mood~
    - ~Blash~ / ~Woot~
    - ~changeMood :: Mood -> Mood~

** DONE 4.4 Numeric types
   CLOSED: [2017-05-21 Sun 01:32]
   - /integral numbers/: Whole numbers. Two types:
     1. ~Int~: Has range.
     2. ~Integer~: support arbitrarily large/small numbers.

   - /Fractional/: Not integers. Four types:
     1. ~Float~: single-precision floating point number type.
        + floating point arithmetic violates some common assumptions and should
          only be used with great care.

        + Generally, floating point numbers should not be used at all in business
          applications.

     2. ~Double~: double-precision floating point number type.
        + It has twice as many bits with which to describe numbers as the ~Float~
          type.

     3. ~Rational~: A fractional number that represents a ratio of two integers.
        + Arbitrarily precise but no as efficient as ~Scientific~.

     4. ~Scientific~ (available in package =scientific=): A space-efficient and
        almost-arbitrary precision scientific number type.
        + They are represented using scientific notation. It stores
          * the coeffcient as an ~Integer~;
          * the exponent as an ~Int~.

        + It has limitation, but hitting that is quite unlikely.

   - These numeric datatypes all have instances of a /typeclass/ called ~Num~.

   - Typeclasses are a way of adding functionality to types that is reusable
     across all the types that have instances of that typeclass.
     =TODO= =LATER=

   - The ~Num~ typeclass is what provides your standard ~(+)~, ~(-)~, and ~(*)~
     operators along with a few others.

   - Hypothetically we could represent Integer as a sum of three cases,
     + recursive constructors headed towards negative infinity,
     + zero, and
     + recursive constructors headed towards positive infinity.

     This representation would be _terribly inefficient_
    =TODO= =???= so there's some GHC magic sprinkled on it.

*** DONE Integral numbers
    CLOSED: [2017-05-20 Sat 23:40]
*** DONE Integer
    CLOSED: [2017-05-20 Sat 23:40]
*** DONE Why do we have ~Int~
    CLOSED: [2017-05-21 Sun 01:16]
    - The ~Int~ numeric type is an artifact of what computer hardware has
      supported natively over the years.

    - Most programs should use ~Integer~ and _NOT_ ~Int~,
      UNLESS the limitations of the type are understood and the additional
      performance makes a difference.

    - There are ~Int8~, ~Int16~, et al.

    - Example:
      #+BEGIN_SRC haskell
        -- Prelude> import GHC.Int
        -- Prelude> 127 :: Int8
        -- 127

        -- Prelude> 128 :: Int8
        -- <interactive>:11:1: Warning:
        --     Literal 128 is out of the Int8 range -128..127
        --     If you are trying to write a large negative literal,
        --     use NegativeLiterals
        -- -128

        -- Prelude> (127 + 1) :: Int8
        -- -128
      #+END_SRC

    - Here the 8 in ~Int8~ _represents how many bits_ the type uses to represent
      integral numbers.
        The representation used for the fixed-size ~Int~ types is
      /two's complement/.

    - Find out the min and max bounds of numeric types using ~maxBound~ and
      ~minBound~ from the ~Bounded~ typeclass.
      Here's an example using our ~Int8~ and ~Int16~ example:
      #+BEGIN_SRC haskell
        -- Prelude> import GHC.Int

        -- Prelude> :t minBound
        -- minBound :: Bounded a => a

        -- Prelude> :t maxBound
        -- maxBound :: Bounded a => a


        -- Prelude> minBound :: Int8
        -- -128

        -- Prelude> minBound :: Int16
        -- -32768

        -- Prelude> minBound :: Int32
        -- -2147483648

        -- Prelude> minBound :: Int64
        -- -9223372036854775808


        -- Prelude> maxBound :: Int8
        -- 127

        -- Prelude> maxBound :: Int16
        -- 32767

        -- Prelude> maxBound :: Int32
        -- 2147483647

        -- Prelude> maxBound :: Int64
        -- 9223372036854775807
      #+END_SRC

    - Find out if a type has an instance of ~Bounded~, or any other typeclass,
      by asking GHCi for the ~:info~ for that type.
      #+BEGIN_SRC haskell
        -- Prelude> :i Int
        -- data Int = GHC.Types.I# GHC.Prim.Int# 	-- Defined in ‘GHC.Types’
        -- instance Bounded Int -- Defined in ‘GHC.Enum’
        -- instance Enum Int -- Defined in ‘GHC.Enum’
        -- instance Eq Int -- Defined in ‘GHC.Classes’
        -- instance Integral Int -- Defined in ‘GHC.Real’
        -- instance Num Int -- Defined in ‘GHC.Num’
        -- instance Ord Int -- Defined in ‘GHC.Classes’
        -- instance Read Int -- Defined in ‘GHC.Read’
        -- instance Real Int -- Defined in ‘GHC.Real’
        -- instance Show Int -- Defined in ‘GHC.Show’
      #+END_SRC

*** DONE Fractional numbers
    CLOSED: [2017-05-21 Sun 01:32]
    - ~Float~, ~Double~, ~Rational~, and ~Scientific~.

    - ~(/) \colon{}\colon{} Fractional a => a -> a -> a~
      The notation ~Fractional a =>~ denotes a /typeclass constraint/.

      Read it as "the type variable ~a~ must implement the ~Fractional~
      typeclass."

    - ~Fractional~ is a typeclass that requires types to already have an instance
      of the ~Num~ typeclass.
        We describe this _relationship_ between typeclasses by saying that:
      ~Num~ is a /superclass/ of ~Fractional~.

** DONE 4.5 Comparing values 
   CLOSED: [2017-05-21 Sun 02:42]
   - ~==~ and ~/=~

   - Types
     #+BEGIN_SRC haskell
       Prelude> :t (==)
       (==) :: Eq a => a -> a -> Bool

       Prelude> :t (<)
       (<) :: Ord a => a -> a -> Bool
     #+END_SRC
     + ~Eq~ is a typeclass that includes everything that CAN BE _compared and
       determined to be equal in value_;

     + ~Ord~ is a typeclass that includes all things that CAN BE _ordered_.

   - /lexicographic ordering/

** DONE 4.6 Go on and Bool me 
   CLOSED: [2017-05-21 Sun 02:56]
   - ~&&~, ~||~, and ~not~
*** DONE Exercises: Find the Mistakes
    CLOSED: [2017-05-21 Sun 02:48]
*** DONE Conditionals with if-then-else
    CLOSED: [2017-05-21 Sun 02:57]
    - ~if ... then ... else~

    - Example (look the ~where~ in the example):
      #+BEGIN_SRC haskell
        -- greetIfCool1.hs
        module GreetIfCool1 where

        greetIfCool :: String -> IO ()
        greetIfCool coolness =
          if cool
            then putStrLn "eyyyyy. What's shakin'?"
          else
            putStrLn "pshhhh."
          where cool = coolness == "downright frosty yo"
      #+END_SRC
** DONE 4.7 Tuples  =RE-READ= CLOSED: [2017-05-21 Sun 03:11] 
   - We will start by looking at the two-tuple, a tuple with two constituents.
     The two-tuple is expressed at both the /type level/ and /term level/ with
     the constructor ~(,)~. The datatype declaration looks like this:
     #+BEGIN_SRC haskell
     -- Prelude> :info (,)
     -- data (,) a b = (,) a b
     #+END_SRC
     + A /product type/, not a /sum type/
     + ~fst~ and ~snd~

   - ~swap~ is from ~Data.Tuple~

   - A /product type/ represents a logical conjunction: you _MUST_ supply _both_
     arguments to produce a value.

   - It's generally _unwise_ to use tuples of an overly large size, both for
     efficiency and sanity reasons. _Most tuples you see will be_ ~( , , , , )~
     _(5-tuple) or smaller._

** DONE 4.8 Lists
   CLOSED: [2017-05-23 Tue 02:35]
   - DONE
** TODO 4.9 Chapter Exercises
   1. ~length :: Foldable t => t a -> Int~

   2. What are the results of the following expressions?
      a) 5
      b) 3
      c) 2
      d) 5

   3. ~6 / length [1, 2, 3]~ returns an error.
      REASON: _Here_ ~6~ is a ~Fractional a => a~, which is ~/~ requires.
              However, the return type of ~length~ is ~Int~, which is NOT an
              instance of typeclass ~Fractional a~.
              (See =5.5 Polymorphism - Working around constraints=)

   4. Replace ~/~ with ~`div`~ can help to fix the broken code.
      TYPE: ~div :: Integral a => a -> a -> a~.

   5. The type is ~Bool~, and the result is ~True~.

   6. The type is ~Bool~, and the result is ~False~.

   7. ... DONE

   8. 
      #+BEGIN_SRC haskell
        isPalindrome :: (Eq a) => [a] -> Bool
        isPalindrome x =
          x == reverse x
      #+END_SRC

   9. 
      #+BEGIN_SRC haskell
      myAbs :: Integer -> Integer
      myAbs = \x -> if x >= 0 then x else (-x)
      #+END_SRC

   10. 
       #+BEGIN_SRC haskell
       f :: (a, b) -> (c, d) -> ((b, d), (a, c))
       f = \x -> (\y -> ((snd x, snd y), (fst x, fst y)))
       #+END_SRC

*** TODO Correcting syntax
    1. =???= =Query meaning?=
       #+BEGIN_SRC haskell
         plus1Length xs = length xs + 1
       #+END_SRC

    2. ~\x -> x~

    3. ~\(x:xs) -> x~

    4. ~f (a, b) = a~

*** DONE Match the function names to their types
    CLOSED: [2017-05-23 Tue 03:19]
    1. c)
    2. b)
    3. a)
    4. d)

** TODO 4.10 Definitions
   - /tuple/: an ordered grouping of values.
     _In Haskell_,
     + you _cannot_ have a tuple with only one element           =TOOD: WHY=
     + but here is a zero tuple /unit/ or ~()~.

   - /typeclass/: =TODO=

   - /data constructors/

   - /type constructors/

   - /data declarations/

   - /type alias/:
     For example,
     #+BEGIN_SRC haskell
       type Name = String
       -- creates a new type alias `Name` of the
       -- type `String` *not* a data delcration.
       -- just a type alias declaration
     #+END_SRC

   - /arity/

   - /polymorphism/

** DONE 4.11 Names and variables
   CLOSED: [2017-05-23 Tue 15:17]
*** DONE Names
    CLOSED: [2017-05-23 Tue 15:17]
    - In Haskell there are seven categories of entities that have names:
      + functions
      + term-level variables
      + data constructors
      + type variables
      + type constructors
      + typeclasses
      + modules

    - /term-level/ :: where your values live and is the code that executes when
                      your program is running. It contains:
      + functions
      + term-level variables
      + data constructors

    - /type-level/ :: it is used during the static analysis & verification of
                      your program. It contains:
      + type variables
      + type constructors
      + typeclasses

    - For the purpose of organizing code into coherent groupings across different
      files, we have
      + modules.

*** DONE Conventions for variables
    CLOSED: [2017-05-23 Tue 15:17]
    - type variable names:
      + ~a~, ~b~, ~c~, ...
      + ~a1~, ...

    - functions used as arguments: ~f~, ~g~, ~f'~, ~f1~, ...
      Name like ~f'~ indicates that it is

      + closely related to
        or
      + a helper function to

      function ~f~.

    - Arguments to funcitons are most often given names starting at ~x~ (and then
      ~y~, ~z~), again occasionally seen numbered as in ~x1~.

    - list: ~(x:xs)~

* TODO 5 Types
** DONE 5.1 Types
   CLOSED: [2017-05-23 Tue 17:46]
   - A dataytpe declaration defines
     + a type constructor
       and
     + data constructors.

   - Data constructors _are the values of a particular type_;
     they _are also functions_ that let us create data, or values, of a
     particular type, although it will take some time before the full import of
     this becomes clear.

** DONE 5.2 What are types for?
   CLOSED: [2017-05-23 Tue 17:46]
   - Haskell is an implementation of a /pure lambda calculus/, in the sense that
     it isn't much more than syntactic sugar over a /typed lambda calculus/.

   - A typed lambda calculus called /System F/ is discovered in the 1970s.

     Haskell has improved on /System F/ in some key ways, such as:
     + by allowing general recursion
     + the Hindley-Milner system to permit type inference

   - In Haskell, where typing is /static/, typechecking occurs at compile time.

   - Good type systems can _also_
     + enable compiler optimizations
     + serve as documentation (that's why explicitly declare types is
       encouraged).

** DONE 5.3 How to read type signatures
   CLOSED: [2017-05-23 Tue 16:59]
   - The compiler doesn't know which specific numeric type a value is
     until
     + the type is either declared
       or
     + the compiler is forced to infer a specific type based on the function.

   - For example, ~13~ can be a ~Integer~, but a ~Integer~ only allow us to use
     it in computations that take integers (and _NOT_, say, in fractional
     division).
     #+BEGIN_SRC haskell
     (13 :: Integer) / 4

     -- ERROR:
     -- No instance for (Fractional Integer) arising from a use of '/'
     #+END_SRC

   - For that reason, the compiler gives it the type with the broadest
     applicability (most polymorphic) and says it's a /constrained polymorphic/.

     For example, ~13~ with no given type info, its type will be derived
     (by the compiler) as ~Num a => a~.

*** DONE Understanding the function type
    CLOSED: [2017-05-23 Tue 16:59]
    - ~(->)~: the type constructor for functions.
      It takes arguments and has _NO_ data constructors.
      #+BEGIN_SRC haskell
        -- Prelude> :inf (->)
        -- data (->) t1 t2 	-- Defined in ‘GHC.Prim’
        -- infixr 0 `(->)`
        -- instance Monad ((->) r) -- Defined in ‘GHC.Base’
        -- instance Functor ((->) r) -- Defined in ‘GHC.Base’
        -- instance Applicative ((->) a) -- Defined in ‘GHC.Base’
        -- instance Monoid b => Monoid (a -> b) -- Defined in ‘GHC.Base’
      #+END_SRC

*** DONE Typeclass-constrained type variables
    CLOSED: [2017-05-23 Tue 16:59]
    - The compiler gives
      + the least specific and most general type
      it can.

    - Instead of limiting this function to a concrete type,
      we get a /typeclass-constrained polymorphic type variable/.

    - What we need to know here is that each typeclass offers a standard set of
      functions that can be used across several concrete types.

    - Type error messages constrast the /actual type/ with the /expected type/.

    - /actual type/: what we /provide / expect/

    - /expected type/: what the compiler expected.

*** DONE Exercises: Type Matching
    CLOSED: [2017-05-23 Tue 16:59]
    a) ~not \colon\colon{} Bool -> Bool~   c)
    b) ~length \colon\colon{} Foldable t => t a -> Int~   d)
    c) ~concat :: Foldable t => t [a] -> [a]~   b)
    d) ~head :: [a] -> a~   a)
    e) ~(<) :: Ord a => a -> a -> Bool~   e)

** TODO 5.4 Currying
   - About /currying/:
     + /Named functions/ are /curried/ _by default_.

     + /Anonymous functions/ are /uncurried/ _by default_.

       =COMMENT=:
       Since this, it is obvious that multi-parameter anonymous functions can't
       be use with curry feature.

   - There are syntactic conveniences that construct /curried/ functions
     _by default_.

   - Anonymous functions is /noncurry/ _by default_.

   - ~(->)~ is an infix operator and right associative.

   - Function application is /left associative/.

   - =TODO=: 128

*** DONE Partial application
    CLOSED: [2017-05-23 Tue 19:28]
    - /partial application/

*** DONE Manual currying and uncurrying
    CLOSED: [2017-05-23 Tue 23:19]
*** DONE Currying and uncurrying existing functions
    CLOSED: [2017-05-23 Tue 23:19]
*** DONE Sectioning
    CLOSED: [2017-05-24 Wed 00:07]
    - /sectioning/: partial application of infix operators.

    - The order is important for non-commutative functions.

    - With the help of _backticks_ you can convert a function to an infix
      operator, and then do a /sectioning/.
      #+BEGIN_SRC haskell
        -- Prelude> elem 9 [1..10]
        -- True

        -- Prelude> 9 `elem` [1..10]
        -- True

        -- Prelude> (`elem` [1..10])
        -- Prelude> c 9
        -- True
        -- Prelude> c 25
        -- False

        -- Prelude> (9 `elem`)  [1..10]
        -- True
      #+END_SRC

      With this technique create partial applied functions to the first and
      second argument _is equally convenient_:
      + ~(fstArg `fun`)~ 
      + ~(`fun` sndArg)~

      If you don't use this technique, no neat way to create a partial applied
      function with the second argument:
      ~(\fstArg -> fun fstArg sndArg)~

    - _Conclusion_: The /sectioning/ syntax exists to allow some freedom in which
      argument of a binary operator you apply the function to.

*** DONE Exercises: Type Arguments
    CLOSED: [2017-05-24 Wed 10:39]
    Check the types of a partial applied function, which you haven't defined:
    #+BEGIN_SRC haskell
      -- Prelude> let f :: a -> a -> a -> a; f = undefined
      -- Prelude> let x :: Char; x = undefined
      -- Prelude> :t f x
      -- f x :: Char -> Char -> Char
    #+END_SRC

    1. a)

    2. d)

    3. d)

    4. c)

    5. a)

    6. e)

    7. d) =TODO= =???=
       ONE more exercise should be added BEFORE here:
       #+BEGIN_SRC haskell
         -- Prelude> :t kessel 1
         -- kessel 1 :: (Ord a, Num b, Num a) => b -> a
       #+END_SRC

    8. a) =TODO= =???=
    9. c)

** DONE 5.5 Polymorphism
   CLOSED: [2017-05-24 Wed 17:28]
   - /polymorphic/: 
     + In programming, this is understood to be in contrast with /monomorphic/,
       "made of one form."

     + Etymology:
       * TIME :: This is a word of relatively recent provenance. It was invented in
               the early 19th century.

       * ROOT ::
         1. from the Greek words poly for "many" and morph for "form".
         2. The -ic suffix in polymorphic means “made of.”

         So, "polymorphic" means "made of many forms."

   - /polymorphic function/: its type signature has variables that can represent
     more than one type.

   - /Type signatures/ may have three kinds of types:
     + /concrete/
     + /constrained polymorphic (ad-hoc polymorphism)/
     + /parametrically polymorphic/

   - In Haskell, polymorphism divides into two categories:
     + /parametric polymorphism/ :: unconstrained by a typeclass, their final,
          concrete type could be anything.
            However,
       * To the compiler: unconstrained also means no attached information.
         No pre-knowledge, and less we can do.

       * To the programmer: the information about the types also can't help the
         programmers much.

     + /constrained polymorphism/ :: in Haskell this implemented with
          typeclasses.
            This increases constraints (applied typeclasses), but constraints
          also a kind of information, which increases what you can actually do
          with it by defining and bringing into scope a set of operations (comes
          from the typeclasses)
          ---- More constraints, More helper facilities.
          (=From Jian=: Edited by Jian)

   - By default,
     type variables are resolved at the left-most part of the type signature
     and
     are fixed once sufficient information to bind them to a concrete type is
     available.

   - A variable represents a set of possible values
     A type variable represents a set of possible types.

   - /Concrete types/ have even more flexibility in terms of computation.

     This is benified by the /additive nature/ of typeclasses.
       For example, an ~Int~ is only an ~Int~, but it can make use of the
     methods of the ~Num~ and ~Integral~ typeclasses because it has instances of
     both.

   - In sum,
     + if a variable could be anything, then there's little that can be done to
       it because it has no methods.

     + If it can be some types (say, a type that is an instance of Num), then it
       has some methods.

     + If it is a concrete type, you lose the type flexibility but, due to the
       additive nature of typeclass inheritance, gain more potential methods.

   - /Parametric polymorphism/ refers to _fully polymorphic (unconstrained by a
     typeclass) parameters_.

   - /Parametricity/: it implies that the behavior of a function with respect to
     the types of its (parametrically polymorphic) arguments is _uniform_. The
     behavior can not change just because it was applied to an argument of a
     different type.

*** DONE Exercises: Parametricity
    CLOSED: [2017-05-24 Wed 16:57]
    1. ...

    2. Solutions to ~a -> a -> a~:
       #+BEGIN_SRC haskell
         ifTrue :: a -> a -> a
         ifTrue x y = x

         ifFalse :: a -> a -> a
         ifFalse x y = y
       #+END_SRC

    3. Solutions to ~a -> b -> b~: =TODO= =RIGHT?=
       Same as the solutions of 2

*** DONE Polymorphic constants
    CLOSED: [2017-05-24 Wed 17:01]
*** DONE Working around constraints
    CLOSED: [2017-05-24 Wed 17:28]
    - ~fromIntegral \colon{}\colon{} (Num b, Integral a) => a -> b~
** DONE 5.6 Type inference
   CLOSED: [2017-05-24 Wed 18:46]
   - The /type inference/ of Haskell is built on an extended version of the
     Damas-Hindley-Milner type system.

   - Haskell will infer the _most generally_ applicable (polymorphic) type that
     is still correct.

   - _Type variables have no meaning outside of the type signatures where they are
     bound._

*** DONE Exercises: Apply Yourself
    CLOSED: [2017-05-24 Wed 18:46]
** DONE 5.7 Asserting types for declarations
   CLOSED: [2017-05-24 Wed 18:56]
   - Type can be assigned within a ~where~ clause:
     #+BEGIN_SRC haskell
       triple x = tripleItYo x
         where tripleItYo :: Integer -> Integer
               tripleItYo y = y * 3
     #+END_SRC
** DONE 5.8 Chapter Exercises
   CLOSED: [2017-05-25 Thu 03:37]
*** DONE Multiple choice
    CLOSED: [2017-05-24 Wed 19:07]
    (Though answers of 3. and 4. seems not complete, they are acutally right:
     No constraints (typeclasses), we don't know what kind of operations can be
     applied to them! Thus, b) and c) are not only a choice of solution, but the
     only solutions, respectively.

    1. c)
    2. a)
    3. b)
    4. c)

*** DONE Determine the type
    CLOSED: [2017-05-25 Thu 02:27]
    /monomorphism restriction/ =TODO= =IMPORTANT= =LATER=
    + _For Now_ it means that top-level declarations by default will have a
      concrete type

    + Use the ~NoMonomorphismRestriction~ pragma to avoid
      /monomorphism restriction/. For example, =TODO=
      #+BEGIN_SRC haskell
        {-# LANGUAGE NoMonomorphismRestriction #-}

        module DetermineTheType where

        -- simple example
        example = 1

        -- With the `NoMonomorphismRestriction` pragma
        -- `example :: Num a => a`

        -- Without the `NoMonomorphismRestriction` pragma
        -- `example :: Integer`
      #+END_SRC
    
    1. Determin the return type.
       a) ~Num a => a~
       b) ~(Num a) => (a, [Char])~
       c) ~(Integer, [Char])~
       d) ~Bool~
       e) ~Int~
       f) ~Bool~

    2. ~Num a => a~

    3. ~Num a => a -> a~

    4. ~Fractional a => a~

    5. ~[Char]~

*** DONE Does it compile?
    CLOSED: [2017-05-24 Wed 19:16]
    1. ~bigNum~ is not a function, and it can't be applied to an argument
       (=10= here).

    2. RIGHT. The type of ~z~ is ~IO ()~, and its return value looks like a
       string in display.

    3. ~a~ is not used,
       ~b~ isn't a function that can be applied on an argument =10=,
       Since ~b 10~ is wrong, ~c~ line and the line after it are wrong.

    4. ~c~ is not declared (not in scope).

*** DONE Type variable or specific type constructor?
    CLOSED: [2017-05-25 Thu 02:37]
    =TODO= ANSWER KEY

    1. EXAMPLE

    2. 
       ~f :: zed -> Zed -> Blah~
       + constrained polymorphic: NONE
       + fully polymorphic: ~zed~
       + concrete: ~Zed~ and ~Blah~

    3. 
       ~f :: Enum b => a -> b -> C~
       + constrained polymorphic: ~b~ which is an ~Enum~ instance
       + fully polymorphic: ~a~
       + concrete: ~C~

    4. 
       ~f :: f -> g -> C~
       + constrained polymorphic: NONE
       + fully polymorphic: ~f~ and ~g~
       + concrete: ~C~

*** DONE Write a type signature
    CLOSED: [2017-05-25 Thu 02:42]
    #+BEGIN_SRC haskell
      -- 1
      functionH :: [a] -> a
      functionH (x:_) = x

      -- 2
      functionC :: (Ord a) => a -> a -> Bool
      functionC x y = if (x > y) then True else False

      -- 3
      functionS :: (a, b) -> b
      functionS (x, y) = y
    #+END_SRC
*** DONE Given a type, write the function
    CLOSED: [2017-05-25 Thu 02:58]
    #+BEGIN_SRC haskell
      -- 1
      i :: a -> a
      i = id

      -- 2
      c :: a -> b -> a
      c x y = x

      -- 3
      -- YES, with alpha equivalence they are the same thing.
      c'' :: b -> a -> b
      c'' x y = x

      -- 4
      c' :: a -> b -> b
      c' x y = y

      -- 5
      r :: [a] -> [a]
      r = tail
      -- r = reverse

      -- 6
      co :: (b -> c) -> (a -> b) -> a -> c
      co b2c a2b a = b2c $ a2b a

      -- 7
      a :: (a -> c) -> a -> a
      a _ x = x

      -- 8
      a' :: (a -> b) -> a -> b
      a' a2b a = a2b a
    #+END_SRC

*** DONE Fix it
    CLOSED: [2017-05-25 Thu 03:13]
    1. 
       #+BEGIN_SRC haskell
         module Sing where

         fstString :: [Char] -> [Char]
         fstString x = x ++ " in the rain"

         sndString :: [Char] -> [Char]
         sndString x = x ++ " over the rainbow"

         sing = if (x > y) then fstString x else sndString y
           where x = "Singin"
                 y = "Somewhere"
       #+END_SRC

    2. Change expression ~(x > y)~  to ~(x <= y)~

    3. 
       #+BEGIN_SRC haskell
         -- arith3broken.hs
         module Arith3Broken where

         main :: IO ()
         main = do
           print 1 + 2
           putStrLn "10"
           print (negate (-1))
           print 0 + blah
             where blah = negate 1
       #+END_SRC

*** DONE Type-Know-Do
    CLOSED: [2017-05-25 Thu 03:37]
    /Bottom/ and /undefined/ will be explained in more detail later.
    The contents of the terms are irrelevant here.
    =TODO= =LATER=

    1. ~h = g . f~

    2. ~e = w . q~

    3. ~xform (x, y) = (xz x, yz y)~

    4. ~munge x2y y2wz x = fst $ y2wz $ x2y x~

** TODO 5.9 Definitions
   1. /polymorphism/

   2. /type inference/

   3. /type variable/

   4. /typeclass/

   5. /parametricity/

   6. /Ad-hoc polymorphism (sometimes called "constrained polymorphism")/

   7. /module/

** TODO 5.10 Follow-up resources
   =DOWNLOADED=
   1. 
   2. 
* TODO 6 Typeclasses
  _Page 163-215_
** DONE 6.1 Typeclasses
   CLOSED: [2017-05-25 Thu 22:25]
  Key points:
  - examine the typeclasses ~Eq~, ~Num~, ~Ord~, ~Enum~, and ~Show~;

  - learn about type-defaulting typeclasses and typeclass inheritance;

  - look at some common but often implicit functions that create side effects.
    =TODO=
** DONE 6.2 What are typeclasses?
   CLOSED: [2017-05-25 Thu 22:46]
   - /Typeclasses/ and /types/, in a sense, opposites:
     + A declaration of a type defines how that type in particular is _created_.

     + A declaration of a typeclass defines how a set of types are _consumed_ or
       _used_ in computations.

   - As Philip Wadler put it,
     "The goal is to define a datatype by cases, where one can add new cases to
      the datatype and new functions over the datatype, without recompiling
      existing code, and while retaining static type safety (e.g., no casts)."
      =WHAT IS /static type safety/???=

   - Typeclasses is like /interfaces/ to data that can work across multiple
     datatypes.

   - =TODO=
     163

** DONE 6.3 Back to ~Bool~
   CLOSED: [2017-05-26 Fri 00:29]
   - When we ~:info Bool~ in GHCi, we get:
     #+BEGIN_SRC haskell
       data Bool = False | True
       instance Bounded Bool
       instance Enum Bool
       instance Eq Bool
       instance Ord Bool
       instance Read Bool
       instance Show Bool
     #+END_SRC
     1. instance ~Bounded Bool~ – ~Bounded~ for types that have
        * an upper bound
          and
        * a lower bound

     2. instance ~Enum Bool~ – ~Enum~ for things that can be enumerated

     3. instance ~Eq Bool~ – ~Eq~ for things that can be tested for equality

     4. instance ~Ord Bool~ – ~Ord~ for things that can be put into a sequential
        order

     5. instance ~Read Bool~ – _Read_ parses strings into things.
        _Don’t use it. No seriously, don’t._     =TODO= =???=

     6. instance ~Show Bool~ – ~Show~ renders things into strings.

   - Typeclasses have a hierarchy of sorts. For instance,
     + All ~Fractional~ numbers implement ~Num~ typeclasses, NOT the reverse
       direction.

     + All members of ~Ord~ must be members of ~Eq~, and all the members of
       ~Enum~ must be members of ~Ord~.
       _Rationale_:
       * To be able to put something in an enumerated list, they must be able to
         be ordered;

       * to be able to order something, they must be able to be compared for
         equality.

** DONE 6.4 ~Eq~
   CLOSED: [2017-05-26 Fri 01:29]
   - Haskell does NOT encode equality into every type (like many other languages do).

   - footnote 3: the function type does not have an ~Eq~ instance for reasons we
                 will not get into here. =TODO=

   - ~Eq~ is defined this way:
     #+BEGIN_SRC haskell
       -- Prelude> :info Eq
       class Eq a where
         (==) :: a -> a -> Bool
         (/=) :: a -> a -> Bool
     #+END_SRC

     The instances of ~Eq~ followed the above output:
     #+BEGIN_SRC haskell
       -- partial list
       instance Eq a => Eq [a] -- Defined in 'GHC.Classes'
       instance Eq Word -- Defined in 'GHC.Classes'
       instance Eq Ordering -- Defined in 'GHC.Classes'
     #+END_SRC

   - *Typeclass deriving*
     Though there are some constraints on deriving typeclasses like ~Eq~, ~Ord~,
     ~Enum~, ~Bounded~, ~Read~, and ~Show~,
     you can magically derive them.

     /deriving/: No need to manually write instances of some typeclasses for each
     new datatype you create.

     =TODO=: Chapter _Algebraic Datatypes_

** DONE 6.5 Writing typeclass instances
   CLOSED: [2017-05-26 Fri 23:02]
*** DONE ~Eq~ instances
    CLOSED: [2017-05-26 Fri 21:50]
    - Typeclasses like ~Eq~ come with the core base library that is located at
      http://hackage.haskell.org/package/base

      ~Eq~ specifically is located at
      http://hackage.haskell.org/package/base/docs/Data-Eq.html

    - We see the ~Eq~ definition in section 6.4. It has two functions.
      However, in the documentation, you'll see:
      ~Minimal complete definition: either == or /=.~
      + Q: Why can be ONE.
        A: This is reasonable: one can be defined as the negation of the other

      + Q: Since the answer of the last question, why not ONLY one?
        A: Although it's rare, you may have something clever to do for each case
           that could make equality checking faster for a particular datatype, so
           you're allowed to specify both if you want to.
        * =TODO= =???= =EXAMPLE???=
        * =COMMENT=: In this book we won't be working with any clever
                     datatypes mentioned as rare cases above.
                     Just consider the negation relation.

    - Example-1:
      Define a trivial datatype, and make it an instance of ~Eq~:
      #+BEGIN_SRC haskell
        -- keep your typeclass instances for a type
        -- in the same file as that type
        -- we'll explain why later

        data Trivial =
          Trival'

        instance Eq Trivial where
          Trivial' == Trivial' = True
      #+END_SRC

    - In Haskell, /data constructors/ and /type constructors/ often have the same
      name.
        To avoid gettiing confusing, you can use a single quote suffixed name
      like the example above.

    - Example-2:
      #+BEGIN_SRC haskell
        data DayOfWeek =
          Mon | Tue | Weds | Thu | Fri | Sat | Sun

        instance Eq DayOfWeek where
          (==) Mon Mon = True
          (==) Tue Tue = True
          (==) Weds Weds = True
          (==) Thu Thu = True
          (==) Fri Fri = True
          (==) Sat Sat = True
          (==) Sun Sun = True
          (==) _ _ = False

        -- day of week and numerical day of month
        data Date =
          Date DayOfWeek Int

        instance Eq Date where
          (==) (Date weekday dayOfWeek)
               (Date weekday' dayOfWeek') =
            weekday == weekday' && dayOfMonth == dayOfMonth'
      #+END_SRC
      One thing must be mention here:
        Since we didn't provide ~Show~ distance, values like ~Date Tue 10~ can be
      evaluated, but they can't be print out -- REPL will complain!
      #+BEGIN_SRC haskell
        -- *Main> Date Thu 10

        -- <interactive>:26:1:
        --     No instance for (Show Date) arising from a use of ‘print’
        --     In a stmt of an interactive GHCi command: print it
      #+END_SRC
      + Q: How to fix this?
        A: Stick a ~deriving Show~ clause on the end of each of the datatypes
           above.

*** DONE Partial functions -- not so strange danger
    CLOSED: [2017-05-26 Fri 22:14]
    - /partial function/: a function that does NOT cover all the possible cases.

    - Turn all warnings on in GHCi: ~:set -Wall~
      Do this in the configuration file =TODO=

*** DONE Sometimes we need to ask for more
    CLOSED: [2017-05-26 Fri 22:19]
    #+BEGIN_SRC haskell
      data Identity a =
        Identity a

      instance Eq a => Eq (Identity a) where
        (==) (Identity v) (Identity v') = v == v'
    #+END_SRC
    - The ~Eq a~ above is important, or else we can't do ~v == v'~ in the body
      of this instance.

    - Don't to too much! You shouldn't to things like replace the above ~Eq a~
      with ~Ord a~. If you do that, the code still can be compiled, but it's not
      clear why you use ~Ord~? You never need to know the order in this code.

*** DONE Exercises: ~Eq~ Instances
    CLOSED: [2017-05-26 Fri 23:02]
    - If you have more than one data constructor, you need the ~_ _~
      unconditional case.
        For example: q7 - ~data Either a b = Hello a | Goodbye b~.

    - If you type constructor have more than one type variable,
      remember you don't need to consider case of corresponding types are
      different -- why? because they are different types, and you can't
      build equality or inequality between different types with the help of ~Eq~
      typeclass.
        For example: q5 - ~data Tuple a b = Tuple a b~.
                     ~Tuple 3 4 == Tuple 3 "a"~ can't pass the type check.

** DONE 6.6 ~Num~
   CLOSED: [2017-05-26 Fri 23:28]
   #+BEGIN_SRC haskell
     class Num a where
       (+) :: a -> a -> a
       (*) :: a -> a -> a
       (-) :: a -> a -> a
       negate :: a -> a
       abs :: a -> a
       signum :: a -> a
       fromInteger :: Integer -> a
   #+END_SRC
   And its list of instances (not quite complete):
   #+BEGIN_SRC haskell
     instance Num Integer
     instance Num Int
     instance Num Float
     instance Num Double
   #+END_SRC

   - ~fromInteger~ is similar to ~fromIntegral~, but restricted to ~Integer~
     rahter than all integral numbers.

*** DONE ~Integral~
    CLOSED: [2017-05-26 Fri 23:22]
    - ~Integral~ definition:
      #+BEGIN_SRC haskell
        class (Real a, Enum a) => Integral a where
          quot :: a -> a -> a
          rem :: a -> a -> a
          div :: a -> a -> a
          mod :: a -> a -> a
          quotRem :: a -> a -> (a, a)
          divMod :: a -> a -> (a, a)
          toInteger :: a -> Integer
      #+END_SRC
      + The tuple syntax ~(Real a, Enum a)~ here denotes the
        _conjunction of typeclass constraints_ on your type variable(s).

      + The tuple syntax here requires that ~a~ employ the methods each of those
        typeclasses.

      + In turn, the ~Real~ typeclass itself requires an instance of ~Num~.
          Since ~Real~ CANNOT override the methods of ~Num~,
        this typeclass inheritance is ONLY additive and the ambiguity problems
        caused by multiple inheritance in some programming languages -- the
        so-called "deadly diamond of death" -- are avoided.
        =IMPORTANT=

    - *Exercises: Tuple Experiment*

*** DONE ~Fractional~
    CLOSED: [2017-05-26 Fri 23:27]
    - ~Fractional~ definition:
      #+BEGIN_SRC haskell
        class (Num a) => Fractional a where
          (/) :: a -> a -> a
          recip :: a -> a
          fromRational :: Rational -> a
      #+END_SRC

    - *Put on your thinking cap*
      =DONE=

** DONE 6.7 Type-defaulting typeclasses
   CLOSED: [2017-05-27 Sat 00:59]
   - When you have a typeclass-constrained (ad hoc) polymorphic value
     and need to evaluate it, the polymorphism must be resolved to a specific
     _concrete type_.

     + The _concrete type_ must have an instance for all the required typeclass
       instances.

     + Ordinarily the _concrete type_ would come
       * from the type signature you've _specified_
         or
       * from _type inference_, such as when a Num a => a is used in an
         expression that expects an ~Integer~ which forces the polymorphic
         number value to concretize as an ~Integer~.

     + But in some cases =???=, particularly when you're working in the GHCi
       REPL you will not have specified a concrete type for a polymorphic value.
         In those situations, _the typeclass will default to a concrete type_,
       and the default types are already set in the libraries.

   - The Haskell Report (https://www.haskell.org/onlinereport/haskell2010/)
     specifies the following defaults relevant to numerical computations:
     #+BEGIN_SRC haskell
       default Num Integer
       default Real Integer
       default Enum Integer
       default Integral Integer
       default Fractional Double
       default RealFrac Double
       default Floating Double
       default RealFloat Double
     #+END_SRC

   - The use of polymorphic values
     + without the ability to infer a specific type
       and
     + no default rule
     will cause GHC to complain about an ambiguous type.

   - We can declare more specific (monomorphic) functions from more general
     (polymorphic) functions:
     ~let add = (+) :: Integer -> Integer -> Integer~

** DONE 6.8 ~Ord~
   CLOSED: [2017-05-27 Sat 04:04]
   #+BEGIN_SRC haskell
     class Eq a => Ord a where
       compare :: a -> a -> Ordering
       (<) :: a -> a -> Bool
       (>=) :: a -> a -> Bool
       (>) :: a -> a -> Bool
       (<=) :: a -> a -> Bool
       max :: a -> a -> a
       min :: a -> a -> a

     -- This list is incomplete!

     -- instance Ord a => Ord (Maybe a)
     -- instance (Ord a, Ord b) => Ord (Either a b)
     -- instance Ord Integer
     -- instance Ord a => Ord [a]
     -- instance Ord Ordering
     -- instance Ord Int
     -- instance Ord Float
     -- instance Ord Double
     -- instance Ord Char
     -- instance Ord Bool
   #+END_SRC

   - ~compare~: The type of return values is ~Ordering~
     #+BEGIN_SRC haskell
       -- Prelude> compare 7 8
       -- LT

       -- Prelude> compare 4 (-4)
       -- GT

       -- Prelude> compare 4 4
       -- EQ

       -- Prelude> compare "Julie" "Chris"
       -- GT

       -- Prelude> compare True False
       -- GT

       -- Prelude> compare True True
       -- EQ
     #+END_SRC

   - In Haskell, ~True~ is greater than ~False~.
     _Proximally_ this is due to how the ~Bool~ datatype is defined:
     ~False | True~.
     + =TODO= What is the real reason???
     + =TODO= IS the right of ~|~ is greater the left of ~|~ is a rule?
     + =TODO= Even if the above is a rule. It's can't be a reason, because you
              can also define the ~Bool~ datatype as ~True | False~.

   - Any time we ask GHCi to print a return value in our terminal, we are
     indirectly invoking ~print :: Show a => a -> IO ()~.

   - Usually, you can't evaluate a partial applied function result in GHCi.

     Rationale: What you really CANNOT do is to print it, not to evaluate it --
                after evaluation, GHCi, on behalf of you, will always try to
                print the result value out (the 'P' in the word "REPL").

*** DONE ~Ord~ instances
    CLOSED: [2017-05-27 Sat 01:50]
    - One of the most necessary skills in Haskell:
      typeclasses instance-writing skills

    - When you /derive/ ~Ord~ instances for a datatype,
      they rely on the way the datatype is defined,

      but if you write your own instance, you can define the behavior you want.

      We'll use the days of the week again to demonstrate:
      #+BEGIN_SRC haskell
        data DayOfWeek =
          Mon | Tue | Weds | Thu | Fri | Sat | Sun
          deriving (Ord, Show)
      #+END_SRC
      + _Q_: Why do we not derive ~Eq~?

        _A_: Actually we did before.

      + _Q_: How about if not derive ~Eq~ before?

        _A_: Two solutions/options:
        1. bring it back into scope by putting it into the file you're currently
           using,
        2. derive an ~Eq~ instance for the datatype now by adding it inside the
           parentheses. For this example, we are lucky, the result of ~deriving~
           is what we want (like the instance we implement before).

        You can't have an ~Ord~ instance _unless_ you _ALSO_ have an ~Eq~ instance,

        so the compiler will complain
        if you don't do one (NOT both) of those two things.

      + Write our own ~Ord~ instance of the above datatype, and express the
        _Friday_ is always the best day -- greater than the other days in
        comparison (and set all the other days are equal -- in the same order).
        #+BEGIN_SRC haskell
          data DayOfWeek =
            Mon | Tue | Weds | Thu | Fri | Sat | Sun
            deriving (Eq, Show)

          instance Ord DayOfWeek where
            compare Fri Fri = EQ
            compare Fri _ = GT
            compare _ Fri = LT
            compare _ _ = EQ
        #+END_SRC

    - A few things should be kept in mind:
      + Make sure for one datatype, the ~Ord~ instance is _consistent_ with your
        ~Eq~ instance -- for example, if ~x == y~ is ~True~, ~compare x y~ should
        be ~EQ~.

      + ~Ord~ instances should define a sensible /total order/ -- all cases
        should be covered. You don't want ~compare x y~ is _inconsistent_ with
        your ~compare y x~.

      + =Question from Jian= How to write a /partial order/ instance??? Sometimes
        I may need to simulate some partial order objects in math.
        =TODO=

*** DONE ~Ord~ implies ~Eq~
    CLOSED: [2017-05-27 Sat 04:00]
    Always keep the idea /minimally sufficient/ in mind.

*** DONE Exercises: Will They Work?
    CLOSED: [2017-05-27 Sat 04:04]
    ONLY 3 can't work. ~compare~ can ONLY accept two arguments of the same type.
    ~String~ and ~Bool~ are not the same type.

** DONE 6.9 ~Enum~
   CLOSED: [2017-05-27 Sat 04:15]
   - ~Enum~ typeclass definition: 
     #+BEGIN_SRC haskell
       class Enum a where
         succ :: a -> a
         pred :: a -> a
         toEnum :: Int -> a
         fromEnum :: a -> Int
         enumFrom :: a -> [a]
         enumFromThen :: a -> a -> [a]
         enumFromTo :: a -> a -> [a]
         enumFromThenTo :: a -> a -> a -> [a]

       -- instance Enum Ordering
       -- instance Enum Integer
       -- instance Enum Int
       -- instance Enum Char
       -- instance Enum Bool
       -- instance Enum ()
       -- instance Enum Float
       -- instance Enum Double
     #+END_SRC

   - ~succ~ and ~pred~
     #+BEGIN_SRC haskell
       -- Prelude> succ 4
       -- 5

       -- Prelude> pred 'd'
       -- 'c'

       -- Prelude> succ 4.5
       -- 5.5
     #+END_SRC

   - ~enumFromTo~
     #+BEGIN_SRC haskell
       -- Prelude> enumFromTo 3 8
       -- [3, 4, 5, 6, 7, 8]

       -- Prelude> enumFromTo 'a' 'f'
       -- "abcdef"
     #+END_SRC

   - ~enumFromThenTo~
     #+BEGIN_SRC haskell
       -- Prelude> enumFromThenTo 1 10 100
       -- [1, 10, 19, 28, 37, 46, 55, 64, 73, 82, 91, 100]
     #+END_SRC

** TODO 6.10 ~Show~
   - ~Show~ :: a typeclass that provides for the creating of human-readable string
               representations of structured data.

   - GHCi uses ~Show~ to create ~String~ values it can print in the terminal.

   - /serialization/ :: how data is rendered to texual or binary format for
       persistence or communicating with other computers over a network.

       EXAMPLE: Save data to a file on disk.

   - ~Show~ is NOT a /serialization/ format. It's not suitable for any of these
     purposes; it's expressly for human readability.

   - The typeclass information looks like this (_truncated_):
     #+BEGIN_SRC haskell
       -- Prelude> :info Show
       class Show a where
         showsPrec :: Int -> a -> ShowS
         show :: a -> String
         showList :: [a] -> ShowS

       instance Show a => Show [a]
       instance Show Ordering
       instance Show a => Show (Maybe a)
       instance Show Integer
       instance Show Int
       instance Show Char
       instance Show Bool
       instance Show ()
       instance Show Float
       instance Show Double
     #+END_SRC

   - ~show~: a function which
     + takes a polymorphic ~a~
       and
     + returns it as a ~String~

*** TODO Printing and side effects
    - GHCi is a REPL, the "P" in "REPL" implies a implicit and indirect call to
      ~print~. ~print~ is important to ~Show~, and here we digress a bit and talk
      about it in more detail.

    - Haskell is a /pure/ /functional/ programming language.
      + /functional/: programs are written as functions, similar to mathematical
        equations, in which an operation is applied to some arguments to produce
        a result.

      + /pure/: expressions in Haskell can be expressed exclusively in terms
        of a lambda calculus.

        =TODO=: This part is not clear to the REALTIONSHIP between functions
        (in /functional/ part) and expressions (in /pure/ part).

    - /side effect/: a potentially observable result apart from the value the
      expression evaluates to.

    - =TODO= =note=

*** DONE Working with Show
    CLOSED: [2017-05-27 Sat 23:02]
    - A minimal implementation of an instance of ~Show~ only requires that
      ~show~ OR ~showPrec~ be implemented, as in the following example:
      #+BEGIN_SRC haskell
        data Mood = Blah

        instance Show Mood where
          show _ = "Blah"

        -- *Main> Blah
        -- Blah
      #+END_SRC

    - Another solution is to derive the ~Show~ instance for ~Mood~
      because it's one of the typeclasses GHC supports deriving instances for by
      default.

** DONE 6.11 ~Read~
   CLOSED: [2017-05-28 Sun 00:01]
   - The ~Read~ typeclass, like ~Show~, a lot of types have instances of ~Read~.

   - ~Read~ is essentially the _opposite_ of ~Show~.
     Where ~Show~ takes things and turns them into human-readable strings,
     ~Read~ takes strings and turns them into things.

   - Like ~Show~, ~Read~ is _NOT_ a /serialization/ format.

   - We gave that dire warning against using ~Read~ earlier in the chapter. 
     + Q :: WHY?

     + A :: The problem is in the ~String~ type -- A ~String~ is a list, which
            could be empty in some cases, or stretch on to infinity in other
            cases.

            For example,
            #+BEGIN_SRC haskell
              -- Prelude> :t read
              -- read :: Read a => String -> a
            #+END_SRC
            No promise to a function of type ~Read a => String -> a~ that it can
            always work.
              One example is that we want to read a ~Integer~, however, we are in
            no way guaranteed that ~String~ will be a valid representation of an
            ~Integer~ value -- that's way too big of a type for things we want to
            parse into numbers!
            #+BEGIN_SRC haskell
              -- Prelude> read "123456" :: Integer
              -- 1234567

              -- Prelude> read "BLAH" :: Integer
              -- *** Exception: Prelude.read: no parse
            #+END_SRC
            That exception is a runtime error and means that read is a partial
            function, a function that doesn't return a proper value as a result for
            all possible inputs.

   - We have ways of cleaning this up we'll explain and demonstrate later. =TODO=

   - We should strive to avoid writing or using such functions in Haskell

     _BECAUSE_ Haskell gives us the tools necessary to avoid senseless sources of
     errors in our code. =TODO= 

** DONE 6.12 Instances are dispatched by type
   CLOSED: [2017-05-28 Sun 16:31]
   - The components of a typeclass:
     + a typeclass defines a set of functions and/or values;

     + types have instances of that typeclass;

     + the instances specify the ways that type uses the functions of the
       typeclass.

   - Here is a example of vacuous and silly -- this is only to make a point:
     #+BEGIN_SRC haskell
       class Numberish a where
         fromNumber :: Integer -> a
         toNumber :: a -> Integer

       -- pretend newtype is data for now
       newtype Age =
         Age Integer
         deriving (Eq, Show)

       instance Numberish Age where
         fromNumber n = Age n
         toNumber (Age n) = n

       --
       newtype Year =
         Year Integer
         deriving (Eq, Show)

       instance Numberish Year where
         fromNumber n = Year n
         toNumber (Year n) = n

       -- Write a function using this typeclass and the two types and instances:
       sumNumberish :: Numberish a => a -> a -> a
       sumNumberish a a' = fromNumber summed
         where integerOfA = toNumber a
               integerOfAPrime = toNumber a'
               summed = integerOfA + integerOfAPrime

       -- Prelude> sumNumberish (Age 10) (Age 10)
       -- Age 20
     #+END_SRC

   - *Why not write a typeclass like this?*
     + Reasons will be given when we talk about ~Monoid~ =TODO=
       =TODO= =CANNOT UNDERSTAND=
       , it's important that your typeclasses have laws and rules about how they
       work.

     + ~Numberish~ is a bit... arbitrary.
       There are better ways to express what it does in Haskell than a typeclass.
       Functions and values alone suffice here.
       =TODO=

** DONE 6.13 Gimme more operations
   CLOSED: [2017-05-28 Sun 16:51]
   - Haveing no constraint on our term-level values
     means
     they could be any type, but there isn't much we can do with them.

   - If you use an operation, and no typeclass(es) given to provide this
     operation, GHC/GHCi will issue an error message to tell you what
     typeclass(es) you should provide -- a prerequisite: the operand of this
     operator is proper, which means it/they can't be type(s) of no that
     operation.

*** DONE Concrete types imply all the typeclasses they provide
    CLOSED: [2017-05-28 Sun 16:51]
    - Concrete types imply all the typeclasses they provide.
      + This is good in many cases.

      + This is not good in some cases: a lot of typeclasses (operations) are
        provided -- it could be easy to make a function that does something
        unintended. Thus, sometimes, even if you think you know what concrete
        type you will operate, you only provide proper typeclass(es), rather than
        the concrete type(s).
        =TODO= =NEED EXAMPLE=
** DONE 6.14 Chapter Exercises
   CLOSED: [2017-05-28 Sun 18:10]
*** DONE Multiple choice
    CLOSED: [2017-05-28 Sun 16:54]
    1. c)
    2. a) b)
    3. a)
    4. c)
    5. a)
*** DONE Does it typecheck?
    CLOSED: [2017-05-28 Sun 17:12]
    Nothing with the function type constructor (~->~) has an instance of Show by
    default in Haskell.
    =TODO= footnote-6
    1. Not typecheck. Add ~deriving Show~ to the datatype declaration.

    2. Not typecheck. Add ~deriving Eq~ to the datatype declaration.

    3. 
       a) Only ~Woot~ and ~Blah~
       b) Type error
       b) Type error. ~Mood~ is not an instance of ~Ord~

    4. Not typecheck. In ~s1~, no enough values are feeded to data constructor
       ~Sentence~.

*** DONE Given a datatype declaration, what can we do?
    CLOSED: [2017-05-28 Sun 17:17]
    1. No typecheck.
       Should be ~phew = Papu (Rocks "chases") (Yeah True)~

    2. Typecheck.

    3. Typecheck.

    4. No typecheck.
       All ~deriving~ part should incude ~Ord~

       =TODO=
       WHY only ~deriving (Eq, Ord, Show)~ is OK and
       ~deriving (Ord, Show)~ doesn't work, even if ~Ord~ is the subclass of
       ~Eq~.

*** DONE Match the types
    CLOSED: [2017-05-28 Sun 17:51]
    1. 
    2. 
    3. 
    4. 
    5. 
    6. 
    7. 
    8. 
    9. 
    10. 
    11. 
*** DONE Type-Kwon-Do Two: Electric Typealoo
    CLOSED: [2017-05-28 Sun 18:10]
    1. ~chk aTob x y = (aTob x) == y~
    2. ~arith aTob int x = aTob x~ =TODO= =BETTER ONE???=
** DONE 6.15 Chapter Definitions
   CLOSED: [2017-05-29 Mon 00:20]
   1. /typeclass inheritance/: a typeclass can have a /superclass/, and a
      typeclass can have a /subclass/.

      #+BEGIN_SRC haskell
        -- class Num a => Fractional a where
        --   (/) :: a -> a -> a
        --   recip :: a -> a
        --   fromRational :: Rational -> a

        newtype Nada = Nada Double deriving (Eq, Show)

        instance Fractional Nada where
          (Nada x) / (Nada y)= Nada (x / y)
          recip (Nada n) = Nada (recip n)
          fromRational r = Nada (fromRational r)
      #+END_SRC
      When we load a source file with these code, we will receive some error
      messages -- the error surce is the ~deriving~ part of the ~newtype~ line.
      ~Nada~ is not an instance of ~Num~, thus it can't be an instance of
      ~Fractional~.

   2. /side effects/: observable actions programs may take other than compute a
      value.

   3. /IO/: =TODO= Read the IO chapter.

   4. /instance/: the definition of how a typeclass should work for a given type.

   5. /derived instances/: can be used to instance obvious or common typeclasses,
      which saves programmers' time, and auto-generates instance typeclasses for
      a given type.

** DONE 6.16 Typeclass inheritance, partial
   CLOSED: [2017-05-28 Sun 18:18]
   Eq
    |
   \|/
   Ord    Num
    |    /   \
   \|/ |/_   _\|
   Real       Fractional  Enum
      \                    /
       ----           -----
          \under{}\|       |/\under{}
             Integral

** TODO 6.17 Follow-up resources
   1. 
   2. 
* TODO 7 More functional patterns
  _Page 216-272_
** DONE 7.1 Make it func-y
   CLOSED: [2017-05-29 Mon 00:22]
** DONE 7.2 Arguments and parameters
   CLOSED: [2017-05-29 Mon 01:07]
*** DONE Declaring parameters
    CLOSED: [2017-05-29 Mon 01:07]
    - /bound/, /unified/

*** DONE Binding variables to values
    CLOSED: [2017-05-29 Mon 01:07]
    - Applying a function binds its parameters to values.

    - Type parameters become bound to a type, and
      function variables are bound to a value.

    - The binding of variables concerns not only the application of function
      arguments, but also things like ~let~ expressions and ~where~ clauses.

    - /Lexical scoping/: resolve the value for a named entity depends on the
      location in the code and the lexical context, for example in ~let~ and
      ~where~ clauses.

    - The seeming-sequentiality of defining things in GHCi is, under the hood,
      actually a never-ending series of nested lambda expressions.

** DONE 7.3 Anonymous functions
   CLOSED: [2017-05-29 Mon 01:28]
   - In GHCi error messages, =it= refers to the last expression you entered.

*** DONE Exercises: Grab Bag
    CLOSED: [2017-05-29 Mon 01:20]
    1. a), b), c), d)

    2. d)

    3. Re-write:
       #+BEGIN_SRC haskell
         -- a)
         f = \n -> n + 1
         -- though `f = (+1)` is better

         -- b)
         addFive = \x -> \y -> (if x > y then y else x) + 5

         -- c)
         mflip f x y = f y x
       #+END_SRC

*** DONE The utility of lambda syntax
    CLOSED: [2017-05-29 Mon 01:28]

** DONE 7.4 Pattern matching
   CLOSED: [2017-05-29 Mon 03:03]
   - Pattern matching allows you to
     _expose_ data
     and
     _dispatch_ different behaviors _based on_ that data in your function
     definitions by _deconstructing_ values to expose their inner workings.

   - Enter a block of code in GHCi with the help of ~:{~ and ~:}~
     #+BEGIN_SRC haskell
       -- Prelude> :{
       -- *Main| let isItTwo :: Integer -> Bool
       -- *Main|     isItTwo 2 = True
       -- *Main|     isItTwo _ = False
       -- *Main| :}
     #+END_SRC

*** DONE Handling all the cases
    CLOSED: [2017-05-29 Mon 02:25]
    - The _order_ of pattern matches _matters_!

    - /bottom/: a non-value used to denote that the program cannot return a value
      or result.
 
    - Incomplete pattern matches applied to data they don't handle will return
      /bottom/.
      For example:
      #+BEGIN_SRC haskell
      isItTwo :: Integer -> Bool
      isItTwo 2 = True

      -- Prelude> isItTwo 2
      -- True
      -- Prelude> isItTwo 3
      -- *** Exception: :50:33-48:
      --   Non-exhaustive patterns
      --       in function isItTwo
      #+END_SRC

    - =TODO= We're going to get well acquainted with the idea of /bottom/ in
      upcoming chapters.

    - ~:set -Wall~ can also (of course, we have ~all~ in the ~-Wall~ option) help
      to make a warnning about non-exhaustive pattern match(es) without
      triggering the /bottom/.

*** DONE Pattern matching against data constructors
    CLOSED: [2017-05-29 Mon 02:55]
    - The purposes of /pattern matching/:
      + It enables us to vary what our functions do given different inputs.
      + It also allows us to _unpack_ and _expose_ the contents of our data.

    - The next example uses ~newtype~ which is a special case of ~data~
      declarations.
        ~newtype~ is different in that it permits
      + _only one_ constructor
        and 
      + _only one_ field.

      =TODO= We will talk about ~newtype~ more later.

    - /sum type/ and /product type/
      #+BEGIN_SRC haskell
        -- sum type
        data WherePenguinsLive =
            Galapagos
          | Antarctica
          | Australia
          | SouthAfrica
          | SouthAmerica
          deriving (Eq, Show)

        -- product type
        data Penguin =
          Peng WherePenguinsLive
          deriving (Eq, Show)
      #+END_SRC

*** DONE Pattern matching tuples
    CLOSED: [2017-05-29 Mon 03:03]
    - One nice thing about tuples patten matching is that
      the tuple syntax allows the function to look a great deal like its type.

      =From Jian=
      The property of "_look like_ a thing it wants to represent" is important
      than it seems. This similarity can help you to avoid a lot of mistakes when
      doing operation.

    - ~:browse ModuleName~ can show you a list of the type signatures of
      functions we loaded from the module =ModuleName=.

*** DONE Exercises: Variety Pack
    CLOSED: [2017-05-29 Mon 01:51]
    1. 
        a) ~(a, b) -> b~
        b) ~[Char]~. Not same.
        a) ~k1~, ~k3~

    2. ~f (va, vb, vc) (vd, ve, vf) = ((va, vd), (vc, vf))~

** DONE 7.5 Case expressions
   CLOSED: [2017-05-29 Mon 23:23]
*** TODO Exercises: Case Practice
    #+BEGIN_SRC haskell
      -- 1
      functionC x y =
        case compare x y of
          LT -> x
          _ -> y

      -- 2
      ifEvenAdd2 n =
        case (even n) == True of
          True -> n + 2
          False -> n

      -- 3
      TODO: ???
    #+END_SRC

** DONE 7.6 Higher-order functions
   CLOSED: [2017-05-30 Tue 01:07]
   - /higher-order functions (HOFs)/

   - ~flip \colon{}\colon{} (a -> b -> c) -> b -> a -> c~
     #+BEGIN_SRC haskell
       -- Prelude> (-) 10 1
       -- 9

       -- Prelude> let fSub = flip (-)
       -- Prelude> fSub 10 1
       -- -9

       -- Prelude> fSub 5 10
       -- 5
     #+END_SRC

   - When we want to express a function argument within a function type, we must
     use parentheses to nest it.

   - One reason we want /HOFs/ is to manipulate how functions are applied to
     arguments.

   - If a type ~deriving (Eq, Ord)~, the latter is greater than the former. For
     example:
     #+BEGIN_SRC haskell
       data Employee = Coder
                     | Manager
                     | Veep
                     | CEO
                     deriving (Eq, Ord, Show)
     #+END_SRC

*** DONE Exercises: Artful Dodgy
    CLOSED: [2017-05-30 Tue 01:10]
    1. 
    2. 
    3. 
    4. 
    5. 
    6. 
    7. 
    8. 
    9. 
    10. 
    11. 

** TODO 7.7 Guards
*** DONE if-then-else
    CLOSED: [2017-05-30 Tue 01:22]
*** DONE Writing guard blocks
    CLOSED: [2017-05-30 Tue 01:31]
    #+BEGIN_SRC haskell
      myAbs :: Integer -> Integer
      myAbs x
         | x < 0 = (-x)
         | otherwise = x
    #+END_SRC
    + The guard case expression between the ~|~ and ~=~ must evaluate to ~Bool~.

    + It is important to note that GHCi _cannot always_ tell you when you haven't
      accounted for all possible cases, and it can be difficult to reason about
      it, so _it is wise to use ~otherwise~ in your final guard_, though it also
      cannot help you to check the coverity -- it just cover all else.

*** TODO Exercises: Guard Duty
    1. 
    2. 
    3. 
    4. 
    5. 
    6. 
    7. 
    8. 
** DONE 7.8 Function composition
   CLOSED: [2017-05-30 Tue 01:46]
   ~(.) :: (b -> c) -> (a -> b) -> a -> c~

   - Function composition can make code easier to read than nested parentheses.
     For example,
     NOT ~(f (g (h x)))~ , BUT ~(f . g . h) x~ or ~f . g . h $ x~ are prefered.

   - ~(f . g) x~ is always the same as ~f (g x)~ if
     + ~f \colon{}\colon{} b -> c~
     + ~g \colon{}\colon{} a -> b~
     + ~x \colon{}\colon{} a~
     Since function application has precedence of 10, the parentheses above is
     always required (or use ~$~).
       If no parentheses ~f . g x~ is the same as ~f . (g x)~, which is generally
     wrong, though it can be right, if
     + ~f \colon{}\colon{} b -> c~
     + ~g \colon{}\colon{} k -> a -> b~
     + ~x \colon{}\colon{} k~

** DONE 7.9 Pointfree style
   CLOSED: [2017-05-30 Tue 01:52]
   - ~foldr~
   - ~filter~ 
** DONE 7.10 Demonstrating composition
   CLOSED: [2017-05-30 Tue 02:08]
   How to create your version of ~print~ with the helper of function composition
   ~(.)~: ~putStrLn . show~
** TODO 7.11 Chapter Exercises
*** DONE Multiple choice
    CLOSED: [2017-05-30 Tue 02:14]
    1. d)
    2. b)
    3. d)
    4. b)
    5. a)
*** TODO Let's write code
    1.
       #+BEGIN_SRC haskell
         -- a)
         tensDigit x = d
           where (xLast, _) = x `divMod` 10
                 d = xLast `mod` 10

         -- I prefer:
         -- tensDigit = (`mod` 10) . (`div` 10)

         -- b) Yes

         -- c)
         hunsD = (`mod` 100) . (`div` 100)

       #+END_SRC

    2. 
       #+BEGIN_SRC haskell
         foldbool3case :: a -> a -> bool -> a
         foldBool3Case x y bl =
           case bl of
             True -> x
             False -> y

         foldBool3Guard :: a -> a -> Bool -> a
         foldBool3Guard x y bl
           | bl = x
           | otherwise = y


       #+END_SRC

    3. 
       #+BEGIN_SRC haskell
         g :: (a -> b) -> (a, c) -> (b, c)
         g aTob (va, vc) = ((aTob va), vc)
       #+END_SRC

    4. =TODO=

    5. =TODO=

    6. =TODO=

** DONE 7.12 Chapter Definitions
   CLOSED: [2017-05-30 Tue 03:03]
   1. /binding/ or /bound/

   2. /anonymous function/

   3. /currying/
      ~curry~ and ~uncurry~ already exist in =Prelude=

   4. /pattern matching/: a syntactic way of deconstructing product and sum types
      to get at their inhabitants.
        It's best to explain pattern matching in terms of how datatypes work, so
      we're going to use terminology that you may not fully understand yet.
      =TODO= We'll cover this more deeply soon.

   5. /bottom/

   6. /higer-order functions/

   7. /composition/

   8. /pointfree/
      #+BEGIN_SRC haskell
        -- not pointfree
        blah x = x
        addAndDrop x y = x + 1
        reverseMkTuple a b = (b, a)
        reverseTuple (a, b) = (b, a)

        -- pointfree versions of the above
        blah = id
        addAndDrop = const . (1 +)
        reverseMkTuple = flip (,)
        reverseTuple = uncurry (flip (,))
      #+END_SRC
      + ~const~

** TODO 7.13 Follow-up resources
   1. 
   2. 
   3. 
   4. 
   5. 
* DONE 8 Recursion
  CLOSED: [2017-05-31 Wed 00:27]
  _Page 273-297_
** DONE 8.1 Recursion
   CLOSED: [2017-05-30 Tue 15:27]
   - /recursion/ gives us a means of expressing /indefinite/ or incremental
     computation without forcing us to explicitly repeat ourselves and allowing
     the data we processing to decide when we are doen computing.

   - Being able to write recursive functions is essential to Turing completeness.

   - /Y combinator (fixed-point combinator)/
     Haskell has native recursion ability based on the same principle as the Y
     combinator.

   - In this chapter, we will
     + explore _what_ recursion is
       and
       _how_ recursive functions _evaluate_;

     + go step-by-step through the process of writing recursive functions;

     + have fun with /bottom/.

** DONE 8.2 Factorial
   CLOSED: [2017-05-30 Tue 16:19]
*** DONE Another way to look at recursion
    CLOSED: [2017-05-30 Tue 16:08]
    - ~enumFrom \colon{}\colon{} Enum a => a -> [a]~

    - /recursion/ is like a self function composition with a stopping point:
      #+BEGIN_SRC haskell
        inc :: Num a => a -> a
        inc = （+1）

        three = inc . inc . inc $ 0

        -- Use a parameter "times" to control how many times of 'inc' need to be applied
        incTimes :: (Eq a, Num a) => a -> a -> a
        incTimes 0 n = n
        incTimes times n = 1 + (incTimes (times -1) n)

        -- Abstract pattern from 'incTimes'
        applyTimes :: (Eq a, Num a) => a -> (b -> b) -> b -> b
        applyTimes 0 f b = b
        applyTimes n f b = f (applyTimes (n - 1) f b)

        incTimes' :: (Eq a, Num a) => a -> a -> a
      #+END_SRC

*** DONE Intermission: Exercise
    CLOSED: [2017-05-30 Tue 16:08]

** DONE 8.3 Bottom
   CLOSED: [2017-05-30 Tue 16:42]
   - ⊥ or /bottom/: computations that do not successfully result in a value.

   - Two main varieties of bottom:
     + computations that failed with an error;
       #+BEGIN_SRC haskell
         -- "f False" results in a bottom
         f :: Bool -> Int
         f True = error "blah"
         f False = 0
         -- Prelude> f True
         -- *** Exception: blah



         -- The error is still there, but our language implementation is making
         -- it the fallback case because we didn't write a "total function".
         g :: Bool -> Int
         g False = 0
         -- Prelude> g True
         -- *** Exception: 6:23-33:
         --       Non-exhaustive patterns in function g

         -- The previous function was really:
         g' :: Bool -> Int
         g' False = 0
         g' _ = error $ "*** Exception: "
                     ++ "Non-exhaustive"
                     ++ "patterns in function g'"
       #+END_SRC

     + computations that failed to terminate.
       #+BEGIN_SRC haskell
         -- Prelude> let x = x in x
         -- *** Exception: <<loop>>
       #+END_SRC

   - In logic, ⊥ corresponds to _false_.

   - You can easily use the datatype ~Maybe~ to re-write a /partial function/,
     and get a /total function/. The definition of ~Maybe~ is:
     ~data Maybe a = Nothing | Just a~

   - ~Nothing~ is a way to say no result without hitting /bottom/.

   - ~Maybe~ makes all uses of ~nil~ values and most uses of /bottom/
     unnecessary.

** DONE 8.4 Fibonacci numbers
   CLOSED: [2017-05-30 Tue 21:49]
   1.
   2. 
   3. 
   4. 
** DONE 8.5 Integral division from scratch
   CLOSED: [2017-05-30 Tue 21:56]
** DONE 8.6 Chapter Exercises
   CLOSED: [2017-05-31 Wed 00:27]
*** DONE Reviewing types
    CLOSED: [2017-05-30 Tue 03:10]
   1. d) 
   2. b)
   3. a) c)
   4. b)

*** DONE Reviewing currying
    CLOSED: [2017-05-30 Tue 03:19]
   1. "woops mrow woohoo!"

   2. "1 mrow haha"

   3. "woops mrow 2 mrow haha"

   4. "woops mrow blue mrow haha"

   5. "pink mrow haha mrow green mrow woops mrow blue"

   6. "are mrow Pugs mrow awesome"

*** DONE Recursion
    CLOSED: [2017-05-30 Tue 23:20]
    1.
       #+BEGIN_SRC haskell
         -- divideby 15 2 =
         -- go 15 2 0
         -- go 13 2 1
         -- go 11 2 2
         -- go 9 2 3
         -- go 7 2 4
         -- go 5 2 5
         -- go 3 2 6
         -- go 1 2 7
         -- (7, 1)
       #+END_SRC

    2. 
       #+BEGIN_SRC haskell
         sum :: (Eq a, Num a) => a -> a
         sum n = go n 0
           where
             go 0 acc = acc
             go m acc = go (m - 1) acc + m
       #+END_SRC

    3. 
       #+BEGIN_SRC haskell
         mult' :: (Integral a) => a -> a -> a
         mult' x y =
           | (x == 0) || (y == 0) = 0
           | otherwise = go (min xAbs yAbs) (xSign * ySign * $ max xAbs yAbs) 0
           where
             sign = (signum x) * (signum y)
             xAbs = abs x
             xAbs = abs x
             arg1 = min xAbs yAbs
             arg2 = sign * (max xAbs yAbs)
             go 0 _ acc = acc
             go n' m acc = go (n'-1) m (acc+m)
       #+END_SRC

*** DONE Fixing dividedBy
    CLOSED: [2017-05-30 Tue 23:54]
    #+BEGIN_SRC haskell
      data DividedResult =
        Result Integer
        | DividedByZero
        deriving Show

      dividedBy :: Integer -> Integer -> (DividedResult, Integer)
      dividedBy num demon
        | demon == 0 = (DividedByZero, num)
        | otherwise = go (abs num) (abs demon) 0
        where
          sign = (signum num) * (signum demon)
          go n d count
            | n < d = (Result $ count * sign, n)
            | otherwise = go (n - d) d (count + 1)
    #+END_SRC

*** DONE McCarthy 91 function
    CLOSED: [2017-05-30 Tue 23:58]
    #+BEGIN_SRC haskell
      mc91 x
        | x > 100 = x - 10
        | otherwise = mc91 $ mc91 (x + 11)
    #+END_SRC
*** DONE Numbers into words
    CLOSED: [2017-05-31 Wed 00:27]
    #+BEGIN_SRC haskell
      module WordNumber where

      import Data.List (intersperse)

      digitToWord :: Int -> String
      digitToWord 0 = "zero"
      digitToWord 1 = "one"
      digitToWord 2 = "two"
      digitToWord 3 = "three"
      digitToWord 4 = "four"
      digitToWord 5 = "five"
      digitToWord 6 = "six"
      digitToWord 7 = "seven"
      digitToWord 8 = "eight"
      digitToWord 9 = "nine"
      digitToWord _ = error "digit other than 0 ~ 9"

      digits :: Int -> [Int]
      digits n = go n []
        where
          go num digitList
            | num < 10 = num:digitList
            | otherwise = let (d, m) = num `divMod` 10
                          in go d (m:digitList)

      wordNumber :: Int -> String
      wordNumber n = concat $ intersperse "-" wordList
        where
          wordList = map digitToWord (digits n)
    #+END_SRC
** DONE 8.7 Definitions
   CLOSED: [2017-05-30 Tue 03:20]
   /recursion/
* TODO 9 Lists
  _Page 298-343_
** DONE 9.1 Lists
   CLOSED: [2017-05-31 Wed 01:13]
   - Two purpose:
     1. a collection or plurality of values.
     2. infinite series of values, usually generated by a function, which allows
        them to act as a stream datatype.

   - In this chapter, we will:
     + explain list's datatype and how to pattern match on lists;
     + practice many standard library functions for operating on lists;
     + learn about the underlying representations of lists;
     + see what that representation means for their evaluation;
     + and do a whole bunch of exercises!

** DONE 9.2 The list datatype
   CLOSED: [2017-05-31 Wed 01:22]
   - ~data [] a = [] | a : [a]~
     + Here ~[]~ is
       the type constructor for lists
       as well as
       the data constructor for the empty list.

     + ~[]~ data constructor is a nullary constructor (no arguments).

     + ~(:)~ is an infix operator usually called "cons".

   - list datatype as a whole is a sum type,
     but the second data constructor is a /product/.

     A /sum type/ can be read as an "or", and a /product/ is like an "and".

   - In English, one can read this as:
     ~data []   a   =  []  |  a : [a]~
       --  [1] [2] [3] [4] [5] [6]
     1. The datatype with the type constructor ~[]~
     2. takes a single type constructor argument ~a~
     3. at the term level can be constructed via
     4. nullary constructor ~[]~
     5. or it can be constructed by
     6. data constructor ~(:)~ which is a product of a value of the type ~a~ we
        mentioned in the type constructor and a value of type ~[a]~, that is,
        “more list.”

** DONE 9.3 Pattern matching on lists
   CLOSED: [2017-05-31 Wed 02:00]
   - *Using Maybe*
     + Later in the book, we’ll also cover a datatype called ~NonEmpty~ which
       always has at least one value and avoids the empty list problem.
** DONE 9.4 List's syntactic sugar
   CLOSED: [2017-05-31 Wed 02:06]
   - /cons cell/
   - =TODO= =???= The cons cell is a /conceptual/ space that values may inhabit.
** DONE 9.5 Using ranges to construct lists
   CLOSED: [2017-05-31 Wed 02:34]
   - ~enumFrom \colon{}\colon{} Enum a => a -> [a]~
     ~enumFromThen \colon{}\colon{} Enum a => a -> a -> [a]~

     They can generate lists of indefinite, _possibly infinite_, length.

     If the type ~a~ which instances the typeclass ~Enum~ has upper bound, then
     the generated lists are NOT infinite.

   - ~enumFromTo \colon{}\colon{} Enum a => a -> a -> [a]~
     #+BEGIN_SRC haskell
       [1..10]
       -- OR
       enumFromTo 1 10

       -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


       enumFromTo 3 1
       -- []
     #+END_SRC

   - ~enumFromThenTo \colon{}\colon{} Enum a => a -> a -> a -> [a]~
     #+BEGIN_SRC haskell
       [1, 2..10]
       -- OR
       enumFromThenTo 1 2 10

       -- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     #+END_SRC

*** DONE Exercise: EnumFromTo
    CLOSED: [2017-05-31 Wed 02:34]
    The definition of ~Enum~ typeclass:
    #+BEGIN_SRC haskell
      -- Prelude> :info Enum
      class Enum a where
        succ :: a -> a
        pred :: a -> a
        toEnum :: Int -> a
        fromEnum :: a -> Int
        enumFrom :: a -> [a]
        enumFromThen :: a -> a -> [a]
        enumFromTo :: a -> a -> [a]
        enumFromThenTo :: a -> a -> a -> [a]
    #+END_SRC

    #+BEGIN_SRC haskell
      eftBool :: Bool -> Bool -> [Bool]
      eftBool False True = [False, True]
      eftBool _ _ = []

      eftOrd :: Ordering -> Ordering -> [Ordering]
      eftOrd LT EQ = [LT, EQ]
      eftOrd LT GT = [LT, EQ, GT]
      eftOrd EQ GT = [EQ, GT]
      eftOrd o1 o2 = if o1 == o2
                     then [o1]
                     else []

      eftInt :: Int -> Int -> [Int]
      eftInt x y
        | x <= y = x : (eftInt (succ x) y)
        | otherwise = []

      eftChar :: Char -> Char -> [Char]
      eftChar c1 c2
        | c1 <= c2 = c1 : (eftChar (succ c1) c2)
        | otherwise = []
    #+END_SRC
** DONE 9.6 Extracting portions of lists
   CLOSED: [2017-05-31 Wed 03:48]
   - ~take \colon{}\colon{} Int -> [a] -> [a]~
     ~take~ n elements from an empty list will result in an empty list.

   - ~drop \colon{}\colon{} Int -> [a] -> [a]~
     ~drop~ n elements from an empty list will result in an empty list.

   - ~splitAt \colon{}\colon{} Int -> [a] -> ([a], [a])~
     split after the nth element.
     ~splitAt~ an empty list will result in an empty list.

   - ~takeWhile \colon{}\colon{} (a -> Bool) -> [a] -> [a]~
     ~dropWhile \colon{}\colon{} (a -> Bool) -> [a] -> [a]~
     Take or drop items out of a list that meet some condition.

*** DONE Exercises: Thy Fearful Symmetry
    CLOSED: [2017-05-31 Wed 03:48]
    1. 
       #+BEGIN_SRC haskell
         myWords :: String -> [String]
         myWords "" = []
         myWords (' ':subSentence) = myWords subSentence
         myWords sentence = word : (myWords subSent)
           where
             subSent = dropWhile (/= ' ') sentence
             word = takeWhile (/= ' ') sentence
       #+END_SRC

    2. 
       #+BEGIN_SRC haskell
         myLines :: String -> [String]
         myLines "" = []
         myLines ('\n':subString) = myLines subString
         myLines string = oneSent : (myLines leftSents)
           where
             oneSent = takeWhile (/= '\n') string
             leftSents = dropWhile (/= '\n') string
       #+END_SRC

    3. 
       #+BEGIN_SRC haskell
         myUnits :: Char -> String -> [String]
         myUnits _ "" = ""
         myUnits sep string@(sep':substring)
           | sep == sep' = myUnits sep subString
           | otherwise = oneSent : (myUnits sep leftSents)
           where
             oneSent = takeWhile (/= sep) string
             leftSents = dropWhile (/= sep) string

         myWords = myUnits ' '
         myLines = myUnits '\n'
       #+END_SRC
** DONE 9.7 List comprehensions
   CLOSED: [2017-05-31 Wed 15:17]
   - /list comprehension/: generate a new list from a list or lists.

   - Example:
     #+BEGIN_SRC haskell
       [x^2 | x <- [1..10]]
     #+END_SRC
     ~<-~ is read as "take"

*** DONE Adding predicates
    CLOSED: [2017-05-31 Wed 15:04]
    - Example:
      #+BEGIN_SRC haskell
        [x^2 | x <- [1..10], rem x 2 == 0]
      #+END_SRC

    - For list comprehensions with multiple generators, one thing to note is that
      the rightmost generator will be exhausted first, then the second rightmost,
      and so on.
        For example,
      #+BEGIN_SRC haskell
        -- Without condition:
        [x^y | x <- [1..5], y <- [2, 3]]
        -- [1, 1, 4, 8, 9, 27, 16, 64, 25, 125]

        -- With condition:
        [x^y | x <- [1..10], y <- [2, 3], x^y < 200]
        -- [1, 1, 4, 8, 9, 27, 16, 64, 25, 125, 36, 49, 64, 81, 100]
      #+END_SRC

*** DONE Exercises: Comprehend Thy Lists
    CLOSED: [2017-05-31 Wed 15:09]
    #+BEGIN_SRC haskell
      mySqr = [x^2 | x <- [1..5]]
      -- [1, 4, 9, 16, 25]

      [x | x <- mySqr, rem x 2 == 0]
      -- [4, 16]

      [(x, y) | x <- mySqr, y <- mySqr, x < 50, y > 50]
      -- []

      take 5 [(x, y) | x <- mySqr,
              y <- mySqr, x < 50, y > 50]
      -- []
    #+END_SRC

*** DONE List comprehensions with Strings
    CLOSED: [2017-05-31 Wed 15:13]
    - ~elem :: Eq a => a -> [a] -> Bool~

*** DONE Exercises: Square Cube
    CLOSED: [2017-05-31 Wed 15:17]
    #+BEGIN_SRC haskell
      -- 1
      tuples = [(x, y) | x <- mySqr, y <- myCube]

      -- 2
      smallTuples = [(x, y) | x <- mySqr, y <- myCube, x < 50, y < 50]

      -- 3
      length tuples
      length SmallTuples
    #+END_SRC

** TODO 9.8 Spines and nonstrict evaluation
   - /spine/: the connective structure that ties the collection of values
     togehter.
       lists, sequences, and trees have /spines/.

*** DONE Using GHCi's ~:sprint~ command
    CLOSED: [2017-05-31 Wed 16:02]
    - ~:sprint~ (in GHCi): print variables and see what has been evaluated
      already, with the underscore (~_~) representing expressions that haven't
      been evaluated yet.

    - _Warning_: ~:sprint~ has some behavioral quirks that can be a bit
      frustrating when you experiment and explore yourself.
      =TODO= =???=
      + GHC Haskell has some _opportunistic optimizations_ =TODO= =???= which
        introduce strictness to make code faster when it won't change how your
        code evaluates.

      + Additionally polymorphism means values like Num a => a are really waiting
        for a sort of argument which will make it concrete (this will be covered
        in more detail in a later chapter).
          To avoid this, you have to assign a more concrete type such as ~Int~ or
        ~Double~, otherwise it stays unevaluated, ~_~, in :sprint's output.
        =TODO= =EXAMPLE=

      If you can keep these _caveats_ to :sprint's behavior in mind, it can be
      useful.
        Otherwise if you find it confusing, don't sweat it and wait for us to
      elaborate more deeply in the chapter on nonstrictness.

    - Example:
      #+BEGIN_SRC haskell
        -- Prelude> let blah = enumFromTo 'a' 'z'
        -- Prelude> :sprint blah
        -- blah = _

        -- Prelude> take 1 blah
        -- "a"
        -- Prelude> :sprint blah
        -- blah = 'a' : _

        -- Prelude> take 2 blah
        -- "ab"
        -- Prelude> :sprint blah
        -- blah = 'a' : 'b' : _
      #+END_SRC

    - The ~length~ function is _ONLY_ /strict/ in the /spine/, meaning it only
      forces evaluation of the /spine/ of a list, _NOT the values_, something we
      can see if we try to find the length of a list of undefined values.
        But when we use ~length~ on =blah=, ~:sprint~ will behave _as though_
      (not real) we had forced evaluation of the values as well:
      #+BEGIN_SRC haskell
        -- Prelude> length blah
        -- 26

        -- Prelude> :sprint blah
        -- blah = "abcdefghijklmnopqrstuvwxyz"

        -- COMMENT: the printed out of blah is not real, its cons cells have not been
        --          evaluated.
      #+END_SRC
      That the individual characters were shown as evaluated and not exclusively
      the /spine/ after getting the ~length~ of =blah= is one of the
      _unfortunate aforementioned quirks of how GHCi evaluates code_.

*** TODO Spines are evaluated independently of values
    - /normal form/: the expression is fully evaluated.

    - /weak head normal form (WHNF)/: the expression is only evaluated as far as
      is necessary to reach a data constructor.

    - /WHNF/ is a larger set and contains the possibility that:
      + the expression is fully evaluated (/normal form/);
      + the expression has been evaluated to the point of arriving at a data
        constructor;
      + lambda awaiting an argument.

    - For an expression in WHNF, further evaluation may be possible once another
      argument is provided.
        If no further inputs are possible, then it is still in WHNF but also in
      normal form (NF).
      =TODO= Chapter non-strictness

    - For example:
      + ~(1, 2) -- WHNF & NF~
        This first example is in /normal form/ and is fully evaluated.
        _Anything in /normal form/ is by definition also in
        /weak head normal form/_,
        because /weak head/ is an expression which is evaluated up to _at least_
        the first data constructor. /Normal form/ exceeds that by requiring
        that all sub-expressions be fully evaluated.

          Here the components of the value are:
        * the tuple data constructor
          and
        * the values 1 and 2.

      + ~(1, 1 + 1) -- WHNF~
        ~1 + 1~ hasn't been evaluated.

      + ~\x -> x * 10 -- WHNF & NF~
        This anonymous function can't reduced further.
        With nothing further to reduce, it is in /normal form/.

      + ~"Papu" ++ "chon"~
        Neither /WHNF/ nor /NF/.
        The "outermost" component of the expression is a function, ~(++)~, whose
        arguments are fully applied but it hasn't been evaluated.

      + ~(1, "Papu" ++ "chon") -- WHNF~

    - When we define a list and define all its values, it is in /NF/ and all its
      values are known.

    - When we construct a list through /ranges/ or /functions/ the list is in
      /WHNF/ but not /NF/.

    - The compiler _ONLY_ evaluates the head or first node of the graph,
      BUT _JUST_ the cons constructor,
          _NOT_ the value or rest of the list it contains.

    - Evaluating a list to /normal form/ would've meant recursing through the
      entire list,
      forcing
      + _not only_ the entire spine
      + _but also_ the values each cons cell contained.

    - =TODO=
      #+BEGIN_SRC haskell
        -- Prelude> let x = [1, undefined, 3]
        -- Prelude> length x
        -- 3
      #+END_SRC

    - 
      #+BEGIN_SRC haskell
        -- *Not* identical to the length function in Prelude
        length :: [a] -> Integer
        length [] = 0
        length (_:xs) = 1 + length xs
      #+END_SRC

    - Currently, if you try using ~_~ on the right-hand side in the definition,
      it'll think you're trying to refer to a _hole_.

    - ~length~ will throw an error on a /bottom/ value if part of the /spine/
      itself is /bottom/:
      #+BEGIN_SRC haskell
        -- Prelude> let x = [1] ++ undefined ++ [3]

        -- Prelude> length x
        -- *** Exception: Prelude.undefined

        -- Prelude> x
        -- [1*** Exception: Prelude.undefined
      #+END_SRC
      + Printing the list fails, although it gets as far as printing the first
        ~[~ and the first value,
        and
      + attempting to get the length also fails because it can't count undefined
        spine values.

    - =TODO= Return to this topic later.
      Developing intuition for Haskell's evaluation strategies takes time and
      practice.

*** TODO Exercises: Bottom Madness
**** TODO Will it blow up?
     1. Neither =TODO= =???=
     2. [1]
     3. ⊥
     4. 3
     5. ⊥
     6. [2]
     7. ⊥
     8. [1]
     9. [1, 3]
     10. ⊥
**** TODO Intermission: Is it in normal form?
     1. WHNF & NF
     2. =TODO= WHNF or neither???
     3. Neither
     4. Neither
     5. Neither
     6. Neither
     7. =TODO=

** DONE 9.9 Transforming lists of values
   CLOSED: [2017-05-31 Wed 22:14]
   - In truth, in part because Haskell uses nonstrict evaluation,

     we _tend to_ use higher-order functions for transforming data
        _rather than_ manually recursing over and over.

   - ~map \colon{}\colon{} (a -> b) -> [a] -> [b]~
     ~map~ can only be used with ~[]~.

   - ~fmap \colon{}\colon{} Functor f => (a -> b) -> f a -> f b~
     ~fmap~ can be applied to data
     other than lists.
     =TODO= See ~Functor~ later.

   - How ~map~ is defined in Base:
     #+BEGIN_SRC haskell
       map :: (a -> b) -> [a] -> [b]
       map _ [] = []
       map f (x:xs) = fx : map f xs
     #+END_SRC

   - A common mantra for performance sensitive code in Haskell is:
     _"lazy in the spine, strict in the leaves."_

     =TODO= We'll cover this properly later
     _when we talk about nonstrictness and data structures_, although many
     Haskell users rarely worry about this.

*** DONE Exercises: More Bottoms
    CLOSED: [2017-05-31 Wed 22:14]
    1. ⊥
    2. [1]
    3. ⊥
    4. ~[Char] -> [Bool]~
    5.
       a) ~[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]~
       b) ~[1, 10, 20]~
       c) ~[15, 15, 15]~
    6. 
       #+BEGIN_SRC haskell
         import Data.Bool

         negateX x :: Num a => [a] -> [a]
         negateX x= map (\y -> bool y (-y) (y==x))
       #+END_SRC

** DONE 9.10 Filtering lists of values
   CLOSED: [2017-05-31 Wed 22:28]
   - The definition of ~filter~
     #+BEGIN_SRC haskell
       filter :: (a -> Bool) -> [a] -> [a]
       filter _ [] = []
       filter pred (x:xs)
         | pred x = x : filter pred xs
         | otherwise = filter pred xs
     #+END_SRC

*** DONE Exercises: Filtering
    CLOSED: [2017-05-31 Wed 22:28]
    #+BEGIN_SRC haskell
      -- 1
      filter (\x -> x `mod` 3 == 0) [1..30]

      -- 2
      length . filter (\x -> x `mod` 3 == 0) $ [1..30]

      -- 3
      myFilter :: String -> [String]
      myFilter = filter f . words
        where
          f = \x -> (x /= "a") && (x /= "an") && (x /= "the")
    #+END_SRC

** DONE 9.11 Zipping lists
   CLOSED: [2017-05-31 Wed 23:16]
   - ~zip \colon{}\colon{} [a] -> [b] -> [(a, b)]~
     #+BEGIN_SRC haskell
       zip [1, 2, 3] [4, 5, 6]
       -- [(1, 4), (2, 5), (3, 6)]

       zip [1, 2] [4, 5, 6]
       -- [(1, 4), (2, 5)]

       zip [] [1..1000000]
       -- []
     #+END_SRC

   - ~unzip \colon{}\colon{} [(a, b)] -> ([a], [b])~
     #+BEGIN_SRC haskell
       unzip $ zip [1, 2, 3] [4, 5, 6]
       -- ([1, 2, 3], [4, 5, 6])
     #+END_SRC

   - ~zipWith \colon{}\colon{} (a -> b -> c) -> [a] -> [b] -> [c]~
     #+BEGIN_SRC haskell
       zipWith (+) [1, 2, 3] [10, 11, 12]
       -- [11, 13, 15]

       zipWith (==) ['a'..'f'] ['a'..'m']
       -- [True, True, True, True, True, True]
     #+END_SRC

*** DONE Zipping exercises
    CLOSED: [2017-05-31 Wed 23:16]
    #+BEGIN_SRC haskell
      -- 1
      myZip :: [a] -> [b] -> [(a, b)]
      myZip [] _ = []
      myZip _ [] = []
      myZip (x:xs) (y:ys) = (x, y) : myZip xs ys

      -- 2
      myZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
      myZipWith f [] _ = []
      myZipWith f _ [] = []
      myZipWith f (x:xs) (y:ys) = (f x y) : (myZipWith f xs ys)

      -- 3
      myZip' = myZipWith (,)
    #+END_SRC

** DONE 9.12 Chapter Exercises
   CLOSED: [2017-06-03 Sat 02:36]
*** DONE ~Data.Char~
    CLOSED: [2017-06-01 Thu 22:33]
    #+BEGIN_SRC haskell
      import Data.Char
      -- 1
      -- Prelude> :t isUpper
      -- isUpper :: Char -> Bool

      -- Prelude> :t toUpper
      -- toUpper :: Char -> Char


      -- 2
      filter isUpper "HbEfLrLxO"


      -- 3
      capitalize :: String -> String
      capitalize "" = ""
      capitalize (c:cs) = toUpper c : cs


      -- 4
      capitalizeAll :: String -> String
      capitalizeAll "" = ""
      capitalizeAll (c:cs) = toUpper c : capitalizeAll cs


      -- 5
      capitalHead :: String -> Char
      capitalHead "" = error "Empty string has no head"
      capitalHead (c:_) = toUpper c

      -- 6
      capitalHead' :: String -> Char
      capitalHead' str = head . capitalize $ str

      capitalHead'' :: String -> Char
      capitalHead'' = head . capitalize
    #+END_SRC

*** DONE Ciphers
    CLOSED: [2017-06-03 Sat 01:52]
    #+BEGIN_SRC haskell
      import Data.Char

      -- A - Z 65 ~ 90
      -- a - z 97 ~ 122

      generatorOfCaesarCodePoint :: Int -> Char -> Int
      generatorOfCaesarCodePoint shift c
        | isLower c && shiftedCodePoint > 122 =  shiftedCodePoint - 122 + 97
        | isLower c = shiftedCodePoint
        | shiftedCodePoint > 90 = shiftedCodePoint - 90 + 65
        | otherwise = shiftedCodePoint
        where
          shiftedCodePoint = ord c + (shift `rem` 26)


      enCaesar :: Int -> String -> String
      enCaesar shift info = map f info
        where
          f = chr . (generatorOfCaesarCodePoint shift)


      unCaesar :: Int -> String -> String
      unCaesar shift info = map f info
        where
          f = chr . (generatorOfCaesarCodePoint (-shift))
    #+END_SRC
*** DONE Writing your own standard functions
    CLOSED: [2017-06-03 Sat 02:36]
    #+BEGIN_SRC haskell
      -- #1
      myOr :: [Bool] -> Bool
      myOr [] = False
      myOr (x:xs) = x || myOr xs

      -- #2
      myAny :: (a -> Bool) -> [a] -> Bool
      myAny f [] = False
      myAny f (x:xs) = f x || myAny f xs

      -- #3
      myElem :: Eq a => a -> [a] -> Bool
      myElem _ [] = False
      myElem e (x:xs) = e == x || (myElem e xs)

      myElem' :: Eq a => a -> [a] -> Bool
      myElem' e xs = any (e==) xs

      -- #4
      myReverse :: [a] -> [a]
      myReverse xs = go xs []
        where
          go [] ys = ys
          go (y:ys) zs = go ys (y:zs)

      -- #5
      squish :: [[a]] -> [a]
      squish [] = []
      squish (x:xs) = x ++ squish xs

      -- #6
      squishMap :: (a -> [b]) -> [a] -> [b]
      squishMap _ [] = []
      squishMap f (x:xs) = f x ++ squishMap f xs

      -- #7
      squishAgain :: [[a]] -> [a]
      squishAgain = squishMap id

      -- #8
      myMaximumBy :: (a -> a -> Ordering) -> [a] -> a
      myMaximumBy f [x] = x
      myMaximumBy f (x:x':xs) = case f x x' of
        GT -> myMaximumBy f (x:xs)
        _ -> myMaximumBy f (x':xs)

      -- #9
      myMinimumBy :: (a -> a -> Ordering) -> [a] -> a
      myMinimumBy f [x] = x
      myMinimumBy f (x:x':xs) = case f x x' of
        LT -> myMaximumBy f (x:xs)
        _ -> myMaximumBy f (x':xs)

      myMaximum :: (Ord a) => [a] -> a
      myMaximum = myMaximumBy compare

      myMinimum :: (Ord a) => [a] -> a
      myMinimum = myMinimumBy compare

    #+END_SRC
 
** DONE 9.13 Definitions
   CLOSED: [2017-05-31 Wed 23:31]
   1. /Product type/: a type made of a set of types _compounded_ over each other.

      In Haskell _represnet products_ using:
      + tuples
        or
      + data constructors with more than one argument.

      Product of types represents a conjunction, "and", of those types.

   2. /Sum type/: a type whose terms are terms in other types, but
      _NOT simultaneously_.

      In Haskell sume types are represented using the pipe, ~|~, in a datatype
      definition.

      Sums of types represents a disjunction, "or", of those types.

   3. /Cons/

   4. /Cons cell/: a data constructor and a product of the types ~a~ and ~[a]~
      as defined in the list datatype.

   5. /spine/: a way to refer to the structure that glues a collection of values
      together.

      In the list datatype it is formed by the recursive nesting of cons cells.

      It applies with tree data structures as well

** TODO 9.14 Follow-up resources
   1. 
   2. 
* TODO 10 Folding lists
  _Page 344-380_
** DONE 10.1 Folds
   CLOSED: [2017-06-01 Thu 18:46]
   - /Folding/ is a concept that extends in usefulness and importance beyound
     lists.
       Lists are just the data structure being used to introduce this concpet.

   - /Folds/ as a general concept are called /catamorphisms/.

   - /catamorphisms/:
     + "morphism" from polymorphism.
     + "Cata-" means "down" or "against", as in "catacombs."
     Catamorphisms are a means of deconstructing data.
       If the spine of a list is the structure of a list, then a fold is what can
     reduce that structure.

   - We will:
     + what folds are and how they work;
     + the evaluation processes of folds;
     + walk through the process of writing folding functions;
     + introduce ~scans~, functions that are related to folds.

** DONE 10.2 Bringing you into the fold
   CLOSED: [2017-06-01 Thu 18:59]
   ~foldr \colon{}\colon{} Foldable t => (a -> b -> b) -> b -> t a -> b~:

   - Short for "fold right".

   - _This is the fold you'll most often want to use with lists._

   - The type signature for list datatype is:
     ~foldr \colon{}\colon{} (a -> b -> b) -> b -> [] a -> b~
     or
     ~foldr \colon{}\colon{} (a -> b -> b) -> b -> [a] -> b~

   - ~map~ applies a function to each member of a list and returns a list,

     /fold/ _replaces_ the cons constructors _with_ the function and reduces the
     list.

** DONE 10.3 Recursive patterns
   CLOSED: [2017-06-01 Thu 19:19]
   - /fold/ pattern can be abstracted from functions like:
     + ~sum~
     + ~length~
     + ~product~
     + ~concat~
     They have similar base case: it has value of the identity for that funciton:
     ~0~, ~0~, ~1~, and ~[]~

** DONE 10.4 Fold right =IMPORTANT= =RE-READ=
   CLOSED: [2017-06-01 Thu 22:02]
   - _Fold right_ means the fold is _right associative_.
     #+BEGIN_SRC haskell
       foldr :: (a -> b -> c) -> b -> [a] -> b
       foldr f z [] = z
       foldr f z (x:xs) = f x (foldr f z xs)
     #+END_SRC
     Here ~z~ is the _zero_ of our fold, and
     it provides
     + a fallback value for the empty list case
       and
     + a second argument to begin our fold with.

*** TODO How ~foldr~ evaluates
    - A trick popularized by some helpful users in the Haskell IRC community:
      #+BEGIN_SRC haskell
        -- Prelude> let xs = map show [1..5]
        -- Prelude> :{
        -- *Prelude| foldr (\x y -> concat ["(",x,"+",y,")"])
        -- *Prelude| "0" xs
        -- *Prelude| :}
        -- "(1+(2+(3+(4+(5+0)))))"
      #+END_SRC
      =IMPORTANT=

    - One initially non-obvious aspect of folding is that it happens in two
      stages:
      + traversal: recurse over the spine.
        and
      + folding: evaluation or reduction of the folding function applied to the
        values.

    - Look at part of the definition of ~foldr~:
      ~foldr f z (x:xs) = f x (foldr f z xs)~
      if ~f~ doesn't evaluate its second argument (rest of the /fold/),
      _since Haskell is lazy in default this can happen often_,
      no more of the /spine/ will be forced.
        One of the consequences of this is that ~foldr~ can _avoid_ evaluating
      + not just some or all of the values in the list,
      + but some or all of the list's /spine/ as well!

      For this reason, ~foldr~ can be used with lists that are potentially
      infinite (though sometimes it can only reach the /bottom/). For example:
      #+BEGIN_SRC haskell
        myAny :: (a -> Bool) -> [a] -> Bool
        myAny f xs =
          foldr (\x b -> f x || b) False xs

        -- Prelude> myany even [1..]
        -- True

        -- Prelude> myAny even (repeat 1)
        -- -- NEVER-ENDING
      #+END_SRC

    - More examples: =IMPORTANT=
      #+BEGIN_SRC haskell
        -- Prelude> let u = undefined

        -- #1
        -- -- here, we give an undefined value
        -- Prelude> foldr (+) 0 [1, 2, 3, 4, u]
        -- *** Exception: Prelude.undefined

        -- #2
        -- Prelude> foldr (+) 0 (take 4 [1, 2, 3, 4, u])
        -- 10

        -- #3
        -- -- here, the undefined is part of the spine
        -- Prelude> foldr (+) 0 ([1, 2, 3, 4] ++ u)
        -- *** Exception: Prelude.undefined

        -- #4
        -- Prelude> foldr (+) 0 (take 4 ([1, 2, 3, 4] ++ u))
        -- 10
      #+END_SRC
      1. For #1, this expression _requires_ the evaluation of ~u~, which is
         ~undefined~.
         This run into /bottom/.

      2. For #2, this expression _DOESN'T require_ the evaluation of ~u~.

      3. For #3, here ~u~ is a part of the spine.

         Here the evaluation of ~u~ is required. _However_, even if the
         evaluation DOESN'T required, since ~u~ is part of the spine, the
         _Exception_ will be thrown out.

      4. For #4, even if ~u~ is a part of the spine, with ~take~, this part of
         spine won't be visited, and no _Exception_.

    - Sometimes, the spines will be evaluated _unconditionally_, but not the
      values:
      #+BEGIN_SRC haskell
        -- Prelude> length [1, 2, 3, 4, undefined]
        -- 5

        -- Prelude> length ([1, 2, 3, 4] ++ undefined)
        -- *** Exception: Prelude.undefined
      #+END_SRC
      However, we can still drop this part of spine (as in the last example #4):
      #+BEGIN_SRC haskell
        -- Prelude> length (take 4 ([1, 2, 3, 4] ++ undefined))
        -- 4
      #+END_SRC

    - ~take~ is non-strict like everything else you've seen so far, and in this
      case, it only returns as much list as you ask for. The difference, in what
      it does, is that it stops returning elements of the list it was given when
      it hits the length limit you gave it. Consider this:
      #+BEGIN_SRC haskell
        -- Prelude> length $ take 2 $ take 4 ([1, 2]++undefined)
        -- 2
      #+END_SRC
      It doesn't matter that ~take 4~ could've hit the /bottom/!
      Nothing forced it to because of the ~take 2~ between it and length.

      =TODO= DETAILS =???=

    - Focus on one part of the definition
      ~foldr f z (x:xs) = f x (foldr f z xs)~,
      and you can see the pattern matching of ~x~. We know
      /pattern matching/ is _strict by default_.

      This means ~foldr~ must force the initial cons cell in order to
      discriminate between the ~[]~ (the base case) and the ~(x : xs)~,
      _so the first cons cell CANNOT be_ ~undefined~.

      For example,
      Here, ~foldr~ will never force evaluation of any of its arguments, so we
      can have a /bottom/
      + as a value
        or
      + as part of the /spine/,
      and it will not force an evaluation:
      #+BEGIN_SRC haskell
        -- Prelude> foldr (\_ _ -> 9001) 0 [1..5]
        -- 9001

        -- Prelude> foldr (\_ _ -> 9001) 0 [1, 2, 3, undefined]
        -- 9001

        -- Prelude> foldr (\_ _ -> 9001) 0 ([1, 2, 3] ++ undefined)
        -- 9001
      #+END_SRC

      Everyting is fine unless the first piece of the /spine/ in /bottom/:
      #+BEGIN_SRC haskell
        -- #1
        -- Prelude> foldr (\_ _ -> 9001) 0 undefined
        -- *** Exception: Prelude.undefined

        -- #2
        -- Prelude> foldr (\_ _ -> 9001) 0 [1, undefined]
        -- 9001

        -- #3
        -- Prelude> foldr (\_ _ -> 9001) 0 [undefined, undefined]
        -- 9001
      #+END_SRC
      #2 and #3 work well because the cons cells contain /bottom/ values
      but are not themselves bottom.
      =IMPORTANT=

      #1 throws _Exception_ because ~undefined~ of it is the cons cell itself.

    - Traversing the rest of the /spine/ _doesn't_ occur
      unless the function asks for the results of having folded the rest of the
      list.

      In the following examples, we don't force traversal of the /spine/ because
      ~const~ just throws away its second argument,
      _which is the rest of the fold_:
      #+BEGIN_SRC haskell
        -- reminder:
        -- const :: a -> b -> a
        -- const x _ = x

        -- Prelude> const 1 2
        -- 1

        -- Prelude> const 2 1
        -- 2

        -- Prelude> foldr const 0 [1..5]
        -- 1

        -- Prelude> foldr const 0 [1, undefined]
        -- 1

        -- Prelude> foldr const 0 ([1, 2] ++ undefined)
        -- 1

        -- Prelude> foldr const 0 [undefined, 2]
        -- *** Exception: Prelude.undefined
      #+END_SRC

** TODO 10.5 Fold left
   The definition of ~foldl~:
   #+BEGIN_SRC haskell
     foldl :: Foldable t => (b -> a -> b) -> b -> [a] -> b
     foldl f acc [] = acc
     foldl f acc (x:xs) = foldl f (f acc x) xs

     -- Given the list
     foldl (+) 0 (1 : 2 : 3 : [])

     -- foldl associates like so
     ((0 + 1) + 2) + 3
   #+END_SRC

   - _Left folds_ traverse the /spine/ _in the same direction_ as right folds.

     BUT their folding process is left associative and proceeds in the opposite
     direction as that of ~foldr~.

   - Check the associativity of ~foldl~:
     #+BEGIN_SRC haskell
       -- Prelude> let f = (\x y -> concat ["(", x, "+", y, ")"])

       -- Prelude> foldl f "0" (map show [1..5])
       "(((((0+1)+2)+3)+4)+5)"
     #+END_SRC

   - =From Jian= Due to the associativity, if a right associative operator is
     used, ~flip~ is required.
     For example,
     #+BEGIN_SRC haskell
       myReverse :: [a] -> [a]
       myReverse = foldl (flip (:)) []
     #+END_SRC


   - _scans_ are similar to _folds_ but return a list of all the itermediate
     stages of the fold.
     #+BEGIN_SRC haskell
     -- Prelude> scanr (+) 0 [1..5]
     -- [15, 14, 12, 9, 5, 0]

     -- Prelude> scanl (+) 0 [1..5]
     -- [0, 1, 3, 6, 10, 15]
     #+END_SRC

   - The relationship between the _scans_ and _folds_ are as follows:
     + ~head (scanr f z xs)~ = ~foldr f z xs~
     + ~last (scanl f z xs)~ = ~foldl f z xs~

*** DONE Associativity and folding
    CLOSED: [2017-06-03 Sat 22:47]
    - The fundamental way to think about evaluation in Haskell is as
      substitution:
      + _right fold_ on a list with the function ~f~ and start value ~z~
        * replacing the cons constructors with our folding function
          and
        * the empty list constructor with our start value ~z~:

      + _left fold_ on a list with the function ~f~ and start value ~z~
        =FROM JIAN=
        * replacing the cons constructors with our folding function
          and
        * the first list constructor with our start value ~z~:

    - /Lazy evaluation/ lets our functions, rather than the ambient semantics of
      the language, dictate what order things get evaluated in.
      #+BEGIN_SRC haskell
        foldr f z [1, 2, 3]
        -- 1 `f` (foldr f z [2, 3])
        -- 1 `f` (2 `f` (foldr f z [3]))
        -- 1 `f` (2 `f` (3 `f` (foldr f z [])))
        -- 1 `f` (2 `f` (3 `f` z))
      #+END_SRC

      ~3 `f` z~ pairing gets evaluated first because it’s in the innermost
      parentheses.

        Right folds have to traverse the list outside-in, but the folding itself
      starts from the end of the list.

    - The effect of associativity on argument order by folding the list into a
      new list.
      #+BEGIN_SRC haskell
        foldr (:) [] [1..3]
        -- [1,2,3]

        foldl (flip (:)) [] [1..3]
        -- [3,2,1]
      #+END_SRC

    - Compare the types of ~foldr~ and ~foldl~:
      + ~foldr \colon\colon Foldable t => (a -> b -> b) -> b -> t a -> b~
      + ~foldl \colon\colon Foldable t => (b -> a -> b) -> b -> t a -> b~
      Then from the type of right associative operators, such as
      ~(:) :: a -> [a] -> [a]~ which can also be written as ~a -> b -> b~, we
      know why, when the first argument of ~foldl~ is operators like ~(:)~, we
      need ~flip~.

    - The spine traversal happens in the same order in both the left and right
      folds for a list, because of the way lists are defined.

    - If your folding function is _NOT commutative_,
      a left fold can lead to a different result than a right fold of the same.

*** DONE Exercises: Understanding Folds
    CLOSED: [2017-06-04 Sun 00:33]
    1. b) and c)

    2. =(3 * (2 * (1 * 1))=

    3. b) c) =TODO=  See next section

    4. a)

    5. Fix them:
       #+BEGIN_SRC haskell
         -- a)
         foldr (++) "" ["woot", "WOOT", "woot"]

         -- b)
         foldr max [] "fear is the little death"

         -- c)
         foldr (&&) True [False, True]

         -- d)
         -- It always returns `True`

         -- e)
         foldl (\x y -> x ++ show y) "" [1..5]

         -- f)
         foldr const 0 [1..5]

         -- g)
         foldr const 'a' "tacos"

         -- h)
         foldl (flip const) '0' "burritos"

         -- i)
         foldl (flip const) 0 [1..5]
       #+END_SRC

*** TODO Unconditional spine recursion
    - An important difference between ~foldr~ and ~foldl~:

      ~foldl~: has the successive steps of the fold as its first argument.
      The next recursion of the spine isn't intermediated by the folding function
      as it is in ~foldr~, which also means recursion of the spine is
      _unconditional_.
        This can be seen from the non-empty pattern matching part
      their definition:
      #+BEGIN_SRC haskell
        foldr f z (x:xs) = f x (foldr f z xs)

        foldl f z (x:xs) = foldl f (f z x) xs
      #+END_SRC
      It is clear that for ~foldr~, that
      =TODO= 

      #+BEGIN_SRC haskell
        -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        -- foldr
        -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

        foldr const 0 ([1..5] ++ undefined)
        -- 1

        foldr (flip const) 0 ([1..5] ++ undefined)
        -- *** Exception: Prelude.undefined

        foldl const 0 ([1..5] ++ undefined)
        -- *** Exception: Prelude.undefined

        foldl (flip const) 0 ([1..5] ++ undefined)
        -- *** Exception: Prelude.undefined


        -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        -- foldl
        -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
        foldl (\_ _ -> 5) 0 ([1..5] ++ undefined)
        -- *** Exception: Prelude.undefined

        -- COMMENT:
        -- -- error because bottom is part of the spine
        -- -- and foldl must evaluate the spine


        foldl (\_ _ -> 5) 0 ([1..5] ++ [undefined])
        -- 5

        -- COMMENT:
        -- this is OK because here bottom is a value
      #+END_SRC

** TODO 10.6 How to write fold functions
   - x
*** TODO Exercises: Database Processing
** TODO 10.7 Folding and evaluation
   - x
** TODO 10.8 Summary
   - x
*** ~foldr~
    1. 
    2. 
    3. 
    4. 
*** ~foldl~
    1. 
    2. 
    3. 
    4. 
** TODO 10.9 Scans
   - x
*** Getting the fibonacci number we want
*** Scans Exercises
** DONE 10.10 Chapter Exercises
   CLOSED: [2017-06-06 Tue 01:46]
*** DONE Warm-up and review
    CLOSED: [2017-06-06 Tue 01:44]
    #+BEGIN_SRC haskell
      -- 1
      stops = "pbtdkg"
      vowels = "aeiou"

      -- a)
      threeTuples :: String -> String -> [(Char, Char, Char)]
      threeTuples stops' vowels' =
        [(s, v, s') | s <- stops', v <- vowels', s' <- stops']

      -- b)
      threeTuplesWithStartP :: String -> String -> [(Char, Char, Char)]
      threeTuplesWithStartP stops' vowels' =
        [(s, v, s') | s <- stops', v <- vowels', s' <- stops', s == 'p']

      -- c)
      -- easy


      -- 2
      -- The average number of letters per word
      seekritFunc :: String -> Int
      seekritFunc x =
        div (sum $ map length wordList)
            (length wordList)
        where
          wordList = words x


      -- 3
      -- Can't rewrite with fractional division (/) directly,
      -- because 'length' returns a 'Int' value, and 'Int' isn't an instance of
      -- the typeclass 'Fractional', which is required by (/)
    #+END_SRC
*** TODO Rewriting functions using folds
    #+BEGIN_SRC haskell
      -- 1
      myOr :: [Bool] -> Bool
      myOr = foldr (||) False


      -- 2 -- avoid using 'map'
      myAny :: (a -> Bool) -> [a] -> Bool
      myAny f = foldr g False
        where
          g x y = f x || y


      -- 3 -- avoid using 'map'
      myElem :: Eq a => a -> [a] -> Bool
      myElem e = foldr g False
        where
          g x y = (e==x) || y

      myElem' :: Eq a => a -> [a] -> Bool
      myElem' e = any (e==)


      -- 4
      myReverse :: [a] -> [a]
      myReverse = foldl (flip (:)) []


      -- 5
      myMap :: (a -> b) -> [a] -> [b]
      myMap f = foldr (\x y -> f x : y) []


      -- 6
      myFilter :: (a -> Bool) -> [a] -> [a]
      myFilter f = foldr g []
        where
          g x y
            | f x = x : y
            | otherwise = y


      -- 7
      squish :: [[a]] -> [a]
      squish = foldr (++) []


      -- 8
      squishMap :: (a -> [b]) -> [a] -> [b]
      squishMap f = foldr (\x y -> f x ++ y) []


      -- 9
      squishAgain :: [[a]] -> [a]
      squishAgain = squishMap id


      -- 10
      -- TODO: can't be point-free.
      myMaximumBy :: (a -> a -> Ordering) -> [a] -> a
      myMaximumBy comp xs = foldr g (head xs) xs
        where
          g x y = case comp x y of
            GT -> x
            otherwise -> y


      -- 11
      -- TODO: can't be point-free.
      myMinimumBy :: (a -> a -> Ordering) -> [a] -> a
      myMinimumBy comp xs = foldr g (head xs) xs
        where
          g x y = case comp x y of
            LT -> x
            otherwise -> y
    #+END_SRC

** DONE 10.11 Definitions
   CLOSED: [2017-06-06 Tue 12:36]
   1. /Fold/: a group of higher-order functions which, given
      + a function to accumulate the results
        and
      + a recursive data structure,
      returns the built up value.

      The term /fold/ is typically used with reference to collections of values
      referenced by a recursive datatype.
        /catamorphism/ is a generalization of "breaking down structure".

   2. /Catamorphism/: a generalization of folds to arbitrary datatypes.

      Where a /fold/ allows you to break down a foldable data structure into an
      arbitrary datatype,
      a /catamorphism/ is a means of breaking down the structure of any datatype.

      For example,
      + ~bool \colon{}\colon{} a -> a -> Bool -> a~ from ~Data.Bool~ is an example of a simple
        catamorphism for simple, non-collection datatype.

      + ~maybe \colon{}\colon{} b -> (a -> b) -> Maybe a -> b~ is the catamorphism for ~Maybe~.

   3. /tail call/: the final result of a function.
      For example,
      #+BEGIN_SRC haskell
        f x y z = h (subFunction x y z)
          where subFunction x y z = g x y z

        -- the /tail call/ is ``h (subFunction x y z)''
        -- or more precisely, ``h''.
      #+END_SRC

   4. /Tail recursion/: a function whose tail calls are recursive invocations of
      itself.

** TODO 10.12 Follow-up resources
   1. 
   2. 
   3. 
   4. 
* TODO 11 Algebraic datatypes  ------- Page 381-452
** DONE 11.1 Algebraic datatypes
   CLOSED: [2017-06-05 Mon 13:40]
   - A type can be thought of as an enumeration of constructors that have zero or
     more arguments.

   - Haskell offers:
     + sum types
     + product types
     + product types with record syntax =TODO=
     + type alias
     + a special datatype called a ~newtype~ that offers a different set of
       options and constraints from either type synonyms or data declarations.

   - This chapter will:
     + explain the "algebra" of algebraic datatypes;
     + analyze the construction of data constructors;
     + spell out when and how to write your own datatypes;
     + clarify usage of type synonyms and ~newtype~;
     + introduce kinds.

** DONE 11.2 Data declarations review
   CLOSED: [2017-06-05 Mon 13:56]
   - Q: Why we always want to create custom datatypes?
     A: For structuring and describing the data we are processing.

     Doing so can
     + help you analyze your problem by allowing you to
       focus first on how you _model_ the domain
       _before_
       you begin thinking about how you write computations that solve your
       problem.

     + make your code easier to read and use
       because it lays the domain model out clearly.

   - Synonyms: /data declartion/ and /a declaration of a datatype/.

   - /nullary/ constructor: a no arguments constructor

   - /sum type/

   - /product type/

** DONE 11.3 Data and type constructors
   CLOSED: [2017-06-06 Tue 18:48]
   - There are two kinds of constructors in Haskell:
     + type constructors, which is used only
       * at the type level
       * in type signatures
       * typeclass declarations and instances.

       Types are static and resolve at compile time.

     + data constructors, which constructs the values at term level, values you
       can interact with at runtime.

   - /constants/: Type and data constructors that take no arguments.
     /constructurs/: ... the other constructors.

   - When a constructor (in general meaning) takes an argument, then it's _like a
     function_ in at least one sense – it must be applied to become a concrete
     type or value.

   - /nullary/: The Haskell Report calls /nullary/ as /type constants/ to
     distinguish them from type constructors that take arguments.

   - synonyms: /value space/, /term space/, and /runtime space/.

   - =TODO= type-level functions exist but are not covered in this book.
     See the foot note of this page 385!

   - Again, (in narrow sense) /constructor/ doesn't behave like a term level
     function in the sense of performing an operation on data.
     It's more like a box to put values into.

     The former means to process data and generate new data.
     The latter means to wrap something.
     In general sense, 

   - =TODO= Be careful with the box/container analogy as it will betray you later
     – not all type arguments to constructors have value-level witnesses!
     Some are /phantom/. We will cover this in a later chapter.

** DONE 11.4 Type constructors and kinds
   CLOSED: [2017-06-06 Tue 18:53]
   - /kind/

   - ~:kind~ or ~:k~: query the kind signature of a type constructor (NOT a data
     constructor) in GHCi.

   - A /kind/ signature ~*~ means the tested type constructor is a /type constant/;

     A /kind/ signature arrow(s) (like ~* -> *~) means the tested type
     constructor is a /type constructor/.

** DONE 11.5 Data constructors and values
   CLOSED: [2017-06-06 Tue 19:24]
   - As metioned the Haskell Report draws a distinction between
     /(type) constants/ and /(type) constructors/.
       We can draw a similar distinction between
     + data constructors
       and
     + constant values.

   - /phanton/: =TODO= later
     For example, here the type argument ~a~ is /phantom/.
     #+BEGIN_SRC haskell
       data HuskyType a = HuskyData
     #+END_SRC

   - /Data constructor/ can have the same name as its /type constructor/.

   - A simple but comprehensive example:
     #+BEGIN_SRC haskell
       data Doggies a =
           Husky a
         | Mastiff a
         deriving (Eq, Show)

       -- Prelude> :k Doggies
       -- Doggies :: * -> *
       -- this needs to be applied to become a
       -- concrete type

       -- Prelude> :t Husky
       -- Husky :: a -> Doggies a
       -- this needs to be applied to become a
       -- concrete value
     #+END_SRC

*** DONE Exercises: Dog Types
    CLOSED: [2017-06-06 Tue 19:24]
    1. A: a type constructor
    2. A: ~* -> *~
    3. A: ~*~
    4. A: ~Num a => Doggies a~
    5. A: ~Doggies Integer~
    6. A: ~Doggies String~
    7. A: It depends where it is: it's a type constructor in type-level, and it's
       a data constructor in term-level.
    8. A: ~a -> DogueDeBordeaux a~
    9. A: ~DogueDeBordeaux String~

** TODO 11.6 What's a type and what's data?
*** TODO Exercises: Vehicles
** TODO 11.7 Data constructor arities
** TODO 11.8 What makes these datatypes algebraic?
*** TODO Exercises: Cardinality
*** TODO Simple datatypes with nullary data constructors
*** TODO Exercises: For Example
*** TODO Unary constructors
** TODO 11.9 newtype
*** TODO Exercises: Logic Goats
** TODO 11.10 Sum types
*** TODO Exercises: Pity the Bool
** TODO 11.11 Product types
*** TODO Record syntax
** TODO 11.12 Normal form
*** TODO Exercises: How Does Your Garden Grow?
** TODO 11.13 Constructing and deconstructing values
*** TODO Sum and Product
*** TODO Constructing values
*** TODO Exercise: Programmers
*** TODO Accidental bottoms from records
*** TODO Deconstructing values
*** TODO Accidental bottoms from records
** TODO 11.14 Function type is exponential
*** TODO Exponentiation in what order?
*** TODO Exercises: The Quad
** TODO 11.15 Higher-kinded datatypes
** TODO 11.16 Lists are polymorphic
** TODO 11.17 Binary Tree
*** TODO Inserting into trees
*** TODO Write map for BinaryTree
*** TODO Convert binary trees to lists
*** TODO Write foldr for BinaryTree
** TODO 11.18 Chapter Exercises
*** TODO Multiple choice
    1. 
    2. 
    3. 
    4.
*** TODO Ciphers
*** TODO As-patterns
    1. 
    2. 
*** TODO Language exercises
    1. 
    2.
*** TODO Phone exercise
    1. 
    2. 
    3. 
    4. 
    5. 
*** TODO Hutton's Razor
    1. 
    2. 
** DONE 11.19 Definitions
   CLOSED: [2017-05-26 Fri 01:51]
   1. /datatype/: A (Haskell) datatype is made up of
      + a type constructor
        and

      + zero or more data constructors
        which each have zero or more arguments.

* TODO 12 Signaling adversity
** TODO 12.1 Signaling adversity
** TODO 12.2 How I learned to stop worrying and love Nothing
*** TODO Smart constructors for datatypes
** TODO 12.3 Bleating either
** TODO 12.4 Kinds, a thousand stars in your types
   - x
   - *Lifted and unlifted types*
*** Data constructors are functions
** TODO 12.5 Chapter Exercises
*** TODO Determine the kinds
    1. 
    2. 
*** TODO String processing
    1. 
    2. 
    3. 
*** TODO Validate the word
*** TODO It's only Natural
*** TODO Small library for ~Maybe~
    1. 
    2. 
    3. 
    4. 
    5. 
    6.
*** TODO Small library for ~Either~
    1. 
    2. 
    3. 
    4. 
    5. 
    6.
*** TODO Unfolds
*** TODO Why bother?
*** TODO Write your own iterate and unfoldr
    1. 
    2. 
    3.
*** TODO Finally something other than a list!
** TODO 12.6 Definitions
   1. /higher kinded type/: =TODO=

* 
* 
* TODO 13 Building projects
** TODO 13.1 Modules
  - In this chapter, we’ll cover:
    + writing Haskell programs with modules;
    + using the Cabal package manager;
    + building our project with Stack;
    + conventions around Haskell project organization;
    + building a small interactive game.

** TODO 13.2 Making packages with Stack
** TODO 13.3 Working with a basic project
*** TODO Building the project
*** TODO Loading and running code from the REPL
*** TODO =stack exec=
*** TODO Executable stanzas in Cabal files
** TODO 13.4 Making our project a library
** TODO 13.5 Module exports
*** TODO Exposing modules
** TODO 13.6 More on importing modules
*** TODO Qualified imports
*** TODO Intermission: Check your understanding
** TODO 13.7 Making our program interactive
   - *What if we tried to pass getLine to sayHello?*
*** TODO Adding a prompt
** TODO 13.8 do syntax and IO
*** TODO return
    - *Do notation considered harmful!*
** TODO 13.9 Hangman game
** TODO 13.10 Step One: Importing modules
** TODO 13.11 Step Two: Generating a word list
** TODO 13.12 Step Three: Making a puzzle
** TODO 13.13 Adding a ~newtype~
** TODO 13.14 Chapter exercises
*** TODO Hangman game logic
*** TODO Modifying code
** TODO 13.15 Follow-up resources
* TODO 14 Testing
** TODO 14.1 Testing
   - This chapter will cover:
     + the whats and whys of testing;
     + using the testing libraries Hspec and QuickCheck;
     + a bit of fun with Morse code.

** TODO 14.2 A quick tour of testing for the uninitated
** TODO 14.3 Conventional testing
*** TODO Truth according to ~Hspec~
*** TODO Our first ~Hspec~ test
*** TODO Intermission: Short Exercise
** TODO 14.4 Enter ~QuickCheck~
*** TODO Arbitrary instances
*** TODO Using ~QuickCheck~ without ~Hspec~
** TODO 14.5 Morse code
   - *Nota bene*
*** TODO Turning words into code
*** TODO The ~Main~ event
*** TODO Make sure it's all working
*** TODO Time to test!
*** TODO Testing the Morse code
** TODO 14.6 Kicking around QuickCheck
*** TODO Babby's First Arbitrary
*** TODO Identity Crisis
*** TODO Arbitrary Products
*** TODO Greater than the sum of its parts
*** TODO CoArbitrary
** TODO 14.7 Chapter Exercises
*** TODO Validating numbers into words
*** TODO Using QuickCheck
*** TODO Failure
*** TODO Idempotence
*** TODO Make a Gen random generator for the datatype
*** TODO Hangman testing
*** TODO Validating ciphers
** TODO 14.8 Definitions
   1. 
   2. 
   3.
** TODO 14.9 Follow-up resources
* TODO 15 Monoid, Semigroup
** TODO 15.1 Monoids and semigroups
   - =TODO=

   - This chapter will include:
     + Algebras!
     + Laws!
     + Monoids!
     + Semigroups!

** TODO 15.2 What we talk about when we talk about algebras
** TODO 15.3 Monoid
** TODO 15.4 How Monoid is defined in Haskell
** TODO 15.5 Examples of using Monoid
*** TODO List
** TODO 15.6 Why ~Integer~ doesn't have a Monoid
*** TODO Why ~newtype~?
    - *For veteran programmers that understand pointers*
    - *In summary, why you might use newtype*
*** TODO More on Sum and Product
** TODO 15.7 Why bother?
** TODO 15.8 Laws
** TODO 15.9 Different instance, same representation
** TODO 15.10 Reusing algebras by asking for algebras
*** TODO Exercise: Optional Monoid
*** TODO Associativity
*** TODO Identity
*** TODO The problem of orphan instances
** TODO 15.11 Madness
** TODO 15.12 Better living through QuickCheck
*** TODO Validating associativity with QuickCheck
*** TODO Quickchecking left and right identity
*** TODO Testing QuickCheck's patience
*** TODO Exercise: Maybe Another Monoid
** TODO 15.13 Semigroup
   - *Not yet part of base*
*** TODO NonEmpty, a useful datatype
*** TODO Strength can be weakness
** TODO 15.14 Chapter exercises
*** TODO Semigroup exercises
    - *Note*

    - xxx
      #+BEGIN_SRC haskell
      -- 1
      -- ...
      -- 13
      #+END_SRC

*** TODO Monoid exercises
    #+BEGIN_SRC haskell
      -- 1
      -- ...
      -- 8
    #+END_SRC

** TODO 15.15 Definitions
   1. /monoid/
   2. /semigroup/
   3. --
   4. /albegra/
** TODO 15.16 Follow-up resources
* TODO 16 Functor
** TODO 16.1 Functor
** TODO 16.2 What's a functor?
** TODO 16.3 There's a whole lot of fmap going round
** TODO 16.4 Let's talk about f, baby
*** TODO Shining star come into view
*** TODO Exercises: Be Kind
*** TODO A shining star for you to see
*** TODO Functor is function application
*** TODO A shining star for you to see what your f can truly be
*** TODO Typeclasses and constructor classes
** TODO 16.5 Functor Laws
*** TODO Identity
*** TODO Composition
*** TODO Structure preservation

** TODO 16.6 The Good, the Bad, and the Ugly
   - *The law won*
*** TODO Composition should just work
** TODO 16.7 Commonly used functors
*** TODO The functors are stacked and that's a fact
*** TODO What if we lift twice?
    - *Wait, how does that even typecheck?*
*** TODO Lift me baby one more time
*** TODO The real type of thing going down
*** TODO Get on up and get down
*** TODO One more round for the P-Funkshun
*** TODO Stay on the scene like an ~fmap~ machine
*** TODO Exercises: Heavy Lifting
** TODO 16.8 Transforming the unapplied type argument
** TODO 16.9 QuickChecking Functor instances
*** TODO Making QuickCheck generate functions too
** TODO 16.10 Exercises: Instances of Func
** TODO 16.11 Ignoring possibilities
*** TODO ~Maybe~
*** TODO Exercise: Possibly
*** TODO ~Either~
*** TODO Short Exercise
** TODO 16.12 A somewhat surprising functor
** TODO 16.13 More structure, more functors
** TODO 16.14 IO Functor
** TODO 16.15 What if we want to do something different?
** TODO 16.16 Functors are unique to a datatype
** TODO 16.17 Chapter exercises
   - x
     1. 
     2. 
     3. 
     4. 
     5. 

   - y
     1. 
     2. 
     3. 

   - z
     1. 
     2. 
     3. 
     4. 
     5. 
     6. 
     7. 
     8. 
     9. 
     10. 
     11. 

** TODO 16.18 Definitions
   1. /Higher-kinded polymorphism/
   2. /Functor/
   3. /lifting/
   4. /George Clinton/

** TODO 16.19 Follow-up resources
* TODO 17 Applicative
** TODO 17.1 Applicative
** TODO 17.2 Defining Applicative
** TODO 17.3 Functor vs. Applicative
** TODO 17.4 Applicative functors are monoidal functors
*** TODO Show me the monoids
*** TODO Tuple Monoid and Applicative side by side
*** TODO Maybe Monoid and Applicative
** TODO 17.5 Applicative in use
*** TODO List Applicative
**** TODO What's the List applicative do?
**** TODO Exercises: Lookups
*** TODO Identity
**** TODO Specializing the types
**** TODO Exercise: Identity Instance
*** TODO Constant
**** TODO Specializing the types
**** TODO Exercise: Constant Instance
*** TODO ~Maybe~ Applicative
**** Specializing the types
**** Using the ~Maybe~ Applicative
**** Breaking down the example we just saw
**** ~Maybe~ Functor and the Name constructor
**** ~Maybe~ Applicative and Person
**** Before we moooove on
**** Exercise: Fixer Upper

** TODO 17.6 Applicative laws
** TODO 17.7 You knew this was coming
** TODO 17.8 ZipList Monoid
*** TODO Zero vs. Identity
*** TODO List Applicative Exercise
*** TODO ZipList Applicative Exercise
    - *Explaining and justifying the weird EqProp*
*** TODO Either and Validation Applicative
**** TODO Specializing the types
**** TODO ~Either~ versus Validation
**** TODO Exercise: Variations on ~Either~
** TODO 17.9 Chapter Exercises
*** TODO Combinations
** TODO 17.10 Definitions
   1. ~Applicative~: =TODO=
** TODO 17.11 Follow-up resources
* TODO 18 Monad
** TODO 18.1 Monad
** TODO 18.2 Sorry -- Monad is not a burrito
*** TODO Applicative m
*** TODO Core operations
*** TODO The novel part of Monad
    - *The answer is the exercise*
*** TODO What Monad is not
*** TODO Monad also lifts!
** TODO 18.3 Do syntax and monads
*** TODO When fmap alone isn't enough
** TODO 18.4 Examples of Monad use
*** TODO List
**** TODO Specializing the types
**** TODO Example of the List Monad in use
*** TODO ~Maybe~
**** TODO Specializing the types
**** TODO Using the Maybe Monad
**** TODO Exploding a spherical cow
**** TODO Fail fast, like an overfunded startup
*** TODO ~Either~
**** TODO Specializing the types
**** TODO Using the Either Monad
**** TODO Short Exercise: Either Monad
** TODO 18.5 Monad laws
*** Identity laws
*** Associativity
*** We're doing that thing again
*** Bad Monads and their denizens
** TODO 18.6 Application and composition
** TODO 18.7 Chapter Exercises
   - =TODO=
     1. 
     2. 
     3. 
     4. 

   - =TODO=
     1. 
     2. 
     3. 
     4. 
     5. 
     6. 

** TODO 18.8 Definition
   1. 
   2. 
   3. 
** TODO 18.9 Follow-up resources
* TODO 19 Applying structure
** TODO 19.1 Applied structure
** TODO 19.2 Monoid
*** TODO Templating content in Scotty
*** TODO Concatenating connection parameters
*** TODO Concatenating key configurations
** TODO 19.3 Functor
*** TODO Lifting over ~IO~
*** TODO Lifting over web app monads
** TODO 19.4 Applicative
*** TODO hgrev
*** TODO More parsing
*** TODO And now for something different
** TODO 19.5 Monad
*** TODO Opening a network socket
*** TODO Binding over failure in initialization
** TODO 19.6 An end-to-end example: URL shortener
*** TODO Brief aside about polymorphic literals
*** TODO Back to the show
*** TODO Exercise
** TODO 19.7 That's a wrap!
** TODO 19.8 Follow-up resources
   1. =TODO=

* TODO 20 Foldable
** TODO 20.1 Foldable
** TODO 20.2 The Foldable class
** TODO 20.3 Revenge of the monoids
*** And now for something different
** TODO 20.4 Demonstrating Foldable instances
*** ~Identity~
*** ~Maybe~
** TODO 20.5 Some basic derived operations
*** Exercises: Library Functions
** TODO 20.6 Chapter Exercises
   1. 
   2. 
   3. 
   4. 
   5. 
** TODO 20.7 Follow-up resources
* TODO 21 ~Traversable~
** TODO 21.1 ~Traversable~
** TODO 21.2 The ~Traversable~ typeclass definition
** TODO 21.3 ~sequenceA~
** TODO 21.4 ~traverse~
*** ~mapM~ is just ~traverse~
** TODO 21.5 So, what's traversable for?
** TODO 21.6 Morse code revisited
** TODO 21.7 Axing tedious code
** TODO 21.8 Do all the things
*** Strength for understanding
** TODO 21.9 Traversable instances
*** ~Either~
*** ~Tuple~
** TODO 21.10 Traversable Laws
** TODO 21.11 Quality Control
** TODO 21.12 Chapter Exercises
*** TODO Traversable instances
*** TODO Identity
**** Constant
**** Maybe
**** List
**** Three
**** Three'
**** S
*** TODO Instances for Tree
** TODO 21.13 Follow-up resources
* TODO 22 Reader
** TODO 22.1 Reader
** TODO 22.2 A new beginning
*** TODO Short Exercise: Warming Up
** TODO 22.3 This is Reader
** TODO 22.4 Breaking down the ~Functor~ of functions
** TODO 22.5 But uh, ~Reader~?
*** TODO Exercise: Ask
** TODO 22.6 Functions have an ~Applicative~ too
*** TODO Demonstrating the function applicative
*** TODO Exercise: Reading Comprehension
** TODO 22.7 The Monad of functions
*** TODO The ~Monad~ instance
*** TODO Example uses of the Reader type
*** TODO Exercise: ~Reader~ ~Monad~
** TODO 22.8 Reader ~Monad~ by itself is kinda boring
** TODO 22.9 You can change what comes below, but not above
** TODO 22.10 You tend to see ~ReaderT~, not Reader
** TODO 22.11 Chapter Exercises
*** TODO A warm-up stretch
*** TODO Rewriting Shawty
** TODO 22.12 Follow-up resources

* TODO 23 State
** TODO 23.1 State
** TODO 23.2 What is state?
** TODO 23.3 Random numbers
** TODO 23.4 The State newtype
** TODO 23.5 Throw down
*** TODO Keep on rolling
*** TODO Exercises: Roll Your Own
** TODO 23.6 Write State for yourself
*** TODO State ~Functor~
*** TODO State ~Applicative~
*** TODO State ~Monad~
** TODO 23.7 Get a coding job with one weird trick
*** TODO Fizzbuzz Differently
** TODO 23.8 Chapter exercises
   1. 
   2. 
   3. 
   4. 
   5. 
** TODO 23.9 Follow-up resources
* TODO 24 Parser combinators
** TODO 24.1 Parser combinators
** TODO 24.2 A few more words of introduction
** TODO 24.3 Understanding the parsing process
*** TODO Since we didn't use an analogy for Monad
*** TODO What demonstration purposes?
*** TODO Back to the code
*** TODO A bit like...
*** TODO Back to our regularly scheduled coding
*** TODO Exercises: Parsing Practice
*** TODO Intermission: parsing free jazz
** TODO 24.4 Parsing fractions
*** TODO Exercise: Unit of Success
** TODO 24.5 Haskell's parsing ecosystem
*** TODO Typeclasses of Parsers
** TODO 24.6 Alternative
*** TODO ~QuasiQuotes~
*** TODO Return to Alternative
*** TODO Exercise: Try Try
** TODO 24.7 Parsing configuration files
** TODO 24.8 Character and token parsers
*** TODO Insert tokens to play
** TODO 24.9 Polymorphic parsers
*** TODO It's not perfect and could bite you
*** TODO Failure and backtracking
** TODO 24.10 Marshalling from an AST to a datatype
*** TODO Marshalling and unmarshalling JSON data
*** TODO Provided a strict ByteString when a lazy one was expected
*** TODO Provided a lazy ByteString when a strict one was expected
*** TODO Back to the...JSON
** TODO 24.11 Chapter Exercises
   1. 
   2. 
   3. 
   4. 
   5. 
   6. 
   7. 
   8. 
   9. 
   10.
** TODO 24.12 Definitions
   1. 
   2. 
   3. 
   4. 
   5. 
* TODO 25 Composing types
** TODO 25.1 Composing types
** TODO 25.2 Common functions as types
*** TODO ~Identity~ is boring
    - *A note about* ~newtypes~
*** TODO ~Compose~
** TODO 25.3 Two little functors sittin' in a tree, L-I-F-T-I-N-G
** TODO 25.4 Twinplicative
*** TODO GOTCHA! Exercise time
** TODO 25.5 Twonad?
*** TODO No free burrito lunches
** TODO 25.6 Exercises: Compose Instances
*** TODO ~Compose~ ~Foldable~
*** TODO ~Compose~ ~Traversable~
*** TODO And now for something completely different
** TODO 25.7 Monad transformers
*** TODO Monadic stacking
*** TODO Doing it badly
** TODO 25.8 ~IdentityT~
*** TODO The bind breakdown
*** TODO Implementing the bind, step by step
*** TODO The essential extra of Monad transformers
** TODO 25.9 Finding a pattern
* TODO 26 Monad transformers
** TODO 26.1 Monad transformers
** TODO 26.2 ~MaybeT~
*** TODO Spoiler alert!
*** TODO ~MaybeT~ Monad instance
** TODO 26.3 ~EitherT~
*** TODO Exercises: ~EitherT~
    1. 
    2. 
    3. 
    4. 
    5. 
** TODO 26.4 ~ReaderT~
** TODO 26.5 ~StateT~
*** TODO Exercises: ~StateT~
    1. 
    2. 
    3. 
*** TODO ~ReaderT~, ~WriterT~, ~StateT~
*** TODO Correspondence between ~StateT~ and Parser
** TODO 26.6 Types you probably don't want to use
*** TODO Why not use Writer or ~WriterT~?
*** TODO The ~ListT~ you want isn't made from the List type
** TODO 26.7 Recovering an ordinary type from a transformer
** TODO 26.8 Lexically inner is structurally outer
*** TODO Exercise: Wrap It Up
** TODO 26.9 ~MonadTrans~
*** TODO The typeclass that lifts
*** TODO Motivating ~MonadTrans~
*** TODO ~MonadTrans~ instances
*** TODO Exercises: Lift More
    1. 
    2. 
*** TODO Prolific lifting is the failure mode
*** TODO Wrap it, smack it, pre-lift it
** TODO 26.10 ~MonadIO~ aka zoom-zoom
*** TODO Example ~MonadIO~ instances
*** TODO Exercises: Some Instances
** TODO 26.11 Monad transformers in use
*** TODO ~MaybeT~ in use
*** TODO Temporary extension of structure
*** TODO ~ExceptT~ aka ~EitherT~ in use
*** TODO Scotty, again
*** TODO Slightly more advanced code
** TODO 26.12 Monads do not commute
*** TODO Hypothetical Exercise
** TODO 26.13 Transform if you want to
** TODO 26.14 Chapter Exercises
*** TODO Write the code
    1. 
    2. 
    3. 
    4. 
    5. 
    6.
*** TODO Fix the code
*** TODO Hit counter
*** TODO Morra
    1. 
    2. 
    3. 
    4. 
** TODO 26.15 Follow-up resources
* TODO 27 Non-strictness
** TODO 27.1 Laziness
** TODO 27.2 Observational Bottom Theory
*** TODO Standards and obligations
** TODO 27.3 Outside in, inside out
** TODO 27.4 What does the other way look like?
*** TODO Can we make Haskell strict?
*** TODO ~seq~ and ye shall find
*** TODO ~seq~ and weak head normal form
*** TODO Case matching also chains evaluation
*** TODO Core Dump
*** TODO A little bit stricter now
*** TODO Exercises: Evaluate
    1. 
    2. 
    3. 
    4. 
    5. 
    6. 
    7. 
** TODO 27.5 Call by name, call by need
** TODO 27.6 Non-strict evaluation changes what we can do
** TODO 27.7 Thunk Life
*** TODO Not all values get thunked
** TODO 27.8 Sharing is caring
*** TODO Using trace to observe sharing
*** TODO What promotes sharing
*** TODO What subverts or prevents sharing
*** TODO Why polymorphic values never seem to get forced
*** TODO Preventing sharing on purpose
*** TODO Forcing sharing
** TODO 27.9 Refutable and irrefutable patterns
*** TODO Lazy patterns
** TODO 27.10 Bang-patterns
*** TODO Bang patterns in data
** TODO 27.11 Strict and StrictData
** TODO 27.12 Adding strictness
** TODO 27.13 Chapter Exercises
*** TODO Strict List
*** TODO What will ~:sprint~ output?
*** TODO Will printing this expression result in bottom?
*** TODO Make the expression bottom
** TODO 27.14 Follow-up resources

* TODO 28 Basic libraries
** TODO 28.1 Basic libraries and data structures
** TODO 28.2 Benchmarking with Criterion
*** TODO More on ~whnf~ and ~nf~
*** TODO Making the case for ~nf~
** TODO 28.3 Profiling your programs
*** TODO Profiling time usage
*** TODO Profiling heap usage
** TODO 28.4 Constant applicative forms
** TODO 28.5 ~Map~
*** TODO What's something that's faster with ~Map~?
*** TODO What's slower with ~Map~?
** TODO 28.6 ~Set~
*** TODO Exercise: Benchmark Practice
** TODO 28.7 Sequence
*** TODO What's faster with Sequence?
*** TODO What's slower with Sequence?
** TODO 28.8 Vector
*** TODO When does one want a ~Vector~ in Haskell?
*** TODO What's this about slicing?
*** TODO Updating vectors
*** TODO Mutable Vectors
*** TODO A sidebar on the ST Monad
*** TODO Exercises: ~Vector~
** TODO 28.9 String types
*** TODO String
*** TODO Text
*** TODO Don't trust your gut, measure
*** TODO ByteString
*** TODO ByteString examples
*** TODO ByteString traps
*** TODO When would I use ByteString instead of Text for textual data?
** TODO 28.10 Chapter Exercises
*** TODO Difference List
    1. 
    2. 
    3. 
    4. 
    5. 
    6. 
*** TODO A simple queue
** TODO 28.11 Follow-up resources
* TODO 29 ~IO~
** TODO 29.1 ~IO~
** TODO 29.2 Where ~IO~ explanations go astray
*** TODO Burn the State to the ground!
** TODO 29.3 The reason we need this type
*** TODO What?
*** TODO Order and chaos
** TODO 29.4 Sharing
*** TODO The time has come
*** TODO Another example
*** TODO The code! It doesn't work!
** TODO 29.5 ~IO~ doesn't disable sharing for everything
** TODO 29.6 Purity is losing meaning
*** TODO Semantically, pedantically accurate
*** TODO Referential transparency
** TODO 29.7 IO's Functor, Applicative, and Monad
*** TODO The ~IO~ Functor
*** TODO Applicative and ~IO~
*** TODO Monad and ~IO~
*** TODO Monadic associativity
** TODO 29.8 Well, then, how do we ~MVar~?
** TODO 29.9 Chapter Exercises
*** TODO File I/O with Vigenère
*** TODO Add timeouts to your utility
*** TODO Config directories
** TODO 29.10 Follow-up resources
* TODO 30 When things go wrong
** TODO 30.1 Exceptions
** TODO 30.2 The Exception class and methods
*** TODO But there is something different going on here
*** TODO A brief introduction to existential quantification
*** TODO So, wait, what?
*** TODO Typeable
** TODO 30.3 This machine kills programs
*** TODO Catch me if you can
** TODO 30.4 Want either? Try!
** TODO 30.5 The unbearable imprecision of trying
** TODO 30.6 Why ~throwIO~?
** TODO 30.7 Making our own exception types
*** TODO Adding context
*** TODO Catch one, catch all
** TODO 30.8 Surprising interaction with bottom
** TODO 30.9 Asynchronous Exceptions
*** TODO Don't panic!
** TODO 30.10 Follow-up Reading
* TODO 31 Final project
** TODO 31.1 Final project
** TODO 31.2 fingerd
*** TODO Caveat for the Windows users
** TODO 31.3 Exploring finger
*** TODO Project overview
*** =fingerd.cabal=
*** =src/Debug.hs=
** TODO 31.4 Slightly modernized fingerd
*** TODO Let your fingers do the walking
** TODO 31.5 Chapter Exercises
   1. 
   2. 
   3. 
   4. 
   5. 
* Tips
  - How to read GHC(i) error messages???

  - Page 73 (v0.12.0) 
    1. Define values at the top level of a module.
       If they are declared at the top level so that they are available
       throughout the module.

    2. We specify explicit types for top-level definitions.
       =GOOD HABIT=

  - Page 86 (v0.12.0) =TODO= =???=
    _UNLIKE in other languages_,
    datatypes in Haskell _by default_ do NOT delimit the operations that can be
    performed on that data.

  - Check the types of a partial function, which you haven't defined:
    #+BEGIN_SRC haskell
      -- Prelude> let f :: a -> a -> a -> a; f = undefined
      -- Prelude> let x :: Char; x = undefined
      -- Prelude> :t f x
      -- f x :: Char -> Char -> Char
    #+END_SRC

  - Since ~Real~ CANNOT override the methods of ~Num~,
      this typeclass inheritance is ONLY additive and the ambiguity problems
    caused by multiple inheritance in some programming languages -- the
    so-called "deadly diamond of death" -- are avoided.

  - ~:browse ModuleName~ can show you a list of the type signatures of
    functions we loaded from the module =ModuleName=.
