#+TITLE: The Formal Semantics of Programming Languages
#+SUBTITLE: An Introduction
#+AUTHOR: Glynn Winskel
#+STARTUP: overview
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[Series foreword][Series foreword]]
- [[Preface][Preface]]
  - [[How to use this book][How to use this book]]
  - [[Acknowledgements][Acknowledgements]]
- [[1 Basic set theory][1 Basic set theory]]
  - [[1.1 Logical notation][1.1 Logical notation]]
  - [[1.2 Sets][1.2 Sets]]
    - [[1.2.1 Sets and properties][1.2.1 Sets and properties]]
    - [[1.2.2 Some important sets][1.2.2 Some important sets]]
    - [[1.2.3 Constructions on sets][1.2.3 Constructions on sets]]
    - [[1.2.4 The axiom of foundation][1.2.4 The axiom of foundation]]
  - [[1.3 Relations and functions 6][1.3 Relations and functions 6]]
    - [[1.3.1 Lambda notation 7][1.3.1 Lambda notation 7]]
    - [[1.3.2 Composing relations and functions 7][1.3.2 Composing relations and functions 7]]
    - [[1.3.3 Direct and inverse image of a relation 9][1.3.3 Direct and inverse image of a relation 9]]
    - [[1.3.4 Equivalence relations 9][1.3.4 Equivalence relations 9]]
  - [[1.4 FUrther reading 10][1.4 FUrther reading 10]]
- [[2 Introduction to operational semantics 11][2 Introduction to operational semantics 11]]
  - [[2.1 IMP-a simple imperative language 11][2.1 IMP-a simple imperative language 11]]
  - [[2.2 The evaluation of arithmetic expressions 13][2.2 The evaluation of arithmetic expressions 13]]
  - [[2.3 The evaluation of boolean expressions 17][2.3 The evaluation of boolean expressions 17]]
  - [[2.4 The execution of commands 19][2.4 The execution of commands 19]]
  - [[2.5 A simple proof 20][2.5 A simple proof 20]]
  - [[2.6 Alternative semantics 24][2.6 Alternative semantics 24]]
  - [[2.7 FUrther reading 26][2.7 FUrther reading 26]]
- [[3 Some principles of induction 27][3 Some principles of induction 27]]
  - [[3.1 Mathematical induction 27][3.1 Mathematical induction 27]]
  - [[3.2 Structural induction 28][3.2 Structural induction 28]]
  - [[3.3 Well-founded induction 31][3.3 Well-founded induction 31]]
  - [[3.4 Induction on derivations 35][3.4 Induction on derivations 35]]
  - [[3.5 Definitions by induction 39][3.5 Definitions by induction 39]]
  - [[3.6 Further reading 40][3.6 Further reading 40]]
- [[4 Inductive definitions 41][4 Inductive definitions 41]]
  - [[4.1 Rule induction 41][4.1 Rule induction 41]]
  - [[4.2 Special rule induction 44][4.2 Special rule induction 44]]
  - [[4.3 Proof rules for operational semantics 45][4.3 Proof rules for operational semantics 45]]
    - [[4.3.1 Rule induction for arithmetic expressions 45][4.3.1 Rule induction for arithmetic expressions 45]]
    - [[4.3.2 Rule induction for boolean expressions 46][4.3.2 Rule induction for boolean expressions 46]]
    - [[4.3.3 Rule induction for commands 47][4.3.3 Rule induction for commands 47]]
  - [[4.4 Operators and their least fixed points 52][4.4 Operators and their least fixed points 52]]
  - [[4.5 Further reading 54][4.5 Further reading 54]]
- [[5 The denotational semantics of IMP 55][5 The denotational semantics of IMP 55]]
  - [[5.1 Motivation 55][5.1 Motivation 55]]
  - [[5.2 Denotational semantics 56][5.2 Denotational semantics 56]]
  - [[5.3 Equivalence of the semantics 61][5.3 Equivalence of the semantics 61]]
  - [[5.4 Complete partial orders and continuous functions 68][5.4 Complete partial orders and continuous functions 68]]
  - [[5.5 The Knaster-Tarski Theorem 74][5.5 The Knaster-Tarski Theorem 74]]
  - [[5.6 Further reading 75][5.6 Further reading 75]]
- [[6 The axiomatic semantics of IMP 77][6 The axiomatic semantics of IMP 77]]
  - [[6.1 The idea 77][6.1 The idea 77]]
  - [[6.2 The assertion language Assn 80][6.2 The assertion language Assn 80]]
    - [[6.2.1 Free and bound variables 81][6.2.1 Free and bound variables 81]]
    - [[6.2.2 Substitution 82][6.2.2 Substitution 82]]
  - [[6.3 Semantics of assertions 84][6.3 Semantics of assertions 84]]
  - [[6.4 Proof rules for partial correctness 89][6.4 Proof rules for partial correctness 89]]
  - [[6.5 Soundness 91][6.5 Soundness 91]]
  - [[6.6 Using the Hoare rules-an example 93][6.6 Using the Hoare rules-an example 93]]
  - [[6.7 Further reading 96][6.7 Further reading 96]]
- [[7 Completeness of the Hoare rules 99][7 Completeness of the Hoare rules 99]]
  - [[7.1 Codel's Incompleteness Theorem 99][7.1 Codel's Incompleteness Theorem 99]]
  - [[7.2 Weakest preconditions and expressiveness 100][7.2 Weakest preconditions and expressiveness 100]]
  - [[7.3 Proof of Codel's Theorem 110][7.3 Proof of Codel's Theorem 110]]
  - [[7.4 Verification conditions 112][7.4 Verification conditions 112]]
  - [[7.5 Predicate transformers 115][7.5 Predicate transformers 115]]
  - [[7.6 Further reading 117][7.6 Further reading 117]]
- [[8 Introduction to domain theory 119][8 Introduction to domain theory 119]]
  - [[8.1 Basic definitions 119][8.1 Basic definitions 119]]
  - [[8.2 Streams-an example 121][8.2 Streams-an example 121]]
  - [[8.3 Constructions on cpo's 123][8.3 Constructions on cpo's 123]]
    - [[8.3.1 Discrete cpo's 124][8.3.1 Discrete cpo's 124]]
    - [[8.3.2 Finite products 125][8.3.2 Finite products 125]]
    - [[8.3.3 Function space 128][8.3.3 Function space 128]]
    - [[8.3.4 Lifting 131][8.3.4 Lifting 131]]
    - [[8.3.5 Sums 133][8.3.5 Sums 133]]
  - [[8.4 A metalanguage 135][8.4 A metalanguage 135]]
  - [[8.5 Further reading 139][8.5 Further reading 139]]
- [[9 Recursion equations 141][9 Recursion equations 141]]
  - [[9.1 The language REC 141][9.1 The language REC 141]]
  - [[9.2 Operational semantics of call-by-value 143][9.2 Operational semantics of call-by-value 143]]
  - [[9.3 Denotational semantics of call-by-value 144][9.3 Denotational semantics of call-by-value 144]]
  - [[9.4 Equivalence of semantics for call-by-value 149][9.4 Equivalence of semantics for call-by-value 149]]
  - [[9.5 Operational semantics of call-by-name 153][9.5 Operational semantics of call-by-name 153]]
  - [[9.6 Denotational semantics of call-by-name 154][9.6 Denotational semantics of call-by-name 154]]
  - [[9.7 Equivalence of semantics for call-by-name 157][9.7 Equivalence of semantics for call-by-name 157]]
  - [[9.8 Local declarations 161][9.8 Local declarations 161]]
  - [[9.9 Further reading 162][9.9 Further reading 162]]
- [[10 Techniques for recursion 163][10 Techniques for recursion 163]]
  - [[10.1 BekiC's Theorem 163][10.1 BekiC's Theorem 163]]
  - [[10.2 Fixed-point induction 166][10.2 Fixed-point induction 166]]
  - [[10.3 Well-founded induction 174][10.3 Well-founded induction 174]]
  - [[10.4 Well-founded recursion 176][10.4 Well-founded recursion 176]]
  - [[10.5 An exercise 179][10.5 An exercise 179]]
  - [[10.6 Further reading 181][10.6 Further reading 181]]
- [[11 Languages with higher types 183][11 Languages with higher types 183]]
  - [[11.1 An eager language 183][11.1 An eager language 183]]
  - [[11.2 Eager operational semantics 186][11.2 Eager operational semantics 186]]
  - [[11.3 Eager denotational semantics 188][11.3 Eager denotational semantics 188]]
  - [[11.4 Agreement of eager semantics 190][11.4 Agreement of eager semantics 190]]
  - [[11.5 A lazy language 200][11.5 A lazy language 200]]
  - [[11.6 Lazy operational semantics 201][11.6 Lazy operational semantics 201]]
  - [[11.7 Lazy denotational semantics 203][11.7 Lazy denotational semantics 203]]
  - [[11.8 Agreement of lazy semantics 204][11.8 Agreement of lazy semantics 204]]
  - [[11.9 Fixed-point operators 209][11.9 Fixed-point operators 209]]
  - [[11.10 Observations and full abstraction 215][11.10 Observations and full abstraction 215]]
  - [[11.11 Sums 219][11.11 Sums 219]]
  - [[11.12 Further reading 221][11.12 Further reading 221]]
- [[12 Information systems 223][12 Information systems 223]]
  - [[12.1 Recursive types 223][12.1 Recursive types 223]]
  - [[12.2 Information systems 225][12.2 Information systems 225]]
  - [[12.3 Closed families and Scott predomains 228][12.3 Closed families and Scott predomains 228]]
  - [[12.4 A cpo of information systems 233][12.4 A cpo of information systems 233]]
  - [[12.5 Constructions 236][12.5 Constructions 236]]
    - [[12.5.1 Lifting 237][12.5.1 Lifting 237]]
    - [[12.5.2 Sums 239][12.5.2 Sums 239]]
    - [[12.5.3 Product 241][12.5.3 Product 241]]
    - [[12.5.4 Lifted function space 243][12.5.4 Lifted function space 243]]
  - [[12.6 Further reading 249][12.6 Further reading 249]]
- [[13 Recursive types 251][13 Recursive types 251]]
  - [[13.1 An eager language 251][13.1 An eager language 251]]
  - [[13.2 Eager operational semantics 255][13.2 Eager operational semantics 255]]
  - [[13.3 Eager denotational semantics 257][13.3 Eager denotational semantics 257]]
  - [[13.4 Adequacy of eager semantics 262][13.4 Adequacy of eager semantics 262]]
  - [[13.5 The eager A-calculus 267][13.5 The eager A-calculus 267]]
    - [[13.5.1 Equational theory 269][13.5.1 Equational theory 269]]
    - [[13.5.2 A fixed-point operator 272][13.5.2 A fixed-point operator 272]]
  - [[13.6 A lazy language 278][13.6 A lazy language 278]]
  - [[13.7 Lazy operational semantics 278][13.7 Lazy operational semantics 278]]
  - [[13.8 Lazy denotational semantics 281][13.8 Lazy denotational semantics 281]]
  - [[13.9 Adequacy of lazy semantics 288][13.9 Adequacy of lazy semantics 288]]
  - [[13.10 The lazy A-calculus 290][13.10 The lazy A-calculus 290]]
    - [[13.10.1 Equational theory 291][13.10.1 Equational theory 291]]
    - [[13.10.2 A fixed-point operator 292][13.10.2 A fixed-point operator 292]]
  - [[13.11 Further reading 295][13.11 Further reading 295]]
- [[14 Nondeterminism and parallelism 297][14 Nondeterminism and parallelism 297]]
  - [[14.1 Introduction 297][14.1 Introduction 297]]
  - [[14.2 Guarded commands 298][14.2 Guarded commands 298]]
  - [[14.3 Communicating processes 303][14.3 Communicating processes 303]]
  - [[14.4 Milner's CCS 308][14.4 Milner's CCS 308]]
  - [[14.5 Pure CCS 311][14.5 Pure CCS 311]]
  - [[14.6 A specification language 316][14.6 A specification language 316]]
  - [[14.7 The modal v-calculus 321][14.7 The modal v-calculus 321]]
  - [[14.8 Local model checking 327][14.8 Local model checking 327]]
  - [[14.9 Further reading 335][14.9 Further reading 335]]
- [[A Incompleteness and undecidability 337][A Incompleteness and undecidability 337]]
- [[Bibliography 353][Bibliography 353]]
- [[Index 357][Index 357]]

* Series foreword
* Preface
  - Give a formal semantics to a programming language
    <->
    build a mathematical model.

    + NOT ONLY useful for various kinds of _analysis_ and _verification_.

    + BUT ALSO (at a more fundamental level) define the meaning of program
      constructions precisely can reveal all kinds of subtleties of which it is
      important to be aware.

  - This book introduces the mathematics, techniques and concepts on which formal
    semantics rests.

  - For _historical reasons_,
    the semantics of programming languages is often viewed as consisting of
    _three_ strands (NOT in opposition to each other):

    + /Operational semantics/ :: describes the meaning of a programming language
         by specifying how it executes on an abstract machine.

      * We concentrate on the method advocated by Gordon Plotkin in his lectures
        at Aarhus on "structural operational semantics"
        in which _evaluation_ and _execution_ relations are specified by rules in
        a way directed by the syntax.

    + /Denotational semantics/ :: A technique for defining the meaning of
         programming languages
      * It is pioneered by Christopher Strachey and provided with a mathematical
        foundation by Dana Scott.

      * Old name: "mathematical semantics".

      * It uses the more abstract mathematical concepts of complete partial
        orders, continuous functions and least fixed points.

    + /Axiomatic semantics/ :: (tries to) fix the meaning of a programming
         contruct by giving proof rules for it within a program logic.

      * The chief names associated with this approach are that of R. W. Floyd and
        C. A. R. Hoare.

      * It emphasises proof of correctness right from the start.

  - There three strands of semantics each have their uses:
    + A clear /operational semantics/ is very HELPFUL in _implementation_.

    + A clear /axiomatic semantics/ for special kinds of languages can give
      strikingly elegant proof systems,
      USEFUL in _developing_ as well as _verifying_ programs.

    + A clear /denotational semantics/ provides the deepest and most widely
      applicable techniques, underpinned by a rich mathematical theory.

  - Indeed, the different styles of semantics are highly dependent on each other.
    (=Re-read= examples are in the page xv)

  - An aim of this book:
    show how operational and denotational semantics fit together.

  - PREREQUISITE: mathematical logic.
    However, this book doesn't suppose you have a good background in logic.

  - *Book description*
    + This book bases on lectures given at Cambridge and Aarhus Universities.

    + ......

** DONE How to use this book
   CLOSED: [2017-08-01 Tue 21:46]
   =TODO=

** DONE Acknowledgements
   CLOSED: [2017-08-01 Tue 21:37]
   
* 1 Basic set theory
  =from page 1=
  This chapter presents the *informal*, *logical* and *set-theoretic* notation
  and concepts we shall use to write down and reason about our ideas.

  + An extension of our everyday language, extended to talk about mathematical
    objects like sets;

** DONE 1.1 Logical notation
   CLOSED: [2017-08-02 Wed 02:03]
   =from page 1=
   - For statements (or assertions) A and B, we shall commonly use abbreviations
     like:
     + A & B (A and B) :: the conjunction of A and B.
     + A => B (A implies B) :: if A then B.
     + A <=> B (A iff B) :: A if and only if B (logic equivalence).

   - We should also form disjunctions (A or B).

   - Tradition: write 7 !< 5 rather than \not{}(7 < 5).

     We say "7 is not less than 5" rather than "not 7 is less than 5".

   - A statement like ~P(x, y)~, which involves variables ~x~, ~y~, is called a
     /predicate/ (or /property/, or /relation/, or /condition/).

   - \exist{} :: there exists.
                \exists{}x. P(x) - "for some x, P(x)" or "there exits x such that P(x)"

   - \forall :: for all
                \forall{}x. P(x) - "for all x, P(x)" or "for any x, P(x)"

   - Equivalent forms:
     + \exist{}x, y, ..., z. P(x, y, ..., z)
       \exist{}x \exist{}y ... \exist{}z. P(x, y, ..., z)

     + \forall{}x, y, ..., z. P(x, y, ..., z)
       \forall{}x \forall{}y ... \forall{}z. P(x, y, ..., z)

   - Write \exist{}x \in{} X. P(x) rather than \exist{}x, x \in{} X. P(x)
     Write \forall{}x \in{} X. P(x) rather than \forall{}x, x \in{} X. P(x)

   - It is traditional to write (x is the unique object satisfying P(x)).
     \exist{}!x. P(x)
     as an abbreviation for
     (\exist{}x. P(x)) & (\forall{}y,z. P(y) & P(z) => y = z)

** TODO 1.2 Sets
   =from page 2=
   \in{}, \sube{}, ...
*** TODO 1.2.1 Sets and properties
    =from page 3=
    - /Russell's paradox/

    - The solution of /Russell's paradox/ is to discipline the way in which sets
      are constructed, so that starting from certain given sets, new sets can
      only be formed when they are constructed by using particular, safe ways
      from old sets.

    - =NO Details= for the solution above. In this book just use the right
      choices, and the author helped us to avoid the ones lead to
      /Russell's paradox/.

      =TODO= Should read the other books by myself.

*** TODO 1.2.2 Some important sets
    =from page 3=
    - 
*** TODO 1.2.3 Constructions on sets
    =from page 4=
    - x
*** TODO 1.2.4 The axiom of foundation
    =from page 6=
    - x
** TODO 1.3 Relations and functions 6
*** 1.3.1 Lambda notation 7
*** 1.3.2 Composing relations and functions 7
*** 1.3.3 Direct and inverse image of a relation 9
*** 1.3.4 Equivalence relations 9
** TODO 1.4 FUrther reading 10

* 2 Introduction to operational semantics 11
** 2.1 IMP-a simple imperative language 11
** 2.2 The evaluation of arithmetic expressions 13
** 2.3 The evaluation of boolean expressions 17
** 2.4 The execution of commands 19
** 2.5 A simple proof 20
** 2.6 Alternative semantics 24
** 2.7 FUrther reading 26

* 3 Some principles of induction 27
** 3.1 Mathematical induction 27
** 3.2 Structural induction 28
** 3.3 Well-founded induction 31
** 3.4 Induction on derivations 35
** 3.5 Definitions by induction 39
** 3.6 Further reading 40

* 4 Inductive definitions 41
** 4.1 Rule induction 41
** 4.2 Special rule induction 44
** 4.3 Proof rules for operational semantics 45
*** 4.3.1 Rule induction for arithmetic expressions 45
*** 4.3.2 Rule induction for boolean expressions 46
*** 4.3.3 Rule induction for commands 47
** 4.4 Operators and their least fixed points 52
** 4.5 Further reading 54

* 5 The denotational semantics of IMP 55
** 5.1 Motivation 55
** 5.2 Denotational semantics 56
** 5.3 Equivalence of the semantics 61
** 5.4 Complete partial orders and continuous functions 68
** 5.5 The Knaster-Tarski Theorem 74
** 5.6 Further reading 75

* 6 The axiomatic semantics of IMP 77
** 6.1 The idea 77
** 6.2 The assertion language Assn 80
*** 6.2.1 Free and bound variables 81
*** 6.2.2 Substitution 82
** 6.3 Semantics of assertions 84
** 6.4 Proof rules for partial correctness 89
** 6.5 Soundness 91
** 6.6 Using the Hoare rules-an example 93
** 6.7 Further reading 96
* 7 Completeness of the Hoare rules 99
** 7.1 Codel's Incompleteness Theorem 99
** 7.2 Weakest preconditions and expressiveness 100
** 7.3 Proof of Codel's Theorem 110
** 7.4 Verification conditions 112
** 7.5 Predicate transformers 115
** 7.6 Further reading 117

* 8 Introduction to domain theory 119
** 8.1 Basic definitions 119
** 8.2 Streams-an example 121
** 8.3 Constructions on cpo's 123
*** 8.3.1 Discrete cpo's 124
*** 8.3.2 Finite products 125
*** 8.3.3 Function space 128
*** 8.3.4 Lifting 131
*** 8.3.5 Sums 133
** 8.4 A metalanguage 135
** 8.5 Further reading 139

* 9 Recursion equations 141
** 9.1 The language REC 141
** 9.2 Operational semantics of call-by-value 143
** 9.3 Denotational semantics of call-by-value 144
** 9.4 Equivalence of semantics for call-by-value 149
** 9.5 Operational semantics of call-by-name 153
** 9.6 Denotational semantics of call-by-name 154
** 9.7 Equivalence of semantics for call-by-name 157
** 9.8 Local declarations 161
** 9.9 Further reading 162

* 10 Techniques for recursion 163
** 10.1 BekiC's Theorem 163 
** 10.2 Fixed-point induction 166
** 10.3 Well-founded induction 174
** 10.4 Well-founded recursion 176
** 10.5 An exercise 179
** 10.6 Further reading 181

* 11 Languages with higher types 183
** 11.1 An eager language 183
** 11.2 Eager operational semantics 186
** 11.3 Eager denotational semantics 188
** 11.4 Agreement of eager semantics 190
** 11.5 A lazy language 200
** 11.6 Lazy operational semantics 201
** 11.7 Lazy denotational semantics 203
** 11.8 Agreement of lazy semantics 204
** 11.9 Fixed-point operators 209
** 11.10 Observations and full abstraction 215
** 11.11 Sums 219
** 11.12 Further reading 221

* 12 Information systems 223
** 12.1 Recursive types 223
** 12.2 Information systems 225
** 12.3 Closed families and Scott predomains 228
** 12.4 A cpo of information systems 233
** 12.5 Constructions 236
*** 12.5.1 Lifting 237
*** 12.5.2 Sums 239
*** 12.5.3 Product 241
*** 12.5.4 Lifted function space 243
** 12.6 Further reading 249

* 13 Recursive types 251
** 13.1 An eager language 251
** 13.2 Eager operational semantics 255
** 13.3 Eager denotational semantics 257
** 13.4 Adequacy of eager semantics 262
** 13.5 The eager A-calculus 267
*** 13.5.1 Equational theory 269
*** 13.5.2 A fixed-point operator 272
** 13.6 A lazy language 278
** 13.7 Lazy operational semantics 278
** 13.8 Lazy denotational semantics 281
** 13.9 Adequacy of lazy semantics 288
** 13.10 The lazy A-calculus 290
*** 13.10.1 Equational theory 291
*** 13.10.2 A fixed-point operator 292
** 13.11 Further reading 295

* 14 Nondeterminism and parallelism 297
** 14.1 Introduction 297
** 14.2 Guarded commands 298
** 14.3 Communicating processes 303
** 14.4 Milner's CCS 308
** 14.5 Pure CCS 311
** 14.6 A specification language 316
** 14.7 The modal v-calculus 321
** 14.8 Local model checking 327
** 14.9 Further reading 335

* A Incompleteness and undecidability 337
* Bibliography 353
* Index 357
