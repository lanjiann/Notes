#+TITLE: Pro Git
#+AUTHOR: Scott Chacon, Ben Straub
#+Version: 2.1.227, 2020-05-26 -> 2.1.267, 2020-10-17 xxx
#+STARTUP: overview
#+STARTUP: entitiespretty

* Licence - 1
* Preface by Scoot Chacon - 2
* Preface by Ben Straub - 3
* Dedications - 4
* Contributors - 5
* Introduction - 7
* DONE 1. Getting Started - 9
  CLOSED: [2019-05-21 Tue 11:50]
** TODO 1.1 About Version Control - 9
*** TODO Local Version Control Systems - 9
*** TODO Centralized Version Control Systems - 10
*** TODO Distributed Version Control Systems - 11

** DONE 1.2 A Short History of Git - 13
   CLOSED: [2017-07-14 Fri 05:26]
   Birth in 2005

** DONE 1.3 What is Git? - 13
   CLOSED: [2019-08-17 Sat 21:41]
*** DONE Snapshots, Not Differences  13
    CLOSED: [2017-07-14 Fri 04:18]
    - /The other VCS/ (/Subversion/ and friends included) store info as a list of
      file-based changes.

      These systems (CVS, Subversion, Perforce, Bazaar, and so on) think of the
      info they keep as a set of files and the changes made to each file over
      time.

    - /Git/ thinks about its data more like a _stream of snapshots_.
      NO-change files won't be save again, only create a link to it.

*** DONE Nearly Every Operation Is Local - 14
    CLOSED: [2017-07-14 Fri 04:21]
    This is also the main difference between /Git/ and the other VCS's.

*** DONE Git Has Integrity - 15
    CLOSED: [2017-07-14 Fri 04:37]
    - Everything in Git is _check-summed_ before it is stored and is then
      referred to by that /checksum/ -- impossible to make change without Git
      knowing about it.

    - Git uses SHA-1 hash for this checksumming (40-character hex).

*** DONE Git Generally Only Adds Data - 15
    CLOSED: [2017-07-14 Fri 04:42]
    As in any VCS, you can lose or mess up changes you haven't committed yet;
    but after you commit a snapshot into Git, it is very difficult to lose.

    =TODO= Any exception.

*** DONE The Three States - 15
    CLOSED: [2017-07-14 Fri 05:05]
    Git has _THREE_ main states that your file can reside in:
    + /committed/ :: the data is safely stored in your local database.
    + /modified/ :: file(s) has/have been changed but _NOT_ committed.
    + /staged/ :: marked a /modified/ file in its current version to go
                  into your next commit snapshot.

    See Figure 1-6. (page 8)

    This leads us to the three main sections of a Git project:
    + the =.git= directory (Repository):
      _where_ Git stores the metadata and object database for your project.
      This is _the most important part_ of Git, and it is what is copied when you
      clone a repository from another computer.

    + the working directory:
      a single checkout of one version of the project.
      These files are pulled out of the compressed database in the Git directory
      and placed on disk for you to use or modify.

    + the staging area:
      a file, generally contained in your =.git= directory, that stores
      information about what will go into your next commit. It's sometimes
      referred to as the "index", but it's also common to refer to it as the
      staging area.

** DONE 1.4 The Command Line - 17
   CLOSED: [2017-07-14 Fri 05:10]
   For this book, we will be using Git on the command line.

** DONE 1.5 Installing Git - 17
   CLOSED: [2017-07-14 Fri 05:10]
   This book was written using Git version 2.0.0.
   Any version after 2.0 should work just fine.

*** Installing on Linux - 17
*** Installing on Mac - 18
*** Installing on Windows - 18
*** Installing from Source - 19

** DONE 1.6 First-Time Git Setup - 20
   CLOSED: [2017-07-14 Fri 05:21]
*** DONE Your Identity - 21
    CLOSED: [2017-07-14 Fri 05:15]
    #+BEGIN_SRC bash
      git config --global user.name "John Doe"
      git config --global user.email johndoe@example.com
    #+END_SRC

    Run with ~--global~ to override the ~config~ in a local project.

*** DONE Your Editor - 21
    CLOSED: [2017-07-14 Fri 05:20]
    #+BEGIN_SRC bash
      git config --global core.editor emacs
      # or
      git config --global core.editor vim
    #+END_SRC
    =Me= I think no one needd a local editor setting.

*** DONE Checking Your Settings - 22
    CLOSED: [2017-07-14 Fri 05:21]
    #+BEGIN_SRC bash
      git config --list
      # user.name=John Doe
      # user.email=johndoe@example.com
      # color.status=auto
      # color.branch=auto
      # color.interactive=auto
      # color.diff=auto
      # ...

      git config user.name
      # John Doe
    #+END_SRC

** DONE 1.7 Getting Help - 23
   CLOSED: [2017-07-14 Fri 05:13]
   #+BEGIN_SRC bash
     git help <verb>
     git <verb> --help
     man git-<verb>
   #+END_SRC

   You can also try the =#git= or =#github= channel on the Freenode IRC server
   (irc. freenode.net).

** DONE 1.8 Summary - 24
   CLOSED: [2017-07-14 Fri 05:14]

* TODO 2. Git Basics - 25
  If you can read only one chapter to get going with Git, this is it.

  - By the end of the chapter, you should be able to:
    + configure and initialize a repository
    + begin and stop tracking files
    + stage and commit changes
    + set up Git to ignore certain files and file patterns
    + undo mistakes quickly and easily
    + browse the history of your project and view changes between commits
    + push and pull from remote repositories

** DONE 2.1 Getting a Git Repository - 25
   CLOSED: [2017-07-15 Sat 14:07]
   Two main approaches:
   1. The first takes an existing project or directory and imports it into Git.
   2. The second clones an existing Git repository from another server.

*** DONE Initializing a Repository in an Existing Directory - 25
    CLOSED: [2017-07-15 Sat 14:07]
    - ~git init~
      TODO What files are in the =.git= folder.

    - Add and commit:
      #+BEGIN_SRC bash
        git add *.c
        git add LICENSE
        git commit -m 'initial project version'
      #+END_SRC

*** DONE Cloning an Existing Repository - 26
    CLOSED: [2017-07-15 Sat 14:07]
    ~git clone <from> [<to>]~

** DONE 2.2 Recording Changes to the Repository - 27
   CLOSED: [2019-08-19 Mon 00:21]
   - Each file in your working directory can be in one of two states:
     + tracked
     + untracked

   - _Tracked files_ are files that were in the last snapshot;
     They can be
     + unmodified
     + modified
     + staged.

   - _Untracked files_ are everything else -- any files in your working directory
     that were
     + NOT in your last snapshot
     + NOT in your staging area

   - Figure 2-1. The lifecycle of the status of your files
     _Untracked_ ------> _Unmodified_ ------> _Modified_ -------> _Staged_
         |--add the file-------------------------------------------->|
         |                    |--Edit the file-->|                   |
         |                    |                  |--Stage the file-->|
         |<--Remove the file--|                  |                   |
         |                    |<--------------------commit-----------|

*** DONE Checking the Status of Your Files - 27
    CLOSED: [2017-07-16 Sun 22:58]
    ~git status~

*** DONE Tracking New Files - 28
    CLOSED: [2017-07-16 Sun 22:58]
    ~git add [<filename(s)> | <directory>]~
    ~git add~ works recursively.

*** DONE Staging Modified Files - 29
    CLOSED: [2017-07-16 Sun 23:10]
    - ~git add~ is a multipurpose command -- you use it
      + to begin tracking new files
      + to stage files
      + to do other things like marking merge-conflicted files as resolved. =TODO=

    - It may be helpful to think of it
      _more as_ "add this content to the next commit"
      _rather than_ "add this file to the project".

    - A file can be /staged/ and /unstaged/ simutaneously:
      If you staged a change in a file and modified this file again before
      committing, then this file is marked as /staged/ and /unstaged/, which
      actually means some change is /staged/ and some change is /unstaged/.

*** DONE Short Status - 30
    CLOSED: [2019-05-21 Tue 15:53]
    - Command:
      ~git status --short~ or ~git status -s~

    - Case study:
      #+BEGIN_SRC text
         M README
        MM Rakefile
        A  lib/git.rb
        M  lib/simplegit.rb
        ?? LICENSE.txt
      #+END_SRC
      + _??_ : _untracked_ file
      + _A _: new files that have been added to the staging area have an A,
      + M: modified files have an M and so on.
           There are _TWO columns_ to the output --
        * left column: the file is staged
        * right column: the file is modified

    - So for example in that output,
      + =README=
        is _modified_ in the working directory but _not yet staged_,

      + =lib/simplegit.rb=:
        is _modified_ and _staged_.

      + =Rakefile=:
        was _modified_, _staged_ and then _modified again_, so there are
        changes to it that are _BOTH staged and unstaged_.

*** DONE Ignoring Files - 31
    CLOSED: [2019-05-21 Tue 16:59]
    Use =.gitignore= file to tell git the files you don't want to track or even
    show.

    - You usually don't want to see some automatically

    - The _rules for the patterns_ you can put in the =.gitignore= file are as follows:
      + Blank lines or lines starting with # are ignored.

      + Standard glob patterns =???= work, and will be applied _recursively throughout
        the entire working tree_.

      + You can _start_ patterns with a forward slash (/) to *AVOID recursivity*.

      + You can _end_ patterns with a forward slash (/) to _specify a directory_.

      + You can _negate_ a pattern by _starting_ it with an exclamation point (~!~).

    - Glob patterns are LIKE _simplified regular expressions_ that shells use.
      + ~*~ matches zero or more characters

      + ~[abc]~ matches any character inside the brackets (in this case ~a~, ~b~,
        or ~c~)

      + ~?~ matches a single character

      + Patterns like ~[0-9]~ matches any character between them _inclusively_

      + ~**~ matches _nested directories_.
        For instance, ~a/**/z~ would match ~a/z~, ~a/b/z~, ~a/b/c/z~, and so on.

    - Case Study:
      #+begin_src gitignore
        # ignore all .a files
        ,*.a

        # but do track lib.a, even though you're ignoring .a files above
        !lib.a

        # only ignore the TODO file in the current directory, not subdir/TODO
        /TODO

        # ignore all files in any directory named build
        build/

        # ignore doc/notes.txt, but not doc/server/arch.txt
        doc/*.txt

        # ignore all .pdf files in the doc/ directory and any of its subdirectories
        doc/**/*.pdf
      #+end_src

    - *Tips*
       GitHub maintains a fairly comprehensive list of good =.gitignore= file
       examples for dozens of projects and languages at
      https://github.com/github/gitignore.
      _Pick one at the start point of your project._

    - *CAUTION*
      You can have only one =.gitignore= in the root of your simple project.
      However, it is also possible to have _ADDITIONAL_ =.gitignore= files in
      subdirectories.
        The rules in these nested =.gitignore= files apply only to the files
      under the directory where they are located.

      Use ~man gitignore~ for the details.

*** DONE Viewing Your Staged and Unstaged Changes - 32
    CLOSED: [2019-08-19 Mon 00:20]
    ~git diff~ show more details than ~git status~.
    - ~git diff~ shows you the exact lines added and removed -- the patch, as it
      were.

    - You probably use ~git diff~ most often to answer two questions:
      + Q :: What have you changed but not yet staged? --
             =from Jian= compare _not staged changes_ with branch head.

      + Q :: What have you staged that you are about to commit? --
             =from Jian= compare _staged changes_ with branch head.

    - For example,
      _edited and staged_ =README= and _edited_ =CONTRIBUTING.md=
      + ~git diff~ compare =CONTRIBUTING.md= with branch head
      + ~git diff --staged~ compare =README= with branch head

    - *Git Diff in an External Tool*
      - If you want to view the differences in diff viewing program, use ~git
        difftool~ instead.

      - Run ~git difftool --tool-help~ to see what is available on your system.

*** DONE Committing Your Changes - 35
    CLOSED: [2019-05-21 Tue 17:11]
    - Command:
      + ~git commit~:
        usually open the editor ~git config --global core.editor~, and you can
        type the commit message inside it. You will see it automatically put the
        change info in the comment. You can keep it or delete it.

      + ~git commit -v~:
        Just like the command above, but in verbose mode -- the comment includes
        more info like the diff result.

      + ~git commit -m~:
        Do not open editor, and provide a inline message that follows the ~-m~
        parameter.

    - After committing, you'll see an SHA-1 checksum.
      =TODO= SHA-1???

*** DONE Skipping the Staging Area - 36
    CLOSED: [2019-05-21 Tue 17:23]
    You can use a ~-a~ option when you work with ~git commit~ command, and
    _AUTOMATICALLY /stage/ EVERY file that is already tracked_ before doing the
    commit.
    For instance, ~git commit -a -m 'added new benchmarks~

    This is convenient, but it can also mass up your commit if you don't pay
    enough attension or overuse it.

*** DONE Removing Files - 37
    CLOSED: [2019-08-18 Sun 00:11]
    ~git rm~
    - If you delete a file with using ~git rm~,
      ~git stauts~ will tell you =Changes not staged for commit=
      + To stage it, you need use ~git rm <filename>~ again, even if you can't
        see the deleted file(s) in your repo.

      + If you use ~git rm~ from the very beginning, you need need to run
        ~rm <filename>~ followed by ~git rm <filename>~.

    - After running ~git rm <filename>~, the next time you commit, the file will
      be gone and no longer tracked.

    - ~git rm -f~
      If you _modified the file_ or _had already added it to the staging area_,
      you *MUST FORCE* the removal with the ~-f~ option.
      + Rationale:
        This is a *safety feature* to PREVENT
        _accidental removal of data that hasn't yet been recorded in a snapshot
        and that can't be recovered from Git._

    - ~git rm --cached~ remove file(s) from your /staging area/ but keep the file(s)
      in your working tree -- no longer track it.
      + This is particularly useful if you forgot to add something to your
        =.gitignore= file and accidentally staged it.

    - With file-glob patterns:
      ~git rm log/\*.log~
      The backslash (~\~) here is used to escape the ~*~ to stop doing shell
      expansion, and pass ~*~ to git, who has its own expansion.
      + =from Jian=
        Shell expansion also works. However, since I don't know the differences,
        and I believe let git to all the operations it can do is good for
        version control.

*** DONE Moving Files - 38
    CLOSED: [2019-08-17 Sat 22:01]
    - _UNLIKE_ many other VCS systems,
      Git does *NOT explicitly track* file movement.

    - If you rename a file in Git, no metadata is stored in Git that tells it you
      renamed the file.
        However, _Git is pretty smart about figuring that out after the fact_ --
      TODO we'll deal with detecting file movement a bit later.

    - Git has a ~mv~ command. For example,
      #+begin_src bash
        git mv README.md README
      #+end_src
      Then, run ~git status~ and you'll see:
      #+begin_src text
        On branch master
        Your branch is up-to-date with 'origin/master'.
        Changes to be committed:
          (use "git reset HEAD <file>..." to unstage)

            renamed:    README.md -> README
      #+end_src

    - Git has a ~mv~ command (e.g. ~git mv README.md README~), which is equivalent
      to running something like:
      #+begin_src bash
        mv README.md README  # Or any other ways, like in GUI, you can use to rename a file
        git rm README.md
        git add README
      #+end_src
      + _The only real difference is that ~git mv~ is one command instead of three._

      + The three commands way is still useful:
        you can use any tool you like to rename (shell's ~mv~, GUI, etc.) a file,
        and address the add/rm (~git add~ and ~git rm~) later, before you commit.

** DONE 2.3 Viewing the Commit History - 39
   CLOSED: [2019-11-23 Sat 18:27]
   - ~git log~

   - ~git log -p~ / ~git log --patch~
     Use ~-<number>~ to limit the number of commits you want to log
     Display in patch-like view

   - ~git log --stat~
     Like ~--patch~, but only one statics line per file, without details of
     difference

   - ~git log --pretty=<format>~
     + ~oneline~

     + ~format:<format-string>~
       Example: ~git log --pretty=format:"%h - %an, %ar : %s"~

     + Table1. Useful options for ~git log --pretty=format~
       TODO TODO TODO

   - Distinguish /author/ and /committer/:
     + Author :: the person who originally wrote the work,
     + Committer :: the person who last applied the work.

   - So, if you send in a patch to a project and one of the core members applies
     the patch, both of you get credit — _you as the /author/, and the core
     member as the /committer/._

   - Another useful option ~--graph~

   - Table 2. Common options to ~git log~
     TODO TODO TODO

*** DONE Limiting Log Output - 44
    CLOSED: [2019-11-23 Sat 18:27]
    - ~-<n>~

    - ~--since~ and ~--until~
      Example: ~git log --since=2.weeks~
      These options can work with lots of formats like ~"2018-01-15"~ or
      ~"2 years 1 day 3 minutes ago"~

    - Use ~--author~ to filter on a specific /author/.
      Use ~--committer~ to filter on a specific /comitter/.

    - Use ~--grep~ to search for keywords in the commit messages.

    - Use ~--all-match~ option to further limit the output to just those commits
      that match *all* ~--grep~ patterns.

    - ~-S~ only show commits adding or removing code match the string.
      For example, ~git log -S function_name~
      + *CAUTION* TODO TODO TODO
        This is _ALWAYS_ the last option and is generally preceded by double
        dashes (~--~) to _separate the paths from the options_.

    - *Preventing the display of merge commits*
      Use ~--no-merges~

** DONE 2.4 Undoing Things - 46
   CLOSED: [2019-11-23 Sat 18:55]
   - *CAUTION*:
     Sometimes, undoing things can be _DANGEOUS_ -- you *can't* always undo some
     of these undos!
     *This is the one of the few areas in Git where you may lose some work if
     you do it wrong*

   - ~git commit --amend~
     =from Jian= =IMPORTANT=
     I think it's better not do this and create more commits -- we can merge
     them later! This way is safer than using the ~--amend~ option!!!

*** DONE Unstaging a Staged File - 47
    CLOSED: [2019-11-23 Sat 18:44]
    - Unstage a file with ~git reset HEAD <file>~
      Acutally, after staging files with ~git add~, when you run ~git status~,
      there will be a hint message that =(use "git reset HEAD <file> ...") to unstage)=.

    - *TIPS*
      It's true that ~git reset~ _CAN BE a *dangerous* command_, especially if you
      provide the ~--hard~ flag.
        _HOWEVER_, in the scenario described above, the file in your working
      directory is not touched (=from Jian= change the staged status of a file
      won't touch its content), so it's relatively safe.

*** DONE Unmodifying a Modified File - 48
    CLOSED: [2019-08-19 Mon 01:14]
    - ~git checkout -- <file>~

    - ~git status~ can also give hits about this like:
      #+begin_src text
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git checkout -- <file>..." to discard changes in working directory)
      #+end_src

    - *CAUTION*:
      ~git checkout -- <file>~ is dangerous.
      Any local changes you made to that file are gone -- _Git just replaced that
      file with the most recently-committed version._
      *Don't ever use this command unless you absolutely know that you don't want
      those unsaved local changes.*

      + =from Jian= To avoid this,
        * Solution 1:
          Add a hook for this command with reminder

        * Solution 2: =from Jian= I prefer this!!!
          Add a hook for this command without reminder, but implicitly
          create a branch with snapshot before this command.

        * Solution 3:
          Manually create a branch with snapshot before this command, and then
          switch back and run this command.

      + =from Jian=
        I prefer Solution 2, and we should add hooks to all the dangerous
        commands!!! TODO TODO TODO

    - *Remember*: =IMPORTANT= TODO TODO TODO
      + _Anything that is committed in Git can almost always be recovered._
        Even commits that were on branches that were deleted or commits that
        were overwritten with an ~--amend~ commit can be recovered (see Data
        Recovery for data recovery). TODO _HOWTO ???_ TODO

      + However, _anything you lose that was never committed is likely never to be
        seen again._

** TODO 2.5 Working with Remotes - 49
*** TODO Showing Your Remotes - 49
*** TODO Adding Remote Repositories - 49
*** TODO Fetching and Pulling from Your Remotes - 51
*** TODO Pushing to Your Remotes - 52
*** TODO Inspecting a Remote - 52
*** TODO Removing and Renaming Remotes - 53

** TODO 2.6 Tagging - 54
*** TODO Listing Your Tags - 54
*** TODO Creating Tags - 55
*** TODO Annotated Tags - 55
*** TODO Lightweight Tags - 56
*** TODO Tagging Later - 56
*** TODO Sharing Tags - 57
*** TODO Deleting Tags - 58
*** TODO Checking out Tags - 59

** DONE 2.7 Git Aliases - 59
   CLOSED: [2019-08-19 Mon 02:11]
   - Create shorter name alias for exist commands
     + Command:
       #+begin_src shell
         $ git config --global alias.co checkout
         $ git config --global alias.br branch
         $ git config --global alias.ci commit
         $ git config --global alias.st status
       #+end_src

     + =.gitconfig= file:
       #+begin_src text
         [alias]
           co = checkout
           br = branch
           ci = commit
           st = status
       #+end_src

   - Create alias for commands with options
     ~git config --global alias.unstage 'reset HEAD --'~

   - A useful command -- show the lastest commit log:
     ~git config --global alias.last 'log -1 HEAD'~

   - Create a alias for external command -- prefix with ~!~:
     ~git config --global alias.visual '!gitk'~
     + Usage:
       ~git visual~

     + Actual external command:
       ~gitk~

** DONE 2.8 Summary - 61
   CLOSED: [2019-08-19 Mon 01:59]

* TODO 3. Git Branching - 62
  - Nearly every VCS has some form of branching support.

  - _Many of their /branching/ is EXPENSIVE._
    One of the "killer feature" of Git is that it branches is incredibly
    _lightweight_.

  - Git enourages workflows that branch and merge often.

** TODO 3.1 Branches in a Nutshell - 62
*** TODO Creating a New Branch - 64
*** TODO Switching Branches - 65

** TODO 3.2 Basic Branching and Merging - 69
*** TODO Basic Branching - 69
*** TODO Basic Merging - 73
*** TODO Basic Merge Conflicts - 74

** TODO 3.3 Branch Management - 77
** TODO 3.4 Branching Workflows - 78
*** TODO Long-Running Branches - 79
*** TODO Topic Branches - 80

** TODO 3.5 Remote Branches - 82
*** TODO Pushing - 88
*** TODO Tracking Branches - 89
*** TODO Pulling - 91
*** TODO Deleting Remote Branches - 91

** TODO 3.6 Rebasing - 92
*** TODO The Basic Rebase - 92
*** TODO More Interesting Rebases - 94
*** TODO The Perils of Rebasing - 97
*** TODO Rebase When You Rebase - 99
*** TODO Rebase vs. Merge - 100

** TODO 3.7 Summary - 101

* TODO 4. Git on the Server - 102
** TODO 4.1 The Protocols - 102
*** TODO Local Protocol - 102
**** The Pros - 103
**** The Cons - 103

*** TODO The HTTP Protocol - 104
**** Smart HTTP - 104
**** Dumb HTTP - 104
***** The Pros - 105
***** The Cons - 105

*** TODO The SSH Protocol - 105
**** The Pros - 106
**** The Cons - 106

*** TODO The Git Protocol - 106
**** The Pros - 106
**** The Cons - 106

** TODO 4.2 Getting Git on a Server - 107
*** TODO Putting the Bare Repository on a Server - 107
*** TODO Small Setups - 108
**** TODO SSH Access - 108

** TODO 4.3 Generating Your SSH Public Key - 109
** TODO 4.4 Setting Up the Server - 110
** TODO 4.5 Git Daemon - 113
** TODO 4.6 Smart HTTP - 114
** TODO 4.7 GitWeb - 116
** TODO 4.8 GitLab - 118
*** TODO Installation - 118
*** TODO Administration - 119
**** TODO Users - 119
**** TODO Groups - 120
**** TODO Projects - 121
**** TODO Hooks - 121

*** TODO Basic Usage - 121
*** TODO Working Together - 122

** TODO 4.9 Third Party Hosted Options - 122
** TODO 4.10 Summary - 123
* TODO 5. Distributed Git - 124
** TODO 5.1 Distributed Workflows - 124
*** TODO Centralized Workflow - 124
*** TODO Integration-Manager Workflow - 125
*** TODO Dictator and Lieutenants Workflow - 126
*** TODO Workflows Summary - 126

** TODO 5.2 Contributing to a Project - 127
*** TODO Commit Guidelines - 127
*** TODO Private Small Team - 129
*** TODO Private Managed Team - 136
*** TODO Forked Public Project - 142
*** TODO Public Project over Email - 146
*** TODO Summary - 149

** TODO 5.3 Maintaining a Project - 149
*** TODO Working in Topic Branches - 149
*** TODO Applying Patches from Email - 150
**** Applying a Patch with apply - 150
**** Applying a Patch with ~am~ - 151

*** TODO Checking Out Remote Branches - 153
*** TODO Determining What Is Introduced - 154
*** TODO Integrating Contributed Work - 155
**** Merging Workflows - 156
**** Large-Merging Workflows - 158
**** Rebasing and Cherry Picking Workflows - 159
**** Rerere - 161

*** TODO Tagging Your Releases - 161
*** TODO Generating a Build Number - 162
*** TODO Preparing a Release - 163
*** TODO The Shortlog - 163

** TODO 5.4 Summary - 164

* TODO 6. GitHub - 165
** TODO 6.1 Account Setup and Configuration - 165
*** TODO SSH Access - 165
*** TODO Your Avatar - 166
*** TODO Your Email Address - 168
*** TODO Two Factor Authentication - 168

** TODO 6.2 Contributing to a Project - 170
*** TODO Forking Projects - 169
*** TODO The GitHub Flow - 170
**** TODO Creating a Pull Request - 170
**** TODO Iterating on a Pull Request - 174

*** TODO Advanced Pull Requests - 178
**** Pull Requests as Patches - 178
**** Keeping up with Upstream - 178
**** References - 181
**** GitHub Flavored Markdown - 183
***** Task Lists - 184
***** Code Snippets - 185
***** Quoting - 185
***** Emoji - 186
***** Images - 187

**** Keep your GitHub public repository up-to-date - 188

** TODO 6.3 Maintaining a Project - 190
*** TODO Creating a New Repository - 189
*** TODO Adding Collaborators - 191
*** TODO Managing Pull Requests - 192
**** Email Notifications - 193
**** Collaborating on the Pull Request - 194
**** Pull Request Refs - 195
**** Pull Requests on Pull Requests - 197

*** TODO Mentions and Notifications - 198
**** The Notifications Page - 199
***** Web Notifications - 200
***** Email Notifications - 201

*** TODO Special Files - 201
**** README - 202
**** CONTRIBUTING - 202

*** TODO Project Administration - 202
**** Changing the Default Branch - 203
**** Transferring a Project - 203

** TODO 6.4 Managing an organization - 205
*** TODO Organization Basics - 204
*** TODO Teams - 204
*** TODO Audit Log - 206

** TODO 6.5 Scripting GitHub - 208
*** TODO Services and Hooks - 208
**** Services - 209
**** Hooks - 210

*** TODO The GitHub API - 212
**** Basic Usage - 213
**** Commenting on an Issue - 214
**** Changing the Status of a Pull Request - 215

*** TODO Octokit - 217

** TODO 6.6 Summary - 217

* TODO 7. Git Tools - 218
** TODO 7.1 Revision Selection - 218
*** Single Revisions - 218
*** Short SHA-1 - 218
*** Branch References - 220
*** RefLog Shortnames - 221
*** Ancestry References - 222
*** Commit Ranges - 224
**** Double Dot - 224
**** Multiple Points - 225
**** Triple Dot - 226

** TODO 7.2 Interactive Staging - 226
*** Staging and Unstaging Files - 227
*** Staging Patches - 229

** TODO 7.3 Stashing and Cleaning - 230
*** Stashing Your Work - 231
*** Creative Stashing - 233
*** Creating a Branch from a Stash - 234
*** Cleaning Your Working Directory - 235

** TODO 7.4 Signing Your Work - 236
*** GPG Introduction - 237
*** Signing Tags - 237
*** Verifying Tags - 238
*** Signing Commits - 239
*** Everyone Must Sign - 240

** TODO 7.5 Searching - 240
*** Git Grep - 241
*** Git Log Searching - 243
**** Line Log Search - 243

** TODO 7.6 Rewriting History - 244
*** Changing the Last Commit - 245
*** Changing Multiple Commit Messages - 246
*** Reordering Commits - 248
*** Squashing Commits - 249
*** Squashing a Commit - 250
*** The Nuclear Option: filter-branch - 251
**** Removing a File from Every Commit - 251
**** Making a Subdirectory the New Root - 251
**** Changing EMail Addresses Globally - 252

** TODO 7.7 Reset Demystified - 252
*** The Three Trees - 252
**** The HEAD - 253
**** The Index - 253
**** The Working Directory - 254

*** The Workflow - 254
*** The Role of Reset - 260
**** Step 1: Move HEAD - 261
**** Step 2: Updating the Index (--mixed) - 262
**** Step 3: Updating the Working Directory (--hard) - 263
**** Recap - 264

*** Reset with a Path - 265
*** Squashing - 267
*** Check It Out - 270
**** Without Paths - 271
**** With Paths - 271

*** Summary - 271

** TODO 7.8 Advanced Merging - 272
*** TODO Merge Conflicts - 273
**** TODO Aborting a Merge - 275
**** TODO Ignoring Whitespace - 276
**** TODO Manual File Re-merging - 276
**** TODO Checking Out Conflicts - 279
**** TODO Merge Log - 281
**** TODO Combined Diff Format - 282

*** TODO Undoing Merges - 284
**** Fix the References - 285
**** Reverse the Commit - 286

*** TODO Other Types of Merges - 287
**** Our or Theirs Preference - 287
**** Subtree Merging - 289

** TODO 7.9 Rerere - 291
** TODO 7.10 Debugging with Git - 297
*** TODO File Annotation - 297
*** TODO Binary Search - 298

** TODO 7.11 Submodules - 300
*** Starting with Submodules - 300
*** Cloning a Project with Submodules - 302
*** Working on a Project with Submodules - 304
**** Pulling in Upstream Changes from the Submodule Remote - 304
**** Pulling in Upstream Changes from the Project Remote - 308
**** Working on a Submodule - 309

*** Publishing Submodule Changes - 311
*** Merging Submodule Changes - 310
*** Submodule Tips - 316
**** Submodule Foreach - 316
**** Useful Aliases - 318

*** Issues with Submodules - 316
**** Switching branches - 319
**** Switching from subdirectories to submodules - 321

** TODO 7.12 Bundling - 322
** TODO 7.13 Replace - 326
** TODO 7.14 Credential Storage - 334
*** TODO Under the Hood - 335
*** TODO A Custom Credential Cache - 337

** TODO 7.15 Summary - 339

* TODO 8. Customizing Git - 340
** TODO 8.1 Git Configuration - 340
*** TODO Basic Client Configuration - 340
**** ~core.editor~
**** ~commit.template~
**** ~core.pager~
**** ~user.signingkey~
**** ~core.excludesfile~
**** ~help.autocorrect~

*** TODO Colors in Git - 343
**** ~color.ui~
**** ~color.*~

*** TODO External Merge and Diff Tools - 344
*** TODO Formatting and Whitespace - 347
**** ~core.autocrlf~ - 347
**** ~core.whitespace~ - 348

*** TODO Server Configuration - 349
**** ~receive.fsckObjects~ - 349
**** ~receive.denyNonFastForwards~ - 349
**** ~receive.denyDeletes~ - 350

** TODO 8.2 Git Attributes - 350
*** Binary Files - 350
**** Indentifying Binary Files - 350
**** Diffing Binary Files - 350

*** Keyword Expansion - 353
*** Exporting Your Repository - 356
**** ~export-ignore~ - 356
**** ~export-subst~ - 357

*** Merge Strategies - 358

** TODO 8.3 Git Hooks - 358
*** Installing a Hook - 358
*** Client-Side Hooks - 359
**** Committing-Workflow Hooks - 359
**** E-mail Workflow Hooks - 359
**** Other Client Hooks - 360

*** Server-Side Hooks - 360
**** ~pre-receive~
**** ~update~
**** ~post-receive~

** TODO 8.4 An Example Git-Enforced Policy - 361
*** Server-Side Hook - 361
**** Enforcing a Specific Commit-Message Format - 362
**** Enforcing a User-Based ACL System - 363
**** Testing It Out - 366

*** Client-Side Hooks - 367

** TODO 8.5 Summary - 370

* TODO 9. Git and Other Systems - 371
** TODO 9.1 Git as a Client - 371
*** TODO Git and Subversion - 371
**** ~git svn~
**** Setting Up
**** Getting Started
**** Committing Back to Subversion
**** Pulling in New Changes
**** Git Branching Issues
**** Subversion Branching
***** Creating a New SVN Branch
***** Switching Active Branches

**** Subversion Commands
***** SVN Style History
***** SVN Annotation
***** SVN Server Information

**** Ignoring What Subversion Ignores
**** Git-Svn Summary

*** TODO Git and Mercurial - 382
**** Getting Started
**** Workflow
**** Branches and Bookmarks
**** Mercurial Summary

*** TODO Git and Bazaar - 389
**** Create a Git repository from a Bazaar repository
**** Bazaar branches
**** Ignore what is ignored with =.bzrignore=
**** Push your work on the remote repository
**** Caveats
**** Summary

*** TODO Git and Perforce - 392
**** Git Fusion
***** Setting Up
***** Fusion Configuration
***** Workflow
***** Git-Fusion Summary

**** Git-p4
***** Setting Up
***** Getting Started
***** Workflow
***** Branching

**** Git and Perforce Summary

*** TODO Git and TFS - 408

** TODO 9.2 Migrating to Git - 417
*** TODO Subversion - 417
*** TODO Mercurial - 419
*** TODO Bazaar - 423
**** Getting the bzr-fastimport plugin - 423
**** Project with a single branch - 424
**** Case of a project with a main branch and a working branch - 424
**** Synchronizing the staging area - 425
**** Ignoring the files that were ignored with =.bzrignore= - 425
**** Sending your repository to the server - 425

*** TODO Perforce - 426
**** TODO Perforce Git Fusion - 426
**** TODO Git-p4 - 426

*** TODO TFS - 427
*** TODO A Custom Importer - 429

** TODO 9.3 Summary - 436
* TODO 10. Git Internals - 437
** TODO 10.1 Plumbing and Porcelain - 437
** TODO 10.2 Git Objects - 438
*** TODO Tree Objects - 440
*** TODO Commit Objects - 443
*** TODO Object Storage - 446

** TODO 10.3 Git References - 448
*** TODO The HEAD - 449
*** TODO Tags - 450
*** TODO Remotes - 451

** TODO 10.4 Packfiles - 452
** TODO 10.5 The Refspec - 455
*** TODO Pushing Refspecs - 457
*** TODO Deleting References - 458

** TODO 10.6 Transfer Protocols - 458
*** TODO The Dumb Protocol - 458
*** TODO The Smart Protocol - 460
**** TODO Uploading Data - 460
***** TODO SSH - 460
***** TODO HTTP(S) - 461

**** TODO Downloading Data - 462
***** TODO SSH - 462
***** TODO HTTP(S) - 463

*** TODO Protocol Summary - 463

** TODO 10.7 Maintenance and Data Recovery - 463
*** TODO Maintenance - 463
*** TODO Data Recovery - 464
*** TODO Removing Objects - 467

** TODO 10.8 Environment Variables - 470
*** TODO Global Behavior - 471
*** TODO Repository Locations - 471
*** TODO Pathspecs - 472
*** TODO Committing - 472
*** TODO Networking - 472
*** TODO Diffing and Merging - 473
*** TODO Debugging - 473
*** TODO Miscellaneous - 475

** TODO 10.9 Summary - 476

* TODO Appendix A: Git in Other Environments - 477
** TODO Graphical Interfaces - 477
*** TODO =gitk= and =git-gui= - 477
*** TODO GitHub for macOS and Windows - 479
**** TODO Installation - 481
**** TODO Recommended Workflow - 481
**** TODO Summary - 481

*** TODO Other GUIs - 482

** TODO Git in Visual Studio - 482
** TODO Git in Visual Studio Code - 484
** TODO Git in Eclipse - 484
** TODO Git in IntelliJ/PyCharm/WebStorm/PhpStorm/RubyMine - 485
** TODO Git in Sublime Text - 486
** TODO Git in Bash - 486
** TODO Git in Zsh - 487
** TODO Git in Powershell - 489
*** Installation - 489
**** Prerequisites (Windows only) - 489
**** PowerShell Gallery - 490
**** Update PowerShell Prompt - 490
**** From Source - 490

** TODO Summary - 491

* TODO Appendix B: Embedding Git in your Applications - 492
** TODO Command-line Git - 492
** TODO Libgit2 - 492
*** TODO Advanced Functionality - 495
*** TODO Other Bindings - 496
**** LibGit2Sharp - 496
**** objective-git - 497
**** pygit2 - 497

*** TODO Further Reading - 497

** TODO JGit - 497
*** Getting Set Up - 497
*** Plumbing - 498
*** Porcelain - 500
*** Further Reading - 501

** TODO go-git - 501
*** Advanced Functionality - 502
*** Further Reading - 502

** TODO Dulwich - 502
*** TODO Further Reading - 503

* TODO Appendix C: Git Commands - 504
** TODO Setup and Config - 504
*** TODO ~git config~
*** TODO ~git config core.editor~ commands
*** TODO ~git help~

** TODO Getting and Creating Projects - 506
*** TODO ~git init~
*** TODO ~git clone~

** TODO Basic Snapshotting - 507
*** TODO ~git add~
*** TODO ~git status~
*** TODO ~git diff~
*** TODO ~git difftool~
*** TODO ~git commit~
*** TODO ~git reset~
*** TODO ~git rm~
*** TODO ~git mv~
*** TODO ~git clean~

** TODO Branching and Merging - 509
*** TODO ~git branch~
*** TODO ~git checkout~
*** TODO ~git merge~
*** TODO ~git mergetool~
*** TODO ~git log~
*** TODO ~git stash~
*** TODO ~git tag~

** TODO Sharing and Updating Projects - 511
*** TODO ~git fetch~
*** TODO ~git pull~
*** TODO ~git push~
*** TODO ~git remote~
*** TODO ~git archive~
*** TODO ~git submodule~

** TODO Inspection and Comparison - 513
*** TODO ~git show~
*** TODO ~git shortlog~
*** TODO ~git describe~

** TODO Debugging - 514
*** TODO ~git bisect~
*** TODO ~git blame~
*** TODO ~git grep~

** TODO Patching - 514
*** TODO ~git cherry-pick~
*** TODO ~git rebase~
*** TODO ~git revert~

** TODO Email - 515
*** TODO ~git apply~
*** TODO ~git am~
*** TODO ~git format-patch~
*** TODO ~git imap-send~
*** TODO ~git send-email~
*** TODO ~git request-pull~

** TODO External Systems - 516
*** TODO ~git svn~
*** TODO ~git fast-import~

** TODO Administration - 517
*** TODO ~git gc~
*** TODO ~git fsck~
*** TODO ~git reflog~
*** TODO ~git filter-branch~

** TODO Plumbing Commands - 518
