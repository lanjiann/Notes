#+TITLE: Category Theory for Programmers
#+SUBTITLE: Scala Edition - Contains code snippets in Haskell and Scala
#+AUTHOR: Bartosz Milewski, (compiled and edited by) Igal Tabachnik
#+VERSION: v1.2.1-0-gb4fb9c1 - March 14 2019
#+STARTUP: entitiespretty

* DONE A note from the editor - ix
  CLOSED: [2019-05-30 Thu 11:33]
  - This version of book use LaTeX macro to load different code snippets from
    external files, while _leaving the original text intact_ -- this means
    *when you see "in Haskell" in the text, you should mentally append the words
    "and Scala".*

  - The Scala code is provided by Typelevel.

  - Some Scala snippets make use the *Kind Projector* _compiler plugin_, to support
    nicer syntax for /partially-applied types/.
    + footnote 2: https://github.com/non/kind-projector

* TODO Preface - xi
* TODO Part One - 3
** DONE 1 Category: The Essence of Composition - 3
   CLOSED: [2019-04-05 Fri 13:43]
   - category :: /objects/ and /arrows/ that _go between them_.

   - The essense of a /category/ is *composition*.
     The essence of *composition* is a /category/.

   - *Arrows compose*
     For instance, if you have
     + an /arrow/ from /object/ _A_ to object _B_
       and
     + another /arrow/ from /object/ _B_ to /object/ _C_

     then there *must be* an /arrow/ ‚Äî their /composition/ ‚Äî that goes from _A_
     to _C_.

*** DONE 1.1 Arrows as Functions - 3
    CLOSED: [2019-05-31 Fri 13:52]
    - /arrows/ are also called /morphisms/.

    - Read (Haskell code) ~g . f~ (or ~g ‚ó¶ f~) as "g after f".

    - Composition:
      + Haskell code
        #+begin_src haskell
          f :: A -> B
          g :: B -> C
          g . f
        #+end_src

      + Scala code
        #+begin_src scala
          val f: A => B
          val g: B => C
          g compose f
        #+end_src

*** DONE 1.2 Properties of Composition - 5
    CLOSED: [2019-05-31 Fri 14:06]
    - There are two extremely important properties that the composition in any category
      must satisfy.
      1. /Composition/ is *associative*.
         + Haskell: ~h . (g . f)~ \equiv{} ~(h . g) . f~ \equiv{} ~h . g. f~

         + Scala: ~h compose (g compose f)~ \equiv{} ~(h compose g) compose f~ \equiv{} ~h compose g compose f~

      2. For every /object/ _A_ there is an /arrow/ which is a *unit of composition*.
         This /arrow/ loops from the /object/ to itself.
         + Haskell
           * ~f . id~ \equiv{} ~f~
           * ~id . f~ \equiv{} ~f~

         + Scala:
           * ~f compose identity[A]~ \equiv{} ~f~
           * ~identity[B] _ compose f~ \equiv{} ~f~

    - Neutral values like _zero_ or _id_ are extremely useful when working with
      /symbolic variables/.
        *So the /identity function/ becomes very handy as an argument to, or a
      return from, a /higher-order function/.*

      + /Higher order functions/ are what make symbolic manipulation of functions
        possible. _/Higher order functions/ are the *algebra of functions*._

*** TODO 1.3 Composition is the Essence of Programming - 7
    - TODO NOTE

    - The moment you have to dig into the implementation of the object in order
      to understand how to compose it with other objects,
      you've lost the advantages of your programming paradigm.

*** TODO 1.4 Challenges - 8
    1. DONE
    2. TODO
    3. TODO
    4. TODO
    5. TODO
    6. TODO

** DONE 2 Types and Functions - 11
   CLOSED: [2019-06-01 Sat 00:15]
   _The /category/ of /types/ and /functions/_ plays an important role in programming,
   so let's talk about
   - what /types/ are
     and
   - why we need them.

*** DONE 2.1 Who Needs Types? - 11
    CLOSED: [2019-05-31 Fri 23:30]
    So the question is, do we want to make monkeys happy, or do we want to
    produce correct programs?

*** DONE 2.2 Types Are About Composability - 12
    CLOSED: [2019-05-31 Fri 23:30]
    - /Category theory/ is about *composing* /arrows/.
      However, the /composition/ can happen ONLY when the /target object/ of one
      /arrow/ *matches* the /source object/ of the NEXT /arrow/.

      _The stronger the type system of the language, the better this match can be
      described and mechanically verified._

    - TODO NOTE

    - TODO NOTE

    - _/Testing/ is a *poor* substitute for /proof/._

*** TODO 2.3 What Are Types? - 13
    - The simplest intuition for /types/ is that they are _sets of values_.
      Since /sets/ can be _finite or infinite_, the number of values of a type
      can be _finite or infinite_.

    - ~Integer~ in Haskell is a /infinite set/, and it can be used to do _arbitrary
      precision_ arithmetic. This is like ~BigInt~ in other languages, including
      Scala and Java.

      The machine type of integer is ~Int~, which is /finite set/.

    - TODO NOTE

    - Partial function :: /functions/ that MAY return /bottom/

    - Total functions :: /functions/ that return _valid results_ for *every*
         possible argument.

    - /Set/ and /Hask/
      TODO NOTE ???

*** TODO 2.4 Why Do We Need a Mathematical Model? - 15
*** TODO 2.5 Pure and Dirty Functions - 17
*** TODO 2.6 Examples of Types - 17
*** TODO 2.7 Challenges - 20

** TODO 3 Categories Great and Small - 23
*** DONE 3.1 No Objects - 23
    CLOSED: [2019-06-01 Sat 00:16]
*** TODO 3.2 Simple Graphs - 23
*** TODO 3.3 Orders - 24
*** TODO 3.4 Monoid as Set - 24
*** TODO 3.5 Monoid as Category - 27
*** TODO 3.6 Challenges - 29

** 4 Kleisli Categories - 31
*** 4.1 The Writer Category - 34
*** 4.2 Writer in Haskell - 36
*** 4.3 Kleisli Categories - 39
*** 4.4 Challenge - 39

** 5 Products and Coproducts - 41
*** 5.1 Initial Object - 41
*** 5.2 Terminal Object - 43
*** 5.3 Duality - 44
*** 5.4 Isomorphisms - 45
*** 5.5 Products - 46
*** 5.6 Coproduct - 51
*** 5.7 Asymmetry - 54
*** 5.8 Challenges - 56
*** 5.9 Bibliography - 57

** 6 Simple Algebraic Data Types - 59
*** 6.1 Product Types - 59
*** 6.2 Records - 63
*** 6.3 Sum Types - 65
*** 6.4 Algebra of Types - 68
*** 6.5 Challenges - 72

** 7 Functors - 73
*** 7.1 Functors in Programming - 75
**** 7.1.1 The Maybe Functor - 75
**** 7.1.2 Equational Reasoning - 77
**** 7.1.3 Optional - 79
**** 7.1.4 Typeclasses - 80
**** 7.1.5 Functor in C++ - 82
**** 7.1.6 The List Functor - 82
**** 7.1.7 The Reader Functor - 84

*** 7.2 Functors as Containers - 86
*** 7.3 Functor Composition - 88
*** 7.4 Challenges - 90

** 8 Functoriality - 93
*** 8.1 Bifunctors - 93
*** 8.2 Product and Coproduct Bifunctors - 95
*** 8.3 Functorial Algebraic Data Types - 97
*** 8.4 Functors in C++ - 100
*** 8.5 The Writer Functor - 102
*** 8.6 Covariant and Contravariant Functors - 104
*** 8.7 Profunctors - 107
*** 8.8 The Hom-Functor - 109
*** 8.9 Challenges - 109

** 9 Function Types - 111
*** 9.1 Universal Construction - 112
*** 9.2 Currying - 115
*** 9.3 Exponentials - 118
*** 9.4 Cartesian Closed Categories - 119
*** 9.5 Exponentials and Algebraic Data Types - 120
**** 9.5.1 Zeroth Power - 120
**** 9.5.2 Powers of One - 121
**** 9.5.3 First Power - 121
**** 9.5.4 Exponentials of Sums - 121
**** 9.5.5 Exponentials of Exponentials - 122
**** 9.5.6 Exponentials over Products - 122

*** 9.6 Curry-Howard Isomorphism - 122
*** 9.7 Bibliography - 124

** 10 Natural Transformations - 125
*** 10.1 Polymorphic Functions - 128
*** 10.2 Beyond Naturality - 134
*** 10.3 Functor Category - 135
*** 10.4 2-Categories - 138
*** 10.5 Conclusion - 142
*** 10.6 Challenges - 142

* Part Two - 145
** 11 Declarative Programming - 145
** 12 Limits and Colimits - 151
*** 12.1 Limit as a Natural Isomorphism - 155
*** 12.2 Examples of Limits - 158
*** 12.3 Colimits - 164
*** 12.4 Continuity - 165
*** 12.5 Challenges - 166

** 13 Free Monoids - 169
*** 13.1 Free Monoid in Haskell - 170
*** 13.2 Free Monoid Universal Construction - 171
*** 13.3 Challenges - 175

** 14 Representable Functors - 177
*** 14.1 The Hom Functor - 178
*** 14.2 Representable Functors - 180
*** 14.3 Challenges - 185
*** 14.4 Bibliography - 185

** 15 The Yoneda Lemma - 187
*** 15.1 Yoneda in Haskell - 192
*** 15.2 Co-Yoneda - 194
*** 15.3 Challenges - 194
*** 15.4 Bibliography - 195

** 16 Yoneda Embedding - 197
*** 16.1 The Embedding - 199
*** 16.2 Application to Haskell - 199
*** 16.3 Preorder Example - 200
*** 16.4 Naturality - 202
*** 16.5 Challenges - 202

* Part Three 207
** 17 It's All About Morphisms - 207
*** 17.1 Functors - 207
*** 17.2 Commuting Diagrams - 207
*** 17.3 Natural Transformations - 208
*** 17.4 Natural Isomorphisms - 209
*** 17.5 Hom-Sets - 210
*** 17.6 Hom-Set Isomorphisms - 210
*** 17.7 Asymmetry of Hom-Sets - 211
*** 17.8 Challenges - 211

** 18 Adjunctions - 213
*** 18.1 Adjunction and Unit/Counit Pair - 214
*** 18.2 Adjunctions and Hom-Sets - 218
*** 18.3 Product from Adjunction - 221
*** 18.4 Exponential from Adjunction - 224
*** 18.5 Challenges - 225

** 19 Free/Forgetful Adjunctions - 227
*** 19.1 Some Intuitions - 230
*** 19.2 Challenges - 232

** 20 Monads: Programmer's Definition - 233
*** 20.1 The Kleisli Category - 234
*** 20.2 Fish Anatomy - 237
*** 20.3 The do Notation - 240

** 21 Monads and Effects - 245
*** 21.1 The Problem - 245
*** 21.2 The Solution - 246
**** 21.2.1 Partiality - 246
**** 21.2.2 Nondeterminism - 247
**** 21.2.3 Read-Only State - 249
**** 21.2.4 Write-Only State - 251
**** 21.2.5 State - 252
**** 21.2.6 Exceptions - 254
**** 21.2.7 Continuations - 254
**** 21.2.8 Interactive Input - 256
**** 21.2.9 Interactive Output - 258

*** 21.3 Conclusion - 259

** 22 Monads Categorically - 261
*** 22.1 Monoidal Categories - 265
*** 22.2 Monoid in a Monoidal Category - 269
*** 22.3 Monads as Monoids - 270
*** 22.4 Monads from Adjunctions - 272

** 23 Comonads - 277
*** 23.1 Programming with Comonads - 278
*** 23.2 The Product Comonad - 278
*** 23.3 Dissecting the Composition - 280
*** 23.4 The Stream Comonad - 282
*** 23.5 Comonad Categorically - 284
*** 23.6 The Store Comonad - 287
*** 23.7 Challenges - 289

** 24 F-Algebras - 291
*** 24.1 Recursion - 294
*** 24.2 Category of F-Algebras - 296
*** 24.3 Natural Numbers - 299
*** 24.4 Catamorphisms - 299
*** 24.5 Folds - 301
*** 24.6 Coalgebras - 303
*** 24.7 Challenges - 306

** 25 Algebras for Monads - 307
*** 25.1 T-algebras - 309
*** 25.2 The Kleisli Category - 312
*** 25.3 Coalgebras for Comonads - 313
*** 25.4 Lenses - 314
*** 25.5 Challenges - 316

** 26 Ends and Coends - 317
*** 26.1 Dinatural Transformations - 318
*** 26.2 Ends - 320
*** 26.3 Ends as Equalizers - 323
*** 26.4 Natural Transformations as Ends - 324
*** 26.5 Coends - 325
*** 26.6 Ninja Yoneda Lemma - 328
*** 26.7 Profunctor Composition - 329

** 27 Kan Extensions - 331
*** 27.1 Right Kan Extension - 333
*** 27.2 Kan Extension as Adjunction - 334
*** 27.3 Left Kan Extension - 336
*** 27.4 Kan Extensions as Ends - 338
*** 27.5 Kan Extensions in Haskell - 340
*** 27.6 Free Functor - 344

** 28 Enriched Categories - 347
*** 28.1 Why Monoidal Category? - 348
*** 28.2 Monoidal Category - 348
*** 28.3 Enriched Category - 350
*** 28.4 Preorders - 351
*** 28.5 Metric Spaces - 352
*** 28.6 Enriched Functors - 353
*** 28.7 Self Enrichment - 354
*** 28.8 Relation to ùüê-Categories - 355

** 29 Topoi - 357
*** 29.1 Subobject Classifier - 358
*** 29.2 Topos - 361
*** 29.3 Topoi and Logic - 361
*** 29.4 Challenges - 362

** 30 Lawvere Theories - 363
*** 30.1 Universal Algebra - 363
*** 30.2 Lawvere Theories - 364
*** 30.3 Models of Lawvere Theories - 367
*** 30.4 The Theory of Monoids - 368
*** 30.5 Lawvere Theories and Monads - 369
*** 30.6 Monads as Coends - 371
*** 30.7 Lawvere Theory of Side Effects - 374
*** 30.8 Challenges - 375
*** 30.9 Further Reading - 375

** 31 Monads, Monoids, and Categories - 377
*** 31.1 Bicategories - 377
*** 31.2 Monads - 381
*** 31.3 Challenges - 384
*** 31.4 Bibliography - 384

* Appendices - 385
* Index - 385
* Acknowledgments - 387
* Colophon - 388
* Copyleft notice - 389
