#+TITLE: Category Theory for Programmers
#+SUBTITLE: Scala Edition - Contains code snippets in Haskell and Scala
#+AUTHOR: Bartosz Milewski, (compiled and edited by) Igal Tabachnik
#+VERSION: v1.2.1-0-gb4fb9c1 - March 14 2019
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[A note from the editor - ix][A note from the editor - ix]]
- [[Preface - xi][Preface - xi]]
- [[Part One - 3][Part One - 3]]
  - [[1 Category: The Essence of Composition - 3][1 Category: The Essence of Composition - 3]]
    - [[1.1 Arrows as Functions - 3][1.1 Arrows as Functions - 3]]
    - [[1.2 Properties of Composition - 5][1.2 Properties of Composition - 5]]
    - [[1.3 Composition is the Essence of Programming - 7][1.3 Composition is the Essence of Programming - 7]]
    - [[1.4 Challenges - 8][1.4 Challenges - 8]]
  - [[2 Types and Functions - 11][2 Types and Functions - 11]]
    - [[2.1 Who Needs Types? - 11][2.1 Who Needs Types? - 11]]
    - [[2.2 Types Are About Composability - 12][2.2 Types Are About Composability - 12]]
    - [[2.3 What Are Types? - 13][2.3 What Are Types? - 13]]
    - [[2.4 Why Do We Need a Mathematical Model? - 15][2.4 Why Do We Need a Mathematical Model? - 15]]
    - [[2.5 Pure and Dirty Functions - 17][2.5 Pure and Dirty Functions - 17]]
    - [[2.6 Examples of Types - 17][2.6 Examples of Types - 17]]
    - [[2.7 Challenges - 20][2.7 Challenges - 20]]
  - [[3 Categories Great and Small - 23][3 Categories Great and Small - 23]]
    - [[3.1 No Objects - 23][3.1 No Objects - 23]]
    - [[3.2 Simple Graphs - 23][3.2 Simple Graphs - 23]]
    - [[3.3 Orders - 24][3.3 Orders - 24]]
    - [[3.4 Monoid as Set - 24][3.4 Monoid as Set - 24]]
    - [[3.5 Monoid as Category - 27][3.5 Monoid as Category - 27]]
    - [[3.6 Challenges - 29][3.6 Challenges - 29]]
  - [[4 Kleisli Categories - 31][4 Kleisli Categories - 31]]
    - [[4.1 The Writer Category - 34][4.1 The Writer Category - 34]]
    - [[4.2 Writer in Haskell - 36][4.2 Writer in Haskell - 36]]
    - [[4.3 Kleisli Categories - 39][4.3 Kleisli Categories - 39]]
    - [[4.4 Challenge - 39][4.4 Challenge - 39]]
  - [[5 Products and Coproducts - 41][5 Products and Coproducts - 41]]
    - [[5.1 Initial Object - 41][5.1 Initial Object - 41]]
    - [[5.2 Terminal Object - 43][5.2 Terminal Object - 43]]
    - [[5.3 Duality - 44][5.3 Duality - 44]]
    - [[5.4 Isomorphisms - 45][5.4 Isomorphisms - 45]]
    - [[5.5 Products - 46][5.5 Products - 46]]
    - [[5.6 Coproduct - 51][5.6 Coproduct - 51]]
    - [[5.7 Asymmetry - 54][5.7 Asymmetry - 54]]
    - [[5.8 Challenges - 56][5.8 Challenges - 56]]
    - [[5.9 Bibliography - 57][5.9 Bibliography - 57]]
  - [[6 Simple Algebraic Data Types - 59][6 Simple Algebraic Data Types - 59]]
    - [[6.1 Product Types - 59][6.1 Product Types - 59]]
    - [[6.2 Records - 63][6.2 Records - 63]]
    - [[6.3 Sum Types - 65][6.3 Sum Types - 65]]
    - [[6.4 Algebra of Types - 68][6.4 Algebra of Types - 68]]
    - [[6.5 Challenges - 72][6.5 Challenges - 72]]
  - [[7 Functors - 73][7 Functors - 73]]
    - [[7.1 Functors in Programming - 75][7.1 Functors in Programming - 75]]
      - [[7.1.1 The Maybe Functor - 75][7.1.1 The Maybe Functor - 75]]
      - [[7.1.2 Equational Reasoning - 77][7.1.2 Equational Reasoning - 77]]
      - [[7.1.3 Optional - 79][7.1.3 Optional - 79]]
      - [[7.1.4 Typeclasses - 80][7.1.4 Typeclasses - 80]]
      - [[7.1.5 Functor in C++ - 82][7.1.5 Functor in C++ - 82]]
      - [[7.1.6 The List Functor - 82][7.1.6 The List Functor - 82]]
      - [[7.1.7 The Reader Functor - 84][7.1.7 The Reader Functor - 84]]
    - [[7.2 Functors as Containers - 86][7.2 Functors as Containers - 86]]
    - [[7.3 Functor Composition - 88][7.3 Functor Composition - 88]]
    - [[7.4 Challenges - 90][7.4 Challenges - 90]]
  - [[8 Functoriality - 93][8 Functoriality - 93]]
    - [[8.1 Bifunctors - 93][8.1 Bifunctors - 93]]
    - [[8.2 Product and Coproduct Bifunctors - 95][8.2 Product and Coproduct Bifunctors - 95]]
    - [[8.3 Functorial Algebraic Data Types - 97][8.3 Functorial Algebraic Data Types - 97]]
    - [[8.4 Functors in C++ - 100][8.4 Functors in C++ - 100]]
    - [[8.5 The Writer Functor - 102][8.5 The Writer Functor - 102]]
    - [[8.6 Covariant and Contravariant Functors - 104][8.6 Covariant and Contravariant Functors - 104]]
    - [[8.7 Profunctors - 107][8.7 Profunctors - 107]]
    - [[8.8 The Hom-Functor - 109][8.8 The Hom-Functor - 109]]
    - [[8.9 Challenges - 109][8.9 Challenges - 109]]
  - [[9 Function Types - 111][9 Function Types - 111]]
    - [[9.1 Universal Construction - 112][9.1 Universal Construction - 112]]
    - [[9.2 Currying - 115][9.2 Currying - 115]]
    - [[9.3 Exponentials - 118][9.3 Exponentials - 118]]
    - [[9.4 Cartesian Closed Categories - 119][9.4 Cartesian Closed Categories - 119]]
    - [[9.5 Exponentials and Algebraic Data Types - 120][9.5 Exponentials and Algebraic Data Types - 120]]
      - [[9.5.1 Zeroth Power - 120][9.5.1 Zeroth Power - 120]]
      - [[9.5.2 Powers of One - 121][9.5.2 Powers of One - 121]]
      - [[9.5.3 First Power - 121][9.5.3 First Power - 121]]
      - [[9.5.4 Exponentials of Sums - 121][9.5.4 Exponentials of Sums - 121]]
      - [[9.5.5 Exponentials of Exponentials - 122][9.5.5 Exponentials of Exponentials - 122]]
      - [[9.5.6 Exponentials over Products - 122][9.5.6 Exponentials over Products - 122]]
    - [[9.6 Curry-Howard Isomorphism - 122][9.6 Curry-Howard Isomorphism - 122]]
    - [[9.7 Bibliography - 124][9.7 Bibliography - 124]]
  - [[10 Natural Transformations - 125][10 Natural Transformations - 125]]
    - [[10.1 Polymorphic Functions - 128][10.1 Polymorphic Functions - 128]]
    - [[10.2 Beyond Naturality - 134][10.2 Beyond Naturality - 134]]
    - [[10.3 Functor Category - 135][10.3 Functor Category - 135]]
    - [[10.4 2-Categories - 138][10.4 2-Categories - 138]]
    - [[10.5 Conclusion - 142][10.5 Conclusion - 142]]
    - [[10.6 Challenges - 142][10.6 Challenges - 142]]
- [[Part Two - 145][Part Two - 145]]
  - [[11 Declarative Programming - 145][11 Declarative Programming - 145]]
  - [[12 Limits and Colimits - 151][12 Limits and Colimits - 151]]
    - [[12.1 Limit as a Natural Isomorphism - 155][12.1 Limit as a Natural Isomorphism - 155]]
    - [[12.2 Examples of Limits - 158][12.2 Examples of Limits - 158]]
    - [[12.3 Colimits - 164][12.3 Colimits - 164]]
    - [[12.4 Continuity - 165][12.4 Continuity - 165]]
    - [[12.5 Challenges - 166][12.5 Challenges - 166]]
  - [[13 Free Monoids - 169][13 Free Monoids - 169]]
    - [[13.1 Free Monoid in Haskell - 170][13.1 Free Monoid in Haskell - 170]]
    - [[13.2 Free Monoid Universal Construction - 171][13.2 Free Monoid Universal Construction - 171]]
    - [[13.3 Challenges - 175][13.3 Challenges - 175]]
  - [[14 Representable Functors - 177][14 Representable Functors - 177]]
    - [[14.1 The Hom Functor - 178][14.1 The Hom Functor - 178]]
    - [[14.2 Representable Functors - 180][14.2 Representable Functors - 180]]
    - [[14.3 Challenges - 185][14.3 Challenges - 185]]
    - [[14.4 Bibliography - 185][14.4 Bibliography - 185]]
  - [[15 The Yoneda Lemma - 187][15 The Yoneda Lemma - 187]]
    - [[15.1 Yoneda in Haskell - 192][15.1 Yoneda in Haskell - 192]]
    - [[15.2 Co-Yoneda - 194][15.2 Co-Yoneda - 194]]
    - [[15.3 Challenges - 194][15.3 Challenges - 194]]
    - [[15.4 Bibliography - 195][15.4 Bibliography - 195]]
  - [[16 Yoneda Embedding - 197][16 Yoneda Embedding - 197]]
    - [[16.1 The Embedding - 199][16.1 The Embedding - 199]]
    - [[16.2 Application to Haskell - 199][16.2 Application to Haskell - 199]]
    - [[16.3 Preorder Example - 200][16.3 Preorder Example - 200]]
    - [[16.4 Naturality - 202][16.4 Naturality - 202]]
    - [[16.5 Challenges - 202][16.5 Challenges - 202]]
- [[Part Three 207][Part Three 207]]
  - [[17 It's All About Morphisms - 207][17 It's All About Morphisms - 207]]
    - [[17.1 Functors - 207][17.1 Functors - 207]]
    - [[17.2 Commuting Diagrams - 207][17.2 Commuting Diagrams - 207]]
    - [[17.3 Natural Transformations - 208][17.3 Natural Transformations - 208]]
    - [[17.4 Natural Isomorphisms - 209][17.4 Natural Isomorphisms - 209]]
    - [[17.5 Hom-Sets - 210][17.5 Hom-Sets - 210]]
    - [[17.6 Hom-Set Isomorphisms - 210][17.6 Hom-Set Isomorphisms - 210]]
    - [[17.7 Asymmetry of Hom-Sets - 211][17.7 Asymmetry of Hom-Sets - 211]]
    - [[17.8 Challenges - 211][17.8 Challenges - 211]]
  - [[18 Adjunctions - 213][18 Adjunctions - 213]]
    - [[18.1 Adjunction and Unit/Counit Pair - 214][18.1 Adjunction and Unit/Counit Pair - 214]]
    - [[18.2 Adjunctions and Hom-Sets - 218][18.2 Adjunctions and Hom-Sets - 218]]
    - [[18.3 Product from Adjunction - 221][18.3 Product from Adjunction - 221]]
    - [[18.4 Exponential from Adjunction - 224][18.4 Exponential from Adjunction - 224]]
    - [[18.5 Challenges - 225][18.5 Challenges - 225]]
  - [[19 Free/Forgetful Adjunctions - 227][19 Free/Forgetful Adjunctions - 227]]
    - [[19.1 Some Intuitions - 230][19.1 Some Intuitions - 230]]
    - [[19.2 Challenges - 232][19.2 Challenges - 232]]
  - [[20 Monads: Programmer's Definition - 233][20 Monads: Programmer's Definition - 233]]
    - [[20.1 The Kleisli Category - 234][20.1 The Kleisli Category - 234]]
    - [[20.2 Fish Anatomy - 237][20.2 Fish Anatomy - 237]]
    - [[20.3 The do Notation - 240][20.3 The do Notation - 240]]
  - [[21 Monads and Effects - 245][21 Monads and Effects - 245]]
    - [[21.1 The Problem - 245][21.1 The Problem - 245]]
    - [[21.2 The Solution - 246][21.2 The Solution - 246]]
      - [[21.2.1 Partiality - 246][21.2.1 Partiality - 246]]
      - [[21.2.2 Nondeterminism - 247][21.2.2 Nondeterminism - 247]]
      - [[21.2.3 Read-Only State - 249][21.2.3 Read-Only State - 249]]
      - [[21.2.4 Write-Only State - 251][21.2.4 Write-Only State - 251]]
      - [[21.2.5 State - 252][21.2.5 State - 252]]
      - [[21.2.6 Exceptions - 254][21.2.6 Exceptions - 254]]
      - [[21.2.7 Continuations - 254][21.2.7 Continuations - 254]]
      - [[21.2.8 Interactive Input - 256][21.2.8 Interactive Input - 256]]
      - [[21.2.9 Interactive Output - 258][21.2.9 Interactive Output - 258]]
    - [[21.3 Conclusion - 259][21.3 Conclusion - 259]]
  - [[22 Monads Categorically - 261][22 Monads Categorically - 261]]
    - [[22.1 Monoidal Categories - 265][22.1 Monoidal Categories - 265]]
    - [[22.2 Monoid in a Monoidal Category - 269][22.2 Monoid in a Monoidal Category - 269]]
    - [[22.3 Monads as Monoids - 270][22.3 Monads as Monoids - 270]]
    - [[22.4 Monads from Adjunctions - 272][22.4 Monads from Adjunctions - 272]]
  - [[23 Comonads - 277][23 Comonads - 277]]
    - [[23.1 Programming with Comonads - 278][23.1 Programming with Comonads - 278]]
    - [[23.2 The Product Comonad - 278][23.2 The Product Comonad - 278]]
    - [[23.3 Dissecting the Composition - 280][23.3 Dissecting the Composition - 280]]
    - [[23.4 The Stream Comonad - 282][23.4 The Stream Comonad - 282]]
    - [[23.5 Comonad Categorically - 284][23.5 Comonad Categorically - 284]]
    - [[23.6 The Store Comonad - 287][23.6 The Store Comonad - 287]]
    - [[23.7 Challenges - 289][23.7 Challenges - 289]]
  - [[24 F-Algebras - 291][24 F-Algebras - 291]]
    - [[24.1 Recursion - 294][24.1 Recursion - 294]]
    - [[24.2 Category of F-Algebras - 296][24.2 Category of F-Algebras - 296]]
    - [[24.3 Natural Numbers - 299][24.3 Natural Numbers - 299]]
    - [[24.4 Catamorphisms - 299][24.4 Catamorphisms - 299]]
    - [[24.5 Folds - 301][24.5 Folds - 301]]
    - [[24.6 Coalgebras - 303][24.6 Coalgebras - 303]]
    - [[24.7 Challenges - 306][24.7 Challenges - 306]]
  - [[25 Algebras for Monads - 307][25 Algebras for Monads - 307]]
    - [[25.1 T-algebras - 309][25.1 T-algebras - 309]]
    - [[25.2 The Kleisli Category - 312][25.2 The Kleisli Category - 312]]
    - [[25.3 Coalgebras for Comonads - 313][25.3 Coalgebras for Comonads - 313]]
    - [[25.4 Lenses - 314][25.4 Lenses - 314]]
    - [[25.5 Challenges - 316][25.5 Challenges - 316]]
  - [[26 Ends and Coends - 317][26 Ends and Coends - 317]]
    - [[26.1 Dinatural Transformations - 318][26.1 Dinatural Transformations - 318]]
    - [[26.2 Ends - 320][26.2 Ends - 320]]
    - [[26.3 Ends as Equalizers - 323][26.3 Ends as Equalizers - 323]]
    - [[26.4 Natural Transformations as Ends - 324][26.4 Natural Transformations as Ends - 324]]
    - [[26.5 Coends - 325][26.5 Coends - 325]]
    - [[26.6 Ninja Yoneda Lemma - 328][26.6 Ninja Yoneda Lemma - 328]]
    - [[26.7 Profunctor Composition - 329][26.7 Profunctor Composition - 329]]
  - [[27 Kan Extensions - 331][27 Kan Extensions - 331]]
    - [[27.1 Right Kan Extension - 333][27.1 Right Kan Extension - 333]]
    - [[27.2 Kan Extension as Adjunction - 334][27.2 Kan Extension as Adjunction - 334]]
    - [[27.3 Left Kan Extension - 336][27.3 Left Kan Extension - 336]]
    - [[27.4 Kan Extensions as Ends - 338][27.4 Kan Extensions as Ends - 338]]
    - [[27.5 Kan Extensions in Haskell - 340][27.5 Kan Extensions in Haskell - 340]]
    - [[27.6 Free Functor - 344][27.6 Free Functor - 344]]
  - [[28 Enriched Categories - 347][28 Enriched Categories - 347]]
    - [[28.1 Why Monoidal Category? - 348][28.1 Why Monoidal Category? - 348]]
    - [[28.2 Monoidal Category - 348][28.2 Monoidal Category - 348]]
    - [[28.3 Enriched Category - 350][28.3 Enriched Category - 350]]
    - [[28.4 Preorders - 351][28.4 Preorders - 351]]
    - [[28.5 Metric Spaces - 352][28.5 Metric Spaces - 352]]
    - [[28.6 Enriched Functors - 353][28.6 Enriched Functors - 353]]
    - [[28.7 Self Enrichment - 354][28.7 Self Enrichment - 354]]
    - [[28.8 Relation to 𝟐-Categories - 355][28.8 Relation to 𝟐-Categories - 355]]
  - [[29 Topoi - 357][29 Topoi - 357]]
    - [[29.1 Subobject Classifier - 358][29.1 Subobject Classifier - 358]]
    - [[29.2 Topos - 361][29.2 Topos - 361]]
    - [[29.3 Topoi and Logic - 361][29.3 Topoi and Logic - 361]]
    - [[29.4 Challenges - 362][29.4 Challenges - 362]]
  - [[30 Lawvere Theories - 363][30 Lawvere Theories - 363]]
    - [[30.1 Universal Algebra - 363][30.1 Universal Algebra - 363]]
    - [[30.2 Lawvere Theories - 364][30.2 Lawvere Theories - 364]]
    - [[30.3 Models of Lawvere Theories - 367][30.3 Models of Lawvere Theories - 367]]
    - [[30.4 The Theory of Monoids - 368][30.4 The Theory of Monoids - 368]]
    - [[30.5 Lawvere Theories and Monads - 369][30.5 Lawvere Theories and Monads - 369]]
    - [[30.6 Monads as Coends - 371][30.6 Monads as Coends - 371]]
    - [[30.7 Lawvere Theory of Side Effects - 374][30.7 Lawvere Theory of Side Effects - 374]]
    - [[30.8 Challenges - 375][30.8 Challenges - 375]]
    - [[30.9 Further Reading - 375][30.9 Further Reading - 375]]
  - [[31 Monads, Monoids, and Categories - 377][31 Monads, Monoids, and Categories - 377]]
    - [[31.1 Bicategories - 377][31.1 Bicategories - 377]]
    - [[31.2 Monads - 381][31.2 Monads - 381]]
    - [[31.3 Challenges - 384][31.3 Challenges - 384]]
    - [[31.4 Bibliography - 384][31.4 Bibliography - 384]]
- [[Appendices - 385][Appendices - 385]]
- [[Index - 385][Index - 385]]
- [[Acknowledgments - 387][Acknowledgments - 387]]
- [[Colophon - 388][Colophon - 388]]
- [[Copyleft notice - 389][Copyleft notice - 389]]

* A note from the editor - ix
* Preface - xi
* Part One - 3
** DONE 1 Category: The Essence of Composition - 3
   CLOSED: [2019-04-05 Fri 13:43]
*** DONE 1.1 Arrows as Functions - 3
    CLOSED: [2019-04-05 Fri 11:37]
*** DONE 1.2 Properties of Composition - 5
    CLOSED: [2019-04-05 Fri 11:37]
    - TODO
      NOTE

    - _To summarize_:
      + A /category/ consists of /objects/ and /arrows/ (/morphisms/).

      + /Arrows/ can be _composed_, and the *composition is associative*.

      + *EVERY* /object/ has an /identity arrow/ that serves as a _unit under
        composition_.

*** DONE 1.3 Composition is the Essence of Programming - 7
    CLOSED: [2019-04-05 Fri 11:50]
    - TODO NOTE

    - The moment you have to dig into the implementation of the object in order
      to understand how to compose it with other objects,
      you've lost the advantages of your programming paradigm.

*** TODO 1.4 Challenges - 8
    1. DONE
    2. TODO
    3. TODO
    4. TODO
    5. TODO
    6. TODO

** TODO 2 Types and Functions - 11
*** 2.1 Who Needs Types? - 11
*** 2.2 Types Are About Composability - 12
*** 2.3 What Are Types? - 13
*** 2.4 Why Do We Need a Mathematical Model? - 15
*** 2.5 Pure and Dirty Functions - 17
*** 2.6 Examples of Types - 17
*** 2.7 Challenges - 20

** 3 Categories Great and Small - 23
*** 3.1 No Objects - 23
*** 3.2 Simple Graphs - 23
*** 3.3 Orders - 24
*** 3.4 Monoid as Set - 24
*** 3.5 Monoid as Category - 27
*** 3.6 Challenges - 29

** 4 Kleisli Categories - 31
*** 4.1 The Writer Category - 34
*** 4.2 Writer in Haskell - 36
*** 4.3 Kleisli Categories - 39
*** 4.4 Challenge - 39

** 5 Products and Coproducts - 41
*** 5.1 Initial Object - 41
*** 5.2 Terminal Object - 43
*** 5.3 Duality - 44
*** 5.4 Isomorphisms - 45
*** 5.5 Products - 46
*** 5.6 Coproduct - 51
*** 5.7 Asymmetry - 54
*** 5.8 Challenges - 56
*** 5.9 Bibliography - 57

** 6 Simple Algebraic Data Types - 59
*** 6.1 Product Types - 59
*** 6.2 Records - 63
*** 6.3 Sum Types - 65
*** 6.4 Algebra of Types - 68
*** 6.5 Challenges - 72

** 7 Functors - 73
*** 7.1 Functors in Programming - 75
**** 7.1.1 The Maybe Functor - 75
**** 7.1.2 Equational Reasoning - 77
**** 7.1.3 Optional - 79
**** 7.1.4 Typeclasses - 80
**** 7.1.5 Functor in C++ - 82
**** 7.1.6 The List Functor - 82
**** 7.1.7 The Reader Functor - 84

*** 7.2 Functors as Containers - 86
*** 7.3 Functor Composition - 88
*** 7.4 Challenges - 90

** 8 Functoriality - 93
*** 8.1 Bifunctors - 93
*** 8.2 Product and Coproduct Bifunctors - 95
*** 8.3 Functorial Algebraic Data Types - 97
*** 8.4 Functors in C++ - 100
*** 8.5 The Writer Functor - 102
*** 8.6 Covariant and Contravariant Functors - 104
*** 8.7 Profunctors - 107
*** 8.8 The Hom-Functor - 109
*** 8.9 Challenges - 109

** 9 Function Types - 111
*** 9.1 Universal Construction - 112
*** 9.2 Currying - 115
*** 9.3 Exponentials - 118
*** 9.4 Cartesian Closed Categories - 119
*** 9.5 Exponentials and Algebraic Data Types - 120
**** 9.5.1 Zeroth Power - 120
**** 9.5.2 Powers of One - 121
**** 9.5.3 First Power - 121
**** 9.5.4 Exponentials of Sums - 121
**** 9.5.5 Exponentials of Exponentials - 122
**** 9.5.6 Exponentials over Products - 122

*** 9.6 Curry-Howard Isomorphism - 122
*** 9.7 Bibliography - 124

** 10 Natural Transformations - 125
*** 10.1 Polymorphic Functions - 128
*** 10.2 Beyond Naturality - 134
*** 10.3 Functor Category - 135
*** 10.4 2-Categories - 138
*** 10.5 Conclusion - 142
*** 10.6 Challenges - 142

* Part Two - 145
** 11 Declarative Programming - 145
** 12 Limits and Colimits - 151
*** 12.1 Limit as a Natural Isomorphism - 155
*** 12.2 Examples of Limits - 158
*** 12.3 Colimits - 164
*** 12.4 Continuity - 165
*** 12.5 Challenges - 166

** 13 Free Monoids - 169
*** 13.1 Free Monoid in Haskell - 170
*** 13.2 Free Monoid Universal Construction - 171
*** 13.3 Challenges - 175

** 14 Representable Functors - 177
*** 14.1 The Hom Functor - 178
*** 14.2 Representable Functors - 180
*** 14.3 Challenges - 185
*** 14.4 Bibliography - 185

** 15 The Yoneda Lemma - 187
*** 15.1 Yoneda in Haskell - 192
*** 15.2 Co-Yoneda - 194
*** 15.3 Challenges - 194
*** 15.4 Bibliography - 195

** 16 Yoneda Embedding - 197
*** 16.1 The Embedding - 199
*** 16.2 Application to Haskell - 199
*** 16.3 Preorder Example - 200
*** 16.4 Naturality - 202
*** 16.5 Challenges - 202

* Part Three 207
** 17 It's All About Morphisms - 207
*** 17.1 Functors - 207
*** 17.2 Commuting Diagrams - 207
*** 17.3 Natural Transformations - 208
*** 17.4 Natural Isomorphisms - 209
*** 17.5 Hom-Sets - 210
*** 17.6 Hom-Set Isomorphisms - 210
*** 17.7 Asymmetry of Hom-Sets - 211
*** 17.8 Challenges - 211

** 18 Adjunctions - 213
*** 18.1 Adjunction and Unit/Counit Pair - 214
*** 18.2 Adjunctions and Hom-Sets - 218
*** 18.3 Product from Adjunction - 221
*** 18.4 Exponential from Adjunction - 224
*** 18.5 Challenges - 225

** 19 Free/Forgetful Adjunctions - 227
*** 19.1 Some Intuitions - 230
*** 19.2 Challenges - 232

** 20 Monads: Programmer's Definition - 233
*** 20.1 The Kleisli Category - 234
*** 20.2 Fish Anatomy - 237
*** 20.3 The do Notation - 240

** 21 Monads and Effects - 245
*** 21.1 The Problem - 245
*** 21.2 The Solution - 246
**** 21.2.1 Partiality - 246
**** 21.2.2 Nondeterminism - 247
**** 21.2.3 Read-Only State - 249
**** 21.2.4 Write-Only State - 251
**** 21.2.5 State - 252
**** 21.2.6 Exceptions - 254
**** 21.2.7 Continuations - 254
**** 21.2.8 Interactive Input - 256
**** 21.2.9 Interactive Output - 258

*** 21.3 Conclusion - 259

** 22 Monads Categorically - 261
*** 22.1 Monoidal Categories - 265
*** 22.2 Monoid in a Monoidal Category - 269
*** 22.3 Monads as Monoids - 270
*** 22.4 Monads from Adjunctions - 272

** 23 Comonads - 277
*** 23.1 Programming with Comonads - 278
*** 23.2 The Product Comonad - 278
*** 23.3 Dissecting the Composition - 280
*** 23.4 The Stream Comonad - 282
*** 23.5 Comonad Categorically - 284
*** 23.6 The Store Comonad - 287
*** 23.7 Challenges - 289

** 24 F-Algebras - 291
*** 24.1 Recursion - 294
*** 24.2 Category of F-Algebras - 296
*** 24.3 Natural Numbers - 299
*** 24.4 Catamorphisms - 299
*** 24.5 Folds - 301
*** 24.6 Coalgebras - 303
*** 24.7 Challenges - 306

** 25 Algebras for Monads - 307
*** 25.1 T-algebras - 309
*** 25.2 The Kleisli Category - 312
*** 25.3 Coalgebras for Comonads - 313
*** 25.4 Lenses - 314
*** 25.5 Challenges - 316

** 26 Ends and Coends - 317
*** 26.1 Dinatural Transformations - 318
*** 26.2 Ends - 320
*** 26.3 Ends as Equalizers - 323
*** 26.4 Natural Transformations as Ends - 324
*** 26.5 Coends - 325
*** 26.6 Ninja Yoneda Lemma - 328
*** 26.7 Profunctor Composition - 329

** 27 Kan Extensions - 331
*** 27.1 Right Kan Extension - 333
*** 27.2 Kan Extension as Adjunction - 334
*** 27.3 Left Kan Extension - 336
*** 27.4 Kan Extensions as Ends - 338
*** 27.5 Kan Extensions in Haskell - 340
*** 27.6 Free Functor - 344

** 28 Enriched Categories - 347
*** 28.1 Why Monoidal Category? - 348
*** 28.2 Monoidal Category - 348
*** 28.3 Enriched Category - 350
*** 28.4 Preorders - 351
*** 28.5 Metric Spaces - 352
*** 28.6 Enriched Functors - 353
*** 28.7 Self Enrichment - 354
*** 28.8 Relation to 𝟐-Categories - 355

** 29 Topoi - 357
*** 29.1 Subobject Classifier - 358
*** 29.2 Topos - 361
*** 29.3 Topoi and Logic - 361
*** 29.4 Challenges - 362

** 30 Lawvere Theories - 363
*** 30.1 Universal Algebra - 363
*** 30.2 Lawvere Theories - 364
*** 30.3 Models of Lawvere Theories - 367
*** 30.4 The Theory of Monoids - 368
*** 30.5 Lawvere Theories and Monads - 369
*** 30.6 Monads as Coends - 371
*** 30.7 Lawvere Theory of Side Effects - 374
*** 30.8 Challenges - 375
*** 30.9 Further Reading - 375

** 31 Monads, Monoids, and Categories - 377
*** 31.1 Bicategories - 377
*** 31.2 Monads - 381
*** 31.3 Challenges - 384
*** 31.4 Bibliography - 384

* Appendices - 385
* Index - 385
* Acknowledgments - 387
* Colophon - 388
* Copyleft notice - 389
