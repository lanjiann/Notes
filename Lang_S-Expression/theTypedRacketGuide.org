#+TITLE: The Typed Racket Guide
#+VERSION: v.7.0
#+AUTHOR: Sam Tobin-Hochstadt, Vincent St-Amour, Eric Dobson, Asumu Takikawa
#+STARTUP: entitiespretty

* Table of Contents                                      :TOC_4_org:noexport:
- [[1 Quick Start][1 Quick Start]]
  - [[1.1 Using Typed Racket from the Racket REPL][1.1 Using Typed Racket from the Racket REPL]]
- [[2 Beginning Typed Racket][2 Beginning Typed Racket]]
  - [[2.1 Datatypes and Unions][2.1 Datatypes and Unions]]
  - [[2.2 Type Errors][2.2 Type Errors]]
- [[3 Specifying Types][3 Specifying Types]]
  - [[3.1 Type Annotation and Binding Forms][3.1 Type Annotation and Binding Forms]]
    - [[3.1.1 Annotating Definitions][3.1.1 Annotating Definitions]]
    - [[3.1.2 Annotating Local Binding][3.1.2 Annotating Local Binding]]
    - [[3.1.3 Annotating Functions][3.1.3 Annotating Functions]]
    - [[3.1.4 Annotating Single Variables][3.1.4 Annotating Single Variables]]
    - [[3.1.5 Annotating Expressions][3.1.5 Annotating Expressions]]
  - [[3.2 Type Inference][3.2 Type Inference]]
    - [[3.2.1 When do you need type annotations?][3.2.1 When do you need type annotations?]]
  - [[3.3 New Type Names][3.3 New Type Names]]
- [[4 Types in Typed Racket][4 Types in Typed Racket]]
  - [[4.1 Basic Types][4.1 Basic Types]]
  - [[4.2 Function Types][4.2 Function Types]]
  - [[4.3 Types for Functions with Optional or Keyword Arguments][4.3 Types for Functions with Optional or Keyword Arguments]]
  - [[4.4 Union Types][4.4 Union Types]]
  - [[4.5 Recursive Types][4.5 Recursive Types]]
  - [[4.6 Structure Types][4.6 Structure Types]]
  - [[4.7 Subtyping][4.7 Subtyping]]
  - [[4.8 Polymorphism][4.8 Polymorphism]]
    - [[4.8.1 Polymorphic Data Structures][4.8.1 Polymorphic Data Structures]]
    - [[4.8.2 Polymorphic Functions][4.8.2 Polymorphic Functions]]
    - [[4.8.3 Lexically Scoped Type Variables][4.8.3 Lexically Scoped Type Variables]]
  - [[4.9 Variable-Arity Functions: Programming with Rest Arguments][4.9 Variable-Arity Functions: Programming with Rest Arguments]]
    - [[4.9.1 Uniform Variable-Arity Functions][4.9.1 Uniform Variable-Arity Functions]]
    - [[4.9.2 Non-Uniform Variable-Arity Functions][4.9.2 Non-Uniform Variable-Arity Functions]]
- [[5 Occurrence Typing][5 Occurrence Typing]]
  - [[5.1 Basic Occurrence Typing][5.1 Basic Occurrence Typing]]
  - [[5.2 Propositions and Predicates][5.2 Propositions and Predicates]]
  - [[5.3 Other conditionals and assertions][5.3 Other conditionals and assertions]]
  - [[5.4 A caveat about ~set!~][5.4 A caveat about ~set!~]]
  - [[5.5 ~let~-aliasing][5.5 ~let~-aliasing]]
- [[6 Typed-Untyped Interaction][6 Typed-Untyped Interaction]]
  - [[6.1 Using Untyped Code from Typed Code][6.1 Using Untyped Code from Typed Code]]
  - [[6.2 Using Typed Code in Untyped Code][6.2 Using Typed Code in Untyped Code]]
  - [[6.3 Protecting Typed-Untyped Interaction][6.3 Protecting Typed-Untyped Interaction]]
- [[7 Optimization in Typed Racket][7 Optimization in Typed Racket]]
  - [[7.1 Turning the optimizer off][7.1 Turning the optimizer off]]
  - [[7.2 Getting the most out of the optimizer][7.2 Getting the most out of the optimizer]]
    - [[7.2.1 Numeric types][7.2.1 Numeric types]]
    - [[7.2.2 Lists][7.2.2 Lists]]
    - [[7.2.3 Vectors][7.2.3 Vectors]]
    - [[7.2.4 Contract boundaries][7.2.4 Contract boundaries]]
- [[8 Caveats and Limitations][8 Caveats and Limitations]]
  - [[8.1 The ~Integer~ type and ~integer?~][8.1 The ~Integer~ type and ~integer?~]]
  - [[8.2 Type inference for polymorphic functions][8.2 Type inference for polymorphic functions]]
  - [[8.3 Typed-untyped interaction and contract generation][8.3 Typed-untyped interaction and contract generation]]
  - [[8.4 Unsupported features][8.4 Unsupported features]]
  - [[8.5 Type generalization][8.5 Type generalization]]
  - [[8.6 Macros and compile-time computation][8.6 Macros and compile-time computation]]
  - [[8.7 Expensive contract boundaries][8.7 Expensive contract boundaries]]

* 1 Quick Start
** 1.1 Using Typed Racket from the Racket REPL

* 2 Beginning Typed Racket
** 2.1 Datatypes and Unions
** 2.2 Type Errors

* 3 Specifying Types
** 3.1 Type Annotation and Binding Forms
*** 3.1.1 Annotating Definitions
*** 3.1.2 Annotating Local Binding
*** 3.1.3 Annotating Functions
*** 3.1.4 Annotating Single Variables
*** 3.1.5 Annotating Expressions

** 3.2 Type Inference
*** 3.2.1 When do you need type annotations?

** 3.3 New Type Names

* 4 Types in Typed Racket
** 4.1 Basic Types
** 4.2 Function Types
** 4.3 Types for Functions with Optional or Keyword Arguments
** 4.4 Union Types
** 4.5 Recursive Types
** 4.6 Structure Types
** 4.7 Subtyping
** 4.8 Polymorphism
*** 4.8.1 Polymorphic Data Structures
*** 4.8.2 Polymorphic Functions
*** 4.8.3 Lexically Scoped Type Variables

** 4.9 Variable-Arity Functions: Programming with Rest Arguments
*** 4.9.1 Uniform Variable-Arity Functions
*** 4.9.2 Non-Uniform Variable-Arity Functions

* 5 Occurrence Typing
** 5.1 Basic Occurrence Typing
** 5.2 Propositions and Predicates
** 5.3 Other conditionals and assertions
** 5.4 A caveat about ~set!~
** 5.5 ~let~-aliasing

* 6 Typed-Untyped Interaction
** 6.1 Using Untyped Code from Typed Code
** 6.2 Using Typed Code in Untyped Code
** 6.3 Protecting Typed-Untyped Interaction

* 7 Optimization in Typed Racket
** 7.1 Turning the optimizer off
** 7.2 Getting the most out of the optimizer
*** 7.2.1 Numeric types
*** 7.2.2 Lists
*** 7.2.3 Vectors
*** 7.2.4 Contract boundaries

* 8 Caveats and Limitations
** 8.1 The ~Integer~ type and ~integer?~
** 8.2 Type inference for polymorphic functions
** 8.3 Typed-untyped interaction and contract generation
** 8.4 Unsupported features
** 8.5 Type generalization
** 8.6 Macros and compile-time computation
** 8.7 Expensive contract boundaries
